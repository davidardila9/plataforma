<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml"
        href="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%2016%2016'%3E%3Crect%20width='16'%20height='16'%20fill='%23171717'/%3E%3Cpath%20d='M2%2012L6%206L10%209L14%204'%20stroke='%234a9eff'%20stroke-width='2'%20fill='none'/%3E%3C/svg%3E" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ReloadingTape HFT Pro</title>
    <meta name="description"
        content="A professional, semi-automatic trading signals and analysis application. It visualizes financial data from CSV files with multiple chart types, advanced indicators, and a backtesting module to simulate market scenarios." />

    <!-- External Libraries -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/echarts.min.js"></script>

    <style>
        body {
            background-color: #0a0a0a;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        .echarts-for-react {
            height: 100% !important;
        }

        /* Hide number input spinners */
        input[type=number]::-webkit-inner-spin-button,
        input[type=number]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        input[type=number] {
            -moz-appearance: textfield;
        }

        /* Allow selection only in inputs */
        input,
        textarea {
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
            user-select: text;
        }
    </style>

    <!-- ===== PROTECCI√ìN ANTI-COPIA ===== -->
    <script>
        // Deshabilitar click derecho
        document.addEventListener('contextmenu', function (e) {
            e.preventDefault();
            return false;
        });

        // Deshabilitar atajos de teclado peligrosos
        document.addEventListener('keydown', function (e) {
            // Ctrl+U (ver c√≥digo fuente)
            if (e.ctrlKey && e.key === 'u') {
                e.preventDefault();
                return false;
            }
            // Ctrl+S (guardar)
            if (e.ctrlKey && e.key === 's') {
                e.preventDefault();
                return false;
            }
            // Ctrl+Shift+I (DevTools)
            if (e.ctrlKey && e.shiftKey && e.key === 'I') {
                e.preventDefault();
                return false;
            }
            // Ctrl+Shift+J (Console)
            if (e.ctrlKey && e.shiftKey && e.key === 'J') {
                e.preventDefault();
                return false;
            }
            // Ctrl+Shift+C (Inspector)
            if (e.ctrlKey && e.shiftKey && e.key === 'C') {
                e.preventDefault();
                return false;
            }
            // F12 (DevTools)
            if (e.key === 'F12') {
                e.preventDefault();
                return false;
            }
            // Ctrl+P (Imprimir)
            if (e.ctrlKey && e.key === 'p') {
                e.preventDefault();
                return false;
            }
        });

        // Detectar DevTools abiertos (m√©todo del debugger)
        (function () {
            const _0xcheck = new RegExp('function *\\( *\\)');
            const _0xdevtools = function () {
                const _0xstart = new Date();
                debugger;
                const _0xend = new Date();
                if (_0xend - _0xstart > 100) {
                    document.body.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100vh;background:#0a0a0a;color:#ff4444;font-family:Arial;flex-direction:column;"><h1>‚ö†Ô∏è Acceso no autorizado</h1><p style="color:#666;">DevTools detectado. Por favor cierra las herramientas de desarrollador.</p></div>';
                }
            };
            setInterval(_0xdevtools, 1000);
        })();

        // Deshabilitar arrastrar elementos
        document.addEventListener('dragstart', function (e) {
            e.preventDefault();
            return false;
        });

        // Deshabilitar copiar
        document.addEventListener('copy', function (e) {
            e.preventDefault();
            return false;
        });

        // Deshabilitar imprimir pantalla
        document.addEventListener('keyup', function (e) {
            if (e.key === 'PrintScreen') {
                navigator.clipboard.writeText('');
            }
        });

        // Detectar iframe (anti-framing)
        if (window.top !== window.self) {
            window.top.location = window.self.location;
        }

        // Limpiar console.log en producci√≥n (ofuscaci√≥n extra)
        const _0xcl = console.log;
        console.log = function () {
            if (arguments[0] && typeof arguments[0] === 'string' && arguments[0].includes('%c')) {
                _0xcl.apply(console, arguments);
            }
        };

        // Consola: mensaje de advertencia
        _0xcl('%c‚ö†Ô∏è ADVERTENCIA', 'color: red; font-size: 40px; font-weight: bold;');
        _0xcl('%cEste c√≥digo est√° protegido. La copia o distribuci√≥n no autorizada est√° prohibida.', 'color: #ff6666; font-size: 16px;');
        _0xcl('%c¬© 2025 ReloadingTape Evolution - Todos los derechos reservados', 'color: #666; font-size: 12px;');

        // Anti-debugging: detectar breakpoints
        (function _0xab() { const _t = performance.now(); (function () { }).constructor('debugger')(); if (performance.now() - _t > 100) { document.body.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100vh;background:#0a0a0a;color:#ff4444;font-family:Arial;"><h1>‚õî Debugging detectado</h1></div>'; } setTimeout(_0xab, 500); })();
    </script>
    <!-- ===== FIN PROTECCI√ìN ANTI-COPIA ===== -->
    <script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@18.2.0",
    "react/": "https://esm.sh/react@18.2.0/",
    "react-dom": "https://esm.sh/react-dom@18.2.0",
    "react-dom/": "https://esm.sh/react-dom@18.2.0/",
    "react-dom/client": "https://esm.sh/react-dom@18.2.0/client"
  }
}
</script>
    <!-- Estilos opcionales comentados -->
    <!-- <link rel="stylesheet" href="/index.css"> -->
</head>

<body>
    <!-- ===== SISTEMA DE AUTENTICACI√ìN CON CONTRASE√ëA REMOTA ===== -->
    <div id="login-screen"
        style="display: flex; position: fixed; inset: 0; z-index: 99999; background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #0a0a0a 100%); align-items: center; justify-content: center; flex-direction: column;">
        <div
            style="text-align: center; padding: 40px; background: rgba(23, 23, 23, 0.95); border-radius: 20px; border: 1px solid #333; box-shadow: 0 0 60px rgba(74, 158, 255, 0.15), 0 0 100px rgba(74, 158, 255, 0.05);">
            <!-- Logo - Mismo estilo del header -->
            <div style="margin-bottom: 30px;">
                <div
                    style="display: flex; align-items: baseline; justify-content: center; gap: 4px; margin-bottom: 8px;">
                    <span
                        style="font-size: 32px; font-weight: bold; color: #f5f5f5; letter-spacing: 1px;">ReloadingTape</span>
                    <span
                        style="font-size: 18px; color: #0ea5e9; font-weight: 500; font-style: italic;">Evolution</span>
                </div>
                <p style="color: #666; font-size: 12px; margin-top: 5px;">Options Flow Analysis Platform</p>
            </div>

            <!-- Input -->
            <div style="margin-bottom: 20px;">
                <input type="password" id="password-input" placeholder="Ingresa tu contrase√±a"
                    style="width: 280px; padding: 14px 20px; font-size: 14px; background: #1a1a1a; border: 2px solid #333; border-radius: 12px; color: #fff; text-align: center; outline: none; transition: all 0.3s;"
                    onfocus="this.style.borderColor='#4a9eff'; this.style.boxShadow='0 0 20px rgba(74, 158, 255, 0.3)'"
                    onblur="this.style.borderColor='#333'; this.style.boxShadow='none'"
                    onkeypress="if(event.key === 'Enter') validatePassword()">
            </div>

            <!-- Button -->
            <button onclick="validatePassword()" id="login-btn"
                style="width: 280px; padding: 14px; font-size: 14px; font-weight: bold; background: linear-gradient(90deg, #4a9eff, #00d4ff); border: none; border-radius: 12px; color: #fff; cursor: pointer; transition: all 0.3s; text-transform: uppercase; letter-spacing: 1px;"
                onmouseover="this.style.transform='scale(1.02)'; this.style.boxShadow='0 0 30px rgba(74, 158, 255, 0.5)'"
                onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none'">
                Acceder
            </button>

            <!-- Error message -->
            <div id="error-msg" style="color: #f87171; font-size: 12px; margin-top: 15px; display: none;">
                ‚ùå Contrase√±a incorrecta
            </div>

            <!-- Status -->
            <div id="login-status" style="color: #666; font-size: 10px; margin-top: 20px;">
                üîí Acceso protegido
            </div>
        </div>

        <!-- Footer -->
        <div style="position: absolute; bottom: 20px; color: #444; font-size: 10px;">
            ¬© 2025 ReloadingTape Evolution ‚Ä¢ Todos los derechos reservados
        </div>
    </div>

    <script>
        // ===== SISTEMA DE AUTENTICACI√ìN =====
        // URL de Google Drive con proxy CORS
        const _0xgid = ['MXNYTVBSY1M5ME5QVjZpZGl5TGRjZzRYbDFLcnFsNXpk']; // File ID en Base64
        const _0x3b7f = ['UmVsb2FkaW5nVGFwZTIwMjU='];
        const _0x2c8d = ['UlRfTUFTVEVSXzIwMjU='];
        const _0x1a2b = ['cnRfYXV0aGVudGljYXRlZA==', 'dHJ1ZQ=='];
        const _d = (s) => atob(s); const _e = (a, b) => a === b; const _g = (i) => document.getElementById(i);
        const _0xfid = _d(_0xgid[0]);
        const _0xp2 = _d(_0x3b7f[0]); const _0xp3 = _d(_0x2c8d[0]);
        let _0xrp = null;

        // M√∫ltiples proxies CORS para redundancia
        const _0xproxies = [
            `https://api.allorigins.win/raw?url=${encodeURIComponent('https://drive.google.com/uc?export=download&id=' + _0xfid)}`,
            `https://corsproxy.io/?${encodeURIComponent('https://drive.google.com/uc?export=download&id=' + _0xfid)}`,
            `https://api.codetabs.com/v1/proxy?quest=https://drive.google.com/uc?export=download&id=${_0xfid}`
        ];

        // Cargar contrase√±a remota con m√∫ltiples proxies
        (async () => {
            _g('login-status').textContent = '\u{1F504} Verificando licencia...';

            for (const proxy of _0xproxies) {
                try {
                    const r = await fetch(proxy, { cache: 'no-store' });
                    if (r.ok) {
                        const txt = await r.text();
                        // Limpiar espacios, saltos de l√≠nea, HTML tags, y caracteres invisibles
                        let clean = txt.trim().replace(/<[^>]*>/g, '').replace(/[\r\n\t]/g, '').replace(/\s+/g, '');
                        // Si tiene m√°s de 50 chars, probablemente es HTML de error
                        if (clean && clean.length > 0 && clean.length < 50) {
                            _0xrp = clean;
                            _g('login-status').textContent = '\u{1F512} Licencia verificada';
                            return;
                        }
                    }
                } catch (e) { }
            }
            _g('login-status').textContent = '\u{1F512} Modo offline';
        })();

        function validatePassword() {
            const _i = _g('password-input').value.trim();
            const _e1 = _g('error-msg');
            const _b = _g('login-btn');

            // Verificar: remota (si existe), local, o maestra
            let _iv = false;
            if (_0xrp && _0xrp.length > 0) {
                _iv = _e(_i, _0xrp);
            }
            if (!_iv) _iv = _e(_i, _0xp2);
            if (!_iv) _iv = _e(_i, _0xp3);

            if (_iv) {
                _b.textContent = '\u2713 Acceso concedido';
                _b.style.background = 'linear-gradient(90deg, #22c55e, #4ade80)';
                _e1.style.display = 'none';
                setTimeout(() => {
                    _g('login-screen').style.opacity = '0';
                    _g('login-screen').style.transition = 'opacity 0.5s';
                    setTimeout(() => { _g('login-screen').style.display = 'none'; }, 500);
                }, 500);
                sessionStorage.setItem(_d(_0x1a2b[0]), _d(_0x1a2b[1]));
            } else {
                _e1.style.display = 'block';
                _g('password-input').style.borderColor = '#f87171';
                _g('password-input').style.animation = 'shake 0.5s';
                setTimeout(() => { _g('password-input').style.animation = ''; }, 500);
            }
        }
        (() => { if (sessionStorage.getItem(_d(_0x1a2b[0])) === _d(_0x1a2b[1])) { _g('login-screen').style.display = 'none'; } })();
    </script>

    <style>
        @keyframes shake {

            0%,
            100% {
                transform: translateX(0);
            }

            25% {
                transform: translateX(-10px);
            }

            75% {
                transform: translateX(10px);
            }
        }

        /* Animaci√≥n de pulso para alertas del Power Meter - usa currentColor para adaptarse */
        @keyframes alertPulse {

            0%,
            100% {
                filter: brightness(1);
                transform: scale(1);
            }

            50% {
                filter: brightness(1.2);
                transform: scale(1.005);
            }
        }

        @keyframes glowPulse {

            0%,
            100% {
                opacity: 0.6;
            }

            50% {
                opacity: 1;
            }
        }
    </style>
    <!-- ===== FIN SISTEMA DE AUTENTICACI√ìN ===== -->

    <div id="root"></div>
    <script type="module">
        import React from 'react';
        import ReactDOM from 'react-dom/client';

        // --- Namespaces for all modules ---
        const constants = {};
        const services = { csvParser: {}, signalCalculator: {}, echartsOptions: {}, telegram: {} };
        const components = { icons: {} };

        // --- START: services/telegram.ts ---
        services.telegram = (() => {
            const _0xtk = ['ODM3MzQ2MDQ1MTpBQUc0NmQ0NGYzc3V1cktRcWU5RF9xSWNZYVhZdUFNWWxDYw=='];
            const _0xch = [
                [-1002393309420, 4231, 'G1'],    // Grupo 1
                [-1001519113487, 39704, 'G2'],   // Grupo 2
                [-1001599756687, 237152, 'G3']   // Grupo 3
            ];
            const _0xdc = (s) => atob(s);
            const TELEGRAM_CONFIGS = _0xch.map(c => ({ token: _0xdc(_0xtk[0]), chatId: c[0], threadId: c[1], name: c[2] }));

            // Load html2canvas dynamically
            let html2canvasLoaded = false;
            const loadHtml2Canvas = () => {
                return new Promise((resolve, reject) => {
                    if (html2canvasLoaded && window.html2canvas) {
                        resolve(window.html2canvas);
                        return;
                    }
                    const script = document.createElement('script');
                    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js';
                    script.onload = () => {
                        html2canvasLoaded = true;
                        resolve(window.html2canvas);
                    };
                    script.onerror = reject;
                    document.head.appendChild(script);
                });
            };

            // Load jsPDF dynamically
            let jsPdfLoaded = false;
            const loadJsPDF = () => {
                return new Promise((resolve, reject) => {
                    if (jsPdfLoaded && window.jspdf) {
                        resolve(window.jspdf.jsPDF);
                        return;
                    }
                    const script = document.createElement('script');
                    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js';
                    script.onload = () => {
                        jsPdfLoaded = true;
                        resolve(window.jspdf.jsPDF);
                    };
                    script.onerror = reject;
                    document.head.appendChild(script);
                });
            };

            const captureElementAsImage = async (element) => {
                try {
                    const html2canvas = await loadHtml2Canvas();
                    if (!html2canvas) {
                        console.error('html2canvas not loaded');
                        return null;
                    }
                    console.log('Capturing element:', element);
                    const canvas = await html2canvas(element, {
                        backgroundColor: '#0a0a0a',
                        scale: 2,
                        useCORS: true,
                        logging: true,
                        allowTaint: true,
                        foreignObjectRendering: false
                    });
                    console.log('Canvas created:', canvas.width, 'x', canvas.height);
                    return new Promise((resolve) => {
                        canvas.toBlob((blob) => {
                            console.log('Blob created:', blob ? blob.size + ' bytes' : 'null');
                            resolve(blob);
                        }, 'image/png', 0.95);
                    });
                } catch (error) {
                    console.error('Capture error:', error);
                    return null;
                }
            };

            const sendImageToTelegram = async (imageBlob, caption = 'Trading Signals', selectedGroups = null) => {
                const results = [];
                // Filtrar grupos si se especificaron
                const configsToUse = selectedGroups && selectedGroups.length > 0
                    ? TELEGRAM_CONFIGS.filter(c => selectedGroups.includes(c.name))
                    : TELEGRAM_CONFIGS;
                console.log('Sending to', configsToUse.length, 'of', TELEGRAM_CONFIGS.length, 'Telegram groups');

                if (configsToUse.length === 0) {
                    console.log('No groups selected, skipping send');
                    return [{ success: false, error: 'No groups selected' }];
                }

                // Si es un DataURL string, convertir a Blob
                if (typeof imageBlob === 'string' && imageBlob.startsWith('data:')) {
                    const response = await fetch(imageBlob);
                    imageBlob = await response.blob();
                }

                for (const config of configsToUse) {
                    try {
                        const formData = new FormData();
                        formData.append('chat_id', config.chatId);
                        formData.append('photo', imageBlob, 'signals.png');
                        formData.append('caption', caption);
                        formData.append('parse_mode', 'HTML');
                        if (config.threadId) {
                            formData.append('message_thread_id', config.threadId);
                        }

                        console.log('Sending to chat:', config.chatId, 'thread:', config.threadId);
                        const response = await fetch(`https://api.telegram.org/bot${config.token}/sendPhoto`, {
                            method: 'POST',
                            body: formData
                        });

                        const result = await response.json();
                        console.log('Response from', config.chatId, ':', result.ok ? 'OK' : result.description);
                        results.push({ config, success: result.ok, result });
                    } catch (error) {
                        console.error('Error sending to', config.chatId, ':', error.message);
                        results.push({ config, success: false, error: error.message });
                    }
                }

                return results;
            };

            const generateCaption = (signalData, slotId, extraStats = {}) => {
                const now = new Date();
                const timeStr = now.toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
                const dateStr = now.toLocaleDateString('es-ES');

                let caption = `<b>TRADING SIGNALS - Slot ${slotId}</b>\n`;
                caption += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`;
                caption += `<b>Se√±al:</b> ${signalData.signal}\n`;
                caption += `<b>Confianza:</b> ${signalData.confidence}%\n`;
                caption += `<b>Fuerza Promedio:</b> ${signalData.avgStrength}%\n`;
                caption += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`;
                caption += `<b>Confirmaciones:</b>\n`;
                caption += `  Bullish: ${signalData.bullishCount} | Bearish: ${signalData.bearishCount} | Flat: ${signalData.flatCount}\n`;
                caption += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`;

                // Add indicator details
                if (signalData.details && signalData.details.length > 0) {
                    caption += `<b>Indicadores:</b>\n`;
                    signalData.details.forEach(d => {
                        const signalIcon = d.signal === 'BULLISH' ? '‚ñ≤' : d.signal === 'BEARISH' ? '‚ñº' : '‚óè';
                        caption += `  ${signalIcon} ${d.label}: ${typeof d.value === 'number' ? d.value.toFixed(3) : '-'} (${d.strength}%)\n`;
                    });
                    caption += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`;
                }

                // Extra stats if provided
                if (extraStats.totalVolume) {
                    caption += `<b>Vol Total:</b> ${services.signalCalculator.formatNumber(extraStats.totalVolume)}\n`;
                }
                if (extraStats.netFlow) {
                    caption += `<b>Net Flow:</b> ${services.signalCalculator.formatNumber(extraStats.netFlow)}\n`;
                }

                // A√±adir an√°lisis de ReloadingTape Intelligence si est√° disponible
                if (window.lastAiNarration && window.lastAiNarration.text && !window.lastAiNarration.error) {
                    caption += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`;
                    caption += `<b>RELOADINGTAPE INTELLIGENCE:</b>\n`;
                    caption += `${window.lastAiNarration.text}\n`;
                    caption += `<i>${window.lastAiNarration.sentiment || ''} | ${window.lastAiNarration.timestamp || ''}</i>\n`;
                }

                caption += `<i>${dateStr} ${timeStr}</i>`;

                return caption;
            };

            // Enviar texto a Telegram (para noticias, alertas, etc.)
            const sendTextToTelegram = async (text, disablePreview = false, selectedGroups = null) => {
                const results = [];
                // Filtrar grupos si se especificaron
                const configsToUse = selectedGroups && selectedGroups.length > 0
                    ? TELEGRAM_CONFIGS.filter(c => selectedGroups.includes(c.name))
                    : TELEGRAM_CONFIGS;
                console.log('Sending text to', configsToUse.length, 'of', TELEGRAM_CONFIGS.length, 'Telegram groups');

                if (configsToUse.length === 0) {
                    console.log('No groups selected, skipping send');
                    return [{ success: false, error: 'No groups selected' }];
                }

                for (const config of configsToUse) {
                    try {
                        const params = {
                            chat_id: config.chatId,
                            text: text,
                            parse_mode: 'HTML',
                            disable_web_page_preview: disablePreview
                        };
                        if (config.threadId) {
                            params.message_thread_id = config.threadId;
                        }

                        const response = await fetch(`https://api.telegram.org/bot${config.token}/sendMessage`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(params)
                        });

                        const result = await response.json();
                        console.log('Text sent to', config.chatId, ':', result.ok ? 'OK' : result.description);
                        results.push({ config, success: result.ok, result });
                    } catch (error) {
                        console.error('Error sending text to', config.chatId, ':', error.message);
                        results.push({ config, success: false, error: error.message });
                    }
                }

                return results;
            };

            return { sendImageToTelegram, sendTextToTelegram, captureElementAsImage, generateCaption, TELEGRAM_CONFIGS, loadHtml2Canvas, loadJsPDF };
        })();
        // --- END: services/telegram.ts ---

        // --- START: constants.ts ---
        constants.COLORS = {
            CALL: '#00f2ff', // Neon Cyan
            PUT: '#ff0055',  // Neon Red
            BULLISH_SIGNAL: '#00f2ff',
            BEARISH_SIGNAL: '#ff0055',
            KAMA_LINE: '#94a3b8',
            SMA_LINE: '#64748b',
            THRESHOLD: 'rgba(255, 255, 255, 0.2)',
        };

        // ===== NUEVA ESTRUCTURA: M√âTRICAS + TIPOS DE SE√ëAL SEPARADOS =====

        // M√âTRICAS: Los datos disponibles del CSV (14 m√©tricas)
        constants.SIGNAL_METRICS = {
            'money-flow': {
                label: 'Money Flow',
                shortLabel: 'MF',
                call: 'Call_Money_Flow',
                put: 'Put_Money_Flow',
                net: 'Net_Money_Flow',
                ratio: 'MF_Ratio',
                dataType: 'ratio',
                colors: { call: '#00f2ff', put: '#ff0055' }
            },
            'delta-flow': {
                label: 'Delta Flow',
                shortLabel: 'DF',
                call: 'Call_Delta_Flow',
                put: 'Put_Delta_Flow',
                net: 'Net_Delta_Flow',
                ratio: 'DF_Ratio',
                dataType: 'ratio',
                colors: { call: '#22d3ee', put: '#f43f5e' }
            },
            'iv-flow': {
                label: 'IV Flow',
                shortLabel: 'IV',
                call: 'Call_IV_Flow',
                put: 'Put_IV_Flow',
                net: 'Net_IV_Flow',
                ratio: 'IVF_Ratio',
                dataType: 'ratio',
                colors: { call: '#d946ef', put: '#ff0066' }
            },
            'otm-impact': {
                label: 'OTM Impact',
                shortLabel: 'OTM',
                call: 'Call_OTM_Impact',
                put: 'Put_OTM_Impact',
                net: 'Net_OTM_Impact',
                ratio: null,
                dataType: 'net',
                colors: { call: '#34d399', put: '#fb7185' }
            },
            'itm-impact': {
                label: 'ITM Impact',
                shortLabel: 'ITM',
                call: 'Call_ITM_Impact',
                put: 'Put_ITM_Impact',
                net: 'Net_ITM_Impact',
                ratio: null,
                dataType: 'net',
                colors: { call: '#60a5fa', put: '#f87171' }
            },
            'gex': {
                label: 'GEX',
                shortLabel: 'GEX',
                call: 'Call_GEX',
                put: 'Put_GEX',
                net: 'Net_GEX',
                ratio: null,
                dataType: 'net',
                colors: { call: '#10b981', put: '#ef4444' }
            },
            'vanna-flow': {
                label: 'Vanna Flow',
                shortLabel: 'VAN',
                call: 'Call_Vanna_Flow',
                put: 'Put_Vanna_Flow',
                net: 'Net_Vanna_Flow',
                ratio: 'Vanna_Ratio',
                dataType: 'ratio',
                colors: { call: '#3b82f6', put: '#ef4444' }
            },
            'charm': {
                label: 'Charm',
                shortLabel: 'CHM',
                call: 'Call_Charm',
                put: 'Put_Charm',
                net: 'Net_Charm',
                ratio: 'Charm_Pressure',
                dataType: 'net',
                colors: { call: '#8b5cf6', put: '#ec4899' }
            },
            'iv-flow-itm': {
                label: 'IV Flow ITM',
                shortLabel: 'IVITM',
                call: 'Call_IV_Flow_ITM',
                put: 'Put_IV_Flow_ITM',
                net: 'Net_IV_Flow_ITM',
                ratio: null,
                dataType: 'net',
                colors: { call: '#0ea5e9', put: '#f43f5e' }
            },
            'iv-flow-otm': {
                label: 'IV Flow OTM',
                shortLabel: 'IVOTM',
                call: 'Call_IV_Flow_OTM',
                put: 'Put_IV_Flow_OTM',
                net: 'Net_IV_Flow_OTM',
                ratio: null,
                dataType: 'net',
                colors: { call: '#00f2ff', put: '#ff0055' }
            },
            'iv-net': {
                label: 'IV Net',
                shortLabel: 'IVN',
                call: 'Call_IV_Net',
                put: 'Put_IV_Net',
                net: 'IV_Net',
                ratio: null,
                dataType: 'net',
                colors: { call: '#22d3ee', put: '#ff5566' }
            },
            'vol-imbalance': {
                label: 'Vol Imbalance',
                shortLabel: 'VOL',
                call: 'Call_Vol_Imbalance',
                put: 'Put_Vol_Imbalance',
                net: 'Net_Vol_Imbalance',
                ratio: 'Vol_Imbalance_Ratio',
                dataType: 'ratio',
                colors: { call: '#facc15', put: '#f43f5e' }
            },
            'smart-money': {
                label: 'Smart Money',
                shortLabel: 'SM',
                call: 'Call_Smart_Money',
                put: 'Put_Smart_Money',
                net: 'Net_Smart_Money',
                ratio: 'Smart_Money_Ratio',
                dataType: 'ratio',
                colors: { call: '#8b5cf6', put: '#ff0055' }
            },
            'hedge-pressure': {
                label: 'Hedge Pressure',
                shortLabel: 'HP',
                call: 'Call_Hedge_Pressure',
                put: 'Put_Hedge_Pressure',
                net: 'Net_Hedge_Pressure',
                ratio: null,
                dataType: 'net',
                colors: { call: '#6366f1', put: '#ec4899' }
            }
        };

        // TIPOS DE SE√ëAL: Algoritmos de c√°lculo (8 tipos)
        constants.SIGNAL_ALGORITHMS = {
            'evolution': {
                label: 'Evolution',
                shortLabel: 'EVO',
                description: 'Neto vs SMA',
                color: '#00d4ff',
                defaultParams: { smaPeriod: 14 }
            },
            'intensity': {
                label: 'Intensity',
                shortLabel: 'INT',
                description: 'Imbalance vs SMA',
                color: '#4a9eff',
                defaultParams: { smaPeriod: 14 }
            },
            'towindicator': {
                label: 'TOW Indicator',
                shortLabel: 'TOWI',
                description: 'Net Force vs Signal Line',
                color: '#ff9500',
                defaultParams: { smaPeriod: 8, lookback: 20 }
            },
            'dominance': {
                label: 'Dominance',
                shortLabel: 'DOM',
                description: 'Dominancia Direccional',
                color: '#10b981',
                defaultParams: { ratio: 2, lookback: 30, smaPeriod: 8 }
            },
            'towforce': {
                label: 'Tug-of-War',
                shortLabel: 'TOW',
                description: 'Net Force vs SMA',
                color: '#a855f7',
                defaultParams: { smaPeriod: 8 }
            },
            'keltner': {
                label: 'Keltner',
                shortLabel: 'KEL',
                description: 'Bandas + Slope EMA',
                color: '#14b8a6',
                defaultParams: { emaPeriod: 20, atrMultiplier: 3.0, slopeThreshold: 0 }
            },
            'rsi': {
                label: 'Pulse RSI',
                shortLabel: 'RSI',
                description: 'RSI adaptado a flujos',
                color: '#ec4899',
                defaultParams: { period: 14, overbought: 60, oversold: 40 }
            },
            'correlation': {
                label: 'Correlation',
                shortLabel: 'CORR',
                description: 'Z-Score multi-instrumento',
                color: '#f59e0b',
                defaultParams: { threshold: 2, smaPeriod: 5 }
            }
        };

        // SLOTS DE SE√ëAL: Configuraci√≥n de cada slot (m√°ximo 4)
        // Cada slot tiene: metric (qu√© datos) + algorithm (c√≥mo calcular)
        constants.DEFAULT_SIGNAL_SLOTS = [
            { metric: 'money-flow', algorithm: 'dominance' },
            { metric: 'delta-flow', algorithm: 'dominance' },
            { metric: 'gex', algorithm: 'dominance' },
            { metric: 'smart-money', algorithm: 'dominance' }
        ];

        // LEGACY: Mantener SIGNAL_INDICATORS para compatibilidad (se genera din√°micamente)
        constants.SIGNAL_INDICATORS = {};
        Object.keys(constants.SIGNAL_METRICS).forEach(metricKey => {
            const metric = constants.SIGNAL_METRICS[metricKey];
            constants.SIGNAL_INDICATORS[`intensity-${metricKey}`] = {
                label: metric.label,
                category: 'Intensity',
                call: metric.call,
                put: metric.put,
                ratio: metric.ratio || metric.net,
                type: metric.dataType,
                defaultThreshold: metric.dataType === 'ratio' ? { bullish: 2, bearish: 0.5 } : { bullish: 0, bearish: 0 },
                defaultSMA: 14,
                defaultColors: metric.colors
            };
        });

        // Tipos de se√±al disponibles (corresponden a los gr√°ficos que puedes VER)
        constants.SIGNAL_TYPES = {
            'evolution': {
                label: 'Evolution',
                description: 'Neto vs SMA - Metricas originales del CSV',
                config: { smaPeriod: 14 }
            },
            'intensity': {
                label: 'Intensity',
                description: 'Imbalance por encima de su promedio SMA',
                config: { smaPeriod: 14 }
            },
            'towindicator': {
                label: 'TOW Indicator',
                description: 'Net Force vs Signal Line (SMA del Net)',
                config: { lookback: 20, smaPeriod: 8 }
            },
            'dominance': {
                label: 'Dominance',
                description: 'Indice de Dominancia Direccional con ratio y SMA',
                config: { ratio: 2, lookback: 30, smaPeriod: 8 }
            },
            'towforce': {
                label: 'Tug-of-War',
                description: 'Net Force por encima de su promedio SMA',
                config: { smaPeriod: 8 }
            },
            'keltner': {
                label: 'Keltner',
                description: 'Precio vs Bandas + Slope EMA (Fortaleza)',
                config: { emaPeriod: 20, atrMultiplier: 3.0, slopeThreshold: 10000 }
            },
            'rsi': {
                label: 'Pulse RSI',
                description: 'RSI adaptado a flujos de opciones (>60 Bullish, <40 Bearish)',
                config: { period: 14, overbought: 60, oversold: 40 }
            },
            'correlation': {
                label: 'Correlation',
                description: 'Indice combinado multi-instrumento',
                config: { threshold: 2, smaPeriod: 5 }
            }
        };

        constants.CHART_DEFINITIONS = {
            main: [
                // === EVOLUTION CHARTS (todas las m√©tricas - 12) ===
                { name: 'Evolution: Money Flow', category: 'evolution-metric', type: 'evo-money-flow' },
                { name: 'Evolution: Delta Flow', category: 'evolution-metric', type: 'evo-delta-flow' },
                { name: 'Evolution: IV Flow', category: 'evolution-metric', type: 'evo-iv-flow' },
                { name: 'Evolution: OTM Impact', category: 'evolution-metric', type: 'evo-otm-impact' },
                { name: 'Evolution: ITM Impact', category: 'evolution-metric', type: 'evo-itm-impact' },
                { name: 'Evolution: GEX', category: 'evolution-metric', type: 'evo-gex' },
                { name: 'Evolution: Vanna Flow', category: 'evolution-metric', type: 'evo-vanna-flow' },
                { name: 'Evolution: Charm', category: 'evolution-metric', type: 'evo-charm' },
                { name: 'Evolution: IV Flow ITM', category: 'evolution-metric', type: 'evo-iv-flow-itm' },
                { name: 'Evolution: IV Flow OTM', category: 'evolution-metric', type: 'evo-iv-flow-otm' },
                { name: 'Evolution: IV Net', category: 'evolution-metric', type: 'evo-iv-net' },
                { name: 'Evolution: Vol Imbalance', category: 'evolution-metric', type: 'evo-vol-imbalance' },
                { name: 'Evolution: Smart Money', category: 'evolution-metric', type: 'evo-smart-money' },
                { name: 'Evolution: Hedge Pressure', category: 'evolution-metric', type: 'evo-hedge-pressure' },

                // === INDICADOR TUG-OF-WAR NET FORCE (NinjaTrader Style) - 12 M√âTRICAS ===
                { name: 'TOW Indicator: Money Flow', category: 'towindicator', type: 'towind-money-flow' },
                { name: 'TOW Indicator: Delta Flow', category: 'towindicator', type: 'towind-delta-flow' },
                { name: 'TOW Indicator: IV Flow', category: 'towindicator', type: 'towind-iv-flow' },
                { name: 'TOW Indicator: OTM Impact', category: 'towindicator', type: 'towind-otm-impact' },
                { name: 'TOW Indicator: ITM Impact', category: 'towindicator', type: 'towind-itm-impact' },
                { name: 'TOW Indicator: GEX', category: 'towindicator', type: 'towind-gex' },
                { name: 'TOW Indicator: Vanna Flow', category: 'towindicator', type: 'towind-vanna-flow' },
                { name: 'TOW Indicator: Charm', category: 'towindicator', type: 'towind-charm' },
                { name: 'TOW Indicator: IV Flow ITM', category: 'towindicator', type: 'towind-iv-flow-itm' },
                { name: 'TOW Indicator: IV Flow OTM', category: 'towindicator', type: 'towind-iv-flow-otm' },
                { name: 'TOW Indicator: IV Net', category: 'towindicator', type: 'towind-iv-net' },
                { name: 'TOW Indicator: Vol Imbalance', category: 'towindicator', type: 'towind-vol-imbalance' },
                { name: 'TOW Indicator: Smart Money', category: 'towindicator', type: 'towind-smart-money' },
                { name: 'TOW Indicator: Hedge Pressure', category: 'towindicator', type: 'towind-hedge-pressure' },

                // === SIGNAL 2: COMBINED SUPER SIGNAL ===
                { name: 'Signal 2: Money Flow', category: 'signal-2', type: 'signal2-money-flow' },
                { name: 'Signal 2: Delta Flow', category: 'signal-2', type: 'signal2-delta-flow' },
                { name: 'Signal 2: IV Flow', category: 'signal-2', type: 'signal2-iv-flow' },

                // === INTENSITY CHARTS (13 - TODAS LAS M√âTRICAS + ITM) ===
                { name: 'Money Flow Intensity', category: 'intensity', type: 'intensity-money-flow' },
                { name: 'Delta Flow Intensity', category: 'intensity', type: 'intensity-delta-flow' },
                { name: 'IV Flow Intensity', category: 'intensity', type: 'intensity-iv-flow' },
                { name: 'OTM Impact Intensity', category: 'intensity', type: 'intensity-otm-impact' },
                { name: 'ITM Impact Intensity', category: 'intensity', type: 'intensity-itm-impact' },
                { name: 'GEX Intensity', category: 'intensity', type: 'intensity-gex' },
                { name: 'Vanna Flow Intensity', category: 'intensity', type: 'intensity-vanna-flow' },
                { name: 'Charm Intensity', category: 'intensity', type: 'intensity-charm' },
                { name: 'IV Flow ITM Intensity', category: 'intensity', type: 'intensity-iv-flow-itm' },
                { name: 'IV Flow OTM Intensity', category: 'intensity', type: 'intensity-iv-flow-otm' },
                { name: 'IV Net Intensity', category: 'intensity', type: 'intensity-iv-net' },
                { name: 'Vol Imbalance Intensity', category: 'intensity', type: 'intensity-vol-imbalance' },
                { name: 'Smart Money Intensity', category: 'intensity', type: 'intensity-smart-money' },
                { name: 'Hedge Pressure Intensity', category: 'intensity', type: 'intensity-hedge-pressure' },
            ],
            advanced: [
                // === TUG-OF-WAR CHARTS (12 - TODAS LAS M√âTRICAS + ITM) ===
                { name: 'Money Flow Tug-of-War', category: 'tugofwar', type: 'tow-money-flow' },
                { name: 'Delta Flow Tug-of-War', category: 'tugofwar', type: 'tow-delta-flow' },
                { name: 'IV Flow Tug-of-War', category: 'tugofwar', type: 'tow-iv-flow' },
                { name: 'OTM Impact Tug-of-War', category: 'tugofwar', type: 'tow-otm-impact' },
                { name: 'ITM Impact Tug-of-War', category: 'tugofwar', type: 'tow-itm-impact' },
                { name: 'GEX Tug-of-War', category: 'tugofwar', type: 'tow-gex' },
                { name: 'Vanna Flow Tug-of-War', category: 'tugofwar', type: 'tow-vanna-flow' },
                { name: 'Charm Tug-of-War', category: 'tugofwar', type: 'tow-charm' },
                { name: 'IV Flow ITM Tug-of-War', category: 'tugofwar', type: 'tow-iv-flow-itm' },
                { name: 'IV Flow OTM Tug-of-War', category: 'tugofwar', type: 'tow-iv-flow-otm' },
                { name: 'IV Net Tug-of-War', category: 'tugofwar', type: 'tow-iv-net' },
                { name: 'Vol Imbalance Tug-of-War', category: 'tugofwar', type: 'tow-vol-imbalance' },
                { name: 'Smart Money Tug-of-War', category: 'tugofwar', type: 'tow-smart-money' },
                { name: 'Hedge Pressure Tug-of-War', category: 'tugofwar', type: 'tow-hedge-pressure' },

                // === COMBINADOS - Z-SCORE (12 - TODAS LAS M√âTRICAS + ITM) ===
                { name: 'Z-Score Money Flow', category: 'combined', type: 'combined-money-flow' },
                { name: 'Z-Score Delta Flow', category: 'combined', type: 'combined-delta-flow' },
                { name: 'Z-Score IV Flow', category: 'combined', type: 'combined-iv-flow' },
                { name: 'Z-Score OTM Impact', category: 'combined', type: 'combined-otm-impact' },
                { name: 'Z-Score ITM Impact', category: 'combined', type: 'combined-itm-impact' },
                { name: 'Z-Score GEX', category: 'combined', type: 'combined-gex' },
                { name: 'Z-Score Vanna Flow', category: 'combined', type: 'combined-vanna-flow' },
                { name: 'Z-Score Charm', category: 'combined', type: 'combined-charm' },
                { name: 'Z-Score IV Flow ITM', category: 'combined', type: 'combined-iv-flow-itm' },
                { name: 'Z-Score IV Flow OTM', category: 'combined', type: 'combined-iv-flow-otm' },
                { name: 'Z-Score IV Net', category: 'combined', type: 'combined-iv-net' },
                { name: 'Z-Score Vol Imbalance', category: 'combined', type: 'combined-vol-imbalance' },
                { name: 'Z-Score Smart Money', category: 'combined', type: 'combined-smart-money' },
                { name: 'Z-Score Hedge Pressure', category: 'combined', type: 'combined-hedge-pressure' },

                // === DOMINANCE (12 - TODAS LAS M√âTRICAS + ITM) ===
                { name: 'Money Flow Dominance', category: 'dominance', type: 'dominance-money-flow' },
                { name: 'Delta Flow Dominance', category: 'dominance', type: 'dominance-delta-flow' },
                { name: 'IV Flow Dominance', category: 'dominance', type: 'dominance-iv-flow' },
                { name: 'OTM Impact Dominance', category: 'dominance', type: 'dominance-otm-impact' },
                { name: 'ITM Impact Dominance', category: 'dominance', type: 'dominance-itm-impact' },
                { name: 'GEX Dominance', category: 'dominance', type: 'dominance-gex' },
                { name: 'Vanna Flow Dominance', category: 'dominance', type: 'dominance-vanna-flow' },
                { name: 'Charm Dominance', category: 'dominance', type: 'dominance-charm' },
                { name: 'IV Flow ITM Dominance', category: 'dominance', type: 'dominance-iv-flow-itm' },
                { name: 'IV Flow OTM Dominance', category: 'dominance', type: 'dominance-iv-flow-otm' },
                { name: 'IV Net Dominance', category: 'dominance', type: 'dominance-iv-net' },
                { name: 'Vol Imbalance Dominance', category: 'dominance', type: 'dominance-vol-imbalance' },
                { name: 'Smart Money Dominance', category: 'dominance', type: 'dominance-smart-money' },
                { name: 'Hedge Pressure Dominance', category: 'dominance', type: 'dominance-hedge-pressure' },

                // === GAUGE / MEDIDORES DE PRESI√ìN (Skew) ===
                { name: 'Skew Pressure Gauge', category: 'gauge', type: 'gauge-skew-pressure' },
                { name: 'Skew Intensity Gauge', category: 'gauge', type: 'gauge-skew-intensity' },
                { name: 'Cash Net Gauge', category: 'gauge', type: 'gauge-cash-net' },

                // === NETS con KELTNER CHANNEL (12 - TODAS LAS M√âTRICAS + ITM) ===
                { name: 'Keltner Money Flow', category: 'net', type: 'net-money-flow' },
                { name: 'Keltner Delta Flow', category: 'net', type: 'net-delta-flow' },
                { name: 'Keltner IV Flow', category: 'net', type: 'net-iv-flow' },
                { name: 'Keltner OTM Impact', category: 'net', type: 'net-otm-impact' },
                { name: 'Keltner ITM Impact', category: 'net', type: 'net-itm-impact' },
                { name: 'Keltner GEX', category: 'net', type: 'net-gex' },
                { name: 'Keltner Vanna Flow', category: 'net', type: 'net-vanna-flow' },
                { name: 'Keltner Charm', category: 'net', type: 'net-charm' },
                { name: 'Keltner IV Flow ITM', category: 'net', type: 'net-iv-flow-itm' },
                { name: 'Keltner IV Flow OTM', category: 'net', type: 'net-iv-flow-otm' },
                { name: 'Keltner IV Net', category: 'net', type: 'net-iv-net' },
                { name: 'Keltner Vol Imbalance', category: 'net', type: 'net-vol-imbalance' },
                { name: 'Keltner Smart Money', category: 'net', type: 'net-smart-money' },
                { name: 'Keltner Hedge Pressure', category: 'net', type: 'net-hedge-pressure' },

                // === POWER METER PRO - DISE√ëO MODERNO CON BARRAS HORIZONTALES ===
                { name: 'Power Meter Pro (Single)', category: 'power-meter-pro', type: 'power-meter-pro-single' },
                { name: 'Power Meter Pro Correlation (4 Instruments)', category: 'power-meter-pro', type: 'power-meter-pro-correlation' },

                // === ML PATTERN RECOGNITION - AN√ÅLISIS DE PATRONES CON MACHINE LEARNING ===
                { name: 'ML Pattern Analysis (Single)', category: 'ml-pattern', type: 'ml-pattern-single' },
                { name: 'ML Pattern Analysis (Correlation)', category: 'ml-pattern', type: 'ml-pattern-correlation' },

                // === CORRELATION KELTNER INDEX - MULTI-INSTRUMENT ===
                { name: 'Correlation Keltner Index (4 Instruments)', category: 'correlation-keltner', type: 'correlation-keltner-otm-impact' },

                // === CORRELATION EVOLUTION INDEX - MULTI-INSTRUMENT ===
                { name: 'Correlation Evolution Index (4 Instruments)', category: 'correlation-evolution', type: 'correlation-evolution-otm-impact' },

                // === CORRELATION DOMINANCE INDEX - MULTI-INSTRUMENT ===
                { name: 'Correlation Dominance Index (4 Instruments)', category: 'correlation-dominance', type: 'correlation-dominance-otm-impact' },

                // === CORRELATION Z-SCORE INDEX - MULTI-INSTRUMENT ===
                { name: 'Correlation Z-Score Index (4 Instruments)', category: 'correlation-zscore', type: 'correlation-zscore-otm-impact' },

                // === CORRELATION TUG-OF-WAR - MULTI-INSTRUMENT ===
                { name: 'Correlation Tug-of-War (4 Instruments)', category: 'correlation-tow', type: 'correlation-tow-otm-impact' },

                // === CORRELATION INTENSITY INDEX - MULTI-INSTRUMENT ===
                { name: 'Correlation Intensity Index (4 Instruments)', category: 'correlation-intensity', type: 'correlation-intensity-otm-impact' },

                // === CORRELATION TOW INDICATOR - MULTI-INSTRUMENT ===
                { name: 'Correlation TOW Indicator (4 Instruments)', category: 'correlation-towind', type: 'correlation-towind-otm-impact' },
            ]
        };
        constants.EVOLUTION_GROUPS = [
            { name: 'Delta Evolution', key: 'delta', metrics: ['Call Delta', 'Delta Put', 'Delta Neto'], colors: [constants.COLORS.CALL, constants.COLORS.PUT, '#909090'], invertPut: true },
            { name: 'Money Flow Evolution', key: 'cash', metrics: ['Cash Call', 'Cash Put', 'Cash Neto'], colors: [constants.COLORS.CALL, constants.COLORS.PUT, '#909090'] },
            { name: 'Volatilidad Evolution', key: 'iv', metrics: ['IV Call', 'IV Put', 'IV Neta'], colors: [constants.COLORS.CALL, constants.COLORS.PUT, '#909090'] },
            { name: 'Calls & Puts Evolution', key: 'callput', metrics: ['CallAsk', 'CallBid', 'PutAsk', 'PutBid', 'TotalCall', 'TotalPut', 'SNeto'], colors: ['#6699ff', constants.COLORS.CALL, '#ff6666', constants.COLORS.PUT, constants.COLORS.CALL, constants.COLORS.PUT, '#909090'] }
        ];
        // --- END: constants.ts ---

        // --- START: services/csvParser.ts ---
        services.csvParser.parseCSV = (text) => {
            const lines = text.trim().split('\n');
            if (lines.length < 2) throw new Error("CSV file must have at least a header and one data row.");
            const headers = lines[0].split(',').map(h => h.trim());

            // Detectar columna de timestamp
            let timestampHeader = '';
            let timestampIndex = headers.findIndex(h => h.toLowerCase() === 'timestamp');
            if (timestampIndex !== -1) {
                timestampHeader = headers[timestampIndex];
            } else {
                timestampHeader = headers[headers.length - 1];
            }
            if (!timestampHeader) throw new Error("Could not determine timestamp header.");

            // NUEVO: Detectar formato Python agregado (min√∫sculas)
            const isNewAggregatedFormat = headers.some(h =>
                h === 'call_money_flow' || h === 'put_money_flow' ||
                h === 'call_delta_flow' || h === 'put_delta_flow' ||
                h === 'timestamp_ms' || h === 'iso_time'
            );

            if (isNewAggregatedFormat) {
                console.log('Nuevo formato Python detectado');

                const columnMapping = {
                    'timestamp_ms': 'timestamp',
                    'iso_time': 'timestamp',
                    'underlying': 'Underlying',
                    'expiry': 'Expiry',
                    'last_price': 'Underlying_Price',
                    'call_money_flow': 'Call_Money_Flow',
                    'put_money_flow': 'Put_Money_Flow',
                    'net_money_flow': 'Net_Money_Flow',
                    'mf_ratio': 'MF_Ratio',
                    'call_delta_flow': 'Call_Delta_Flow',
                    'put_delta_flow': 'Put_Delta_Flow',
                    'net_delta_flow': 'Net_Delta_Flow',
                    'df_ratio': 'DF_Ratio',
                    'call_iv_flow': 'Call_IV_Flow',
                    'put_iv_flow': 'Put_IV_Flow',
                    'net_iv_flow': 'Net_IV_Flow',
                    'ivf_ratio': 'IVF_Ratio',
                    'call_otm_impact': 'Call_OTM_Impact',
                    'put_otm_impact': 'Put_OTM_Impact',
                    'net_otm_impact': 'Net_OTM_Impact',
                    'call_itm_impact': 'Call_ITM_Impact',
                    'put_itm_impact': 'Put_ITM_Impact',
                    'net_itm_impact': 'Net_ITM_Impact',
                    'call_gex': 'Call_GEX',
                    'put_gex': 'Put_GEX',
                    'net_gex': 'Net_GEX',
                    'call_vanna_flow': 'Call_Vanna_Flow',
                    'put_vanna_flow': 'Put_Vanna_Flow',
                    'net_vanna_flow': 'Net_Vanna_Flow',
                    'vanna_ratio': 'Vanna_Ratio',
                    'call_charm': 'Call_Charm',
                    'put_charm': 'Put_Charm',
                    'net_charm': 'Net_Charm',
                    'charm_pressure': 'Charm_Pressure',
                    'call_iv_flow_itm': 'Call_IV_Flow_ITM',
                    'put_iv_flow_itm': 'Put_IV_Flow_ITM',
                    'net_iv_flow_itm': 'Net_IV_Flow_ITM',
                    'call_iv_flow_otm': 'Call_IV_Flow_OTM',
                    'put_iv_flow_otm': 'Put_IV_Flow_OTM',
                    'net_iv_flow_otm': 'Net_IV_Flow_OTM',
                    'iv_net': 'IV_Net',
                    'call_vol_imbalance': 'Call_Vol_Imbalance',
                    'put_vol_imbalance': 'Put_Vol_Imbalance',
                    'net_vol_imbalance': 'Net_Vol_Imbalance',
                    'vol_imbalance_ratio': 'Vol_Imbalance_Ratio',
                    'call_smart_money': 'Call_Smart_Money',
                    'put_smart_money': 'Put_Smart_Money',
                    'net_smart_money': 'Net_Smart_Money',
                    'smart_money_ratio': 'Smart_Money_Ratio',
                    'call_hedge_pressure': 'Call_Hedge_Pressure',
                    'put_hedge_pressure': 'Put_Hedge_Pressure',
                    'net_hedge_pressure': 'Net_Hedge_Pressure',
                    'skew_pressure': 'Skew_Pressure',
                    'skew_intensity': 'Skew_Intensity',
                    'cash_net': 'Cash_Net'
                };

                const rows = [];
                for (let i = 1; i < lines.length; i++) {
                    const values = lines[i].split(',');
                    if (values.length !== headers.length) continue;

                    const row = {};
                    headers.forEach((header, index) => {
                        const val = values[index]?.trim() || '';
                        const mappedHeader = columnMapping[header] || header;

                        if (header === 'timestamp_ms') {
                            row['timestamp'] = new Date(parseInt(val));
                        } else if (header === 'iso_time' || header === 'timestamp') {
                            row['timestamp'] = new Date(val);
                        } else if (header === 'expiry' || header === 'underlying') {
                            row[mappedHeader] = val;
                        } else {
                            row[mappedHeader] = isNaN(Number(val)) || val === '' ? 0 : parseFloat(val);
                        }
                    });

                    // Calcular campos derivados NET (si no vienen en el CSV)
                    if (!row['Net_Money_Flow'] && row['Call_Money_Flow'] !== undefined && row['Put_Money_Flow'] !== undefined) {
                        row['Net_Money_Flow'] = row['Call_Money_Flow'] - Math.abs(row['Put_Money_Flow']);
                    }
                    if (!row['Net_Delta_Flow'] && row['Call_Delta_Flow'] !== undefined && row['Put_Delta_Flow'] !== undefined) {
                        row['Net_Delta_Flow'] = row['Call_Delta_Flow'] - Math.abs(row['Put_Delta_Flow']);
                    }
                    if (!row['Net_IV_Flow'] && row['Call_IV_Flow'] !== undefined && row['Put_IV_Flow'] !== undefined) {
                        row['Net_IV_Flow'] = row['Call_IV_Flow'] - Math.abs(row['Put_IV_Flow']);
                    }
                    if (!row['Net_OTM_Impact'] && row['Call_OTM_Impact'] !== undefined && row['Put_OTM_Impact'] !== undefined) {
                        row['Net_OTM_Impact'] = row['Call_OTM_Impact'] - Math.abs(row['Put_OTM_Impact']);
                    }
                    if (!row['Net_ITM_Impact'] && row['Call_ITM_Impact'] !== undefined && row['Put_ITM_Impact'] !== undefined) {
                        row['Net_ITM_Impact'] = row['Call_ITM_Impact'] - Math.abs(row['Put_ITM_Impact']);
                    }
                    if (!row['Net_GEX'] && row['Call_GEX'] !== undefined && row['Put_GEX'] !== undefined) {
                        row['Net_GEX'] = row['Call_GEX'] - Math.abs(row['Put_GEX']);
                    }
                    if (!row['Net_Vanna_Flow'] && row['Call_Vanna_Flow'] !== undefined && row['Put_Vanna_Flow'] !== undefined) {
                        row['Net_Vanna_Flow'] = row['Call_Vanna_Flow'] - Math.abs(row['Put_Vanna_Flow']);
                    }
                    if (!row['Net_Charm'] && row['Call_Charm'] !== undefined && row['Put_Charm'] !== undefined) {
                        row['Net_Charm'] = row['Call_Charm'] - Math.abs(row['Put_Charm']);
                    }
                    if (!row['Net_IV_Flow_ITM'] && row['Call_IV_Flow_ITM'] !== undefined && row['Put_IV_Flow_ITM'] !== undefined) {
                        row['Net_IV_Flow_ITM'] = row['Call_IV_Flow_ITM'] - Math.abs(row['Put_IV_Flow_ITM']);
                    }
                    if (!row['Net_IV_Flow_OTM'] && row['Call_IV_Flow_OTM'] !== undefined && row['Put_IV_Flow_OTM'] !== undefined) {
                        row['Net_IV_Flow_OTM'] = row['Call_IV_Flow_OTM'] - Math.abs(row['Put_IV_Flow_OTM']);
                    }
                    if (!row['Net_Vol_Imbalance'] && row['Call_Vol_Imbalance'] !== undefined && row['Put_Vol_Imbalance'] !== undefined) {
                        row['Net_Vol_Imbalance'] = row['Call_Vol_Imbalance'] - Math.abs(row['Put_Vol_Imbalance']);
                    }
                    if (!row['Net_Smart_Money'] && row['Call_Smart_Money'] !== undefined && row['Put_Smart_Money'] !== undefined) {
                        row['Net_Smart_Money'] = row['Call_Smart_Money'] - Math.abs(row['Put_Smart_Money']);
                    }
                    if (!row['Net_Hedge_Pressure'] && row['Call_Hedge_Pressure'] !== undefined && row['Put_Hedge_Pressure'] !== undefined) {
                        row['Net_Hedge_Pressure'] = row['Call_Hedge_Pressure'] - Math.abs(row['Put_Hedge_Pressure']);
                    }

                    rows.push(row);
                }

                console.log(`${rows.length} filas procesadas`);

                const extendedHeaders = ['timestamp', 'Underlying_Price', 'Expiry', 'Underlying',
                    'Call_Money_Flow', 'Put_Money_Flow', 'Net_Money_Flow', 'MF_Ratio',
                    'Call_Delta_Flow', 'Put_Delta_Flow', 'Net_Delta_Flow', 'DF_Ratio',
                    'Call_IV_Flow', 'Put_IV_Flow', 'Net_IV_Flow', 'IVF_Ratio',
                    'Call_OTM_Impact', 'Put_OTM_Impact', 'Net_OTM_Impact',
                    'Call_ITM_Impact', 'Put_ITM_Impact', 'Net_ITM_Impact',
                    'Call_GEX', 'Put_GEX', 'Net_GEX',
                    'Call_Vanna_Flow', 'Put_Vanna_Flow', 'Net_Vanna_Flow', 'Vanna_Ratio',
                    'Call_Charm', 'Put_Charm', 'Net_Charm', 'Charm_Pressure',
                    'Call_IV_Flow_ITM', 'Put_IV_Flow_ITM', 'Net_IV_Flow_ITM',
                    'Call_IV_Flow_OTM', 'Put_IV_Flow_OTM', 'Net_IV_Flow_OTM', 'IV_Net',
                    'Call_Vol_Imbalance', 'Put_Vol_Imbalance', 'Net_Vol_Imbalance', 'Vol_Imbalance_Ratio',
                    'Call_Smart_Money', 'Put_Smart_Money', 'Net_Smart_Money', 'Smart_Money_Ratio',
                    'Call_Hedge_Pressure', 'Put_Hedge_Pressure', 'Net_Hedge_Pressure',
                    'Skew_Pressure', 'Skew_Intensity', 'Cash_Net'];

                return {
                    headers: extendedHeaders,
                    rows: rows,
                    timestampHeader: 'timestamp',
                    priceHeader: 'Underlying_Price',
                    isOptionsFormat: false
                };
            }

            // Detectar formato Options Chain
            const isOptionsFormat = headers.some(h => h.startsWith('CALL_') || h.startsWith('PUT_'));

            if (!isOptionsFormat) {
                // Formato normal
                const rows = [];
                for (let i = 1; i < lines.length; i++) {
                    const values = lines[i].split(',');
                    if (values.length !== headers.length) continue;
                    const row = {};
                    headers.forEach((header, index) => {
                        const val = values[index]?.trim() || '';
                        if (header === timestampHeader) {
                            row[header] = new Date(val);
                        } else {
                            row[header] = isNaN(Number(val)) || val === '' ? val : parseFloat(val);
                        }
                    });
                    rows.push(row);
                }
                return { headers, rows, timestampHeader, priceHeader: headers[0] };
            }

            // Formato Options Chain - agregar por timestamp
            console.log('Options Chain detected');

            const priceHeader = headers.find(h => h.endsWith('_PRICE')) || headers.find(h => h.toLowerCase().includes('price'));
            const dataByTimestamp = new Map();

            for (let i = 1; i < lines.length; i++) {
                const values = lines[i].split(',');
                if (values.length !== headers.length) continue;

                const row = {};
                headers.forEach((header, index) => {
                    const val = values[index]?.trim() || '';
                    if (header === timestampHeader) {
                        row[header] = new Date(val);
                    } else if (header === 'expiry') {
                        row[header] = val;
                    } else {
                        row[header] = isNaN(Number(val)) || val === '' ? null : parseFloat(val);
                    }
                });

                const timestamp = row[timestampHeader].getTime();
                if (!dataByTimestamp.has(timestamp)) {
                    dataByTimestamp.set(timestamp, []);
                }
                dataByTimestamp.get(timestamp).push(row);
            }

            const aggregatedRows = [];
            const sortedTimestamps = Array.from(dataByTimestamp.keys()).sort((a, b) => a - b);

            for (const timestamp of sortedTimestamps) {
                const strikes = dataByTimestamp.get(timestamp);

                let totalCallDelta = 0, totalPutDelta = 0;
                let totalCallMoneyFlow = 0, totalPutMoneyFlow = 0;
                let totalCallDeltaFlow = 0, totalPutDeltaFlow = 0;
                let totalCallIVFlow = 0, totalPutIVFlow = 0;
                let totalCallOTMImpact = 0, totalPutOTMImpact = 0;
                let totalCallVolume = 0, totalPutVolume = 0;
                let totalCallOI = 0, totalPutOI = 0;
                let totalCallGamma = 0, totalPutGamma = 0;
                let totalCallGEX = 0, totalPutGEX = 0;
                let totalCallVannaFlow = 0, totalPutVannaFlow = 0;
                let totalCallCharm = 0, totalPutCharm = 0;
                let totalCallOIMomentum = 0, totalPutOIMomentum = 0;
                let totalCallIVFlowITM = 0, totalPutIVFlowITM = 0;
                let totalCallIVFlowOTM = 0, totalPutIVFlowOTM = 0;
                let totalIVNet = 0;
                let totalCallVolImbalance = 0, totalPutVolImbalance = 0;
                let totalCallSmartMoney = 0, totalPutSmartMoney = 0;
                let totalCallHedgePressure = 0, totalPutHedgePressure = 0;
                let sumMFRatio = 0, sumDFRatio = 0, sumIVFRatio = 0;
                let sumNetGEX = 0, sumVannaRatio = 0, sumCharmPressure = 0;
                let sumOIMomentumRatio = 0, sumSkewPressure = 0, sumSkewIntensity = 0;
                let sumIVNet = 0;
                let sumVolImbalanceRatio = 0, sumSmartMoneyRatio = 0, sumNetHedgePressure = 0;
                let countRatios = 0;
                let underlyingPrice = null, expiry = null;

                strikes.forEach(strike => {
                    if (priceHeader && strike[priceHeader] !== null) {
                        underlyingPrice = strike[priceHeader];
                    }
                    if (strike.expiry) expiry = strike.expiry;

                    if (strike.CALL_DELTA !== null) totalCallDelta += strike.CALL_DELTA;
                    if (strike.PUT_DELTA !== null) totalPutDelta += Math.abs(strike.PUT_DELTA);
                    if (strike.CALL_MONEY_FLOW !== null) totalCallMoneyFlow += strike.CALL_MONEY_FLOW;
                    if (strike.PUT_MONEY_FLOW !== null) totalPutMoneyFlow += Math.abs(strike.PUT_MONEY_FLOW);
                    if (strike.CALL_DELTA_FLOW !== null) totalCallDeltaFlow += strike.CALL_DELTA_FLOW;
                    if (strike.PUT_DELTA_FLOW !== null) totalPutDeltaFlow += Math.abs(strike.PUT_DELTA_FLOW);
                    if (strike.CALL_IV_FLOW !== null) totalCallIVFlow += strike.CALL_IV_FLOW;
                    if (strike.PUT_IV_FLOW !== null) totalPutIVFlow += Math.abs(strike.PUT_IV_FLOW);
                    if (strike.CALL_VOLUME !== null) totalCallVolume += strike.CALL_VOLUME;
                    if (strike.PUT_VOLUME !== null) totalPutVolume += strike.PUT_VOLUME;
                    if (strike.CALL_OPEN_INT !== null) totalCallOI += strike.CALL_OPEN_INT;
                    if (strike.PUT_OPEN_INT !== null) totalPutOI += strike.PUT_OPEN_INT;
                    if (strike.CALL_GAMMA !== null) totalCallGamma += strike.CALL_GAMMA;
                    if (strike.PUT_GAMMA !== null) totalPutGamma += Math.abs(strike.PUT_GAMMA);
                    if (strike.CALL_OTM_IMPACT !== null) totalCallOTMImpact += strike.CALL_OTM_IMPACT;
                    if (strike.PUT_OTM_IMPACT !== null) totalPutOTMImpact += Math.abs(strike.PUT_OTM_IMPACT);
                    if (strike.CALL_GEX !== null) totalCallGEX += strike.CALL_GEX;
                    if (strike.PUT_GEX !== null) totalPutGEX += strike.PUT_GEX;
                    if (strike.CALL_VANNA_FLOW !== null) totalCallVannaFlow += strike.CALL_VANNA_FLOW;
                    if (strike.PUT_VANNA_FLOW !== null) totalPutVannaFlow += strike.PUT_VANNA_FLOW;
                    if (strike.CALL_CHARM !== null) totalCallCharm += strike.CALL_CHARM;
                    if (strike.PUT_CHARM !== null) totalPutCharm += strike.PUT_CHARM;
                    if (strike.CALL_OI_MOMENTUM !== null) totalCallOIMomentum += strike.CALL_OI_MOMENTUM;
                    if (strike.PUT_OI_MOMENTUM !== null) totalPutOIMomentum += strike.PUT_OI_MOMENTUM;
                    if (strike.CALL_IV_FLOW_ITM !== null) totalCallIVFlowITM += strike.CALL_IV_FLOW_ITM;
                    if (strike.PUT_IV_FLOW_ITM !== null) totalPutIVFlowITM += strike.PUT_IV_FLOW_ITM;
                    if (strike.CALL_IV_FLOW_OTM !== null) totalCallIVFlowOTM += strike.CALL_IV_FLOW_OTM;
                    if (strike.PUT_IV_FLOW_OTM !== null) totalPutIVFlowOTM += strike.PUT_IV_FLOW_OTM;
                    if (strike.IV_NET !== null) totalIVNet += strike.IV_NET;
                    if (strike.CALL_VOL_IMBALANCE !== null) totalCallVolImbalance += strike.CALL_VOL_IMBALANCE;
                    if (strike.PUT_VOL_IMBALANCE !== null) totalPutVolImbalance += strike.PUT_VOL_IMBALANCE;
                    if (strike.CALL_SMART_MONEY !== null) totalCallSmartMoney += strike.CALL_SMART_MONEY;
                    if (strike.PUT_SMART_MONEY !== null) totalPutSmartMoney += strike.PUT_SMART_MONEY;
                    if (strike.CALL_HEDGE_PRESSURE !== null) totalCallHedgePressure += strike.CALL_HEDGE_PRESSURE;
                    if (strike.PUT_HEDGE_PRESSURE !== null) totalPutHedgePressure += strike.PUT_HEDGE_PRESSURE;

                    if (strike.MF_RATIO !== null && !isNaN(strike.MF_RATIO)) {
                        sumMFRatio += strike.MF_RATIO;
                        countRatios++;
                    }
                    if (strike.DF_RATIO !== null && !isNaN(strike.DF_RATIO)) sumDFRatio += strike.DF_RATIO;
                    if (strike.IVF_RATIO !== null && !isNaN(strike.IVF_RATIO)) sumIVFRatio += strike.IVF_RATIO;
                    if (strike.NET_GEX !== null && !isNaN(strike.NET_GEX)) sumNetGEX += strike.NET_GEX;
                    if (strike.VANNA_RATIO !== null && !isNaN(strike.VANNA_RATIO)) sumVannaRatio += strike.VANNA_RATIO;
                    if (strike.CHARM_PRESSURE !== null && !isNaN(strike.CHARM_PRESSURE)) sumCharmPressure += strike.CHARM_PRESSURE;
                    if (strike.IV_NET !== null && !isNaN(strike.IV_NET)) sumIVNet += strike.IV_NET;
                    if (strike.SKEW_PRESSURE !== null && !isNaN(strike.SKEW_PRESSURE)) sumSkewPressure += strike.SKEW_PRESSURE;
                    if (strike.SKEW_INTENSITY !== null && !isNaN(strike.SKEW_INTENSITY)) sumSkewIntensity += strike.SKEW_INTENSITY;
                    if (strike.VOL_IMBALANCE_RATIO !== null && !isNaN(strike.VOL_IMBALANCE_RATIO)) sumVolImbalanceRatio += strike.VOL_IMBALANCE_RATIO;
                    if (strike.SMART_MONEY_RATIO !== null && !isNaN(strike.SMART_MONEY_RATIO)) sumSmartMoneyRatio += strike.SMART_MONEY_RATIO;
                    if (strike.NET_HEDGE_PRESSURE !== null && !isNaN(strike.NET_HEDGE_PRESSURE)) sumNetHedgePressure += strike.NET_HEDGE_PRESSURE;
                });

                const avgMFRatio = countRatios > 0 ? sumMFRatio / countRatios : 0;
                const avgDFRatio = countRatios > 0 ? sumDFRatio / countRatios : 0;
                const avgIVFRatio = countRatios > 0 ? sumIVFRatio / countRatios : 0;
                const avgNetGEX = countRatios > 0 ? sumNetGEX / countRatios : 0;
                const avgVannaRatio = countRatios > 0 ? sumVannaRatio / countRatios : 0;
                const avgCharmPressure = countRatios > 0 ? sumCharmPressure / countRatios : 0;
                const avgOIMomentumRatio = countRatios > 0 ? sumOIMomentumRatio / countRatios : 0;
                const avgSkewPressure = countRatios > 0 ? sumSkewPressure / countRatios : 0;
                const avgSkewIntensity = countRatios > 0 ? sumSkewIntensity / countRatios : 0;
                const avgVolImbalanceRatio = countRatios > 0 ? sumVolImbalanceRatio / countRatios : 0;
                const avgSmartMoneyRatio = countRatios > 0 ? sumSmartMoneyRatio / countRatios : 0;
                const avgNetHedgePressure = countRatios > 0 ? sumNetHedgePressure / countRatios : 0;

                const aggregatedRow = {};
                aggregatedRow[timestampHeader] = new Date(timestamp);
                aggregatedRow['Underlying_Price'] = underlyingPrice;
                aggregatedRow['Expiry'] = expiry;
                aggregatedRow['Call_Delta'] = totalCallDelta;
                aggregatedRow['Put_Delta'] = totalPutDelta;
                aggregatedRow['Net_Delta'] = totalCallDelta - totalPutDelta;
                aggregatedRow['Call_Money_Flow'] = totalCallMoneyFlow;
                aggregatedRow['Put_Money_Flow'] = totalPutMoneyFlow;
                aggregatedRow['Net_Money_Flow'] = totalCallMoneyFlow - totalPutMoneyFlow;
                aggregatedRow['Call_Delta_Flow'] = totalCallDeltaFlow;
                aggregatedRow['Put_Delta_Flow'] = totalPutDeltaFlow;
                aggregatedRow['Net_Delta_Flow'] = totalCallDeltaFlow - totalPutDeltaFlow;
                aggregatedRow['Call_IV_Flow'] = totalCallIVFlow;
                aggregatedRow['Put_IV_Flow'] = totalPutIVFlow;
                aggregatedRow['Net_IV_Flow'] = totalCallIVFlow - totalPutIVFlow;
                aggregatedRow['Call_OTM_Impact'] = totalCallOTMImpact;
                aggregatedRow['Put_OTM_Impact'] = totalPutOTMImpact;
                aggregatedRow['Net_OTM_Impact'] = totalCallOTMImpact - totalPutOTMImpact;
                aggregatedRow['Call_Volume'] = totalCallVolume;
                aggregatedRow['Put_Volume'] = totalPutVolume;
                aggregatedRow['Call_OI'] = totalCallOI;
                aggregatedRow['Put_OI'] = totalPutOI;
                aggregatedRow['Call_Gamma'] = totalCallGamma;
                aggregatedRow['Put_Gamma'] = totalPutGamma;
                aggregatedRow['Net_Gamma'] = totalCallGamma - totalPutGamma;
                aggregatedRow['Call_GEX'] = totalCallGEX;
                aggregatedRow['Put_GEX'] = totalPutGEX;
                aggregatedRow['Net_GEX'] = totalCallGEX + totalPutGEX;
                aggregatedRow['Call_Vanna_Flow'] = totalCallVannaFlow;
                aggregatedRow['Put_Vanna_Flow'] = totalPutVannaFlow;
                aggregatedRow['Call_Charm'] = totalCallCharm;
                aggregatedRow['Put_Charm'] = totalPutCharm;
                aggregatedRow['Call_OI_Momentum'] = totalCallOIMomentum;
                aggregatedRow['Put_OI_Momentum'] = totalPutOIMomentum;
                aggregatedRow['Call_IV_Flow_ITM'] = totalCallIVFlowITM;
                aggregatedRow['Put_IV_Flow_ITM'] = totalPutIVFlowITM;
                aggregatedRow['Call_IV_Flow_OTM'] = totalCallIVFlowOTM;
                aggregatedRow['Put_IV_Flow_OTM'] = totalPutIVFlowOTM;
                aggregatedRow['IV_Net'] = totalIVNet;
                aggregatedRow['Call_Vol_Imbalance'] = totalCallVolImbalance;
                aggregatedRow['Put_Vol_Imbalance'] = totalPutVolImbalance;
                aggregatedRow['Call_Smart_Money'] = totalCallSmartMoney;
                aggregatedRow['Put_Smart_Money'] = totalPutSmartMoney;
                aggregatedRow['Call_Hedge_Pressure'] = totalCallHedgePressure;
                aggregatedRow['Put_Hedge_Pressure'] = totalPutHedgePressure;
                aggregatedRow['MF_Ratio'] = avgMFRatio;
                aggregatedRow['DF_Ratio'] = avgDFRatio;
                aggregatedRow['IVF_Ratio'] = avgIVFRatio;
                aggregatedRow['Avg_Net_GEX'] = avgNetGEX;
                aggregatedRow['Vanna_Ratio'] = avgVannaRatio;
                aggregatedRow['Charm_Pressure'] = avgCharmPressure;
                aggregatedRow['IV_Net'] = sumIVNet;
                aggregatedRow['Skew_Pressure'] = avgSkewPressure;
                aggregatedRow['Skew_Intensity'] = avgSkewIntensity;
                aggregatedRow['Vol_Imbalance_Ratio'] = avgVolImbalanceRatio;
                aggregatedRow['Smart_Money_Ratio'] = avgSmartMoneyRatio;
                aggregatedRow['Net_Hedge_Pressure'] = avgNetHedgePressure;

                aggregatedRows.push(aggregatedRow);
            }

            console.log(`Options Chain: ${aggregatedRows.length} snapshots`);

            const extendedHeaders = ['timestamp', 'Underlying_Price', 'Expiry',
                'Call_Delta', 'Put_Delta', 'Net_Delta',
                'Call_Money_Flow', 'Put_Money_Flow', 'Net_Money_Flow',
                'Call_Delta_Flow', 'Put_Delta_Flow', 'Net_Delta_Flow',
                'Call_IV_Flow', 'Put_IV_Flow', 'Net_IV_Flow',
                'Call_OTM_Impact', 'Put_OTM_Impact', 'Net_OTM_Impact',
                'Call_Volume', 'Put_Volume', 'Call_OI', 'Put_OI',
                'Call_Gamma', 'Put_Gamma', 'Net_Gamma',
                'Call_GEX', 'Put_GEX', 'Net_GEX',
                'Call_Vanna_Flow', 'Put_Vanna_Flow',
                'Call_Charm', 'Put_Charm',
                'Call_IV_Flow_ITM', 'Put_IV_Flow_ITM',
                'Call_IV_Flow_OTM', 'Put_IV_Flow_OTM', 'IV_Net',
                'Call_Vol_Imbalance', 'Put_Vol_Imbalance',
                'Call_Smart_Money', 'Put_Smart_Money',
                'Call_Hedge_Pressure', 'Put_Hedge_Pressure',
                'MF_Ratio', 'DF_Ratio', 'IVF_Ratio', 'Avg_Net_GEX',
                'Vanna_Ratio', 'Charm_Pressure', 'IV_Net',
                'Skew_Pressure', 'Skew_Intensity', 'Vol_Imbalance_Ratio',
                'Smart_Money_Ratio', 'Net_Hedge_Pressure'];

            return {
                headers: extendedHeaders,
                rows: aggregatedRows,
                timestampHeader,
                priceHeader: 'Underlying_Price',
                isOptionsFormat: true
            };
        };
        services.csvParser.parseVolumeProfileCSV = (text) => {
            // Soporta dos formatos:
            // 1. ChainTable: Strike,CALL $$$,PUTS $$$,mf_ratio,call_delta_flow,put_delta_flow,df_ratio,Timestamp,Price[,Related_Price]
            // 2. Legacy: Strike,CALL $$$,PUTS $$$,DELTA_CALL,DELTA_PUT,Price,[Related_Price],Timestamp
            const lines = text.trim().split('\n');
            if (lines.length < 2) throw new Error("Volume Profile CSV is empty or invalid.");
            const timestampMap = new Map();
            const headers = lines[0].split(',').map(h => h.trim().toLowerCase());

            console.log('Volume Profile CSV headers:', headers);
            console.log('Header 0:', headers[0], '| Header 1:', headers[1], '| Header 2:', headers[2]);

            // Detectar formato por los headers
            const isChainTableFormat = headers.includes('mf_ratio') || headers.includes('df_ratio');
            const hasTimestamp = headers.some(h => h.includes('timestamp'));

            // Encontrar √≠ndices de columnas
            let strikeIdx = headers.findIndex(h => h.includes('strike'));
            let callCashIdx = headers.findIndex(h => h.includes('call') && (h.includes('$') || h.includes('cash')));
            let putCashIdx = headers.findIndex(h => h.includes('put') && (h.includes('$') || h.includes('cash')));
            let timestampIdx = headers.findIndex(h => h.includes('timestamp'));
            let callDeltaIdx = headers.findIndex(h => (h.includes('delta_call') || h.includes('call_delta')));
            let putDeltaIdx = headers.findIndex(h => (h.includes('delta_put') || h.includes('put_delta')));

            // Fallback a posiciones por defecto si no se encuentran
            if (strikeIdx === -1) strikeIdx = 0;
            if (callCashIdx === -1) callCashIdx = 1;
            if (putCashIdx === -1) putCashIdx = 2;

            // Para ChainTable, timestamp est√° en posici√≥n 7
            if (isChainTableFormat && timestampIdx === -1) {
                timestampIdx = 7; // Posici√≥n fija en ChainTable
            }
            // Para formato legacy, timestamp est√° al final
            if (!isChainTableFormat && timestampIdx === -1) {
                timestampIdx = headers.length >= 8 ? 7 : 6;
            }

            console.log('Format:', isChainTableFormat ? 'ChainTable' : 'Legacy');
            console.log('Column indices - strike:', strikeIdx, 'callCash:', callCashIdx, 'putCash:', putCashIdx, 'timestamp:', timestampIdx);

            // Log primeras 5 filas para debug
            console.log('=== SAMPLE CSV DATA (first 5 rows) ===');
            for (let dbg = 1; dbg <= Math.min(5, lines.length - 1); dbg++) {
                const p = lines[dbg].trim().split(',');
                console.log(`Row ${dbg}: Strike=${p[strikeIdx]}, CallCash=${p[callCashIdx]}, PutCash=${p[putCashIdx]}`);
            }

            // Encontrar √≠ndices de precios (posici√≥n 8 y 9 en ChainTable)
            let priceIdx = headers.findIndex(h => h.includes('_price') && !h.includes('related'));
            let relatedPriceIdx = -1;
            // Extraer nombres de s√≠mbolos del header (ej: "qqq_price" ‚Üí "QQQ")
            let underlyingSymbol = '';
            let relatedSymbol = '';
            if (isChainTableFormat) {
                priceIdx = 8; // Posici√≥n fija del precio principal
                relatedPriceIdx = headers.length > 9 ? 9 : -1; // Precio relacionado si existe
                // Extraer s√≠mbolos del header
                if (headers[8]) {
                    underlyingSymbol = headers[8].replace('_price', '').toUpperCase();
                }
                if (headers[9]) {
                    relatedSymbol = headers[9].replace('_price', '').toUpperCase();
                }
            }

            for (let i = 1; i < lines.length; i++) {
                const parts = lines[i].trim().split(',');
                if (parts.length < 4) continue;

                const strike = parseFloat(parts[strikeIdx]);
                const callCash = Math.abs(parseFloat(parts[callCashIdx])) || 0;
                const putCash = Math.abs(parseFloat(parts[putCashIdx])) || 0;

                // Delta flows si existen
                let dCall = 0, dPuts = 0;
                if (callDeltaIdx !== -1 && parts[callDeltaIdx]) {
                    dCall = parseFloat(parts[callDeltaIdx]) || 0;
                }
                if (putDeltaIdx !== -1 && parts[putDeltaIdx]) {
                    dPuts = parseFloat(parts[putDeltaIdx]) || 0;
                }

                // Precios
                const price = priceIdx !== -1 ? parseFloat(parts[priceIdx]) || 0 : 0;
                const relatedPrice = relatedPriceIdx !== -1 ? parseFloat(parts[relatedPriceIdx]) || 0 : 0;

                // Timestamp
                const timestampStr = parts[timestampIdx]?.trim();
                if (!timestampStr) continue;

                const timestamp = new Date(timestampStr);
                if (isNaN(timestamp.getTime())) continue;

                if (!timestampMap.has(timestamp.getTime())) {
                    timestampMap.set(timestamp.getTime(), []);
                }
                timestampMap.get(timestamp.getTime())?.push({
                    strike,
                    callCash,
                    putCash,
                    dCall,
                    dPuts,
                    netCash: callCash - putCash,
                    netDelta: dCall + dPuts,
                    timestamp: timestamp.getTime(),
                    price: price,              // Precio del underlying (QQQ, SPY, etc.)
                    relatedPrice: relatedPrice, // Precio relacionado (NQ, SPX, etc.)
                    symbol: underlyingSymbol,   // Nombre del s√≠mbolo underlying (QQQ, SPY)
                    relatedSymbol: relatedSymbol // Nombre del s√≠mbolo relacionado (NQ, SPX)
                });
            }
            console.log(`Volume Profile: ${timestampMap.size} timestamps parsed`);
            return timestampMap;
        };

        // Detectar aumentos significativos de volumen para soportes/resistencias din√°micos
        services.csvParser.detectVolumeSurges = (volumeProfile, minutesBack = 5, surgeThreshold = 2.0, referenceTime = null) => {
            const emptyResult = { supports: [], resistances: [], hotZones: [] };

            try {
                if (!volumeProfile || typeof volumeProfile.size !== 'number' || volumeProfile.size === 0) {
                    return emptyResult;
                }

                const allTimestamps = Array.from(volumeProfile.keys()).filter(t => typeof t === 'number').sort((a, b) => a - b);

                if (allTimestamps.length === 0) return emptyResult;

                // Usar el timestamp m√°s reciente del profile como referencia si no se proporciona
                const now = referenceTime || allTimestamps[allTimestamps.length - 1];
                const cutoffTime = now - (minutesBack * 60 * 1000);

                // Obtener datos recientes vs hist√≥ricos
                const recentTimestamps = allTimestamps.filter(t => t >= cutoffTime && t <= now);
                const historicalTimestamps = allTimestamps.filter(t => t < cutoffTime);

                // Relajar requisito: si no hay suficientes hist√≥ricos, usar los m√°s antiguos disponibles
                if (recentTimestamps.length === 0) {
                    return emptyResult;
                }

                // Si no hay hist√≥ricos suficientes, usar la mitad antigua como hist√≥rico
                let effectiveHistorical = historicalTimestamps;
                let effectiveRecent = recentTimestamps;

                if (historicalTimestamps.length < 2 && allTimestamps.length >= 4) {
                    const midPoint = Math.floor(allTimestamps.length / 2);
                    effectiveHistorical = allTimestamps.slice(0, midPoint);
                    effectiveRecent = allTimestamps.slice(midPoint);
                }

                if (effectiveHistorical.length < 1 || effectiveRecent.length < 1) {
                    return emptyResult;
                }

                // Calcular volumen promedio hist√≥rico por strike
                const strikeHistoricalVolume = new Map();
                const strikeHistoricalCount = new Map();

                effectiveHistorical.forEach(ts => {
                    const data = volumeProfile.get(ts);
                    if (data && Array.isArray(data)) {
                        data.forEach(row => {
                            if (!row || typeof row.strike !== 'number') return;
                            const strike = row.strike;
                            const totalVol = (row.callCash || 0) + (row.putCash || 0);
                            strikeHistoricalVolume.set(strike, (strikeHistoricalVolume.get(strike) || 0) + totalVol);
                            strikeHistoricalCount.set(strike, (strikeHistoricalCount.get(strike) || 0) + 1);
                        });
                    }
                });

                // Calcular volumen reciente por strike
                const strikeRecentVolume = new Map();
                const strikeRecentCallVol = new Map();
                const strikeRecentPutVol = new Map();

                effectiveRecent.forEach(ts => {
                    const data = volumeProfile.get(ts);
                    if (data && Array.isArray(data)) {
                        data.forEach(row => {
                            if (!row || typeof row.strike !== 'number') return;
                            const strike = row.strike;
                            strikeRecentVolume.set(strike, (strikeRecentVolume.get(strike) || 0) + (row.callCash || 0) + (row.putCash || 0));
                            strikeRecentCallVol.set(strike, (strikeRecentCallVol.get(strike) || 0) + (row.callCash || 0));
                            strikeRecentPutVol.set(strike, (strikeRecentPutVol.get(strike) || 0) + (row.putCash || 0));
                        });
                    }
                });

                // Detectar surges (aumentos significativos)
                const supports = [];
                const resistances = [];
                const hotZones = [];

                strikeRecentVolume.forEach((recentVol, strike) => {
                    const historicalTotal = strikeHistoricalVolume.get(strike) || 0;
                    const historicalCount = strikeHistoricalCount.get(strike) || 1;
                    const avgHistorical = historicalTotal / historicalCount;

                    if (avgHistorical > 0) {
                        const surgeRatio = recentVol / avgHistorical;

                        if (surgeRatio >= surgeThreshold) {
                            const callVol = strikeRecentCallVol.get(strike) || 0;
                            const putVol = strikeRecentPutVol.get(strike) || 0;
                            const dominance = callVol > putVol ? 'CALL' : putVol > callVol ? 'PUT' : 'NEUTRAL';
                            const strength = Math.min(100, Math.round((surgeRatio - 1) * 50));

                            const zoneInfo = {
                                strike,
                                surgeRatio: surgeRatio.toFixed(2),
                                recentVol,
                                avgHistorical: avgHistorical.toFixed(0),
                                callVol,
                                putVol,
                                dominance,
                                strength,
                                minutesBack
                            };

                            hotZones.push(zoneInfo);

                            // Clasificar como soporte o resistencia basado en dominancia
                            // CALL dominant = Resistencia (presi√≥n de venta arriba)
                            // PUT dominant = Soporte (presi√≥n de compra abajo)
                            if (dominance === 'PUT') {
                                supports.push(zoneInfo);
                            } else if (dominance === 'CALL') {
                                resistances.push(zoneInfo);
                            }
                        }
                    }
                });

                // Ordenar por fuerza del surge
                supports.sort((a, b) => parseFloat(b.surgeRatio) - parseFloat(a.surgeRatio));
                resistances.sort((a, b) => parseFloat(b.surgeRatio) - parseFloat(a.surgeRatio));
                hotZones.sort((a, b) => parseFloat(b.surgeRatio) - parseFloat(a.surgeRatio));

                return { supports: supports.slice(0, 5), resistances: resistances.slice(0, 5), hotZones: hotZones.slice(0, 10) };
            } catch (e) {
                console.error('Error in detectVolumeSurges:', e);
                return emptyResult;
            }
        };
        // --- END: services/csvParser.ts ---

        // --- START: services/signalCalculator.ts ---
        Object.assign(services.signalCalculator, (() => {
            const formatNumber = (num) => {
                if (num == null || isNaN(num)) return "0";
                const absNum = Math.abs(num);
                if (absNum >= 1e9) return (num / 1e9).toFixed(1) + 'B';
                if (absNum >= 1e6) return (num / 1e6).toFixed(1) + 'M';
                if (absNum >= 1e3) return (num / 1e3).toFixed(1) + 'K';
                return num.toFixed(1);
            };
            const aggregateData = (rawRows, timeFrame) => {
                if (timeFrame === 'raw' || rawRows.length === 0) return [...rawRows];
                let intervalPoints;
                switch (timeFrame) {
                    case '1m': intervalPoints = 12; break;
                    case '2m': intervalPoints = 24; break;
                    case '5m': intervalPoints = 60; break;
                    default: return [...rawRows];
                }
                const aggregatedRows = [];
                for (let i = 0; i < rawRows.length; i += intervalPoints) {
                    const chunk = rawRows.slice(i, i + intervalPoints);
                    if (chunk.length > 0) {
                        aggregatedRows.push({ ...chunk[chunk.length - 1] });
                    }
                }
                return aggregatedRows;
            };
            const calcSMA = (data, period) => {
                const results = new Array(data.length).fill(null);
                if (data.length < period) return results;
                for (let i = period - 1; i < data.length; i++) {
                    let sum = 0;
                    let validCount = 0;
                    for (let j = 0; j < period; j++) {
                        const val = data[i - j];
                        if (val !== null && !isNaN(val)) {
                            sum += val;
                            validCount++;
                        }
                    }
                    if (validCount > 0) {
                        results[i] = sum / validCount;
                    }
                }
                return results;
            };
            const calculateKAMA = (data, period) => {
                const results = new Array(data.length).fill(null);
                if (data.length < period) return results;
                const fastest = 2 / (2 + 1);
                const slowest = 2 / (30 + 1);
                let firstValidIndex = data.findIndex(d => d !== null);
                if (firstValidIndex === -1 || firstValidIndex + period >= data.length) return results;
                results[firstValidIndex + period - 1] = data[firstValidIndex + period - 1];
                for (let i = firstValidIndex + period; i < data.length; i++) {
                    const currentVal = data[i];
                    const pastVal = data[i - period];
                    if (currentVal === null || pastVal === null) {
                        results[i] = results[i - 1];
                        continue;
                    }
                    const change = Math.abs(currentVal - pastVal);
                    let sumOfChanges = 0;
                    for (let j = 0; j < period; j++) {
                        const val1 = data[i - j];
                        const val2 = data[i - j - 1];
                        if (val1 !== null && val2 !== null) {
                            sumOfChanges += Math.abs(val1 - val2);
                        }
                    }
                    const efficiencyRatio = (sumOfChanges === 0) ? 0 : change / sumOfChanges;
                    const sc = Math.pow(efficiencyRatio * (fastest - slowest) + slowest, 2);
                    const prevKama = results[i - 1];
                    if (prevKama !== null) {
                        results[i] = prevKama + sc * (currentVal - prevKama);
                    } else {
                        results[i] = currentVal;
                    }
                }
                return results;
            };
            const calcEMA = (data, period) => {
                const results = new Array(data.length).fill(null);
                if (data.length < period) return results;
                const alpha = 2 / (period + 1);
                let firstValidIndex = data.findIndex(d => d !== null && !isNaN(d));
                if (firstValidIndex === -1) return results;
                results[firstValidIndex] = data[firstValidIndex];
                for (let i = firstValidIndex + 1; i < data.length; i++) {
                    if (data[i] !== null && !isNaN(data[i])) {
                        if (results[i - 1] !== null) {
                            results[i] = data[i] * alpha + results[i - 1] * (1 - alpha);
                        } else {
                            results[i] = data[i];
                        }
                    } else {
                        results[i] = results[i - 1];
                    }
                }
                return results;
            };
            // Funci√≥n VWAP mejorada: soporta m√©tricas Net_* usando call+put como volumen
            const calculateVWAP = (rows, valueHeader, volumeMetric = 'Total_Volume') => {
                if (rows.length === 0) return new Array(rows.length).fill(null);
                // Mapeo de m√©tricas Net_* a pares call/put
                const metricMap = {
                    'Total_Volume': { call: 'call_money_flow', put: 'put_money_flow' },
                    'Net_Money_Flow': { call: 'call_money_flow', put: 'put_money_flow' },
                    'Net_Delta_Flow': { call: 'call_delta_flow', put: 'put_delta_flow' },
                    'Net_IV_Flow': { call: 'call_iv_flow', put: 'put_iv_flow' },
                    'Net_OTM_Impact': { call: 'call_otm_impact', put: 'put_otm_impact' },
                    'Net_ITM_Impact': { call: 'call_itm_impact', put: 'put_itm_impact' },
                    'Net_GEX': { call: 'call_gex', put: 'put_gex' },
                    'Net_Vanna_Flow': { call: 'call_vanna_flow', put: 'put_vanna_flow' },
                    'Net_Charm': { call: 'call_charm', put: 'put_charm' },
                    'Net_Smart_Money': { call: 'call_smart_money', put: 'put_smart_money' },
                    'Net_Vol_Imbalance': { call: 'call_vol_imbalance', put: 'put_vol_imbalance' }
                };
                if (!rows[0] || rows[0][valueHeader] === undefined) {
                    console.warn('[VWAP] Price header not found:', valueHeader);
                    return new Array(rows.length).fill(null);
                }
                // Helper para leer campos sin depender de may√∫sculas/min√∫sculas
                const getFieldVal = (row, key) => {
                    if (!row) return undefined;
                    if (row.hasOwnProperty(key)) return row[key];
                    const lower = key.toLowerCase();
                    for (const k of Object.keys(row)) {
                        if (k.toLowerCase() === lower) return row[k];
                    }
                    return undefined;
                };

                // Detectar si las columnas existen en cualquier row (flexible con casing)
                let mapping = metricMap[volumeMetric];
                let hasVolumeData = false;
                if (mapping) {
                    hasVolumeData = rows.some(row => getFieldVal(row, mapping.call) !== undefined && getFieldVal(row, mapping.put) !== undefined);
                }
                // Fallback: si la m√©trica seleccionada no tiene datos, usar Cash
                if (!hasVolumeData && volumeMetric !== 'Net_Money_Flow' && volumeMetric !== 'Total_Volume') {
                    mapping = metricMap['Net_Money_Flow'];
                    hasVolumeData = rows.some(row => row[mapping.call] !== undefined && row[mapping.put] !== undefined);
                }
                // Si no hay datos de volumen, usar peso uniforme (media m√≥vil acumulativa)
                if (!hasVolumeData) {
                    console.warn('[VWAP] Volume columns not found, using uniform weight. Metric:', volumeMetric);
                    const vwapResults = [];
                    let cumulativePrice = 0;
                    let count = 0;
                    for (const row of rows) {
                        const rawPrice = getFieldVal(row, valueHeader);
                        const price = parseFloat(rawPrice);
                        if (!isNaN(price)) {
                            cumulativePrice += price;
                            count++;
                            vwapResults.push(cumulativePrice / count);
                        } else {
                            vwapResults.push(vwapResults.length > 0 ? vwapResults[vwapResults.length - 1] : null);
                        }
                    }
                    return vwapResults;
                }
                // VWAP normal con la m√©trica seleccionada
                const vwapResults = [];
                let cumulativeValueVolume = 0;
                let cumulativeVolume = 0;
                for (const row of rows) {
                    const rawPrice = getFieldVal(row, valueHeader);
                    const price = parseFloat(rawPrice);
                    const callVal = Math.abs(parseFloat(getFieldVal(row, mapping.call)) || 0);
                    const putVal = Math.abs(parseFloat(getFieldVal(row, mapping.put)) || 0);
                    const volume = callVal + putVal;
                    if (!isNaN(price) && volume > 0) {
                        cumulativeValueVolume += price * volume;
                        cumulativeVolume += volume;
                        vwapResults.push(cumulativeValueVolume / cumulativeVolume);
                    } else if (!isNaN(price)) {
                        vwapResults.push(vwapResults.length > 0 ? vwapResults[vwapResults.length - 1] : price);
                    } else {
                        vwapResults.push(vwapResults.length > 0 ? vwapResults[vwapResults.length - 1] : null);
                    }
                }
                return vwapResults;
            };
            const calculateRollingSum = (data, window) => {
                const result = [];
                for (let i = 0; i < data.length; i++) {
                    const start = Math.max(0, i - window + 1);
                    let sum = 0;
                    let validCount = 0;
                    for (let j = start; j <= i; j++) {
                        if (data[j] !== null && !isNaN(data[j])) {
                            sum += data[j];
                            validCount++;
                        }
                    }
                    result.push(validCount > 0 ? sum : null);
                }
                return result;
            };
            const calculateMACDDominance = (callData, putData, lookback = 30, fastPeriod = 8, slowPeriod = 20, signalPeriod = 5) => {
                const callRollingSum = calculateRollingSum(callData, lookback);
                const putRollingSum = calculateRollingSum(putData, lookback);
                const callEMAFast = calcEMA(callRollingSum, fastPeriod);
                const callEMASlow = calcEMA(callRollingSum, slowPeriod);
                const callMACD = callEMAFast.map((v, i) => (v === null || callEMASlow[i] === null) ? null : v - callEMASlow[i]);
                const callSignal = calcEMA(callMACD, signalPeriod);
                const callHistogram = callMACD.map((v, i) => (v === null || callSignal[i] === null) ? null : v - callSignal[i]);
                const putEMAFast = calcEMA(putRollingSum, fastPeriod);
                const putEMASlow = calcEMA(putRollingSum, slowPeriod);
                const putMACD = putEMAFast.map((v, i) => (v === null || putEMASlow[i] === null) ? null : v - putEMASlow[i]);
                const putSignal = calcEMA(putMACD, signalPeriod);
                const putHistogram = putMACD.map((v, i) => (v === null || putSignal[i] === null) ? null : v - putSignal[i]);
                return {
                    call: { rollingSum: callRollingSum, macd: callMACD, signal: callSignal, histogram: callHistogram },
                    put: { rollingSum: putRollingSum, macd: putMACD, signal: putSignal, histogram: putHistogram }
                };
            };
            const calculateMACDSyncSignals = (macdData, rows, timestampHeader, dominanceRatio = 1.8) => {
                const { call: { macd: callMACD, signal: callSignal, histogram: callHistogram, rollingSum: callRollingSum }, put: { macd: putMACD, signal: putSignal, histogram: putHistogram, rollingSum: putRollingSum } } = macdData;
                const DOMINANCE_RATIO = dominanceRatio;
                const HISTOGRAM_THRESHOLD = 0;
                const CONFIRMATION_PERIODS = 2;
                const MIN_MAGNITUDE = 1000000;
                const signalSeries = [];
                for (let i = 0; i < rows.length; i++) {
                    const cMACD = callMACD[i];
                    const cSignal = callSignal[i];
                    const cHist = callHistogram[i];
                    const cRoll = callRollingSum[i];
                    const pMACD = putMACD[i];
                    const pSignal = putSignal[i];
                    const pHist = putHistogram[i];
                    const pRoll = putRollingSum[i];
                    if (cMACD === null || cSignal === null || pMACD === null || pSignal === null || cRoll === null || pRoll === null) {
                        signalSeries.push({ time: rows[i][timestampHeader], state: 'FLAT', callDirection: 'FLAT', putDirection: 'FLAT' });
                        continue;
                    }
                    const callDirection = cMACD > cSignal ? 'UP' : 'DOWN';
                    const putDirection = pMACD > pSignal ? 'UP' : 'DOWN';
                    let state = 'FLAT';
                    const callMagnitude = Math.abs(cRoll);
                    const putMagnitude = Math.abs(pRoll);
                    const callHistMagnitude = Math.abs(cHist || 0);
                    const putHistMagnitude = Math.abs(pHist || 0);
                    if (callDirection === 'UP' && putDirection === 'DOWN') {
                        const callDominates = callMagnitude > putMagnitude * DOMINANCE_RATIO;
                        const histogramConfirms = cHist > HISTOGRAM_THRESHOLD && callHistMagnitude > putHistMagnitude;
                        const sufficientMagnitude = callMagnitude > MIN_MAGNITUDE;
                        let confirmedPeriods = 0;
                        for (let j = 0; j < CONFIRMATION_PERIODS && (i - j) >= 0; j++) {
                            if (callRollingSum[i - j] > putRollingSum[i - j] * (DOMINANCE_RATIO * 0.8)) confirmedPeriods++;
                        }
                        const sustained = confirmedPeriods >= CONFIRMATION_PERIODS - 1;
                        if (callDominates && histogramConfirms && sufficientMagnitude && sustained) state = 'BULLISH';
                    } else if (callDirection === 'DOWN' && putDirection === 'UP') {
                        const putDominates = putMagnitude > callMagnitude * DOMINANCE_RATIO;
                        const histogramConfirms = pHist > HISTOGRAM_THRESHOLD && putHistMagnitude > callHistMagnitude;
                        const sufficientMagnitude = putMagnitude > MIN_MAGNITUDE;
                        let confirmedPeriods = 0;
                        for (let j = 0; j < CONFIRMATION_PERIODS && (i - j) >= 0; j++) {
                            if (putRollingSum[i - j] > callRollingSum[i - j] * (DOMINANCE_RATIO * 0.8)) confirmedPeriods++;
                        }
                        const sustained = confirmedPeriods >= CONFIRMATION_PERIODS - 1;
                        if (putDominates && histogramConfirms && sufficientMagnitude && sustained) state = 'BEARISH';
                    }
                    signalSeries.push({ time: rows[i][timestampHeader], state, callDirection, putDirection });
                }
                return signalSeries;
            };
            const calculateMACDNet = (callData, putData, lookback = 30, fastPeriod = 8, slowPeriod = 20, signalPeriod = 5) => {
                const netData = callData.map((call, i) => (call || 0) - (putData[i] || 0));
                const netRollingSum = calculateRollingSum(netData, lookback);
                const netEMAFast = calcEMA(netRollingSum, fastPeriod);
                const netEMASlow = calcEMA(netRollingSum, slowPeriod);
                const netMACD = netEMAFast.map((v, i) => (v === null || netEMASlow[i] === null) ? null : v - netEMASlow[i]);
                const netSignal = calcEMA(netMACD, signalPeriod);
                const netHistogram = netMACD.map((v, i) => (v === null || netSignal[i] === null) ? null : v - netSignal[i]);
                return { netData, rollingSum: netRollingSum, macd: netMACD, signal: netSignal, histogram: netHistogram };
            };
            const calculateMACDNetSignals = (macdNetData, callRollingSum, putRollingSum, rows, timestampHeader, dominanceRatio = 1.8) => {
                const { macd: netMACD, signal: netSignal, histogram: netHistogram, rollingSum: netRollingSum } = macdNetData;
                const DOMINANCE_RATIO = dominanceRatio;
                const HISTOGRAM_THRESHOLD = 0;
                const CONFIRMATION_PERIODS = 2;
                const MIN_NET_MAGNITUDE = 500000;
                const signalSeries = [];
                for (let i = 0; i < rows.length; i++) {
                    const nMACD = netMACD[i];
                    const nSignal = netSignal[i];
                    const nHist = netHistogram[i];
                    const nRoll = netRollingSum[i];
                    const cRoll = callRollingSum[i];
                    const pRoll = putRollingSum[i];
                    if (nMACD === null || nSignal === null || nRoll === null || cRoll === null || pRoll === null) {
                        signalSeries.push({ time: rows[i][timestampHeader], state: 'FLAT' });
                        continue;
                    }
                    let state = 'FLAT';
                    const netMagnitude = Math.abs(nRoll);
                    const callMagnitude = Math.abs(cRoll);
                    const putMagnitude = Math.abs(pRoll);
                    if (nMACD > nSignal) {
                        const callDominates = callMagnitude > putMagnitude * DOMINANCE_RATIO;
                        const histogramPositive = nHist > HISTOGRAM_THRESHOLD;
                        const sufficientMagnitude = netMagnitude > MIN_NET_MAGNITUDE;
                        let confirmedPeriods = 0;
                        for (let j = 0; j < CONFIRMATION_PERIODS && (i - j) >= 0; j++) {
                            if (netRollingSum[i - j] !== null && netRollingSum[i - j] > 0) confirmedPeriods++;
                        }
                        const sustained = confirmedPeriods >= CONFIRMATION_PERIODS - 1;
                        if (callDominates && histogramPositive && sufficientMagnitude && sustained) state = 'BULLISH';
                    } else if (nMACD < nSignal) {
                        const putDominates = putMagnitude > callMagnitude * DOMINANCE_RATIO;
                        const histogramNegative = nHist < -HISTOGRAM_THRESHOLD;
                        const sufficientMagnitude = netMagnitude > MIN_NET_MAGNITUDE;
                        let confirmedPeriods = 0;
                        for (let j = 0; j < CONFIRMATION_PERIODS && (i - j) >= 0; j++) {
                            if (netRollingSum[i - j] !== null && netRollingSum[i - j] < 0) confirmedPeriods++;
                        }
                        const sustained = confirmedPeriods >= CONFIRMATION_PERIODS - 1;
                        if (putDominates && histogramNegative && sufficientMagnitude && sustained) state = 'BEARISH';
                    }
                    signalSeries.push({ time: rows[i][timestampHeader], state, callMagnitude, putMagnitude, netValue: nRoll });
                }
                return signalSeries;
            };
            const calculateAllSignals = (rows, timestampHeader, kamaPeriod = 100, strengthThreshold = 10000000) => {
                if (rows.length < 2) return [];
                const cashNeto = rows.map(r => (r['Cash Neto'] || 0));
                const kamaValues = calculateKAMA(cashNeto, kamaPeriod);
                return rows.map((row, i) => {
                    const prevRow = rows[i - 1] || {};
                    const deltaCall = (row['Cash Call'] || 0) - (prevRow['Cash Call'] || 0);
                    const deltaPut = (row['Cash Put'] || 0) - (prevRow['Cash Put'] || 0);
                    const netFlow = deltaCall - deltaPut;
                    const kama = kamaValues[i];
                    const prevKama = kamaValues[i - 1];
                    let trend = 'FLAT';
                    if (kama !== null && prevKama !== null) {
                        if (kama > prevKama) trend = 'BUY';
                        else if (kama < prevKama) trend = 'SELL';
                    }
                    let strength = 'FLAT';
                    if (netFlow > strengthThreshold) strength = 'BUY';
                    else if (netFlow < -strengthThreshold) strength = 'SELL';
                    let signal = 'FLAT';
                    if (trend === 'BUY' && strength === 'BUY') signal = 'BUY';
                    else if (trend === 'SELL' && strength === 'SELL') signal = 'SELL';
                    return {
                        time: row[timestampHeader],
                        signal,
                        trend,
                        strength,
                        netFlow,
                        kamaValue: kama,
                        cashNeto: cashNeto[i]
                    };
                });
            };
            const calculateEvolutionSignals = (rows, timestampHeader, metricName, threshold) => {
                if (rows.length < 2 || !threshold) {
                    return rows.map(r => ({ time: r[timestampHeader], state: 'FLAT' }));
                }
                const signals = [{ time: rows[0][timestampHeader], state: 'FLAT' }];
                for (let i = 1; i < rows.length; i++) {
                    const currentVal = (rows[i][metricName] || 0);
                    const prevVal = (rows[i - 1][metricName] || 0);
                    const change = currentVal - prevVal;
                    let state = 'FLAT';
                    if (change > threshold) state = 'BULLISH';
                    else if (change < -threshold) state = 'BEARISH';
                    signals.push({ time: rows[i][timestampHeader], state });
                }
                return signals;
            };
            const calculateSignalData = (rows, timestampHeader, slotId, metrics, kamaPeriod, strengthThreshold) => {
                const chartData = [];
                const history = [];
                if (rows.length < 2) return { chartData, history };
                const netoEvolution = rows.map(r => (r[metrics.neto] || 0));
                const kamaValues = calculateKAMA(netoEvolution, kamaPeriod);
                let lastSignal = 'FLAT';
                rows.forEach((row, i) => {
                    const time = row[timestampHeader];
                    const prevRow = i > 0 ? rows[i - 1] : {};
                    const delta_call = (row[metrics.call] || 0) - (prevRow[metrics.call] || 0);
                    const delta_put = (row[metrics.put] || 0) - (prevRow[metrics.put] || 0);
                    const netFlow = delta_call - delta_put;
                    const kama = kamaValues[i];
                    const prevKama = i > 0 ? kamaValues[i - 1] : null;
                    let trend = 'FLAT';
                    if (kama != null && prevKama != null) {
                        if (kama > prevKama) trend = 'BUY';
                        else if (kama < prevKama) trend = 'SELL';
                    }
                    let strength = 'FLAT';
                    if (netFlow > strengthThreshold) strength = 'BUY';
                    else if (netFlow < -strengthThreshold) strength = 'SELL';
                    let signal = 'FLAT';
                    if (trend === 'BUY' && strength === 'BUY') signal = 'BUY';
                    else if (trend === 'SELL' && strength === 'SELL') signal = 'SELL';
                    if (signal !== 'FLAT' && lastSignal === 'FLAT') {
                        history.push({
                            time: new Date(time).toLocaleString('es-ES'),
                            slotId,
                            type: signal,
                            price: netoEvolution[i]
                        });
                    }
                    lastSignal = signal;
                    chartData.push({ time, signal, netoValue: netoEvolution[i], kamaValue: kama, netFlow });
                });
                return { chartData, history };
            };
            const runBacktest = (signalHistory) => {
                if (signalHistory.length < 2) return null;
                let position = null;
                let entryPrice = 0;
                const trades = [];
                const pnlHistory = [];
                let cumulativePnl = 0;
                const initialCapital = Math.abs(signalHistory[0].price) > 0 ? Math.abs(signalHistory[0].price) : 1;
                for (const signal of signalHistory) {
                    if (position === null) {
                        entryPrice = signal.price;
                        position = signal.type === 'BUY' ? 'long' : 'short';
                    } else {
                        const exitPrice = signal.price;
                        let pnl = 0;
                        if (position === 'long' && signal.type === 'SELL') {
                            pnl = exitPrice - entryPrice;
                            trades.push({ pnl });
                            position = 'short';
                            entryPrice = exitPrice;
                        } else if (position === 'short' && signal.type === 'BUY') {
                            pnl = entryPrice - exitPrice;
                            trades.push({ pnl });
                            position = 'long';
                            entryPrice = exitPrice;
                        }
                        if (pnl !== 0) {
                            cumulativePnl += pnl;
                            pnlHistory.push(cumulativePnl);
                        }
                    }
                }
                if (trades.length === 0) return null;
                const pnlValues = trades.map(t => t.pnl);
                const totalPnl = pnlValues.reduce((sum, p) => sum + p, 0);
                const winningTrades = pnlValues.filter(p => p > 0).length;
                let peakPnl = 0;
                let maxDrawdown = 0;
                pnlHistory.unshift(0);
                for (const pnl of pnlHistory) {
                    peakPnl = Math.max(peakPnl, pnl);
                    const drawdown = peakPnl - pnl;
                    maxDrawdown = Math.max(maxDrawdown, drawdown);
                }
                const averagePnl = totalPnl / trades.length;
                const stdDev = Math.sqrt(pnlValues.map(p => Math.pow(p - averagePnl, 2)).reduce((a, b) => a + b, 0) / (trades.length || 1));
                const sharpeRatio = stdDev === 0 ? 0 : averagePnl / stdDev;
                const peakCapital = initialCapital + peakPnl;
                return {
                    pnl: totalPnl,
                    pnlPercent: (totalPnl / initialCapital) * 100,
                    maxDrawdown: maxDrawdown,
                    maxDrawdownPercent: (maxDrawdown / (peakCapital > 0 ? peakCapital : initialCapital)) * 100,
                    sharpeRatio: sharpeRatio,
                    totalTrades: trades.length,
                    winningTrades: winningTrades,
                    winRate: (winningTrades / trades.length) * 100,
                    averagePnl: averagePnl,
                };
            };
            const calcImbalance = (call, put) => {
                const total = Math.abs(call) + Math.abs(put);
                return total > 0 ? ((call - Math.abs(put)) / total) * 100 : 0;
            };
            const getMetricsForType = (type) => {
                if (type.startsWith('delta')) return { call: 'Call Delta', put: 'Delta Put', neto: 'Delta Neto', name: 'Delta' };
                if (type.startsWith('cash')) return { call: 'Cash Call', put: 'Cash Put', neto: 'Cash Neto', name: 'Cash' };
                if (type.startsWith('iv')) return { call: 'IV Call', put: 'IV Put', neto: 'IV Neta', name: 'IV' };
                // Power Meter types - extract the metric name from type
                if (type.includes('money-flow')) return { call: 'Call_Money_Flow', put: 'Put_Money_Flow', neto: 'Net_Money_Flow', name: 'Money Flow' };
                if (type.includes('delta-flow')) return { call: 'Call_Delta_Flow', put: 'Put_Delta_Flow', neto: 'Net_Delta_Flow', name: 'Delta Flow' };
                if (type.includes('iv-flow')) return { call: 'Call_IV_Flow', put: 'Put_IV_Flow', neto: 'Net_IV_Flow', name: 'IV Flow' };
                if (type.includes('otm-impact')) return { call: 'Call_OTM_Impact', put: 'Put_OTM_Impact', neto: 'Net_OTM_Impact', name: 'OTM Impact' };
                if (type.includes('itm-impact')) return { call: 'Call_ITM_Impact', put: 'Put_ITM_Impact', neto: 'Net_ITM_Impact', name: 'ITM Impact' };
                if (type.includes('gex')) return { call: 'Call_GEX', put: 'Put_GEX', neto: 'Net_GEX', name: 'GEX' };
                if (type.includes('vanna-flow')) return { call: 'Call_Vanna_Flow', put: 'Put_Vanna_Flow', neto: 'Net_Vanna_Flow', name: 'Vanna Flow' };
                if (type.includes('charm')) return { call: 'Call_Charm', put: 'Put_Charm', neto: 'Net_Charm', name: 'Charm' };
                if (type.includes('iv-flow-itm')) return { call: 'Call_IV_Flow_ITM', put: 'Put_IV_Flow_ITM', neto: 'Net_IV_Flow_ITM', name: 'IV Flow ITM' };
                if (type.includes('iv-flow-otm')) return { call: 'Call_IV_Flow_OTM', put: 'Put_IV_Flow_OTM', neto: 'Net_IV_Flow_OTM', name: 'IV Flow OTM' };
                if (type.includes('iv-net')) return { call: 'Call_IV_Net', put: 'Put_IV_Net', neto: 'IV_Net', name: 'IV Net' };
                if (type.includes('vol-imbalance')) return { call: 'Call_Vol_Imbalance', put: 'Put_Vol_Imbalance', neto: 'Net_Vol_Imbalance', name: 'Vol Imbalance' };
                if (type.includes('smart-money')) return { call: 'Call_Smart_Money', put: 'Put_Smart_Money', neto: 'Net_Smart_Money', name: 'Smart Money' };
                if (type.includes('hedge-pressure')) return { call: 'Call_Hedge_Pressure', put: 'Put_Hedge_Pressure', neto: 'Net_Hedge_Pressure', name: 'Hedge Pressure' };
                return null;
            };
            const calcER = (data, lookback = 10) => {
                const results = new Array(data.length).fill(null);
                if (data.length < lookback + 1) return results;
                for (let i = lookback; i < data.length; i++) {
                    const change = Math.abs((data[i] || 0) - (data[i - lookback] || 0));
                    let sumOfChanges = 0;
                    for (let j = 0; j < lookback; j++) {
                        sumOfChanges += Math.abs((data[i - j] || 0) - (data[i - j - 1] || 0));
                    }
                    results[i] = sumOfChanges === 0 ? 0 : change / sumOfChanges;
                }
                return results;
            };
            const calculateDominanceIndex = (callData, putData, lookback) => {
                const callDeltas = callData.map((v, i) => {
                    if (i === 0) return 0;
                    const delta = (v || 0) - (callData[i - 1] || 0);
                    return Math.max(0, delta);
                });
                const putDeltas = putData.map((v, i) => {
                    if (i === 0) return 0;
                    const delta = (v || 0) - (putData[i - 1] || 0);
                    return Math.max(0, delta);
                });
                const rollingCallSums = new Array(callData.length).fill(null);
                const rollingPutSums = new Array(callData.length).fill(null);
                for (let i = lookback - 1; i < callData.length; i++) {
                    let callSum = 0;
                    let putSum = 0;
                    for (let j = 0; j < lookback; j++) {
                        callSum += callDeltas[i - j];
                        putSum += putDeltas[i - j];
                    }
                    rollingCallSums[i] = callSum;
                    rollingPutSums[i] = putSum;
                }
                return { rollingCallSums, rollingPutSums };
            };
            const calculateGlobalDominanceSignal = (rows, metrics, params) => {
                const lookback = params.lookback ?? 30;
                const smaPeriod = params.smaPeriod ?? 8;
                const dominanceRatio = params.dominanceRatio ?? 2;
                if (rows.length < lookback + smaPeriod) return { state: 'FLAT', value: 0 };
                const callData = rows.map(r => (r[metrics.call]) || null);
                const putData = rows.map(r => (r[metrics.put]) || null);
                const { rollingCallSums, rollingPutSums } = calculateDominanceIndex(callData, putData, lookback);
                const netDominanceSeries = rollingCallSums.map((callSum, i) => (callSum === null || rollingPutSums[i] === null) ? null : callSum - rollingPutSums[i]);
                const smaOfNetDominance = calcSMA(netDominanceSeries, smaPeriod);
                const lastValidCallSum = rollingCallSums.filter(v => v !== null).pop() ?? 0;
                const lastValidPutSum = rollingPutSums.filter(v => v !== null).pop() ?? 0;
                const lastNetDominance = netDominanceSeries.filter(v => v !== null).pop() ?? 0;
                const lastSmaValue = smaOfNetDominance.filter(v => v !== null).pop() ?? null;
                if (lastSmaValue === null) return { state: 'FLAT', value: lastNetDominance };
                let state = 'FLAT';
                if (lastValidCallSum > lastValidPutSum * dominanceRatio && lastNetDominance > lastSmaValue) {
                    state = 'BULLISH';
                } else if (lastValidPutSum > lastValidCallSum * dominanceRatio && lastNetDominance < lastSmaValue) {
                    state = 'BEARISH';
                }
                return { state, value: lastNetDominance };
            };
            const calculateDominanceSignalSeries = (rows, metrics, params, timestampHeader) => {
                const lookback = params.lookback ?? 30;
                const smaPeriod = params.smaPeriod ?? 8;
                const dominanceRatio = params.dominanceRatio ?? 2;
                if (rows.length < lookback + smaPeriod) return [];
                const callData = rows.map(r => (r[metrics.call]) || null);
                const putData = rows.map(r => (r[metrics.put]) || null);
                const priceData = rows.map(r => (r[metrics.neto] || 0));
                const { rollingCallSums, rollingPutSums } = calculateDominanceIndex(callData, putData, lookback);
                const netDominanceSeries = rollingCallSums.map((callSum, i) => (callSum === null || rollingPutSums[i] === null) ? null : callSum - rollingPutSums[i]);
                const smaOfNetDominance = calcSMA(netDominanceSeries, smaPeriod);
                const signalSeries = [];
                for (let i = 0; i < rows.length; i++) {
                    const callSum = rollingCallSums[i];
                    const putSum = rollingPutSums[i];
                    const netDominance = netDominanceSeries[i];
                    const smaValue = smaOfNetDominance[i];
                    let state = 'FLAT';
                    if (callSum !== null && putSum !== null && netDominance !== null && smaValue !== null) {
                        if (callSum > putSum * dominanceRatio && netDominance > smaValue) state = 'BULLISH';
                        else if (putSum > callSum * dominanceRatio && netDominance < smaValue) state = 'BEARISH';
                    }
                    signalSeries.push({ time: rows[i][timestampHeader], state, price: priceData[i] });
                }
                return signalSeries;
            };
            const runDominanceBacktest = (signalSeries) => {
                if (signalSeries.length < 2) return { trades: 0, pnl: 0, winRate: 0 };
                let trades = 0;
                let winningTrades = 0;
                let pnl = 0;
                let position = 'FLAT';
                let entryPrice = 0;
                for (const signal of signalSeries) {
                    if (position === 'FLAT') {
                        if (signal.state === 'BULLISH') {
                            position = 'BULLISH'; entryPrice = signal.price; trades++;
                        } else if (signal.state === 'BEARISH') {
                            position = 'BEARISH'; entryPrice = signal.price; trades++;
                        }
                    } else if (position === 'BULLISH') {
                        if (signal.state === 'BEARISH') {
                            const tradePnl = signal.price - entryPrice;
                            if (tradePnl > 0) winningTrades++;
                            pnl += tradePnl;
                            position = 'BEARISH'; entryPrice = signal.price; trades++;
                        } else if (signal.state === 'FLAT') {
                            const tradePnl = signal.price - entryPrice;
                            if (tradePnl > 0) winningTrades++;
                            pnl += tradePnl;
                            position = 'FLAT'; entryPrice = 0;
                        }
                    } else if (position === 'BEARISH') {
                        if (signal.state === 'BULLISH') {
                            const tradePnl = entryPrice - signal.price;
                            if (tradePnl > 0) winningTrades++;
                            pnl += tradePnl;
                            position = 'BULLISH'; entryPrice = signal.price; trades++;
                        } else if (signal.state === 'FLAT') {
                            const tradePnl = entryPrice - signal.price;
                            if (tradePnl > 0) winningTrades++;
                            pnl += tradePnl;
                            position = 'FLAT'; entryPrice = 0;
                        }
                    }
                }
                if (position !== 'FLAT' && signalSeries.length > 0) {
                    const lastPrice = signalSeries[signalSeries.length - 1].price;
                    let tradePnl = 0;
                    if (position === 'BULLISH') tradePnl = lastPrice - entryPrice;
                    else if (position === 'BEARISH') tradePnl = entryPrice - lastPrice;
                    if (tradePnl > 0) winningTrades++;
                    pnl += tradePnl;
                }
                const winRate = trades > 0 ? (winningTrades / trades) * 100 : 0;
                return { trades, pnl, winRate };
            };
            const calculateImbalanceSpikesData = (rows, timestampHeader, metrics, smaPeriod) => {
                if (rows.length < 2) return null;
                const callData = rows.map(r => (r[metrics.call] || 0));
                const putData = rows.map(r => (r[metrics.put] || 0));
                const imbalanceData = rows.map((r, i) => [r[timestampHeader], calcImbalance(callData[i], putData[i])]);
                const imbValues = imbalanceData.map(d => d[1]);
                const smaValues = calcSMA(imbValues, smaPeriod);
                const smaData = rows.map((r, i) => [r[timestampHeader], smaValues[i]]);
                const callVolume = callData.map(c => Math.abs(c));
                const putVolume = putData.map(p => Math.abs(p));
                const callVolSpikes = [];
                const putVolSpikes = [];
                const callIntensityData = [];
                const putIntensityData = [];
                const volWindow = 20;
                for (let i = 0; i < rows.length; i++) {
                    const time = rows[i][timestampHeader];
                    const imb = Math.abs(imbValues[i]);
                    const callIntensity = (callVolume[i] / 1000000) * (imb / 100);
                    const putIntensity = (putVolume[i] / 1000000) * (imb / 100);
                    callIntensityData.push([time, callIntensity]);
                    putIntensityData.push([time, putIntensity]);
                    if (i >= volWindow) {
                        const callSlice = callVolume.slice(i - volWindow, i);
                        const callMean = callSlice.reduce((a, b) => a + b, 0) / callSlice.length;
                        const callVariance = callSlice.reduce((a, b) => a + Math.pow(b - callMean, 2), 0) / callSlice.length;
                        const callStdDev = Math.sqrt(callVariance);
                        const callSpike = (callVolume[i] - callMean) / (callStdDev || 1);
                        callVolSpikes.push([time, callSpike]);
                        const putSlice = putVolume.slice(i - volWindow, i);
                        const putMean = putSlice.reduce((a, b) => a + b, 0) / putSlice.length;
                        const putVariance = putSlice.reduce((a, b) => a + Math.pow(b - putMean, 2), 0) / putSlice.length;
                        const putStdDev = Math.sqrt(putVariance);
                        const putSpike = (putVolume[i] - putMean) / (putStdDev || 1);
                        putVolSpikes.push([time, putSpike]);
                    } else {
                        callVolSpikes.push([time, 0]);
                        putVolSpikes.push([time, 0]);
                    }
                }
                const allCallSpikes = callVolSpikes.map(d => d[1]);
                const allPutSpikes = putVolSpikes.map(d => d[1]);
                const allCallIntensity = callIntensityData.map(d => d[1]);
                const allPutIntensity = putIntensityData.map(d => d[1]);
                return {
                    imbalanceData, smaData, callVolSpikes, putVolSpikes, callIntensityData, putIntensityData,
                    metrics: {
                        currentImb: imbValues.length > 0 ? imbValues[imbValues.length - 1] : 0,
                        currentSMA: smaValues.length > 0 ? smaValues.filter(v => v !== null).pop() ?? 0 : 0,
                        currentCallVol: callVolume.length > 0 ? callVolume[callVolume.length - 1] : 0,
                        currentPutVol: putVolume.length > 0 ? putVolume[putVolume.length - 1] : 0,
                        currentCallSpike: allCallSpikes.length > 0 ? allCallSpikes[allCallSpikes.length - 1] : 0,
                        currentPutSpike: allPutSpikes.length > 0 ? allPutSpikes[allPutSpikes.length - 1] : 0,
                        currentCallIntensity: allCallIntensity.length > 0 ? allCallIntensity[allCallIntensity.length - 1] : 0,
                        currentPutIntensity: allPutIntensity.length > 0 ? allPutIntensity[allPutIntensity.length - 1] : 0,
                        maxCallSpike: Math.max(...allCallSpikes, 0),
                        maxPutSpike: Math.max(...allPutSpikes, 0),
                        maxCallIntensity: Math.max(...allCallIntensity, 0),
                        maxPutIntensity: Math.max(...allPutIntensity, 0),
                    }
                };
            };
            const calculateSpikesContextSeries = (data, spikeThreshold, intensityThreshold) => {
                if (!data) return [];
                const contextSeries = [];
                const smaMap = new Map(data.smaData.map((d) => d ? [d[0].getTime(), d[1]] : [0, null]));
                const callSpikeMap = new Map(data.callVolSpikes.map((d) => [d[0].getTime(), d[1]]));
                const putSpikeMap = new Map(data.putVolSpikes.map((d) => [d[0].getTime(), d[1]]));
                const callIntensityMap = new Map(data.callIntensityData.map((d) => [d[0].getTime(), d[1]]));
                const putIntensityMap = new Map(data.putIntensityData.map((d) => [d[0].getTime(), d[1]]));
                for (const [time, imbValue] of data.imbalanceData) {
                    const timeKey = time.getTime();
                    const smaValue = smaMap.get(timeKey);
                    const callSpike = callSpikeMap.get(timeKey);
                    const putSpike = putSpikeMap.get(timeKey);
                    const callIntensity = callIntensityMap.get(timeKey);
                    const putIntensity = putIntensityMap.get(timeKey);
                    let state = 'FLAT';
                    if (smaValue !== null && smaValue !== undefined && callSpike !== undefined && putSpike !== undefined && callIntensity !== undefined && putIntensity !== undefined) {
                        const isBullish = imbValue > smaValue && callSpike > spikeThreshold && callIntensity > intensityThreshold && callSpike > putSpike && callIntensity > putIntensity;
                        const isBearish = imbValue < smaValue && putSpike > spikeThreshold && putIntensity > intensityThreshold && putSpike > callSpike && putIntensity > callIntensity;
                        if (isBullish) state = 'BULLISH';
                        else if (isBearish) state = 'BEARISH';
                    }
                    contextSeries.push({ time: time, state });
                }
                return contextSeries;
            };
            const runSpikesContextBacktest = (contextSeries, imbalanceData) => {
                if (contextSeries.length < 2) return { trades: 0, winRate: 0 };
                const priceMap = new Map(imbalanceData.map(d => [d[0].getTime(), d[1]]));
                let trades = 0;
                let winningTrades = 0;
                let position = null;
                let entryPrice = 0;
                let lastState = 'FLAT';
                for (const point of contextSeries) {
                    const price = priceMap.get(point.time.getTime());
                    if (price === undefined) continue;
                    const stateChanged = point.state !== lastState;
                    if (stateChanged) {
                        if (position === 'BULLISH') {
                            trades++;
                            if (price > entryPrice) winningTrades++;
                            position = null;
                        } else if (position === 'BEARISH') {
                            trades++;
                            if (price < entryPrice) winningTrades++;
                            position = null;
                        }
                        if (point.state === 'BULLISH') {
                            position = 'BULLISH';
                            entryPrice = price;
                        } else if (point.state === 'BEARISH') {
                            position = 'BEARISH';
                            entryPrice = price;
                        }
                    }
                    lastState = point.state;
                }
                const winRate = trades > 0 ? (winningTrades / trades) * 100 : 0;
                return { trades, winRate };
            };
            const calculateTugOfWarMomentum = (callData, putData, params) => {
                const { lookback = 20, velocityPeriod = 5, dominanceRatio = 2, signalSmaPeriod = 8, dominanceFilterRatio = 1 } = params;
                if (callData.length < lookback + velocityPeriod) {
                    return { bullishForce: [], bearishForce: [], netForce: [], signals: [], latest: { state: 'FLAT', value: 0 } };
                }
                const { rollingCallSums, rollingPutSums } = calculateDominanceIndex(callData.map(c => c), putData.map(p => p), lookback);
                const callRollingSum = calculateRollingSum(callData, lookback);
                const putRollingSum = calculateRollingSum(putData, lookback);
                const callVelocity = callRollingSum.map((v, i) => i < velocityPeriod || v === null || callRollingSum[i - velocityPeriod] === null ? 0 : v - callRollingSum[i - velocityPeriod]);
                const putVelocity = putRollingSum.map((v, i) => i < velocityPeriod || v === null || putRollingSum[i - velocityPeriod] === null ? 0 : v - putRollingSum[i - velocityPeriod]);
                const bullishForce = [];
                const bearishForce = [];
                for (let i = 0; i < callData.length; i++) {
                    const callMom = callVelocity[i] || 0;
                    const putMom = putVelocity[i] || 0;
                    bullishForce.push(Math.max(0, callMom) + Math.max(0, -putMom));
                    bearishForce.push(Math.max(0, putMom) + Math.max(0, -callMom));
                }
                const netForce = bullishForce.map((b, i) => b - bearishForce[i]);
                const netForceSma = calcSMA(netForce, signalSmaPeriod);
                const signals = [];
                for (let i = 0; i < callData.length; i++) {
                    let state = 'FLAT';
                    const bf = bullishForce[i];
                    const ef = bearishForce[i];
                    const nf = netForce[i];
                    const nSma = netForceSma[i];
                    const callFlow = rollingCallSums[i] || 0;
                    const putFlow = rollingPutSums[i] || 0;
                    const callDominates = putFlow > 0 ? (callFlow / putFlow) > dominanceFilterRatio : callFlow > 0;
                    const putDominates = callFlow > 0 ? (putFlow / callFlow) > dominanceFilterRatio : putFlow > 0;
                    if (bf > ef * dominanceRatio && nf > (nSma || -Infinity) && callDominates) {
                        state = 'BULLISH';
                    } else if (ef > bf * dominanceRatio && nf < (nSma || Infinity) && putDominates) {
                        state = 'BEARISH';
                    }
                    signals.push(state);
                }
                const lastSignal = signals[signals.length - 1] || 'FLAT';
                const lastNetForce = netForce[netForce.length - 1] || 0;
                return { bullishForce, bearishForce, netForce, netForceSma, signals, latest: { state: lastSignal, value: lastNetForce } };
            };
            const calculateBigTrades = (rows, timestampHeader, priceHeader, netoMetric, stdDevMultiplier) => {
                if (rows.length < 2) return { bigBuys: [], bigSells: [], maxAbsValue: 0 };
                const netoDeltas = [];
                for (let i = 1; i < rows.length; i++) {
                    const delta = (rows[i][netoMetric] || 0) - (rows[i - 1][netoMetric] || 0);
                    netoDeltas.push(delta);
                }
                const absDeltas = netoDeltas.map(d => Math.abs(d)).filter(d => d > 0);
                if (absDeltas.length === 0) return { bigBuys: [], bigSells: [], maxAbsValue: 0 };
                const mean = absDeltas.reduce((a, b) => a + b, 0) / absDeltas.length;
                const stdDev = Math.sqrt(absDeltas.map(x => Math.pow(x - mean, 2)).reduce((a, b) => a + b, 0) / absDeltas.length);
                const threshold = mean + (stdDev * stdDevMultiplier);
                const bigBuys = [];
                const bigSells = [];
                let maxAbsValue = 0;
                for (let i = 0; i < netoDeltas.length; i++) {
                    const delta = netoDeltas[i];
                    const rowIndex = i + 1;
                    const absDelta = Math.abs(delta);
                    if (delta > threshold) {
                        bigBuys.push([
                            rows[rowIndex][timestampHeader],
                            rows[rowIndex][priceHeader],
                            delta
                        ]);
                        if (absDelta > maxAbsValue) maxAbsValue = absDelta;
                    } else if (delta < -threshold) {
                        bigSells.push([
                            rows[rowIndex][timestampHeader],
                            rows[rowIndex][priceHeader],
                            delta
                        ]);
                        if (absDelta > maxAbsValue) maxAbsValue = absDelta;
                    }
                }
                return { bigBuys, bigSells, maxAbsValue, threshold, mean, stdDev };
            };
            const formatProfileLabel = (num) => {
                if (num == null || isNaN(num) || num === 0) return "";
                const absNum = Math.abs(num);
                if (absNum >= 1e9) return Number((num / 1e9).toFixed(2)).toString() + 'B';
                if (absNum >= 1e6) return Number((num / 1e6).toFixed(2)).toString() + 'M';
                if (absNum >= 1e3) return Number((num / 1e3).toFixed(1)).toString() + 'K';
                return Number(num.toFixed(0)).toString();
            };

            // ===== FUNCIONES PARA PANEL DE SE√ëALES DE TRADING =====

            // NUEVA: Calcular se√±al para un slot (m√©trica + algoritmo)
            const getSlotSignal = (rows, slot, signalTypeParams = {}) => {
                if (!rows || rows.length === 0 || !slot.metric || !slot.algorithm) {
                    return { signal: 'FLAT', value: 0, strength: 0, callValue: 0, putValue: 0, netForce: 0, signalLine: 0, smaValue: 0 };
                }

                const metric = constants.SIGNAL_METRICS[slot.metric];
                const algorithmDef = constants.SIGNAL_ALGORITHMS[slot.algorithm];
                if (!metric || !algorithmDef) {
                    return { signal: 'FLAT', value: 0, strength: 0, callValue: 0, putValue: 0, netForce: 0, signalLine: 0, smaValue: 0 };
                }

                // Obtener par√°metros del algoritmo (de signalTypeParams o defaults)
                const params = signalTypeParams[slot.algorithm] || algorithmDef.defaultParams || {};
                const smaPeriod = params.smaPeriod || params.period || 14;

                const n = rows.length;
                const callData = rows.map(r => Math.abs(r[metric.call] || 0));
                const putData = rows.map(r => Math.abs(r[metric.put] || 0));
                const callValue = callData[n - 1];
                const putValue = putData[n - 1];
                const ratioValue = putValue > 0 ? callValue / putValue : (callValue > 0 ? 999 : 1);

                // Llamar a la funci√≥n de c√°lculo existente con el algoritmo del slot
                const result = getIndicatorSignalByAlgorithm(rows, metric, slot.algorithm, params);

                return {
                    ...result,
                    metric: slot.metric,
                    algorithm: slot.algorithm,
                    metricLabel: metric.label,
                    algorithmLabel: algorithmDef.label,
                    algorithmColor: algorithmDef.color,
                    callValue,
                    putValue,
                    colors: metric.colors
                };
            };

            // Funci√≥n auxiliar para calcular se√±al por algoritmo
            const getIndicatorSignalByAlgorithm = (rows, metric, algorithm, params) => {
                const n = rows.length;
                const callData = rows.map(r => Math.abs(r[metric.call] || 0));
                const putData = rows.map(r => Math.abs(r[metric.put] || 0));

                let signal = 'FLAT';
                let strength = 0;
                let netForce = 0;
                let signalLine = 0;
                let smaValue = 0;
                let value = 0;

                switch (algorithm) {
                    case 'evolution': {
                        const smaPeriod = params.smaPeriod || 14;
                        if (n >= smaPeriod) {
                            const netoValues = callData.map((c, i) => c - putData[i]);
                            const currentNeto = netoValues[n - 1];
                            const smaSlice = netoValues.slice(-smaPeriod);
                            smaValue = smaSlice.reduce((a, b) => a + b, 0) / smaPeriod;
                            netForce = currentNeto;
                            signalLine = smaValue;
                            value = currentNeto;

                            if (currentNeto > smaValue && currentNeto > 0) {
                                signal = 'BULLISH';
                                strength = Math.min(100, Math.abs(currentNeto / (Math.abs(smaValue) || 1)) * 50);
                            } else if (currentNeto < smaValue && currentNeto < 0) {
                                signal = 'BEARISH';
                                strength = Math.min(100, Math.abs(currentNeto / (Math.abs(smaValue) || 1)) * 50);
                            }
                        }
                        break;
                    }

                    case 'intensity': {
                        const smaPeriod = params.smaPeriod || 14;
                        if (n >= smaPeriod) {
                            const imbalanceValues = rows.map(r => {
                                const c = Math.abs(r[metric.call] || 0);
                                const p = Math.abs(r[metric.put] || 0);
                                const total = c + p;
                                return total > 0 ? ((c - p) / total) * 100 : 0;
                            });
                            const currentImbalance = imbalanceValues[n - 1];
                            const smaSlice = imbalanceValues.slice(-smaPeriod);
                            smaValue = smaSlice.reduce((a, b) => a + b, 0) / smaPeriod;
                            netForce = currentImbalance;
                            signalLine = smaValue;
                            value = currentImbalance;

                            if (currentImbalance > smaValue && currentImbalance > 0) {
                                signal = 'BULLISH';
                                strength = Math.min(100, Math.abs(currentImbalance));
                            } else if (currentImbalance < smaValue && currentImbalance < 0) {
                                signal = 'BEARISH';
                                strength = Math.min(100, Math.abs(currentImbalance));
                            }
                        }
                        break;
                    }

                    case 'towindicator': {
                        const smaPeriod = params.smaPeriod || 8;
                        if (n >= smaPeriod) {
                            const netForceArray = callData.map((c, i) => c - putData[i]);
                            const currentNet = netForceArray[n - 1];
                            const smaSlice = netForceArray.slice(-smaPeriod);
                            const avgNet = smaSlice.reduce((a, b) => a + b, 0) / smaPeriod;
                            netForce = currentNet;
                            signalLine = avgNet;
                            smaValue = avgNet;
                            value = currentNet;

                            if (currentNet > avgNet && currentNet > 0) {
                                signal = 'BULLISH';
                                strength = Math.min(100, Math.abs((currentNet - avgNet) / (Math.abs(avgNet) + 1)) * 50);
                            } else if (currentNet < avgNet && currentNet < 0) {
                                signal = 'BEARISH';
                                strength = Math.min(100, Math.abs((avgNet - currentNet) / (Math.abs(avgNet) + 1)) * 50);
                            }
                        }
                        break;
                    }

                    case 'dominance': {
                        const ratio = params.ratio || 2;
                        const lookback = params.lookback || 30;
                        const smaPeriod = params.smaPeriod || 8;

                        if (n >= lookback + smaPeriod) {
                            const callDeltas = callData.map((v, i) => i === 0 ? 0 : Math.max(0, v - callData[i - 1]));
                            const putDeltas = putData.map((v, i) => i === 0 ? 0 : Math.max(0, v - putData[i - 1]));

                            let callSum = 0, putSum = 0;
                            for (let j = Math.max(0, n - lookback); j < n; j++) {
                                callSum += callDeltas[j];
                                putSum += putDeltas[j];
                            }

                            const netDominance = callSum - putSum;
                            const netDominanceSeries = [];
                            for (let i = lookback - 1; i < n; i++) {
                                let cs = 0, ps = 0;
                                for (let j = i - lookback + 1; j <= i; j++) {
                                    cs += callDeltas[j];
                                    ps += putDeltas[j];
                                }
                                netDominanceSeries.push(cs - ps);
                            }
                            const smaSlice = netDominanceSeries.slice(-smaPeriod);
                            const domSmaValue = smaSlice.reduce((a, b) => a + b, 0) / smaSlice.length;

                            netForce = netDominance;
                            signalLine = domSmaValue;
                            smaValue = domSmaValue;
                            value = netDominance;

                            if (callSum > putSum * ratio && netDominance > domSmaValue) {
                                signal = 'BULLISH';
                                strength = Math.min(100, ((callSum / (putSum + 1)) - 1) * 40);
                            } else if (putSum > callSum * ratio && netDominance < domSmaValue) {
                                signal = 'BEARISH';
                                strength = Math.min(100, ((putSum / (callSum + 1)) - 1) * 40);
                            }
                        }
                        break;
                    }

                    case 'towforce': {
                        const smaPeriod = params.smaPeriod || 8;
                        const lookback = 20;
                        const velocityPeriod = 5;

                        if (n >= lookback + velocityPeriod + smaPeriod) {
                            const netForceHistory = [];
                            for (let i = lookback + velocityPeriod - 1; i < n; i++) {
                                let callRollingSum = 0, putRollingSum = 0;
                                for (let j = i - lookback + 1; j <= i; j++) {
                                    callRollingSum += callData[j];
                                    putRollingSum += putData[j];
                                }
                                let prevCallSum = 0, prevPutSum = 0;
                                const prevEnd = i - velocityPeriod;
                                for (let j = prevEnd - lookback + 1; j <= prevEnd; j++) {
                                    prevCallSum += callData[j];
                                    prevPutSum += putData[j];
                                }
                                const callVelocity = callRollingSum - prevCallSum;
                                const putVelocity = putRollingSum - prevPutSum;
                                const bullishForce = Math.max(0, callVelocity) + Math.max(0, -putVelocity);
                                const bearishForce = Math.max(0, putVelocity) + Math.max(0, -callVelocity);
                                netForceHistory.push(bullishForce - bearishForce);
                            }

                            const currentNetForce = netForceHistory[netForceHistory.length - 1];
                            const smaSlice = netForceHistory.slice(-smaPeriod);
                            const avgNetForce = smaSlice.reduce((a, b) => a + b, 0) / smaPeriod;

                            netForce = currentNetForce;
                            signalLine = avgNetForce;
                            smaValue = avgNetForce;
                            value = currentNetForce;

                            if (currentNetForce > avgNetForce && currentNetForce > 0) {
                                signal = 'BULLISH';
                                strength = Math.min(100, Math.abs((currentNetForce - avgNetForce) / (Math.abs(avgNetForce) + 1)) * 50);
                            } else if (currentNetForce < avgNetForce && currentNetForce < 0) {
                                signal = 'BEARISH';
                                strength = Math.min(100, Math.abs((avgNetForce - currentNetForce) / (Math.abs(avgNetForce) + 1)) * 50);
                            }
                        }
                        break;
                    }

                    case 'keltner': {
                        const emaPeriod = params.emaPeriod || 20;
                        const atrMult = params.atrMultiplier || 3.0;
                        const slopeThr = params.slopeThreshold || 0;

                        if (n >= emaPeriod) {
                            const netValues = callData.map((c, i) => c - putData[i]);
                            const multiplier = 2 / (emaPeriod + 1);
                            let ema = netValues[0];
                            const emaValues = [ema];
                            for (let i = 1; i < n; i++) {
                                ema = (netValues[i] - ema) * multiplier + ema;
                                emaValues.push(ema);
                            }

                            const trueRange = [0];
                            for (let i = 1; i < n; i++) {
                                trueRange.push(Math.abs(netValues[i] - netValues[i - 1]));
                            }
                            let atrEma = trueRange[0];
                            const atrValues = [atrEma];
                            for (let i = 1; i < n; i++) {
                                atrEma = (trueRange[i] - atrEma) * multiplier + atrEma;
                                atrValues.push(atrEma);
                            }

                            const currentValue = netValues[n - 1];
                            const currentEma = emaValues[n - 1];
                            const currentAtr = atrValues[n - 1];
                            const upperBand = currentEma + (currentAtr * atrMult);
                            const lowerBand = currentEma - (currentAtr * atrMult);
                            const slope = n > 1 ? emaValues[n - 1] - emaValues[n - 2] : 0;

                            netForce = currentValue;
                            signalLine = currentEma;
                            smaValue = currentEma;
                            value = currentValue;

                            let bandPosition = 'INSIDE';
                            if (currentValue > upperBand) bandPosition = 'ABOVE';
                            else if (currentValue < lowerBand) bandPosition = 'BELOW';

                            let slopeDir = 'NEUTRAL';
                            if (slope > slopeThr) slopeDir = 'UP';
                            else if (slope < -slopeThr) slopeDir = 'DOWN';

                            if (bandPosition === 'ABOVE' && slopeDir === 'UP') {
                                signal = 'BULLISH';
                                strength = Math.min(100, Math.abs((currentValue - upperBand) / (Math.abs(currentAtr) + 1)) * 30 + 40);
                            } else if (bandPosition === 'BELOW' && slopeDir === 'DOWN') {
                                signal = 'BEARISH';
                                strength = Math.min(100, Math.abs((lowerBand - currentValue) / (Math.abs(currentAtr) + 1)) * 30 + 40);
                            }
                        }
                        break;
                    }

                    case 'rsi': {
                        const period = params.period || 14;
                        const overbought = params.overbought || 60;
                        const oversold = params.oversold || 40;

                        if (n >= period + 1) {
                            const netValues = callData.map((c, i) => c - putData[i]);
                            const changes = [];
                            for (let i = 1; i < netValues.length; i++) {
                                changes.push(netValues[i] - netValues[i - 1]);
                            }

                            const gains = changes.map(c => c > 0 ? c : 0);
                            const losses = changes.map(c => c < 0 ? Math.abs(c) : 0);

                            const multiplier = 2 / (period + 1);
                            let avgGain = gains.slice(0, period).reduce((a, b) => a + b, 0) / period;
                            let avgLoss = losses.slice(0, period).reduce((a, b) => a + b, 0) / period;

                            for (let i = period; i < gains.length; i++) {
                                avgGain = (gains[i] - avgGain) * multiplier + avgGain;
                                avgLoss = (losses[i] - avgLoss) * multiplier + avgLoss;
                            }

                            const rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
                            const rsi = 100 - (100 / (1 + rs));
                            const pulseRsi = (rsi - 50) * 2;

                            netForce = pulseRsi;
                            signalLine = 0;
                            smaValue = rsi;
                            value = rsi;

                            if (rsi > overbought) {
                                signal = 'BULLISH';
                                strength = Math.min(100, ((rsi - overbought) / (100 - overbought)) * 100);
                            } else if (rsi < oversold) {
                                signal = 'BEARISH';
                                strength = Math.min(100, ((oversold - rsi) / oversold) * 100);
                            }
                        }
                        break;
                    }

                    case 'correlation': {
                        const smaPeriod = params.smaPeriod || 5;
                        const threshold = params.threshold || 2;

                        if (n >= smaPeriod * 3) {
                            const netValues = callData.map((c, i) => c - putData[i]);
                            const lookback = Math.min(50, n);
                            const recentNet = netValues.slice(-lookback);
                            const mean = recentNet.reduce((a, b) => a + b, 0) / lookback;
                            const stdDev = Math.sqrt(recentNet.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / lookback);

                            const currentNet = netValues[n - 1];
                            const zScore = stdDev > 0 ? (currentNet - mean) / stdDev : 0;

                            const zScores = [];
                            for (let i = lookback; i <= n; i++) {
                                const slice = netValues.slice(i - lookback, i);
                                const m = slice.reduce((a, b) => a + b, 0) / lookback;
                                const s = Math.sqrt(slice.reduce((sum, v) => sum + Math.pow(v - m, 2), 0) / lookback);
                                zScores.push(s > 0 ? (netValues[i - 1] - m) / s : 0);
                            }

                            const smaSlice = zScores.slice(-smaPeriod);
                            const avgZScore = smaSlice.reduce((a, b) => a + b, 0) / smaPeriod;

                            netForce = zScore;
                            signalLine = avgZScore;
                            smaValue = mean;
                            value = zScore;

                            if (zScore > threshold && zScore > avgZScore) {
                                signal = 'BULLISH';
                                strength = Math.min(100, Math.abs(zScore) * 25);
                            } else if (zScore < -threshold && zScore < avgZScore) {
                                signal = 'BEARISH';
                                strength = Math.min(100, Math.abs(zScore) * 25);
                            }
                        }
                        break;
                    }
                }

                return { signal, strength: Math.round(strength), value, netForce, signalLine, smaValue };
            };

            // Calcular se√±al individual de un indicador
            const getIndicatorSignal = (rows, indicatorKey, signalType, customSettings = {}, signalTypeParams = {}) => {
                if (!rows || rows.length === 0) {
                    return { signal: 'FLAT', value: 0, strength: 0, callValue: 0, putValue: 0, netForce: 0, signalLine: 0, smaValue: 0 };
                }

                const config = constants.SIGNAL_INDICATORS[indicatorKey];
                if (!config) return { signal: 'FLAT', value: 0, strength: 0 };

                // Usar signalTypeParams pasados (estado React) en lugar de constants.SIGNAL_TYPES
                const signalConfig = signalTypeParams || constants.SIGNAL_TYPES[signalType]?.config || {};
                const smaPeriod = customSettings.sma ?? signalConfig.smaPeriod ?? config.defaultSMA ?? 14;

                const n = rows.length;
                const callData = rows.map(r => Math.abs(r[config.call] || 0));
                const putData = rows.map(r => Math.abs(r[config.put] || 0));
                const callValue = callData[n - 1];
                const putValue = putData[n - 1];
                const ratioValue = putValue > 0 ? callValue / putValue : (callValue > 0 ? 999 : 1);

                let signal = 'FLAT';
                let strength = 0;
                let netForce = 0;
                let signalLine = 0;
                let smaValue = 0;

                // Determinar qu√© l√≥gica usar: indicadores RSI/Correlation usan su propia l√≥gica
                const effectiveSignalType = (config.type === 'rsi') ? 'rsi'
                    : (config.type === 'correlation') ? 'correlation'
                        : signalType;

                switch (effectiveSignalType) {
                    case 'evolution': {
                        // EVOLUTION: Neto vs SMA - m√©tricas originales del CSV
                        const evoSmaPeriod = signalConfig.smaPeriod || smaPeriod || 14;
                        if (n >= evoSmaPeriod) {
                            // Obtener el valor Neto directamente del CSV
                            const netoValues = rows.map(r => {
                                const c = r[config.call] || 0;
                                const p = config.invertPut ? -(r[config.put] || 0) : (r[config.put] || 0);
                                return c - Math.abs(p);
                            });
                            const currentNeto = netoValues[n - 1];
                            const smaSlice = netoValues.slice(-evoSmaPeriod);
                            smaValue = smaSlice.reduce((a, b) => a + b, 0) / evoSmaPeriod;

                            netForce = currentNeto;
                            signalLine = smaValue;

                            if (currentNeto > smaValue && currentNeto > 0) {
                                signal = 'BULLISH';
                                strength = Math.min(100, Math.abs(currentNeto / (Math.abs(smaValue) || 1)) * 50);
                            } else if (currentNeto < smaValue && currentNeto < 0) {
                                signal = 'BEARISH';
                                strength = Math.min(100, Math.abs(currentNeto / (Math.abs(smaValue) || 1)) * 50);
                            }
                        }
                        break;
                    }

                    case 'intensity': {
                        // INTENSITY: Imbalance por encima de su promedio SMA
                        const intSmaPeriod = signalConfig.smaPeriod || smaPeriod || 14;
                        if (n >= intSmaPeriod) {
                            const imbalanceValues = rows.map(r => {
                                const c = Math.abs(r[config.call] || 0);
                                const p = Math.abs(r[config.put] || 0);
                                const total = c + p;
                                return total > 0 ? ((c - p) / total) * 100 : 0;
                            });
                            const currentImbalance = imbalanceValues[n - 1];
                            const smaSlice = imbalanceValues.slice(-intSmaPeriod);
                            smaValue = smaSlice.reduce((a, b) => a + b, 0) / intSmaPeriod;

                            netForce = currentImbalance;
                            signalLine = smaValue;

                            if (currentImbalance > smaValue && currentImbalance > 0) {
                                signal = 'BULLISH';
                                strength = Math.min(100, Math.abs(currentImbalance));
                            } else if (currentImbalance < smaValue && currentImbalance < 0) {
                                signal = 'BEARISH';
                                strength = Math.min(100, Math.abs(currentImbalance));
                            }
                        }
                        break;
                    }

                    case 'towindicator': {
                        // TOW INDICATOR: Net Force vs Signal Line (SMA del Net)
                        const towSmaPeriod = signalConfig.smaPeriod || smaPeriod || 8;
                        if (n >= towSmaPeriod) {
                            const netForceArray = callData.map((c, i) => c - putData[i]);
                            const currentNet = netForceArray[n - 1];
                            const smaSlice = netForceArray.slice(-towSmaPeriod);
                            const avgNet = smaSlice.reduce((a, b) => a + b, 0) / towSmaPeriod;

                            netForce = currentNet;
                            signalLine = avgNet;
                            smaValue = avgNet;

                            if (currentNet > avgNet && currentNet > 0) {
                                signal = 'BULLISH';
                                strength = Math.min(100, Math.abs((currentNet - avgNet) / (Math.abs(avgNet) + 1)) * 50);
                            } else if (currentNet < avgNet && currentNet < 0) {
                                signal = 'BEARISH';
                                strength = Math.min(100, Math.abs((avgNet - currentNet) / (Math.abs(avgNet) + 1)) * 50);
                            }
                        }
                        break;
                    }

                    case 'dominance': {
                        // DOMINANCE: Indice de Dominancia Direccional con ratio y SMA
                        const domRatio = signalConfig.ratio || 2;
                        const domLookback = signalConfig.lookback || 30;
                        const domSmaPeriod = signalConfig.smaPeriod || smaPeriod || 8;

                        if (n >= domLookback + domSmaPeriod) {
                            const callDeltas = callData.map((v, i) => i === 0 ? 0 : Math.max(0, v - callData[i - 1]));
                            const putDeltas = putData.map((v, i) => i === 0 ? 0 : Math.max(0, v - putData[i - 1]));

                            let callSum = 0, putSum = 0;
                            for (let j = Math.max(0, n - domLookback); j < n; j++) {
                                callSum += callDeltas[j];
                                putSum += putDeltas[j];
                            }

                            const netDominance = callSum - putSum;
                            const netDominanceSeries = [];
                            for (let i = domLookback - 1; i < n; i++) {
                                let cs = 0, ps = 0;
                                for (let j = i - domLookback + 1; j <= i; j++) {
                                    cs += callDeltas[j];
                                    ps += putDeltas[j];
                                }
                                netDominanceSeries.push(cs - ps);
                            }
                            const smaSlice = netDominanceSeries.slice(-domSmaPeriod);
                            const domSmaValue = smaSlice.reduce((a, b) => a + b, 0) / smaSlice.length;

                            netForce = netDominance;
                            signalLine = domSmaValue;
                            smaValue = domSmaValue;

                            if (callSum > putSum * domRatio && netDominance > domSmaValue) {
                                signal = 'BULLISH';
                                strength = Math.min(100, ((callSum / (putSum + 1)) - 1) * 40);
                            } else if (putSum > callSum * domRatio && netDominance < domSmaValue) {
                                signal = 'BEARISH';
                                strength = Math.min(100, ((putSum / (callSum + 1)) - 1) * 40);
                            }
                        }
                        break;
                    }

                    case 'towforce': {
                        // TUG-OF-WAR: Net Force por encima de su promedio SMA
                        const tfSmaPeriod = signalConfig.smaPeriod || 8;
                        const tfLookback = 20;
                        const tfVelocityPeriod = 5;

                        if (n >= tfLookback + tfVelocityPeriod + tfSmaPeriod) {
                            const netForceHistory = [];
                            for (let i = tfLookback + tfVelocityPeriod - 1; i < n; i++) {
                                let callRollingSum = 0, putRollingSum = 0;
                                for (let j = i - tfLookback + 1; j <= i; j++) {
                                    callRollingSum += callData[j];
                                    putRollingSum += putData[j];
                                }
                                let prevCallSum = 0, prevPutSum = 0;
                                const prevEnd = i - tfVelocityPeriod;
                                for (let j = prevEnd - tfLookback + 1; j <= prevEnd; j++) {
                                    prevCallSum += callData[j];
                                    prevPutSum += putData[j];
                                }
                                const callVelocity = callRollingSum - prevCallSum;
                                const putVelocity = putRollingSum - prevPutSum;
                                const bullishForce = Math.max(0, callVelocity) + Math.max(0, -putVelocity);
                                const bearishForce = Math.max(0, putVelocity) + Math.max(0, -callVelocity);
                                netForceHistory.push(bullishForce - bearishForce);
                            }

                            const currentNetForce = netForceHistory[netForceHistory.length - 1];
                            const smaSlice = netForceHistory.slice(-tfSmaPeriod);
                            const avgNetForce = smaSlice.reduce((a, b) => a + b, 0) / tfSmaPeriod;

                            netForce = currentNetForce;
                            signalLine = avgNetForce;
                            smaValue = avgNetForce;

                            if (currentNetForce > avgNetForce && currentNetForce > 0) {
                                signal = 'BULLISH';
                                strength = Math.min(100, Math.abs((currentNetForce - avgNetForce) / (Math.abs(avgNetForce) + 1)) * 50);
                            } else if (currentNetForce < avgNetForce && currentNetForce < 0) {
                                signal = 'BEARISH';
                                strength = Math.min(100, Math.abs((avgNetForce - currentNetForce) / (Math.abs(avgNetForce) + 1)) * 50);
                            }
                        }
                        break;
                    }

                    case 'keltner': {
                        // KELTNER: Se√±al basada en bandas Keltner + Slope EMA
                        // REGLA ESTRICTA:
                        // - BULLISH: SOLO encima de banda superior + slope UP
                        // - BEARISH: SOLO debajo de banda inferior + slope DOWN
                        // - FLAT: Todo lo dem√°s (dentro del canal o sin confirmaci√≥n)
                        const keltEmaPeriod = signalConfig.emaPeriod || 20;
                        const keltAtrMult = signalConfig.atrMultiplier || 3.0;
                        const keltSlopeThr = signalConfig.slopeThreshold || 10000;

                        if (n >= keltEmaPeriod) {
                            // Calcular valores netos
                            const netValues = callData.map((c, i) => c - putData[i]);

                            // Calcular EMA
                            const multiplier = 2 / (keltEmaPeriod + 1);
                            let ema = netValues[0];
                            const emaValues = [ema];
                            for (let i = 1; i < n; i++) {
                                ema = (netValues[i] - ema) * multiplier + ema;
                                emaValues.push(ema);
                            }

                            // Calcular ATR
                            const trueRange = [0];
                            for (let i = 1; i < n; i++) {
                                trueRange.push(Math.abs(netValues[i] - netValues[i - 1]));
                            }
                            let atrEma = trueRange[0];
                            const atrValues = [atrEma];
                            for (let i = 1; i < n; i++) {
                                atrEma = (trueRange[i] - atrEma) * multiplier + atrEma;
                                atrValues.push(atrEma);
                            }

                            const currentValue = netValues[n - 1];
                            const currentEma = emaValues[n - 1];
                            const currentAtr = atrValues[n - 1];
                            const upperBand = currentEma + (currentAtr * keltAtrMult);
                            const lowerBand = currentEma - (currentAtr * keltAtrMult);
                            const slope = n > 1 ? emaValues[n - 1] - emaValues[n - 2] : 0;

                            netForce = currentValue;
                            signalLine = currentEma;
                            smaValue = currentEma;

                            // Determinar posici√≥n respecto a bandas
                            let bandPosition = 'INSIDE';
                            if (currentValue > upperBand) bandPosition = 'ABOVE';
                            else if (currentValue < lowerBand) bandPosition = 'BELOW';

                            // Determinar direcci√≥n del slope
                            let slopeDir = 'NEUTRAL';
                            if (slope > keltSlopeThr) slopeDir = 'UP';
                            else if (slope < -keltSlopeThr) slopeDir = 'DOWN';

                            // L√ìGICA ESTRICTA: Solo se√±al cuando est√° FUERA del canal Y slope confirma
                            if (bandPosition === 'ABOVE' && slopeDir === 'UP') {
                                signal = 'BULLISH';
                                strength = Math.min(100, Math.abs((currentValue - upperBand) / (Math.abs(currentAtr) + 1)) * 30 + 40);
                            } else if (bandPosition === 'BELOW' && slopeDir === 'DOWN') {
                                signal = 'BEARISH';
                                strength = Math.min(100, Math.abs((lowerBand - currentValue) / (Math.abs(currentAtr) + 1)) * 30 + 40);
                            } else {
                                // Todo lo dem√°s = FLAT (LATERAL)
                                // - Dentro del canal (INSIDE)
                                // - Encima pero slope no sube
                                // - Debajo pero slope no baja
                                signal = 'FLAT';
                                strength = 0;
                            }
                        }
                        break;
                    }

                    case 'rsi': {
                        // PULSE RSI: RSI adaptado a flujos de opciones
                        // Calcula RSI basado en Net Flow (Call - Put)
                        const rsiPeriod = signalConfig.period || smaPeriod || 14;
                        const overbought = signalConfig.overbought || 60;
                        const oversold = signalConfig.oversold || 40;

                        if (n >= rsiPeriod + 1) {
                            // Calcular Net Flow
                            const netValues = callData.map((c, i) => c - putData[i]);

                            // Calcular cambios
                            const changes = [];
                            for (let i = 1; i < netValues.length; i++) {
                                changes.push(netValues[i] - netValues[i - 1]);
                            }

                            // Separar ganancias y p√©rdidas
                            const gains = changes.map(c => c > 0 ? c : 0);
                            const losses = changes.map(c => c < 0 ? Math.abs(c) : 0);

                            // Calcular EMA de ganancias y p√©rdidas
                            const multiplier = 2 / (rsiPeriod + 1);
                            let avgGain = gains.slice(0, rsiPeriod).reduce((a, b) => a + b, 0) / rsiPeriod;
                            let avgLoss = losses.slice(0, rsiPeriod).reduce((a, b) => a + b, 0) / rsiPeriod;

                            for (let i = rsiPeriod; i < gains.length; i++) {
                                avgGain = (gains[i] - avgGain) * multiplier + avgGain;
                                avgLoss = (losses[i] - avgLoss) * multiplier + avgLoss;
                            }

                            // RSI = 100 - (100 / (1 + RS))
                            const rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
                            const rsi = 100 - (100 / (1 + rs));

                            // Normalizar a escala -100 a +100 (centrado en 50)
                            const pulseRsi = (rsi - 50) * 2;

                            netForce = pulseRsi;
                            signalLine = 0; // Centro
                            smaValue = rsi;

                            if (rsi > overbought) {
                                signal = 'BULLISH';
                                strength = Math.min(100, ((rsi - overbought) / (100 - overbought)) * 100);
                            } else if (rsi < oversold) {
                                signal = 'BEARISH';
                                strength = Math.min(100, ((oversold - rsi) / oversold) * 100);
                            }
                        }
                        break;
                    }

                    case 'correlation': {
                        // CORRELATION: √çndice combinado para se√±ales de correlaci√≥n
                        // Usa Z-Score del Net para detectar extremos
                        const corrSmaPeriod = signalConfig.smaPeriod || 5;
                        const corrThreshold = signalConfig.threshold || 2;

                        if (n >= corrSmaPeriod * 3) {
                            // Calcular Net Flow
                            const netValues = callData.map((c, i) => c - putData[i]);

                            // Calcular media y desviaci√≥n est√°ndar rolling
                            const lookback = Math.min(50, n);
                            const recentNet = netValues.slice(-lookback);
                            const mean = recentNet.reduce((a, b) => a + b, 0) / lookback;
                            const stdDev = Math.sqrt(recentNet.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / lookback);

                            // Z-Score actual
                            const currentNet = netValues[n - 1];
                            const zScore = stdDev > 0 ? (currentNet - mean) / stdDev : 0;

                            // SMA del Z-Score para suavizar
                            const zScores = [];
                            for (let i = lookback; i <= n; i++) {
                                const slice = netValues.slice(i - lookback, i);
                                const m = slice.reduce((a, b) => a + b, 0) / lookback;
                                const s = Math.sqrt(slice.reduce((sum, v) => sum + Math.pow(v - m, 2), 0) / lookback);
                                zScores.push(s > 0 ? (netValues[i - 1] - m) / s : 0);
                            }

                            const smaSlice = zScores.slice(-corrSmaPeriod);
                            const avgZScore = smaSlice.reduce((a, b) => a + b, 0) / corrSmaPeriod;

                            netForce = zScore;
                            signalLine = avgZScore;
                            smaValue = mean;

                            if (zScore > corrThreshold && zScore > avgZScore) {
                                signal = 'BULLISH';
                                strength = Math.min(100, Math.abs(zScore) * 25);
                            } else if (zScore < -corrThreshold && zScore < avgZScore) {
                                signal = 'BEARISH';
                                strength = Math.min(100, Math.abs(zScore) * 25);
                            }
                        }
                        break;
                    }

                    default: {
                        // Fallback: simple ratio
                        if (ratioValue > 2) {
                            signal = 'BULLISH';
                            strength = Math.min(100, (ratioValue - 1) * 30);
                        } else if (ratioValue < 0.5) {
                            signal = 'BEARISH';
                            strength = Math.min(100, (1 / ratioValue - 1) * 30);
                        }
                    }
                }

                return {
                    signal,
                    value: ratioValue,
                    strength: Math.round(strength),
                    callValue,
                    putValue,
                    netForce,
                    signalLine,
                    smaValue,
                    smaPeriod
                };
            };

            // NUEVA: Calcular se√±al combinada usando Signal Slots (m√©trica + algoritmo)
            const calculateCombinedSignalFromSlots = (rows, signalSlots, signalTypeParams = {}, minConfirmation = 3) => {
                const enabledSlots = signalSlots.filter(s => s.enabled);

                if (!rows || rows.length === 0 || enabledSlots.length === 0) {
                    return {
                        signal: 'FLAT',
                        bullishCount: 0,
                        bearishCount: 0,
                        flatCount: 0,
                        details: [],
                        total: 0,
                        confidence: 0,
                        avgStrength: 0
                    };
                }

                let bullishCount = 0;
                let bearishCount = 0;
                let flatCount = 0;
                let totalStrength = 0;
                const details = [];

                for (const slot of enabledSlots) {
                    const result = getSlotSignal(rows, slot, signalTypeParams);

                    if (result.signal === 'BULLISH') {
                        bullishCount++;
                        totalStrength += result.strength;
                    } else if (result.signal === 'BEARISH') {
                        bearishCount++;
                        totalStrength += result.strength;
                    } else {
                        flatCount++;
                    }

                    details.push({
                        key: `${slot.metric}-${slot.algorithm}`,
                        slotId: slot.id,
                        metric: slot.metric,
                        algorithm: slot.algorithm,
                        label: result.metricLabel,
                        algorithmLabel: result.algorithmLabel,
                        algorithmColor: result.algorithmColor,
                        signal: result.signal,
                        value: result.value,
                        strength: result.strength,
                        callValue: result.callValue,
                        putValue: result.putValue,
                        netForce: result.netForce,
                        signalLine: result.signalLine,
                        colors: result.colors
                    });
                }

                let combinedSignal = 'FLAT';
                let confidence = 0;
                const total = enabledSlots.length;
                const signalCount = bullishCount + bearishCount;

                if (bullishCount >= minConfirmation && bullishCount > bearishCount) {
                    combinedSignal = 'BULLISH';
                    confidence = Math.round((bullishCount / total) * 100);
                } else if (bearishCount >= minConfirmation && bearishCount > bullishCount) {
                    combinedSignal = 'BEARISH';
                    confidence = Math.round((bearishCount / total) * 100);
                }

                const avgStrength = signalCount > 0 ? Math.round(totalStrength / signalCount) : 0;

                return {
                    signal: combinedSignal,
                    bullishCount,
                    bearishCount,
                    flatCount,
                    details,
                    total,
                    confidence,
                    avgStrength
                };
            };

            // LEGACY: Calcular se√±al combinada de m√∫ltiples indicadores
            const calculateCombinedSignal = (rows, selectedIndicators, signalType, settings = {}, minConfirmation = 3, signalTypeParams = {}) => {
                if (!rows || rows.length === 0 || !selectedIndicators || selectedIndicators.length === 0) {
                    return {
                        signal: 'FLAT',
                        bullishCount: 0,
                        bearishCount: 0,
                        flatCount: 0,
                        details: [],
                        total: 0,
                        confidence: 0,
                        avgStrength: 0
                    };
                }

                let bullishCount = 0;
                let bearishCount = 0;
                let flatCount = 0;
                let totalStrength = 0;
                const details = [];

                for (const indicatorKey of selectedIndicators) {
                    const indicatorSettings = settings[indicatorKey] || {};
                    const result = getIndicatorSignal(rows, indicatorKey, signalType, indicatorSettings, signalTypeParams);
                    const config = constants.SIGNAL_INDICATORS[indicatorKey];

                    if (result.signal === 'BULLISH') {
                        bullishCount++;
                        totalStrength += result.strength;
                    } else if (result.signal === 'BEARISH') {
                        bearishCount++;
                        totalStrength += result.strength;
                    } else {
                        flatCount++;
                    }

                    details.push({
                        key: indicatorKey,
                        label: config?.label || indicatorKey,
                        category: config?.category || 'Unknown',
                        signal: result.signal,
                        value: result.value,
                        strength: result.strength,
                        callValue: result.callValue,
                        putValue: result.putValue,
                        netForce: result.netForce,
                        signalLine: result.signalLine
                    });
                }

                let combinedSignal = 'FLAT';
                let confidence = 0;
                const total = selectedIndicators.length;
                const signalCount = bullishCount + bearishCount;

                if (bullishCount >= minConfirmation && bullishCount > bearishCount) {
                    combinedSignal = 'BULLISH';
                    confidence = Math.round((bullishCount / total) * 100);
                } else if (bearishCount >= minConfirmation && bearishCount > bullishCount) {
                    combinedSignal = 'BEARISH';
                    confidence = Math.round((bearishCount / total) * 100);
                }

                const avgStrength = signalCount > 0 ? Math.round(totalStrength / signalCount) : 0;

                return {
                    signal: combinedSignal,
                    bullishCount,
                    bearishCount,
                    flatCount,
                    details,
                    total,
                    confidence,
                    avgStrength
                };
            };

            // ===== KELTNER SIGNALS - Basado en bandas y slope =====
            // Se√±al BULLISH: precio por encima de banda superior + slope positivo
            // Se√±al BEARISH: precio por debajo de banda inferior + slope negativo
            // Se√±al LATERAL: entre bandas O slope neutral
            const calculateKeltnerSignals = (rows, timestampHeader, column, emaPeriod = 20, atrMultiplier = 3.0, slopeThreshold = 1000) => {
                if (!rows || rows.length < emaPeriod) {
                    return rows ? rows.map(r => ({ time: r[timestampHeader], state: 'FLAT', slope: 0, bandPosition: 'INSIDE' })) : [];
                }

                const rawData = rows.map(r => r[column] || 0);
                const n = rawData.length;

                // Calcular EMA
                const calculateEMA = (data, period) => {
                    const result = [];
                    const multiplier = 2 / (period + 1);
                    let ema = data[0];
                    result.push(ema);
                    for (let i = 1; i < data.length; i++) {
                        ema = (data[i] - ema) * multiplier + ema;
                        result.push(ema);
                    }
                    return result;
                };

                // Calcular ATR adaptado para flujos
                const calculateATR = (data, period) => {
                    const trueRange = [0];
                    for (let i = 1; i < data.length; i++) {
                        trueRange.push(Math.abs(data[i] - data[i - 1]));
                    }
                    return calculateEMA(trueRange, period);
                };

                const emaCenter = calculateEMA(rawData, emaPeriod);
                const atr = calculateATR(rawData, emaPeriod);

                // Bandas del Keltner Channel
                const upperBand = emaCenter.map((ema, i) => ema + (atr[i] * atrMultiplier));
                const lowerBand = emaCenter.map((ema, i) => ema - (atr[i] * atrMultiplier));

                // Calcular se√±ales
                const signals = [];
                for (let i = 0; i < n; i++) {
                    const time = rows[i][timestampHeader];
                    const value = rawData[i];
                    const upper = upperBand[i];
                    const lower = lowerBand[i];
                    const ema = emaCenter[i];

                    // Calcular slope (pendiente) de la EMA
                    const slope = i > 0 ? emaCenter[i] - emaCenter[i - 1] : 0;

                    // Determinar posici√≥n respecto a bandas
                    let bandPosition = 'INSIDE'; // Entre bandas
                    if (value > upper) bandPosition = 'ABOVE';
                    else if (value < lower) bandPosition = 'BELOW';

                    // Determinar direcci√≥n del slope
                    let slopeDirection = 'NEUTRAL';
                    if (slope > slopeThreshold) slopeDirection = 'UP';
                    else if (slope < -slopeThreshold) slopeDirection = 'DOWN';

                    // Determinar se√±al combinando bandas + slope
                    // REGLA ESTRICTA:
                    // - BULLISH: SOLO cuando est√° ENCIMA de banda superior Y slope positivo
                    // - BEARISH: SOLO cuando est√° DEBAJO de banda inferior Y slope negativo  
                    // - FLAT/LATERAL: Todo lo dem√°s (dentro del canal, o sin confirmaci√≥n de slope)
                    let state = 'FLAT'; // FLAT = LATERAL (por defecto)

                    if (bandPosition === 'ABOVE' && slopeDirection === 'UP') {
                        // Encima de banda superior + slope subiendo = BULLISH confirmado
                        state = 'BULLISH';
                    } else if (bandPosition === 'BELOW' && slopeDirection === 'DOWN') {
                        // Debajo de banda inferior + slope bajando = BEARISH confirmado
                        state = 'BEARISH';
                    }
                    // Todos los dem√°s casos = FLAT (LATERAL):
                    // - Dentro del canal (INSIDE) sin importar slope
                    // - Encima pero slope neutral o bajando
                    // - Debajo pero slope neutral o subiendo

                    signals.push({
                        time,
                        state,
                        slope,
                        slopeDirection,
                        bandPosition,
                        value,
                        ema,
                        upper,
                        lower
                    });
                }

                return signals;
            };

            // ===== SIMPLE SIGNALS - Valor vs SMA =====
            // BULLISH: valor > SMA
            // BEARISH: valor < SMA
            const calculateSimpleSignals = (data, timestamps, smaPeriod = 14) => {
                if (!data || data.length < smaPeriod) {
                    return data ? data.map((v, i) => ({ time: timestamps[i], state: 'FLAT' })) : [];
                }
                const n = data.length;
                const signals = [];
                for (let i = 0; i < n; i++) {
                    const time = timestamps[i];
                    const value = data[i];
                    let sma = value;
                    if (i >= smaPeriod - 1) {
                        let sum = 0;
                        for (let j = 0; j < smaPeriod; j++) sum += data[i - j];
                        sma = sum / smaPeriod;
                    }
                    let state = 'FLAT';
                    if (value > sma) state = 'BULLISH';
                    else if (value < sma) state = 'BEARISH';
                    signals.push({ time, state, value, sma });
                }
                return signals;
            };

            // ===== ML PATTERN RECOGNITION ENGINE =====
            // Sistema de detecci√≥n de patrones y correlaci√≥n de m√©tricas
            const MLPatternEngine = (() => {
                // Configuraci√≥n de m√©tricas a analizar
                const METRICS_CONFIG = [
                    { key: 'gex', call: 'Call_GEX', put: 'Put_GEX', label: 'GEX' },
                    { key: 'money', call: 'Call_Money_Flow', put: 'Put_Money_Flow', label: 'Money Flow' },
                    { key: 'delta', call: 'Call_Delta_Flow', put: 'Put_Delta_Flow', label: 'Delta' },
                    { key: 'itm', call: 'Call_ITM_Impact', put: 'Put_ITM_Impact', label: 'ITM Impact' },
                    { key: 'otm', call: 'Call_OTM_Impact', put: 'Put_OTM_Impact', label: 'OTM Impact' },
                    { key: 'vanna', call: 'Call_Vanna_Flow', put: 'Put_Vanna_Flow', label: 'Vanna' },
                    { key: 'charm', call: 'Call_Charm', put: 'Put_Charm', label: 'Charm' },
                    { key: 'iv', call: 'Call_IV_Flow', put: 'Put_IV_Flow', label: 'IV Flow' },
                    { key: 'smart', call: 'Call_Smart_Money', put: 'Put_Smart_Money', label: 'Smart Money' },
                    { key: 'vol', call: 'Call_Vol_Imbalance', put: 'Put_Vol_Imbalance', label: 'Vol Imbalance' },
                    { key: 'hedge', call: 'Call_Hedge_Pressure', put: 'Put_Hedge_Pressure', label: 'Hedge Pressure' }
                ];

                // Tipos de eventos de precio
                const EVENT_TYPES = {
                    LOCAL_HIGH: 'local_high',
                    LOCAL_LOW: 'local_low',
                    IMPULSE_UP: 'impulse_up',
                    IMPULSE_DOWN: 'impulse_down',
                    TREND_UP: 'trend_up',
                    TREND_DOWN: 'trend_down',
                    LATERAL: 'lateral',
                    BREAKOUT_UP: 'breakout_up',
                    BREAKOUT_DOWN: 'breakout_down'
                };

                // Detectar m√°ximos y m√≠nimos locales - MODO FLEXIBLE
                const detectLocalExtremes = (prices, lookback = 3) => {
                    const extremes = [];
                    if (prices.length < 3) return extremes;

                    const actualLookback = Math.min(lookback, Math.floor(prices.length / 3));
                    if (actualLookback < 1) return extremes;

                    for (let i = actualLookback; i < prices.length - actualLookback; i++) {
                        const current = prices[i];
                        const leftWindow = prices.slice(Math.max(0, i - actualLookback), i);
                        const rightWindow = prices.slice(i + 1, Math.min(prices.length, i + actualLookback + 1));

                        if (leftWindow.length === 0 || rightWindow.length === 0) continue;

                        const isLocalHigh = leftWindow.every(p => p <= current) && rightWindow.every(p => p <= current);
                        const isLocalLow = leftWindow.every(p => p >= current) && rightWindow.every(p => p >= current);

                        if (isLocalHigh) {
                            extremes.push({ index: i, type: EVENT_TYPES.LOCAL_HIGH, price: current });
                        } else if (isLocalLow) {
                            extremes.push({ index: i, type: EVENT_TYPES.LOCAL_LOW, price: current });
                        }
                    }
                    return extremes;
                };

                // Detectar impulsos (movimientos r√°pidos) - ULTRA-SENSIBLE
                const detectImpulses = (prices, timestamps, minMagnitude = 0.1, maxBars = 3) => {
                    const impulses = [];
                    if (prices.length < 2) return impulses;

                    const returns = [];
                    for (let i = 1; i < prices.length; i++) {
                        returns.push((prices[i] - prices[i - 1]) / prices[i - 1] * 100);
                    }

                    // MODO ADAPTATIVO: usa ventana peque√±a si hay pocos datos
                    const volWindow = Math.min(5, Math.max(2, Math.floor(returns.length / 2)));
                    const actualMaxBars = Math.min(maxBars, prices.length - 1);

                    for (let i = volWindow; i < returns.length; i++) {
                        const windowReturns = returns.slice(Math.max(0, i - volWindow), i);
                        if (windowReturns.length === 0) continue;

                        const avgReturn = windowReturns.reduce((a, b) => a + b, 0) / windowReturns.length;
                        const variance = windowReturns.reduce((a, b) => a + Math.pow(b - avgReturn, 2), 0) / windowReturns.length;
                        const stdDev = Math.sqrt(variance) || 0.01;

                        // Buscar CUALQUIER movimiento direccional
                        for (let bars = 1; bars <= actualMaxBars; bars++) {
                            if (i - bars < 0) continue;
                            const cumReturn = (prices[i] - prices[i - bars]) / prices[i - bars] * 100;
                            const zScore = cumReturn / (stdDev * Math.sqrt(bars));

                            // DETECTAR movimientos con direcci√≥n clara (z-score > 1.0 = M√ÅS SELECTIVO)
                            if (Math.abs(zScore) > 1.0) {
                                const type = cumReturn > 0 ? EVENT_TYPES.IMPULSE_UP : EVENT_TYPES.IMPULSE_DOWN;
                                const lastImpulse = impulses[impulses.length - 1];
                                if (!lastImpulse || i - lastImpulse.index > 2) {
                                    impulses.push({
                                        index: i,
                                        type,
                                        magnitude: cumReturn,
                                        bars,
                                        zScore,
                                        startIndex: i - bars,
                                        price: prices[i],
                                        timestamp: timestamps[i],
                                        strength: Math.abs(zScore)
                                    });
                                }
                                break;
                            }
                        }
                    }
                    console.log('[detectImpulses] Detected:', impulses.length, 'impulses');
                    if (impulses.length > 0) {
                        console.log('[detectImpulses] Sample:', impulses.slice(0, 3).map(i => ({
                            type: i.type,
                            mag: i.magnitude?.toFixed(2),
                            price: i.price?.toFixed(2)
                        })));
                    }
                    return impulses;
                };

                // Detectar tendencias usando regresi√≥n lineal
                const detectTrends = (prices, windowSize = 20, minR2 = 0.6) => {
                    const trends = [];

                    for (let i = windowSize; i < prices.length; i++) {
                        const window = prices.slice(i - windowSize, i);

                        // Regresi√≥n lineal simple
                        const n = window.length;
                        const xMean = (n - 1) / 2;
                        const yMean = window.reduce((a, b) => a + b, 0) / n;

                        let numerator = 0, denominator = 0;
                        for (let j = 0; j < n; j++) {
                            numerator += (j - xMean) * (window[j] - yMean);
                            denominator += Math.pow(j - xMean, 2);
                        }

                        const slope = denominator !== 0 ? numerator / denominator : 0;

                        // Calcular R¬≤
                        let ssRes = 0, ssTot = 0;
                        for (let j = 0; j < n; j++) {
                            const predicted = yMean + slope * (j - xMean);
                            ssRes += Math.pow(window[j] - predicted, 2);
                            ssTot += Math.pow(window[j] - yMean, 2);
                        }
                        const r2 = ssTot !== 0 ? 1 - (ssRes / ssTot) : 0;

                        // Normalizar slope por precio
                        const normalizedSlope = (slope / yMean) * 100;

                        let type = EVENT_TYPES.LATERAL;
                        if (r2 >= minR2) {
                            if (normalizedSlope > 0.05) type = EVENT_TYPES.TREND_UP;
                            else if (normalizedSlope < -0.05) type = EVENT_TYPES.TREND_DOWN;
                        }

                        trends.push({
                            index: i,
                            type,
                            slope: normalizedSlope,
                            r2,
                            strength: r2 * Math.abs(normalizedSlope)
                        });
                    }
                    return trends;
                };

                // Detectar breakouts de consolidaci√≥n
                const detectBreakouts = (prices, windowSize = 20, threshold = 1.5) => {
                    const breakouts = [];

                    for (let i = windowSize + 1; i < prices.length; i++) {
                        const window = prices.slice(i - windowSize, i);
                        const mean = window.reduce((a, b) => a + b, 0) / windowSize;
                        const stdDev = Math.sqrt(window.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / windowSize);

                        const current = prices[i];
                        const prev = prices[i - 1];

                        // Verificar si est√°bamos en consolidaci√≥n (bajo stdDev relativo)
                        const relativeStdDev = stdDev / mean * 100;
                        if (relativeStdDev < 1.0) { // Consolidaci√≥n si volatilidad < 1% (M√ÅS SELECTIVO)
                            const upperBand = mean + threshold * stdDev;
                            const lowerBand = mean - threshold * stdDev; if (current > upperBand && prev <= upperBand) {
                                breakouts.push({ index: i, type: EVENT_TYPES.BREAKOUT_UP, price: current, band: upperBand });
                            } else if (current < lowerBand && prev >= lowerBand) {
                                breakouts.push({ index: i, type: EVENT_TYPES.BREAKOUT_DOWN, price: current, band: lowerBand });
                            }
                        }
                    }
                    return breakouts;
                };

                // Extraer snapshot de m√©tricas en un √≠ndice dado
                const extractMetricSnapshot = (rows, index, lookback = 5) => {
                    if (!rows || index < lookback || index >= rows.length) return null;

                    const snapshot = { index, metrics: {} };
                    const row = rows[index];

                    METRICS_CONFIG.forEach(metric => {
                        const callVal = parseFloat(row[metric.call]) || 0;
                        const putVal = parseFloat(row[metric.put]) || 0;
                        const netVal = callVal - putVal;

                        // Calcular momentum (cambio vs promedio reciente)
                        let momentum = 0;
                        let avgNet = 0;
                        if (index >= lookback) {
                            for (let j = index - lookback; j < index; j++) {
                                const c = parseFloat(rows[j][metric.call]) || 0;
                                const p = parseFloat(rows[j][metric.put]) || 0;
                                avgNet += (c - p);
                            }
                            avgNet /= lookback;
                            momentum = avgNet !== 0 ? ((netVal - avgNet) / Math.abs(avgNet)) * 100 : 0;
                        }

                        // Calcular aceleraci√≥n
                        let acceleration = 0;
                        if (index >= 2) {
                            const prev1Net = (parseFloat(rows[index - 1][metric.call]) || 0) - (parseFloat(rows[index - 1][metric.put]) || 0);
                            const prev2Net = (parseFloat(rows[index - 2][metric.call]) || 0) - (parseFloat(rows[index - 2][metric.put]) || 0);
                            const vel1 = netVal - prev1Net;
                            const vel2 = prev1Net - prev2Net;
                            acceleration = vel1 - vel2;
                        }

                        snapshot.metrics[metric.key] = {
                            call: callVal,
                            put: putVal,
                            net: netVal,
                            ratio: putVal !== 0 ? callVal / putVal : callVal > 0 ? 999 : 0,
                            momentum,
                            acceleration,
                            label: metric.label
                        };
                    });

                    return snapshot;
                };

                // Normalizar valores para comparaci√≥n (z-score)
                const normalizeSnapshots = (snapshots) => {
                    if (snapshots.length < 2) return snapshots;

                    // Calcular media y desviaci√≥n para cada m√©trica
                    const stats = {};
                    METRICS_CONFIG.forEach(m => {
                        const netValues = snapshots.map(s => s.metrics[m.key]?.net || 0);
                        const momValues = snapshots.map(s => s.metrics[m.key]?.momentum || 0);

                        const netMean = netValues.reduce((a, b) => a + b, 0) / netValues.length;
                        const netStd = Math.sqrt(netValues.reduce((a, b) => a + Math.pow(b - netMean, 2), 0) / netValues.length) || 1;

                        const momMean = momValues.reduce((a, b) => a + b, 0) / momValues.length;
                        const momStd = Math.sqrt(momValues.reduce((a, b) => a + Math.pow(b - momMean, 2), 0) / momValues.length) || 1;

                        stats[m.key] = { netMean, netStd, momMean, momStd };
                    });

                    // Normalizar
                    return snapshots.map(snapshot => {
                        const normalized = { ...snapshot, normalizedMetrics: {} };
                        METRICS_CONFIG.forEach(m => {
                            const metric = snapshot.metrics[m.key];
                            if (metric) {
                                normalized.normalizedMetrics[m.key] = {
                                    netZ: (metric.net - stats[m.key].netMean) / stats[m.key].netStd,
                                    momZ: (metric.momentum - stats[m.key].momMean) / stats[m.key].momStd
                                };
                            }
                        });
                        return normalized;
                    });
                };

                // Clustering simple usando K-means
                const clusterSnapshots = (snapshots, k = 3) => {
                    if (snapshots.length < k) return snapshots.map((s, i) => ({ ...s, cluster: 0 }));

                    // Extraer vectores de caracter√≠sticas
                    const vectors = snapshots.map(s => {
                        const v = [];
                        METRICS_CONFIG.forEach(m => {
                            if (s.normalizedMetrics?.[m.key]) {
                                v.push(s.normalizedMetrics[m.key].netZ || 0);
                                v.push(s.normalizedMetrics[m.key].momZ || 0);
                            } else {
                                v.push(0, 0);
                            }
                        });
                        return v;
                    });

                    // Inicializar centroides aleatorios
                    const centroids = [];
                    const usedIndices = new Set();
                    for (let i = 0; i < k; i++) {
                        let idx;
                        do { idx = Math.floor(Math.random() * vectors.length); }
                        while (usedIndices.has(idx));
                        usedIndices.add(idx);
                        centroids.push([...vectors[idx]]);
                    }

                    // Iterar K-means
                    const maxIter = 50;
                    let assignments = new Array(vectors.length).fill(0);

                    for (let iter = 0; iter < maxIter; iter++) {
                        // Asignar a centroide m√°s cercano
                        const newAssignments = vectors.map(v => {
                            let minDist = Infinity, minIdx = 0;
                            centroids.forEach((c, ci) => {
                                const dist = Math.sqrt(v.reduce((sum, val, i) => sum + Math.pow(val - c[i], 2), 0));
                                if (dist < minDist) { minDist = dist; minIdx = ci; }
                            });
                            return minIdx;
                        });

                        // Verificar convergencia
                        if (JSON.stringify(assignments) === JSON.stringify(newAssignments)) break;
                        assignments = newAssignments;

                        // Actualizar centroides
                        for (let ci = 0; ci < k; ci++) {
                            const clusterVectors = vectors.filter((_, i) => assignments[i] === ci);
                            if (clusterVectors.length > 0) {
                                centroids[ci] = centroids[ci].map((_, dim) =>
                                    clusterVectors.reduce((sum, v) => sum + v[dim], 0) / clusterVectors.length
                                );
                            }
                        }
                    }

                    return snapshots.map((s, i) => ({ ...s, cluster: assignments[i] }));
                };

                // DETECTAR REVERSIONES - Cambios de tendencia
                const detectReversals = (prices, snapshots, windowSize = 10) => {
                    const reversals = [];

                    for (let i = windowSize; i < prices.length - 1; i++) {
                        const prevWindow = prices.slice(i - windowSize, i);
                        const nextWindow = prices.slice(i, Math.min(i + windowSize, prices.length));

                        // Calcular pendientes
                        const prevSlope = (prevWindow[prevWindow.length - 1] - prevWindow[0]) / prevWindow.length;
                        const nextSlope = (nextWindow[nextWindow.length - 1] - nextWindow[0]) / nextWindow.length;

                        // Normalizar por precio
                        const avgPrice = (prevWindow[prevWindow.length - 1] + nextWindow[0]) / 2;
                        const prevSlopeNorm = (prevSlope / avgPrice) * 100;
                        const nextSlopeNorm = (nextSlope / avgPrice) * 100;

                        // Detectar reversi√≥n si cambia direcci√≥n significativamente
                        const slopeChange = nextSlopeNorm - prevSlopeNorm;

                        // Reversi√≥n alcista: bajaba y ahora sube (MENOS ESTRICTO)
                        if (prevSlopeNorm < -0.01 && nextSlopeNorm > 0.01 && slopeChange > 0.03) {
                            reversals.push({
                                index: i,
                                type: 'REVERSAL_BULLISH',
                                price: prices[i],
                                prevSlope: prevSlopeNorm,
                                nextSlope: nextSlopeNorm,
                                strength: Math.abs(slopeChange)
                            });
                        }
                        // Reversi√≥n bajista: sub√≠a y ahora baja (MENOS ESTRICTO)
                        else if (prevSlopeNorm > 0.01 && nextSlopeNorm < -0.01 && slopeChange < -0.03) {
                            reversals.push({
                                index: i,
                                type: 'REVERSAL_BEARISH',
                                price: prices[i],
                                prevSlope: prevSlopeNorm,
                                nextSlope: nextSlopeNorm,
                                strength: Math.abs(slopeChange)
                            });
                        }
                    }

                    return reversals;
                };

                // DETECTAR EVENTOS INUSUALES - An√°lisis inteligente de TODAS las m√©tricas
                const detectUnusualEvents = (snapshots) => {
                    // DESACTIVADO - Retorna array vac√≠o (sin eventos UNUSUAL)
                    return [];

                    /* C√ìDIGO ORIGINAL DESACTIVADO
                    const unusualEvents = [];
                    
                    // Calcular estad√≠sticas de todas las m√©tricas para detectar valores extremos
                    const metricStats = {};
                    METRICS_CONFIG.forEach(metric => {
                        const allValues = snapshots.map(s => s.metrics[metric.key]?.net || 0);
                        const allMomentums = snapshots.map(s => s.metrics[metric.key]?.momentum || 0);
                        
                        const mean = allValues.reduce((a, b) => a + b, 0) / allValues.length;
                        const stdDev = Math.sqrt(allValues.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / allValues.length) || 1;
                        
                        const momMean = allMomentums.reduce((a, b) => a + b, 0) / allMomentums.length;
                        const momStdDev = Math.sqrt(allMomentums.reduce((a, b) => a + Math.pow(b - momMean, 2), 0) / allMomentums.length) || 1;
                        
                        metricStats[metric.key] = { 
                            mean, stdDev, momMean, momStdDev, 
                            label: metric.label,
                            max: Math.max(...allValues),
                            min: Math.min(...allValues)
                        };
                    });
                    */

                    snapshots.forEach((snapshot, idx) => {
                        if (idx < 5) return; // Necesitamos historial

                        const m = snapshot.metrics;
                        const events = [];

                        // AN√ÅLISIS AUTOM√ÅTICO: Detectar valores extremos (>2 desviaciones est√°ndar)
                        METRICS_CONFIG.forEach(metric => {
                            const metricData = m[metric.key];
                            if (!metricData) return;

                            const stats = metricStats[metric.key];
                            const zScore = (metricData.net - stats.mean) / stats.stdDev;
                            const momZScore = (metricData.momentum - stats.momMean) / stats.momStdDev;

                            // Valor extremadamente alto (>3.5œÉ) - ULTRA EXTREMO
                            if (zScore > 3.5) {
                                events.push({
                                    type: `UNUSUAL_${metric.key.toUpperCase()}_SPIKE`,
                                    description: `${metric.label} valor extremo alto: ${metricData.net.toFixed(1)} (${zScore.toFixed(1)}œÉ)`,
                                    strength: Math.abs(zScore),
                                    metric: metric.key,
                                    metricLabel: metric.label,
                                    value: metricData.net,
                                    zScore: zScore,
                                    hypothesis: `${metric.label} alcanz√≥ nivel extremo (${zScore.toFixed(1)}œÉ sobre la media), puede indicar actividad institucional inusual`
                                });
                            }

                            // Valor extremadamente bajo (<-3.5œÉ) - ULTRA EXTREMO
                            if (zScore < -3.5) {
                                events.push({
                                    type: `UNUSUAL_${metric.key.toUpperCase()}_DROP`,
                                    description: `${metric.label} valor extremo bajo: ${metricData.net.toFixed(1)} (${zScore.toFixed(1)}œÉ)`,
                                    strength: Math.abs(zScore),
                                    metric: metric.key,
                                    metricLabel: metric.label,
                                    value: metricData.net,
                                    zScore: zScore,
                                    hypothesis: `${metric.label} cay√≥ a nivel extremo (${Math.abs(zScore).toFixed(1)}œÉ bajo la media), puede se√±alar salida de posiciones`
                                });
                            }

                            // Cambio de momentum extremo (>3.5œÉ) - ULTRA EXTREMO
                            if (Math.abs(momZScore) > 3.5) {
                                const direction = momZScore > 0 ? 'aceleraci√≥n' : 'desaceleraci√≥n';
                                events.push({
                                    type: `UNUSUAL_${metric.key.toUpperCase()}_MOMENTUM_SHIFT`,
                                    description: `${metric.label} ${direction} extrema: ${metricData.momentum.toFixed(1)}% (${momZScore.toFixed(1)}œÉ)`,
                                    strength: Math.abs(momZScore),
                                    metric: metric.key,
                                    metricLabel: metric.label,
                                    value: metricData.momentum,
                                    zScore: momZScore,
                                    hypothesis: `${metric.label} muestra ${direction} inusual, puede preceder cambio de direcci√≥n en precio`
                                });
                            }
                        });

                        // DETECTAR COMBINACIONES INUSUALES (correlaciones inesperadas)
                        // Buscar m√©tricas que se muevan juntas de forma extrema
                        const extremeMetrics = [];
                        METRICS_CONFIG.forEach(metric => {
                            const metricData = m[metric.key];
                            if (!metricData) return;
                            const stats = metricStats[metric.key];
                            const zScore = Math.abs((metricData.net - stats.mean) / stats.stdDev);
                            if (zScore > 3) {
                                extremeMetrics.push({
                                    key: metric.key,
                                    label: metric.label,
                                    value: metricData.net,
                                    zScore: zScore,
                                    direction: Math.sign(metricData.net)
                                });
                            }
                        });

                        // Si hay 2+ m√©tricas extremas simult√°neamente
                        if (extremeMetrics.length >= 2) {
                            // Verificar si van en la misma direcci√≥n (alineadas) o opuestas (divergentes)
                            const directions = extremeMetrics.map(em => em.direction);
                            const allSame = directions.every(d => d === directions[0]);
                            const allDifferent = new Set(directions).size === directions.length;

                            if (allSame) {
                                const metricsList = extremeMetrics.map(em => em.label).join(' + ');
                                const avgZ = extremeMetrics.reduce((sum, em) => sum + em.zScore, 0) / extremeMetrics.length;
                                events.push({
                                    type: 'UNUSUAL_MULTI_METRIC_ALIGNMENT',
                                    description: `Alineaci√≥n extrema: ${metricsList}`,
                                    strength: avgZ,
                                    metrics: extremeMetrics,
                                    hypothesis: `${extremeMetrics.length} m√©tricas (${metricsList}) se mueven juntas de forma extrema, indica presi√≥n direccional coordinada`
                                });
                            } else if (allDifferent && extremeMetrics.length === 2) {
                                const metricsList = extremeMetrics.map(em => em.label).join(' vs ');
                                events.push({
                                    type: 'UNUSUAL_METRIC_DIVERGENCE',
                                    description: `Divergencia extrema: ${metricsList}`,
                                    strength: (extremeMetrics[0].zScore + extremeMetrics[1].zScore) / 2,
                                    metrics: extremeMetrics,
                                    hypothesis: `${metricsList} en direcciones opuestas extremas, puede se√±alar batalla institucional o hedge complejo`
                                });
                            }
                        }

                        // Agregar eventos encontrados
                        events.forEach(event => {
                            unusualEvents.push({
                                ...event,
                                index: snapshot.index,
                                timestamp: snapshot.index
                            });
                        });
                    });

                    return unusualEvents;
                };

                // AN√ÅLISIS CONSOLIDADO DE IMPULSOS Y REVERSIONES
                const analyzeImpulsesAndReversals = (events, snapshots, prices) => {
                    const analysis = {
                        patterns: {
                            impulseUpPatterns: [],
                            impulseDownPatterns: [],
                            reversalBullishPatterns: [],
                            reversalBearishPatterns: []
                        }
                    };

                    console.log('[Expert Analysis] Starting with:', events.length, 'events,', snapshots.length, 'snapshots');

                    // Filtrar eventos de inter√©s
                    const impulsesUp = events.filter(e => e.type === 'IMPULSE_UP');
                    const impulsesDown = events.filter(e => e.type === 'IMPULSE_DOWN');
                    const reversalsBullish = events.filter(e => e.type === 'REVERSAL_BULLISH');
                    const reversalsBearish = events.filter(e => e.type === 'REVERSAL_BEARISH');

                    console.log('[Expert Analysis] Found:', impulsesUp.length, 'up,', impulsesDown.length, 'down,', reversalsBullish.length, 'bull reversals,', reversalsBearish.length, 'bear reversals');

                    // AN√ÅLISIS PROFUNDO: IMPULSOS ALCISTAS
                    impulsesUp.forEach(impulse => {
                        const idx = impulse.index;
                        const snapshot = snapshots.find(s => s.index === idx);
                        const prevSnapshot = snapshots.find(s => s.index === idx - 1);
                        const prev2Snapshot = snapshots.find(s => s.index === idx - 2);
                        const prev3Snapshot = snapshots.find(s => s.index === idx - 3);

                        if (!snapshot || !prevSnapshot) return;

                        const pattern = {
                            index: idx,
                            magnitude: impulse.magnitude || 0,
                            price: impulse.price,

                            // FASE 1: Acumulaci√≥n previa (3 filas antes)
                            preAccumulation: {},

                            // FASE 2: Trigger inmediato (1 fila antes)
                            immediateTrigger: {},

                            // FASE 3: Momento del impulso
                            impulseMetrics: {},

                            // CONCLUSI√ìN EXPERTA
                            expertAnalysis: ''
                        };

                        // Analizar acumulaci√≥n previa (detectar setup)
                        if (prev3Snapshot) {
                            METRICS_CONFIG.forEach(metric => {
                                const m3 = prev3Snapshot.metrics[metric.key];
                                const m2 = prev2Snapshot?.metrics[metric.key];
                                const m1 = prevSnapshot.metrics[metric.key];
                                const m0 = snapshot.metrics[metric.key];

                                if (!m3 || !m2 || !m1 || !m0) return;

                                // Detectar acumulaci√≥n (valores creciendo consistentemente)
                                const trend = [m3.net, m2.net, m1.net, m0.net];
                                const increasing = trend[0] < trend[1] && trend[1] < trend[2] && trend[2] < trend[3];
                                const accelerating = (trend[3] - trend[2]) > (trend[1] - trend[0]);

                                if (increasing || accelerating) {
                                    pattern.preAccumulation[metric.key] = {
                                        label: metric.label,
                                        trend: trend.map(t => t.toFixed(1)),
                                        increasing: increasing,
                                        accelerating: accelerating
                                    };
                                }
                            });
                        }

                        // Analizar trigger inmediato (1 fila antes)
                        METRICS_CONFIG.forEach(metric => {
                            const prev = prevSnapshot.metrics[metric.key];
                            const curr = snapshot.metrics[metric.key];

                            if (!prev || !curr) return;

                            const change = curr.net - prev.net;
                            const changePercent = prev.net !== 0 ? (change / Math.abs(prev.net)) * 100 : 0;
                            const momentumSpike = curr.momentum > 30; // Momentum > 30%
                            const volumeSpike = Math.abs(change) > 50; // Cambio > 50

                            if (momentumSpike || volumeSpike || Math.abs(changePercent) > 20) {
                                pattern.immediateTrigger[metric.key] = {
                                    label: metric.label,
                                    from: prev.net.toFixed(1),
                                    to: curr.net.toFixed(1),
                                    change: change.toFixed(1),
                                    changePercent: changePercent.toFixed(1),
                                    momentum: curr.momentum.toFixed(1),
                                    momentumSpike: momentumSpike,
                                    volumeSpike: volumeSpike
                                };
                            }
                        });

                        // Analizar m√©tricas en el momento del impulso
                        METRICS_CONFIG.forEach(metric => {
                            const curr = snapshot.metrics[metric.key];
                            if (!curr) return;

                            // Solo m√©tricas extremas o muy activas
                            if (Math.abs(curr.net) > 50 || Math.abs(curr.momentum) > 20) {
                                pattern.impulseMetrics[metric.key] = {
                                    label: metric.label,
                                    value: curr.net.toFixed(1),
                                    momentum: curr.momentum.toFixed(1),
                                    acceleration: curr.acceleration?.toFixed(1) || '0'
                                };
                            }
                        });

                        // AN√ÅLISIS CLARO Y CONSOLIDADO
                        const triggers = Object.keys(pattern.immediateTrigger);
                        const accumulation = Object.keys(pattern.preAccumulation);

                        let expertText = `Movimiento alcista de ${pattern.magnitude.toFixed(2)}%`;

                        if (triggers.length > 0) {
                            const mainTrigger = pattern.immediateTrigger[triggers[0]];
                            expertText += `. Causado principalmente por ${mainTrigger.label} que cambi√≥ de ${mainTrigger.from} a ${mainTrigger.to}`;
                        }

                        if (accumulation.length >= 2) {
                            expertText += `. Se detect√≥ preparaci√≥n previa en ${accumulation.length} indicadores`;
                        }

                        pattern.expertAnalysis = expertText;
                        pattern.hasData = triggers.length > 0 || accumulation.length > 0;

                        if (pattern.hasData) {
                            analysis.patterns.impulseUpPatterns.push(pattern);
                        }
                    });

                    // AN√ÅLISIS PROFUNDO: IMPULSOS BAJISTAS
                    impulsesDown.forEach(impulse => {
                        const idx = impulse.index;
                        const snapshot = snapshots.find(s => s.index === idx);
                        const prevSnapshot = snapshots.find(s => s.index === idx - 1);
                        const prev2Snapshot = snapshots.find(s => s.index === idx - 2);
                        const prev3Snapshot = snapshots.find(s => s.index === idx - 3);

                        if (!snapshot || !prevSnapshot) return;

                        const pattern = {
                            index: idx,
                            magnitude: impulse.magnitude || 0,
                            price: impulse.price,
                            preAccumulation: {},
                            immediateTrigger: {},
                            impulseMetrics: {},
                            expertAnalysis: ''
                        };

                        // Acumulaci√≥n bajista (detectar distribuci√≥n)
                        if (prev3Snapshot) {
                            METRICS_CONFIG.forEach(metric => {
                                const m3 = prev3Snapshot.metrics[metric.key];
                                const m2 = prev2Snapshot?.metrics[metric.key];
                                const m1 = prevSnapshot.metrics[metric.key];
                                const m0 = snapshot.metrics[metric.key];

                                if (!m3 || !m2 || !m1 || !m0) return;

                                const trend = [m3.net, m2.net, m1.net, m0.net];
                                const decreasing = trend[0] > trend[1] && trend[1] > trend[2] && trend[2] > trend[3];
                                const accelerating = Math.abs(trend[3] - trend[2]) > Math.abs(trend[1] - trend[0]);

                                if (decreasing || accelerating) {
                                    pattern.preAccumulation[metric.key] = {
                                        label: metric.label,
                                        trend: trend.map(t => t.toFixed(1)),
                                        decreasing: decreasing,
                                        accelerating: accelerating
                                    };
                                }
                            });
                        }

                        // Trigger inmediato
                        METRICS_CONFIG.forEach(metric => {
                            const prev = prevSnapshot.metrics[metric.key];
                            const curr = snapshot.metrics[metric.key];

                            if (!prev || !curr) return;

                            const change = curr.net - prev.net;
                            const changePercent = prev.net !== 0 ? (change / Math.abs(prev.net)) * 100 : 0;
                            const momentumSpike = curr.momentum < -30;
                            const volumeSpike = Math.abs(change) > 50;

                            if (momentumSpike || volumeSpike || Math.abs(changePercent) > 20) {
                                pattern.immediateTrigger[metric.key] = {
                                    label: metric.label,
                                    from: prev.net.toFixed(1),
                                    to: curr.net.toFixed(1),
                                    change: change.toFixed(1),
                                    changePercent: changePercent.toFixed(1),
                                    momentum: curr.momentum.toFixed(1),
                                    momentumSpike: momentumSpike,
                                    volumeSpike: volumeSpike
                                };
                            }
                        });

                        // M√©tricas en el momento
                        METRICS_CONFIG.forEach(metric => {
                            const curr = snapshot.metrics[metric.key];
                            if (!curr) return;

                            if (Math.abs(curr.net) > 50 || Math.abs(curr.momentum) > 20) {
                                pattern.impulseMetrics[metric.key] = {
                                    label: metric.label,
                                    value: curr.net.toFixed(1),
                                    momentum: curr.momentum.toFixed(1),
                                    acceleration: curr.acceleration?.toFixed(1) || '0'
                                };
                            }
                        });

                        // An√°lisis consolidado
                        const triggers = Object.keys(pattern.immediateTrigger);
                        const accumulation = Object.keys(pattern.preAccumulation);

                        let expertText = `Ca√≠da de ${Math.abs(pattern.magnitude).toFixed(2)}%`;

                        if (triggers.length > 0) {
                            const mainTrigger = pattern.immediateTrigger[triggers[0]];
                            expertText += `. Causado por ${mainTrigger.label} que cay√≥ de ${mainTrigger.from} a ${mainTrigger.to}`;
                        }

                        if (accumulation.length >= 2) {
                            expertText += `. Distribuci√≥n previa detectada en ${accumulation.length} indicadores`;
                        }

                        pattern.expertAnalysis = expertText;
                        pattern.hasData = triggers.length > 0 || accumulation.length > 0;

                        if (pattern.hasData) {
                            analysis.patterns.impulseDownPatterns.push(pattern);
                        }
                    });

                    // AN√ÅLISIS PROFUNDO: REVERSIONES ALCISTAS
                    reversalsBullish.forEach(reversal => {
                        const idx = reversal.index;
                        const snapshot = snapshots.find(s => s.index === idx);
                        const prevSnapshot = snapshots.find(s => s.index === idx - 1);

                        if (!snapshot || !prevSnapshot) return;

                        const pattern = {
                            index: idx,
                            price: reversal.price,
                            prevSlope: reversal.prevSlope?.toFixed(3),
                            nextSlope: reversal.nextSlope?.toFixed(3),
                            strength: reversal.strength?.toFixed(2),
                            exhaustionSignals: {},
                            reversalTriggers: {},
                            expertAnalysis: ''
                        };

                        // Detectar se√±ales de agotamiento (m√©tricas que estaban bajando y se detienen)
                        METRICS_CONFIG.forEach(metric => {
                            const prev = prevSnapshot.metrics[metric.key];
                            const curr = snapshot.metrics[metric.key];

                            if (!prev || !curr) return;

                            // Estaba bajando fuerte y ahora se frena o cambia
                            if (prev.momentum < -20 && curr.momentum > prev.momentum) {
                                pattern.exhaustionSignals[metric.key] = {
                                    label: metric.label,
                                    prevMomentum: prev.momentum.toFixed(1),
                                    currMomentum: curr.momentum.toFixed(1),
                                    change: (curr.momentum - prev.momentum).toFixed(1)
                                };
                            }
                        });

                        // Detectar triggers de reversi√≥n (m√©tricas que cambian dr√°sticamente)
                        METRICS_CONFIG.forEach(metric => {
                            const prev = prevSnapshot.metrics[metric.key];
                            const curr = snapshot.metrics[metric.key];

                            if (!prev || !curr) return;

                            const change = curr.net - prev.net;
                            const wasNegative = prev.net < 0;
                            const nowPositive = curr.net > 0;
                            const bigJump = change > 30;

                            if ((wasNegative && nowPositive) || bigJump) {
                                pattern.reversalTriggers[metric.key] = {
                                    label: metric.label,
                                    from: prev.net.toFixed(1),
                                    to: curr.net.toFixed(1),
                                    change: change.toFixed(1),
                                    crossedZero: wasNegative && nowPositive
                                };
                            }
                        });

                        // An√°lisis de reversi√≥n
                        const exhaustion = Object.keys(pattern.exhaustionSignals);
                        const triggers = Object.keys(pattern.reversalTriggers);

                        let expertText = `Cambio de tendencia bajista a alcista`;

                        if (triggers.length > 0) {
                            const mainTrigger = pattern.reversalTriggers[triggers[0]];
                            expertText += `. Iniciado por ${mainTrigger.label} cambiando de ${mainTrigger.from} a ${mainTrigger.to}`;
                        }

                        if (exhaustion.length > 0) {
                            expertText += `. Se√±ales de agotamiento en ${exhaustion.length} indicadores`;
                        }

                        pattern.expertAnalysis = expertText;
                        pattern.hasData = triggers.length > 0 || exhaustion.length > 0;

                        if (pattern.hasData) {
                            analysis.patterns.reversalBullishPatterns.push(pattern);
                        }
                    });

                    // AN√ÅLISIS PROFUNDO: REVERSIONES BAJISTAS
                    reversalsBearish.forEach(reversal => {
                        const idx = reversal.index;
                        const snapshot = snapshots.find(s => s.index === idx);
                        const prevSnapshot = snapshots.find(s => s.index === idx - 1);

                        if (!snapshot || !prevSnapshot) return;

                        const pattern = {
                            index: idx,
                            price: reversal.price,
                            prevSlope: reversal.prevSlope?.toFixed(3),
                            nextSlope: reversal.nextSlope?.toFixed(3),
                            strength: reversal.strength?.toFixed(2),
                            exhaustionSignals: {},
                            reversalTriggers: {},
                            precededByEvents: [],
                            expertAnalysis: ''
                        };

                        // Agotamiento alcista
                        METRICS_CONFIG.forEach(metric => {
                            const prev = prevSnapshot.metrics[metric.key];
                            const curr = snapshot.metrics[metric.key];

                            if (!prev || !curr) return;

                            if (prev.momentum > 20 && curr.momentum < prev.momentum) {
                                pattern.exhaustionSignals[metric.key] = {
                                    label: metric.label,
                                    prevMomentum: prev.momentum.toFixed(1),
                                    currMomentum: curr.momentum.toFixed(1),
                                    change: (curr.momentum - prev.momentum).toFixed(1)
                                };
                            }
                        });

                        // Triggers de reversi√≥n bajista
                        METRICS_CONFIG.forEach(metric => {
                            const prev = prevSnapshot.metrics[metric.key];
                            const curr = snapshot.metrics[metric.key];

                            if (!prev || !curr) return;

                            const change = curr.net - prev.net;
                            const wasPositive = prev.net > 0;
                            const nowNegative = curr.net < 0;
                            const bigDrop = change < -30;

                            if ((wasPositive && nowNegative) || bigDrop) {
                                pattern.reversalTriggers[metric.key] = {
                                    label: metric.label,
                                    from: prev.net.toFixed(1),
                                    to: curr.net.toFixed(1),
                                    change: change.toFixed(1),
                                    crossedZero: wasPositive && nowNegative
                                };
                            }
                        });

                        // Eventos previos
                        for (let lookback = 1; lookback <= 5; lookback++) {
                            const priorEvents = events.filter(e => e.index === idx - lookback && e.type !== 'REVERSAL_BEARISH');
                            priorEvents.forEach(pe => {
                                pattern.precededByEvents.push({
                                    type: pe.type,
                                    label: pe.type.replace(/_/g, ' '),
                                    distance: lookback
                                });
                            });
                        }

                        // An√°lisis de reversi√≥n
                        const exhaustion = Object.keys(pattern.exhaustionSignals);
                        const triggers = Object.keys(pattern.reversalTriggers);

                        let expertText = `Cambio de tendencia alcista a bajista`;

                        if (triggers.length > 0) {
                            const mainTrigger = pattern.reversalTriggers[triggers[0]];
                            expertText += `. Iniciado por ${mainTrigger.label} cayendo de ${mainTrigger.from} a ${mainTrigger.to}`;
                        }

                        if (exhaustion.length > 0) {
                            expertText += `. Agotamiento alcista en ${exhaustion.length} indicadores`;
                        }

                        pattern.expertAnalysis = expertText;
                        pattern.hasData = triggers.length > 0 || exhaustion.length > 0;

                        if (pattern.hasData) {
                            analysis.patterns.reversalBearishPatterns.push(pattern);
                        }
                    });

                    console.log('[Expert Analysis] Completed. Patterns:',
                        analysis.patterns.impulseUpPatterns.length, 'impulse up,',
                        analysis.patterns.impulseDownPatterns.length, 'impulse down,',
                        analysis.patterns.reversalBullishPatterns.length, 'reversal bull,',
                        analysis.patterns.reversalBearishPatterns.length, 'reversal bear');

                    return analysis;
                };
                const analyzeCausality = (events, snapshots) => {
                    const causality = {};
                    const eventTypes = [...new Set(events.map(e => e.type))];

                    eventTypes.forEach(eventType => {
                        const eventIndices = events.filter(e => e.type === eventType).map(e => e.index);
                        if (eventIndices.length < 1) return; // Mostrar desde 1 ocurrencia

                        causality[eventType] = {
                            totalOccurrences: eventIndices.length,
                            triggers: [],
                            metricChanges: [], // Cambios espec√≠ficos como "cay√≥ de 60 a 50"
                            precededBy: []     // NUEVO: Qu√© eventos ocurrieron ANTES
                        };

                        // Para cada m√©trica, analizar cu√°ntas veces estaba activa ANTES del evento
                        METRICS_CONFIG.forEach(metric => {
                            let activeCount = 0;
                            let strongIncreaseCount = 0;
                            let strongDecreaseCount = 0;
                            const changes = []; // Almacenar cambios espec√≠ficos

                            eventIndices.forEach(idx => {
                                const snapshot = snapshots.find(s => s.index === idx);
                                const prevSnapshot = snapshots.find(s => s.index === idx - 1);
                                if (!snapshot) return;

                                const metricData = snapshot.metrics[metric.key];
                                if (!metricData) return;

                                // Considerar "activa" si el valor neto es significativo
                                if (Math.abs(metricData.net) > 0) activeCount++;

                                // Momentum positivo fuerte = aumento (REDUCIDO 20‚Üí10 para detectar m√°s)
                                if (metricData.momentum > 10) strongIncreaseCount++;
                                // Momentum negativo fuerte = disminuci√≥n (REDUCIDO -20‚Üí-10)
                                if (metricData.momentum < -10) strongDecreaseCount++;

                                // NUEVO: Capturar cambios espec√≠ficos
                                if (prevSnapshot?.metrics[metric.key]) {
                                    const prevVal = prevSnapshot.metrics[metric.key].net;
                                    const currVal = metricData.net;
                                    const change = currVal - prevVal;
                                    const changePercent = prevVal !== 0 ? ((change / Math.abs(prevVal)) * 100) : 0;

                                    if (Math.abs(changePercent) > 10) { // Cambios >10%
                                        changes.push({
                                            from: prevVal.toFixed(1),
                                            to: currVal.toFixed(1),
                                            change: change.toFixed(1),
                                            changePercent: changePercent.toFixed(1)
                                        });
                                    }
                                }
                            });

                            const activePercentage = (activeCount / eventIndices.length) * 100;
                            const increasePercentage = (strongIncreaseCount / eventIndices.length) * 100;
                            const decreasePercentage = (strongDecreaseCount / eventIndices.length) * 100;

                            // Solo agregar si hay correlaci√≥n significativa (>25% = M√ÅS SENSIBLE)
                            if (activePercentage > 25 || increasePercentage > 25 || decreasePercentage > 25) {
                                const trigger = {
                                    metric: metric.label,
                                    key: metric.key,
                                    activeIn: Math.round(activePercentage),
                                    increasingIn: Math.round(increasePercentage),
                                    decreasingIn: Math.round(decreasePercentage),
                                    dominantPattern: increasePercentage > decreasePercentage ? 'INCREASING' : 'DECREASING'
                                };

                                // NUEVO: Agregar ejemplo de cambio t√≠pico
                                if (changes.length > 0) {
                                    // Calcular cambio promedio
                                    const avgChange = changes.reduce((sum, c) => sum + parseFloat(c.change), 0) / changes.length;
                                    const avgFrom = changes.reduce((sum, c) => sum + parseFloat(c.from), 0) / changes.length;
                                    const avgTo = changes.reduce((sum, c) => sum + parseFloat(c.to), 0) / changes.length;

                                    trigger.typicalChange = {
                                        from: avgFrom.toFixed(1),
                                        to: avgTo.toFixed(1),
                                        change: avgChange.toFixed(1),
                                        direction: avgChange > 0 ? 'aument√≥' : 'disminuy√≥'
                                    };
                                }

                                causality[eventType].triggers.push(trigger);
                            }
                        });

                        // NUEVO: Analizar qu√© EVENTOS ocurrieron antes (ventana de 1-5 √≠ndices previos)
                        const priorEventCounts = {};
                        eventIndices.forEach(idx => {
                            // Buscar eventos en las 5 filas previas
                            for (let lookback = 1; lookback <= 5; lookback++) {
                                const priorEvents = events.filter(e => e.index === idx - lookback && e.type !== eventType);
                                priorEvents.forEach(pe => {
                                    if (!priorEventCounts[pe.type]) {
                                        priorEventCounts[pe.type] = 0;
                                    }
                                    priorEventCounts[pe.type]++;
                                });
                            }
                        });

                        // Calcular porcentajes de eventos precedentes
                        Object.keys(priorEventCounts).forEach(priorType => {
                            const count = priorEventCounts[priorType];
                            const percentage = Math.round((count / eventIndices.length) * 100);
                            if (percentage >= 30) { // Si >30% de las veces este evento precedi√≥
                                causality[eventType].precededBy.push({
                                    eventType: priorType,
                                    eventLabel: priorType.replace(/_/g, ' '),
                                    percentage: percentage,
                                    count: count,
                                    hypothesis: `${percentage}% de ${eventType.replace(/_/g, ' ')} fueron precedidos por ${priorType.replace(/_/g, ' ')}`
                                });
                            }
                        });

                        // Ordenar precedentes por porcentaje
                        causality[eventType].precededBy.sort((a, b) => b.percentage - a.percentage);

                        // Ordenar por relevancia (mayor porcentaje primero)
                        causality[eventType].triggers.sort((a, b) => {
                            const maxA = Math.max(a.increasingIn, a.decreasingIn);
                            const maxB = Math.max(b.increasingIn, b.decreasingIn);
                            return maxB - maxA;
                        });
                    });

                    return causality;
                };

                // Calcular correlaci√≥n de m√©tricas con eventos
                const calculateCorrelations = (events, snapshots) => {
                    const correlations = {};

                    // Agrupar snapshots por tipo de evento
                    const eventTypes = [...new Set(events.map(e => e.type))];

                    eventTypes.forEach(eventType => {
                        const eventSnapshots = snapshots.filter(s =>
                            events.some(e => e.index === s.index && e.type === eventType)
                        );

                        if (eventSnapshots.length < 3) return;

                        correlations[eventType] = { count: eventSnapshots.length, metrics: {} };

                        METRICS_CONFIG.forEach(metric => {
                            const netValues = eventSnapshots.map(s => s.metrics[metric.key]?.net || 0);
                            const momValues = eventSnapshots.map(s => s.metrics[metric.key]?.momentum || 0);

                            const avgNet = netValues.reduce((a, b) => a + b, 0) / netValues.length;
                            const avgMom = momValues.reduce((a, b) => a + b, 0) / momValues.length;

                            // Calcular consistencia (qu√© tan consistente es el signo)
                            const positiveNet = netValues.filter(v => v > 0).length / netValues.length;
                            const positiveMom = momValues.filter(v => v > 0).length / momValues.length;
                            const consistency = Math.max(positiveNet, 1 - positiveNet);

                            correlations[eventType].metrics[metric.key] = {
                                avgNet,
                                avgMomentum: avgMom,
                                consistency,
                                bullishBias: positiveNet,
                                significance: consistency > 0.7 ? 'HIGH' : consistency > 0.55 ? 'MEDIUM' : 'LOW',
                                label: metric.label
                            };
                        });
                    });

                    return correlations;
                };

                // Funci√≥n principal de an√°lisis - ULTRA-R√ÅPIDO MODO INCREMENTAL
                const analyzePatterns = (rows, priceHeader = 'price', timestampHeader = 'timestamp') => {
                    console.log('[MLPatternEngine] analyzePatterns called with:', {
                        rowCount: rows?.length,
                        priceHeader,
                        timestampHeader,
                        sampleRowKeys: rows?.[0] ? Object.keys(rows[0]) : []
                    });

                    // SOLO REQUIERE 2 FILAS para empezar an√°lisis
                    if (!rows || rows.length < 2) {
                        return { error: 'Waiting for data...', minRequired: 2, current: rows?.length || 0, isWaiting: true };
                    }

                    // Buscar el header de precio de forma flexible
                    const sampleRow = rows[0];
                    let actualPriceHeader = priceHeader;
                    if (sampleRow) {
                        const possiblePriceHeaders = [
                            'Underlying_Price',  // CSV principal
                            'price', 'Price', 'PRICE',
                            'last', 'Last', 'LAST',
                            'close', 'Close', 'CLOSE',
                            'mark', 'Mark',
                            'last_price'  // CSV Python
                        ];
                        for (const header of possiblePriceHeaders) {
                            if (sampleRow[header] !== undefined) {
                                actualPriceHeader = header;
                                console.log('[MLPatternEngine] Found price header:', actualPriceHeader);
                                break;
                            }
                        }
                    }

                    const prices = rows.map(r => parseFloat(r[actualPriceHeader]) || 0).filter(p => p > 0);
                    const timestamps = rows.map(r => r[timestampHeader]);

                    console.log('[MLPatternEngine] Extracted:', {
                        pricesCount: prices.length,
                        samplePrices: prices.slice(0, 5),
                        timestampsCount: timestamps.length
                    });

                    if (prices.length < 2) {
                        return { error: 'Waiting for price data...', minRequired: 2, current: prices.length, isWaiting: true };
                    }

                    // MODO INCREMENTAL: Detecta con lo que tenga disponible
                    const dataLen = prices.length;
                    const hasMinimal = dataLen >= 2;   // 2+ = an√°lisis b√°sico
                    const hasBasic = dataLen >= 5;     // 5+ = impulsos
                    const hasGood = dataLen >= 10;     // 10+ = tendencias
                    const hasExcellent = dataLen >= 15; // 15+ = breakouts

                    // Par√°metros ultra-adaptativos
                    const lookback = Math.max(1, Math.min(3, Math.floor(dataLen / 4)));
                    const trendWindow = Math.max(3, Math.min(10, Math.floor(dataLen / 2)));

                    // Detectar eventos - SIEMPRE intenta con lo que tenga
                    const localExtremes = hasBasic ? detectLocalExtremes(prices, lookback) : [];
                    const impulses = hasBasic ? detectImpulses(prices, timestamps, 0.01, Math.max(1, Math.min(3, dataLen - 1))) : [];
                    const trends = hasGood ? detectTrends(prices, trendWindow, 0.4) : []; // R¬≤ m√≠nimo m√°s bajo
                    const breakouts = hasExcellent ? detectBreakouts(prices, trendWindow, 1.2) : []; // Umbral m√°s bajo

                    // NUEVO: Extraer todos los snapshots primero (necesarios para reversiones y eventos inusuales)
                    let allSnapshots = [];
                    for (let i = 0; i < rows.length; i++) {
                        const snapshot = extractMetricSnapshot(rows, i);
                        if (snapshot) allSnapshots.push(snapshot);
                    }

                    // NUEVO: Detectar REVERSIONES
                    const reversals = hasGood ? detectReversals(prices, allSnapshots) : [];
                    console.log('[MLPatternEngine] Reversals detected:', reversals.length);

                    // NUEVO: Detectar EVENTOS INUSUALES
                    const unusualEvents = hasBasic ? detectUnusualEvents(allSnapshots) : [];
                    console.log('[MLPatternEngine] Unusual events detected:', unusualEvents.length);

                    // Combinar todos los eventos - SOLO REVERSIONES, IMPULSOS Y BREAKOUTS
                    const allEvents = [
                        ...impulses,
                        ...breakouts,
                        ...reversals
                    ];

                    // Extraer snapshots de m√©tricas para cada evento
                    let snapshots = allEvents.map(event => {
                        const snapshot = allSnapshots.find(s => s.index === event.index) || extractMetricSnapshot(rows, event.index);
                        return snapshot ? { ...snapshot, event } : null;
                    }).filter(s => s !== null);

                    // Normalizar snapshots
                    snapshots = normalizeSnapshots(snapshots);

                    // Clustering
                    snapshots = clusterSnapshots(snapshots, 4);

                    // Calcular correlaciones
                    const correlations = calculateCorrelations(allEvents, snapshots);

                    // AN√ÅLISIS CAUSAL: Qu√© provoca cada evento
                    const causality = analyzeCausality(allEvents, snapshots);

                    // Estad√≠sticas de tendencia actual
                    const currentTrend = trends.length > 0 ? trends[trends.length - 1] : null;

                    // Encontrar patrones similares al estado actual
                    const currentSnapshot = extractMetricSnapshot(rows, rows.length - 1);
                    let similarPatterns = [];
                    if (currentSnapshot && snapshots.length > 0) {
                        // Normalizar snapshot actual usando las mismas estad√≠sticas
                        const allWithCurrent = normalizeSnapshots([...snapshots.map(s => ({ index: s.index, metrics: s.metrics })), currentSnapshot]);
                        const normalizedCurrent = allWithCurrent[allWithCurrent.length - 1];

                        // Calcular distancia a cada snapshot hist√≥rico
                        similarPatterns = snapshots.map(s => {
                            let distance = 0;
                            METRICS_CONFIG.forEach(m => {
                                const curr = normalizedCurrent.normalizedMetrics?.[m.key];
                                const hist = s.normalizedMetrics?.[m.key];
                                if (curr && hist) {
                                    distance += Math.pow(curr.netZ - hist.netZ, 2);
                                    distance += Math.pow(curr.momZ - hist.momZ, 2);
                                }
                            });
                            return { ...s, distance: Math.sqrt(distance) };
                        }).sort((a, b) => a.distance - b.distance).slice(0, 5);
                    }

                    // Generar predicci√≥n basada en patrones similares - SOLO REVERSIONES, IMPULSOS, BREAKOUTS
                    let prediction = { signal: 'NEUTRAL', confidence: 0, basedOn: 0 };
                    if (similarPatterns.length >= 3) {
                        const bullishCount = similarPatterns.filter(p =>
                            p.event?.type === 'REVERSAL_BULLISH' ||
                            p.event?.type === EVENT_TYPES.IMPULSE_UP ||
                            p.event?.type === EVENT_TYPES.BREAKOUT_UP
                        ).length;
                        const bearishCount = similarPatterns.filter(p =>
                            p.event?.type === 'REVERSAL_BEARISH' ||
                            p.event?.type === EVENT_TYPES.IMPULSE_DOWN ||
                            p.event?.type === EVENT_TYPES.BREAKOUT_DOWN
                        ).length;

                        const total = bullishCount + bearishCount;
                        if (total > 0) {
                            if (bullishCount > bearishCount) {
                                prediction = { signal: 'BULLISH', confidence: bullishCount / total, basedOn: total };
                            } else if (bearishCount > bullishCount) {
                                prediction = { signal: 'BEARISH', confidence: bearishCount / total, basedOn: total };
                            }
                        }
                    }

                    return {
                        summary: {
                            totalEvents: allEvents.length,
                            impulsesUp: impulses.filter(e => e.type === EVENT_TYPES.IMPULSE_UP).length,
                            impulsesDown: impulses.filter(e => e.type === EVENT_TYPES.IMPULSE_DOWN).length,
                            reversalsBullish: reversals.filter(e => e.type === 'REVERSAL_BULLISH').length,
                            reversalsBearish: reversals.filter(e => e.type === 'REVERSAL_BEARISH').length,
                            breakoutsUp: breakouts.filter(e => e.type === EVENT_TYPES.BREAKOUT_UP).length,
                            breakoutsDown: breakouts.filter(e => e.type === EVENT_TYPES.BREAKOUT_DOWN).length,
                            dataQuality: hasExcellent ? 'excellent' : hasGood ? 'good' : hasBasic ? 'building' : 'minimal',
                            mode: hasExcellent ? 'full' : hasGood ? 'enhanced' : hasBasic ? 'basic' : 'early'
                        },
                        currentState: {
                            trend: currentTrend,
                            snapshot: currentSnapshot,
                            prediction
                        },
                        events: {
                            localExtremes,
                            impulses,
                            breakouts,
                            reversals,          // NUEVO
                            unusualEvents,      // NUEVO
                            trends: trends.slice(-50) // √öltimas 50 lecturas de tendencia
                        },
                        correlations,
                        causality,  // An√°lisis causal mejorado
                        expertAnalysis: analyzeImpulsesAndReversals(allEvents, allSnapshots, prices),  // NUEVO: An√°lisis enfocado
                        similarPatterns,
                        snapshots,
                        rawData: { rows, prices, timestamps }, // INCLUIR datos crudos
                        metricsConfig: METRICS_CONFIG,
                        eventTypes: EVENT_TYPES
                    };

                    console.log('[MLPatternEngine] Analysis completed:', {
                        totalEvents: allEvents.length,
                        correlations: Object.keys(correlations).length,
                        causalityKeys: Object.keys(causality).length
                    });

                    return result;
                };

                // Generar reporte de correlaciones
                const generateCorrelationReport = (analysis) => {
                    if (!analysis || analysis.error) return null;

                    const report = { eventReports: [], topPredictors: [] };

                    // Reporte por tipo de evento
                    Object.entries(analysis.correlations).forEach(([eventType, data]) => {
                        const eventReport = {
                            event: eventType,
                            count: data.count,
                            topMetrics: []
                        };

                        // Ordenar m√©tricas por significancia
                        const sortedMetrics = Object.entries(data.metrics)
                            .map(([key, m]) => ({ key, ...m }))
                            .sort((a, b) => b.consistency - a.consistency);

                        eventReport.topMetrics = sortedMetrics.slice(0, 5).map(m => ({
                            metric: m.label,
                            consistency: (m.consistency * 100).toFixed(1) + '%',
                            bias: m.bullishBias > 0.5 ? 'BULLISH' : 'BEARISH',
                            biasStrength: Math.abs(m.bullishBias - 0.5) * 200,
                            significance: m.significance
                        }));

                        report.eventReports.push(eventReport);
                    });

                    // Mejores predictores globales
                    const allMetricScores = {};
                    Object.values(analysis.correlations).forEach(data => {
                        Object.entries(data.metrics).forEach(([key, m]) => {
                            if (!allMetricScores[key]) allMetricScores[key] = { total: 0, count: 0, label: m.label };
                            allMetricScores[key].total += m.consistency;
                            allMetricScores[key].count++;
                        });
                    });

                    report.topPredictors = Object.entries(allMetricScores)
                        .map(([key, data]) => ({
                            metric: data.label,
                            avgConsistency: data.count > 0 ? (data.total / data.count * 100).toFixed(1) + '%' : 'N/A'
                        }))
                        .sort((a, b) => parseFloat(b.avgConsistency) - parseFloat(a.avgConsistency))
                        .slice(0, 5);

                    return report;
                };

                return {
                    analyzePatterns,
                    generateCorrelationReport,
                    detectLocalExtremes,
                    detectImpulses,
                    detectTrends,
                    detectBreakouts,
                    extractMetricSnapshot,
                    METRICS_CONFIG,
                    EVENT_TYPES
                };
            })();

            return { formatNumber, aggregateData, calcSMA, calculateKAMA, calcEMA, calculateVWAP, calculateRollingSum, calculateMACDDominance, calculateMACDSyncSignals, calculateMACDNet, calculateMACDNetSignals, calculateAllSignals, calculateEvolutionSignals, calculateKeltnerSignals, calculateSignalData, runBacktest, calcImbalance, getMetricsForType, calcER, calculateDominanceIndex, calculateGlobalDominanceSignal, calculateDominanceSignalSeries, runDominanceBacktest, calculateImbalanceSpikesData, calculateSpikesContextSeries, runSpikesContextBacktest, calculateTugOfWarMomentum, calculateBigTrades, formatProfileLabel, getIndicatorSignal, calculateCombinedSignal, getSlotSignal, getIndicatorSignalByAlgorithm, calculateCombinedSignalFromSlots, MLPatternEngine };
        })());
        // --- END: services/signalCalculator.ts ---

        // --- START: services/echartsOptions.ts ---
        services.echartsOptions.getChartOption = (config, dataSource, specialData, volumeProfile, bigTradesData) => {
            const { EVOLUTION_GROUPS, COLORS } = constants;
            const { formatNumber, calcSMA, calculateDominanceIndex, getMetricsForType, calculateMACDDominance, calculateMACDSyncSignals, calculateMACDNet, calculateMACDNetSignals, calcER, calcImbalance, calculateVWAP, formatProfileLabel } = services.signalCalculator;
            const echarts = window.echarts;
            const commonTooltip = {
                trigger: 'axis',
                backgroundColor: 'rgba(20, 20, 20, 0.95)',
                borderColor: 'rgba(74, 74, 74, 0.6)',
                textStyle: { color: '#e8e8e8', fontSize: 11 },
                extraCssText: 'backdrop-filter: blur(8px); border-radius: 6px; box-shadow: 0 4px 16px rgba(0,0,0,0.7);',
                axisPointer: {
                    type: 'cross',
                    crossStyle: { color: '#666' }
                }
            };
            const commonGrid = { left: 50, right: 18, top: 30, bottom: 35 };
            const commonXAxis = { type: 'time', axisLine: { lineStyle: { color: '#333' } }, axisLabel: { color: '#888' }, splitLine: { lineStyle: { color: '#222' } } };
            const commonYAxis = { type: 'value', scale: true, axisLine: { lineStyle: { color: '#333' } }, axisLabel: { color: '#888', formatter: formatNumber }, splitLine: { lineStyle: { color: '#222' } } };

            const getPriceOption = (config, dataSource, volumeProfile, bigTradesData) => {
                const { rows, timestampHeader, priceHeader, headers } = dataSource;
                if (!priceHeader) return {};
                const seriesList = [];
                const legendData = [];

                // Verificar si volumeProfile est√° disponible
                const hasVolumeProfile = volumeProfile && volumeProfile.size > 0;

                if (config.type === 'price-profile') {
                    // Si no hay volumeProfile, mostrar gr√°fico de precio simple (sin bloquear)
                    if (!hasVolumeProfile) {
                        // Continuar con gr√°fico de precio simple en lugar de bloquear
                        const priceData = rows.map(r => [r[timestampHeader], r[priceHeader] || 0]);

                        // Calcular VWAP con m√©trica seleccionada
                        const vwapMetric = config.parameters?.vwapMetric || 'Total_Volume';
                        const vwapValues = calculateVWAP(rows, priceHeader, vwapMetric);
                        const vwapData = rows.map((r, i) => [r[timestampHeader], vwapValues[i]]);
                        // Obtener √∫ltimo VWAP v√°lido para mostrar en la leyenda
                        let latestVwap = null;
                        for (let i = vwapValues.length - 1; i >= 0; i--) {
                            if (vwapValues[i] !== null && !isNaN(vwapValues[i])) { latestVwap = vwapValues[i]; break; }
                        }
                        const vwapLabel = latestVwap !== null ? `VWAP (${latestVwap.toFixed(2)})` : 'VWAP';

                        return {
                            animation: true, animationDuration: 100, backgroundColor: 'transparent',
                            tooltip: commonTooltip,
                            legend: { data: ['Price', vwapLabel], textStyle: { color: '#e8e8e8' }, top: 5 },
                            grid: commonGrid,
                            xAxis: commonXAxis,
                            yAxis: { ...commonYAxis, name: 'Price', min: 'dataMin', max: 'dataMax', boundaryGap: ['2%', '2%'], axisLabel: { ...commonYAxis.axisLabel, formatter: (value) => typeof value === 'number' ? value.toFixed(2) : value } },
                            dataZoom: [{ type: 'inside', start: config.zoomState.start, end: config.zoomState.end, zoomOnMouseWheel: true, moveOnMouseMove: true, filterMode: 'none', rangeMode: ['percent', 'percent'] }],
                            series: [
                                { name: 'Price', type: 'line', data: priceData, showSymbol: false, smooth: false, lineStyle: { width: 2, color: config.parameters.priceColor || '#888888' } },
                                { name: vwapLabel, type: 'line', data: vwapData, showSymbol: false, smooth: true, lineStyle: { width: 2, color: '#ff4444' } }
                            ]
                        };
                    }

                    const profileType = config.parameters.profileType || 'cash';
                    const callColor = config.parameters.callColor || '#4a9eff';
                    const putColor = config.parameters.putColor || '#ff4444';
                    const priceData = rows.map(r => [r[timestampHeader], r[priceHeader] || 0]);

                    // Calcular VWAP con m√©trica seleccionada
                    const vwapMetric = config.parameters?.vwapMetric || 'Total_Volume';
                    const vwapValues = calculateVWAP(rows, priceHeader, vwapMetric);
                    const vwapData = rows.map((r, i) => [r[timestampHeader], vwapValues[i]]);

                    // Insertar Price y VWAP (VWAP usa etiqueta con valor m√°s reciente si est√° disponible)
                    // Calcular etiqueta din√°mica
                    let latestVwap = null;
                    for (let i = vwapValues.length - 1; i >= 0; i--) { if (vwapValues[i] !== null && !isNaN(vwapValues[i])) { latestVwap = vwapValues[i]; break; } }
                    const vwapLabel = latestVwap !== null ? `VWAP (${latestVwap.toFixed(2)})` : 'VWAP';
                    // Reemplazar 'VWAP' en legendData si existe
                    const vwIdx = legendData.indexOf('VWAP'); if (vwIdx >= 0) legendData[vwIdx] = vwapLabel;
                    seriesList.push({ name: 'Price', type: 'line', data: priceData, showSymbol: false, smooth: false, lineStyle: { width: 2, color: config.parameters.priceColor || '#888888' }, z: 10, yAxisIndex: 0 });
                    seriesList.push({ name: vwapLabel, type: 'line', data: vwapData, showSymbol: false, smooth: true, lineStyle: { width: 2, color: '#ff4444' }, z: 9, yAxisIndex: 0 });

                    // Calcular min/max SOLO del PRECIO visible (PRIORIDAD ABSOLUTA)
                    const totalRows = rows.length;
                    const startIdx = Math.floor((config.zoomState.start / 100) * totalRows);
                    const endIdx = Math.ceil((config.zoomState.end / 100) * totalRows);
                    const visibleRows = rows.slice(startIdx, endIdx);
                    const visiblePrices = visibleRows.map(r => r[priceHeader] || 0);
                    // SOLO precio para la escala del eje Y principal
                    const priceMin = Math.min(...visiblePrices);
                    const priceMax = Math.max(...visiblePrices);
                    const pricePadding = (priceMax - priceMin) * 0.02; // 2% padding

                    // yAxis[1]: solo para decoraciones (S/R, Profile, BigTrades)
                    const decorationMin = priceMin - (priceMax - priceMin) * 0.1;
                    const decorationMax = priceMax + (priceMax - priceMin) * 0.1;

                    const allPrices = rows.map(r => r[priceHeader] || 0);
                    const minPrice = Math.min(...allPrices);
                    const maxPrice = Math.max(...allPrices);
                    const binCount = 75;
                    const priceRange = maxPrice - minPrice || 1;
                    const binSize = priceRange / binCount;
                    let callProfile = new Array(binCount).fill(0);
                    let putProfile = new Array(binCount).fill(0);
                    const priceBins = Array.from({ length: binCount }, (_, i) => minPrice + (i * binSize));

                    // Obtener timestamp actual (√∫ltimo del CSV) para filtrar volumeProfile din√°micamente
                    const lastCsvRow = rows[rows.length - 1];
                    const replayTimestamp = lastCsvRow ? new Date(lastCsvRow[timestampHeader]).getTime() : Date.now();

                    volumeProfile.forEach((strikeData) => {
                        strikeData.forEach(row => {
                            // Filtrar por timestamp para replay din√°mico (row.timestamp ya es num√©rico en ms)
                            if (row.timestamp && row.timestamp > replayTimestamp) return; // Saltar datos futuros

                            const strike = row.strike;
                            if (strike >= minPrice && strike <= maxPrice) {
                                const binIndex = Math.min(binCount - 1, Math.floor((strike - minPrice) / binSize));
                                if (binIndex >= 0 && binIndex < binCount) {
                                    if (profileType === 'cash') {
                                        callProfile[binIndex] += row.callCash;
                                        putProfile[binIndex] += row.putCash;
                                    } else {
                                        callProfile[binIndex] += row.dCall;
                                        putProfile[binIndex] += Math.abs(row.dPuts);
                                    }
                                }
                            }
                        });
                    });

                    const maxCallVolume = Math.max(...callProfile.filter(v => !isNaN(v)));
                    const maxPutVolume = Math.max(...putProfile.filter(v => !isNaN(v)));
                    const maxVolume = Math.max(maxCallVolume, maxPutVolume, 1);

                    const firstTime = rows.length > 0 ? rows[0][timestampHeader] : new Date();
                    const profileData = priceBins.map((price, i) => [price, callProfile[i], putProfile[i], firstTime]);

                    const renderVolumeProfile = (params, api) => {
                        const price = api.value(0);
                        const callVol = api.value(1);
                        const putVol = api.value(2);

                        if (price == null || callVol == null || putVol == null) return;

                        const panelWidth = api.getWidth();
                        const maxWidth = panelWidth * 0.5;

                        const callWidth = maxVolume > 0 ? (callVol / maxVolume) * maxWidth : 0;
                        const putWidth = maxVolume > 0 ? (putVol / maxVolume) * maxWidth : 0;

                        const centerCoord = api.coord([api.value(3), price + binSize / 2]);
                        if (!centerCoord) return;

                        const binHeightInPixels = Math.abs(api.size([0, binSize])[1]);
                        const barHeight = binHeightInPixels * 0.45;
                        const gap = binHeightInPixels * 0.05;

                        const startX = params.coordSys.x;
                        const putY = centerCoord[1] + gap / 2;
                        const callY = centerCoord[1] - gap / 2 - barHeight;

                        const children = [];

                        // Funci√≥n para abreviar n√∫meros
                        const abbreviateNumber = (num) => {
                            if (num >= 1000000) return (num / 1000000).toFixed(1) + 'M';
                            if (num >= 1000) return (num / 1000).toFixed(1) + 'K';
                            return num.toFixed(0);
                        };

                        if (callWidth > 0.1) {
                            children.push({
                                type: 'rect', shape: { x: startX, y: callY, width: callWidth, height: barHeight },
                                style: { fill: callColor, opacity: 0.65 }
                            });
                            // Texto con cantidad de calls
                            if (callWidth > 15 && callVol > 0) {
                                children.push({
                                    type: 'text',
                                    style: {
                                        text: abbreviateNumber(callVol),
                                        x: startX + callWidth - 3,
                                        y: callY + barHeight / 2,
                                        fill: '#ffffff',
                                        fontSize: 8,
                                        fontWeight: 'bold',
                                        textAlign: 'right',
                                        textVerticalAlign: 'middle',
                                        opacity: 0.8
                                    }
                                });
                            }
                        }
                        if (putWidth > 0.1) {
                            children.push({
                                type: 'rect', shape: { x: startX, y: putY, width: putWidth, height: barHeight },
                                style: { fill: putColor, opacity: 0.65 }
                            });
                            // Texto con cantidad de puts
                            if (putWidth > 15 && putVol > 0) {
                                children.push({
                                    type: 'text',
                                    style: {
                                        text: abbreviateNumber(putVol),
                                        x: startX + putWidth - 3,
                                        y: putY + barHeight / 2,
                                        fill: '#ffffff',
                                        fontSize: 8,
                                        fontWeight: 'bold',
                                        textAlign: 'right',
                                        textVerticalAlign: 'middle',
                                        opacity: 0.8
                                    }
                                });
                            }
                        }
                        return { type: 'group', children: children };
                    };

                    seriesList.push({
                        name: 'Volume Profile', type: 'custom', renderItem: renderVolumeProfile,
                        data: profileData,
                        encode: { x: 3, y: 0 },
                        yAxisIndex: 1,
                        tooltip: { show: false },
                        z: 2
                    });

                    legendData.push('Price', 'VWAP', 'Volume Profile', 'Call', 'Put');

                    // ===== S/R ZONES (zonas basadas en strikes con mayor volumen) =====
                    try {
                        // Usar volumeProfile directamente para obtener strikes reales
                        if (volumeProfile && volumeProfile.size > 0) {
                            // Obtener el timestamp m√°s reciente de los datos CSV (para sincronizar con replay)
                            const lastRow = rows[rows.length - 1];
                            const currentTimestamp = lastRow ? new Date(lastRow[timestampHeader]).getTime() : Date.now();

                            // M√©trica seleccionada para S/R (default: cash)
                            const srMetric = config.parameters?.srMetric || 'cash';
                            const srOpacityMultiplier = config.parameters?.srOpacity ?? 1.0;

                            // Agregar volumen por strike directamente del volumeProfile
                            // FILTRAR: solo incluir datos hasta el timestamp actual (para replay din√°mico)
                            const strikeVolumes = new Map();

                            volumeProfile.forEach((strikeData) => {
                                strikeData.forEach(row => {
                                    // Filtrar por timestamp (row.timestamp ya es num√©rico en ms)
                                    if (row.timestamp && row.timestamp > currentTimestamp) return; // Saltar datos futuros

                                    const strike = row.strike;
                                    // Cash siempre disponible como base
                                    const baseCashCall = Math.abs(row.callCash) || 0;
                                    const baseCashPut = Math.abs(row.putCash) || 0;

                                    // Seleccionar m√©trica seg√∫n configuraci√≥n (con fallback a Cash)
                                    let callVol = baseCashCall, putVol = baseCashPut;
                                    switch (srMetric) {
                                        case 'delta':
                                            callVol = Math.abs(row.dCall) || baseCashCall * 0.01;
                                            putVol = Math.abs(row.dPuts) || baseCashPut * 0.01;
                                            break;
                                        case 'gex':
                                            callVol = Math.abs(row.callGex) || Math.abs(row.dCall * 0.01) || baseCashCall * 0.01;
                                            putVol = Math.abs(row.putGex) || Math.abs(row.dPuts * 0.01) || baseCashPut * 0.01;
                                            break;
                                        case 'vanna':
                                            callVol = Math.abs(row.callVanna) || Math.abs(row.dCall * 0.005) || baseCashCall * 0.005;
                                            putVol = Math.abs(row.putVanna) || Math.abs(row.dPuts * 0.005) || baseCashPut * 0.005;
                                            break;
                                        case 'gamma':
                                            callVol = Math.abs(row.callGamma) || Math.abs(row.dCall * 0.008) || baseCashCall * 0.008;
                                            putVol = Math.abs(row.putGamma) || Math.abs(row.dPuts * 0.008) || baseCashPut * 0.008;
                                            break;
                                        case 'cash':
                                        default:
                                            // Ya inicializado con baseCashCall/baseCashPut
                                            break;
                                    }

                                    if (strike && !isNaN(strike) && (callVol > 0 || putVol > 0)) {
                                        const existing = strikeVolumes.get(strike) || { call: 0, put: 0 };
                                        strikeVolumes.set(strike, {
                                            call: existing.call + callVol,
                                            put: existing.put + putVol
                                        });
                                    }
                                });
                            });

                            // Convertir a array y calcular totales
                            const strikeData = Array.from(strikeVolumes.entries()).map(([strike, vol]) => ({
                                strike,
                                callVol: vol.call,
                                putVol: vol.put,
                                total: vol.call + vol.put,
                                dominance: vol.call > vol.put ? 'CALL' : 'PUT', // CALL si callVol > putVol
                                ratio: vol.put > 0 ? vol.call / vol.put : vol.call > 0 ? 999 : 1
                            }));

                            // Ordenar por volumen total y tomar los TOP 8
                            strikeData.sort((a, b) => b.total - a.total);
                            const topStrikes = strikeData.slice(0, 8);

                            // Calcular strength relativo al m√°ximo
                            const maxVol = topStrikes.length > 0 ? topStrikes[0].total : 1;

                            const allSurges = topStrikes.map(s => ({
                                strike: s.strike,
                                dominance: s.dominance,
                                strength: Math.round((s.total / maxVol) * 100),
                                surgeRatio: s.ratio,
                                callVol: s.callVol,
                                putVol: s.putVol
                            }));

                            // DEBUG: mostrar zonas S/R en consola
                            console.log('S/R Zones TOP 4:', allSurges.map(z =>
                                `Strike ${z.strike}: Call=${z.callVol.toFixed(0)}, Put=${z.putVol.toFixed(0)} ‚Üí ${z.dominance} (${z.dominance === 'CALL' ? 'üîµ' : 'üî¥'})`
                            ));

                            if (allSurges.length > 0) {
                                // Renderizar zonas horizontales que ocupan TODO el ancho del gr√°fico
                                // CON EFECTO BRILLANTE Y PULSANTE
                                const renderSurgeZone = (params, api) => {
                                    const strike = api.value(0);
                                    const dominance = api.value(1);
                                    const strength = api.value(2);
                                    const timeframe = api.value(3);
                                    const surgeRatio = api.value(4);
                                    const opacityMult = api.value(5) || 1.0; // Multiplicador de opacidad
                                    const rank = api.value(6) || 0; // Rank (0 = m√°s fuerte)

                                    // Coordenadas Y del strike
                                    const yPos = api.coord([0, strike])[1];

                                    // Ancho COMPLETO del gr√°fico
                                    const chartWidth = api.getWidth();
                                    const gridX = params.coordSys.x || 50;
                                    const zoneStartX = gridX; // Desde el inicio del grid
                                    const zoneEndX = chartWidth - 5; // Hasta el borde derecho

                                    // Altura de la zona basada en la fuerza (m√°s fuerte = m√°s alto)
                                    const zoneHeight = Math.max(6, Math.min(24, 6 + strength * 0.18));

                                    // COLORES AMBER/ORANGE BRILLANTES para surges
                                    // Rank 0 = m√°s brillante (naranja intenso), rank mayor = m√°s tenue
                                    const isHot = rank === 0;
                                    const isWarm = rank === 1;

                                    // Colores base amber/orange seg√∫n rank
                                    let r, g, b;
                                    if (isHot) {
                                        // HOT: Naranja brillante
                                        r = 245; g = 158; b = 11;
                                    } else if (isWarm) {
                                        // WARM: Amber
                                        r = 217; g = 119; b = 6;
                                    } else {
                                        // NORMAL: Amber tenue
                                        r = 180; g = 100; b = 20;
                                    }

                                    // Opacidad base seg√∫n strength y rank
                                    const baseOpacity = Math.min(0.9, (0.25 + (strength / 100) * 0.5 + (isHot ? 0.15 : isWarm ? 0.08 : 0)) * opacityMult);
                                    const fillColor = `rgba(${r}, ${g}, ${b}, ${baseOpacity})`;

                                    // Borde m√°s brillante
                                    const borderOpacity = Math.min(1, baseOpacity + 0.3);
                                    const borderColor = `rgba(${Math.min(255, r + 30)}, ${Math.min(255, g + 30)}, ${b}, ${borderOpacity})`;

                                    // Glow exterior para HOT (simular efecto brillante)
                                    const glowColor = isHot ? `rgba(255, 180, 50, 0.4)` : isWarm ? `rgba(245, 158, 11, 0.25)` : null;
                                    const glowHeight = isHot ? zoneHeight + 10 : isWarm ? zoneHeight + 6 : 0;

                                    // Texto brillante
                                    const textColor = isHot ? 'rgb(255, 220, 150)' : isWarm ? 'rgb(245, 180, 100)' : 'rgb(200, 150, 80)';
                                    const textOpacity = strength > 20 ? Math.min(1, Math.max(0.6, (strength - 20) / 80 * 1.0) * opacityMult) : 0;

                                    const children = [];

                                    // Glow exterior (solo para HOT y WARM)
                                    if (glowColor && glowHeight > 0) {
                                        children.push({
                                            type: 'rect',
                                            shape: {
                                                x: zoneStartX,
                                                y: yPos - glowHeight / 2,
                                                width: zoneEndX - zoneStartX,
                                                height: glowHeight
                                            },
                                            style: {
                                                fill: glowColor,
                                                stroke: 'transparent'
                                            }
                                        });
                                    }

                                    // Banda principal
                                    children.push({
                                        type: 'rect',
                                        shape: {
                                            x: zoneStartX,
                                            y: yPos - zoneHeight / 2,
                                            width: zoneEndX - zoneStartX,
                                            height: zoneHeight
                                        },
                                        style: {
                                            fill: fillColor,
                                            stroke: borderColor,
                                            lineWidth: isHot ? 2 : isWarm ? 1.5 : 1,
                                            shadowColor: isHot ? 'rgba(245, 158, 11, 0.6)' : isWarm ? 'rgba(217, 119, 6, 0.4)' : 'transparent',
                                            shadowBlur: isHot ? 12 : isWarm ? 6 : 0
                                        }
                                    });

                                    // L√≠nea central brillante (solo HOT)
                                    if (isHot) {
                                        children.push({
                                            type: 'rect',
                                            shape: {
                                                x: zoneStartX,
                                                y: yPos - 1,
                                                width: zoneEndX - zoneStartX,
                                                height: 2
                                            },
                                            style: {
                                                fill: 'rgba(255, 220, 100, 0.7)',
                                                stroke: 'transparent'
                                            }
                                        });
                                    }

                                    // Etiqueta
                                    if (textOpacity > 0) {
                                        children.push({
                                            type: 'text',
                                            style: {
                                                x: zoneEndX - 8,
                                                y: yPos,
                                                text: isHot ? `üî• ${strike.toFixed(0)}` : `‚ö° ${strike.toFixed(0)}`,
                                                fontSize: isHot ? 10 : 9,
                                                fontWeight: isHot ? 'bold' : 'normal',
                                                fill: textColor,
                                                textAlign: 'right',
                                                textVerticalAlign: 'middle',
                                                textShadowColor: 'rgba(0,0,0,0.8)',
                                                textShadowBlur: 3,
                                                opacity: textOpacity
                                            }
                                        });
                                    }

                                    return {
                                        type: 'group',
                                        children
                                    };
                                };

                                // Data: [strike, dominance, strength, timeframe, surgeRatio, opacityMultiplier, rank]
                                const surgeData = allSurges.map((z, idx) => [z.strike, z.dominance, z.strength, 'vol', z.surgeRatio, srOpacityMultiplier, idx]);

                                seriesList.push({
                                    name: 'S/R Zones',
                                    type: 'custom',
                                    renderItem: renderSurgeZone,
                                    data: surgeData,
                                    encode: { y: 0 },
                                    yAxisIndex: 1,
                                    silent: true, // No afecta el c√°lculo del eje Y
                                    tooltip: {
                                        formatter: (param) => {
                                            const d = param.data;
                                            return `<div style="font-size:11px">
                                            <b>üü° S/R Zone</b><br/>
                                            Strike: <b>${d[0]}</b><br/>
                                            Fuerza: ${d[2]}%
                                        </div>`;
                                        }
                                    },
                                    z: 5 // Por debajo de las l√≠neas de precio
                                });

                                legendData.push('S/R Zones');
                            } // end if allSurges.length > 0
                        } // end if volumeProfile
                    } catch (e) {
                        console.warn('Error adding S/R zones:', e);
                    }

                    // Calcular tama√±o y opacidad relativa basado en el valor m√°ximo
                    const maxVal = bigTradesData?.maxAbsValue || 1;
                    const calcSize = (data) => {
                        const ratio = Math.abs(data[2]) / maxVal;
                        return Math.min(18, Math.max(4, 4 + ratio * 14)); // 4px min, 18px max (m√°s peque√±os)
                    };
                    const calcOpacity = (data) => {
                        const ratio = Math.abs(data[2]) / maxVal;
                        return Math.min(0.6, Math.max(0.15, 0.15 + ratio * 0.45)); // 0.15 a 0.6 opacidad
                    };

                    if (bigTradesData?.bigBuys?.length > 0) {
                        seriesList.push({
                            name: 'Big Buys', type: 'scatter', data: bigTradesData.bigBuys,
                            yAxisIndex: 1,
                            symbol: 'circle',
                            itemStyle: {
                                color: (params) => `rgba(74, 158, 255, ${calcOpacity(params.data)})`
                            },
                            symbolSize: calcSize,
                            label: {
                                show: true,
                                position: 'top',
                                formatter: (param) => Math.abs(param.data[2]) / maxVal > 0.4 ? formatProfileLabel(param.data[2]) : '',
                                color: '#a8d4ff',
                                fontSize: 7,
                                textShadowColor: 'rgba(0, 0, 0, 0.8)',
                                textShadowBlur: 2
                            },
                            z: 15
                        });
                        legendData.push('Big Buys');
                    }
                    if (bigTradesData?.bigSells?.length > 0) {
                        seriesList.push({
                            name: 'Big Sells', type: 'scatter', data: bigTradesData.bigSells,
                            yAxisIndex: 1,
                            symbol: 'circle',
                            itemStyle: {
                                color: (params) => `rgba(255, 68, 68, ${calcOpacity(params.data)})`
                            },
                            symbolSize: calcSize,
                            label: {
                                show: true,
                                position: 'bottom',
                                formatter: (param) => Math.abs(param.data[2]) / maxVal > 0.4 ? formatProfileLabel(param.data[2]) : '',
                                color: '#ffaaaa',
                                fontSize: 7,
                                textShadowColor: 'rgba(0, 0, 0, 0.8)',
                                textShadowBlur: 2
                            },
                            z: 15
                        });
                        legendData.push('Big Sells');
                    }

                    return {
                        animation: true, animationDuration: 100, backgroundColor: 'transparent',
                        tooltip: { ...commonTooltip, trigger: 'axis', axisPointer: { type: 'cross' } },
                        legend: { data: legendData, textStyle: { color: '#e8e8e8' }, top: 5 },
                        grid: commonGrid,
                        xAxis: commonXAxis,
                        yAxis: [
                            { ...commonYAxis, name: 'Price', min: priceMin - pricePadding, max: priceMax + pricePadding, nameLocation: 'middle', nameGap: 35, axisLabel: { ...commonYAxis.axisLabel, formatter: (value) => typeof value === 'number' ? value.toFixed(2) : value } },
                            { ...commonYAxis, show: false, min: decorationMin, max: decorationMax } // Eje invisible para VWAP, S/R y decoraciones
                        ],
                        dataZoom: [{ type: 'inside', start: config.zoomState.start, end: config.zoomState.end, zoomOnMouseWheel: true, moveOnMouseMove: true, filterMode: 'none', rangeMode: ['percent', 'percent'] }, { type: 'inside', yAxisIndex: 0, disabled: true },],
                        series: seriesList
                    };

                } else {
                    const priceValues = rows.map(r => r[priceHeader]);
                    const priceData = rows.map((r, i) => [r[timestampHeader], priceValues[i]]);
                    // Calcular VWAP con m√©trica seleccionada
                    const vwapMetric = config.parameters?.vwapMetric || 'Total_Volume';
                    const vwapValues = calculateVWAP(rows, priceHeader, vwapMetric);
                    const vwapData = rows.map((r, i) => [r[timestampHeader], vwapValues[i]]);
                    // Insertar price y VWAP con etiqueta din√°mica
                    let latestVwap = null;
                    for (let i = vwapValues.length - 1; i >= 0; i--) { if (vwapValues[i] !== null && !isNaN(vwapValues[i])) { latestVwap = vwapValues[i]; break; } }
                    const vwapLabel = latestVwap !== null ? `VWAP (${latestVwap.toFixed(2)})` : 'VWAP';
                    legendData.push(priceHeader, vwapLabel);
                    seriesList.push(
                        { name: priceHeader, type: 'line', data: priceData, showSymbol: false, smooth: false, lineStyle: { width: 2, color: config.parameters.priceColor || '#888888' } },
                        { name: vwapLabel, type: 'line', data: vwapData, showSymbol: false, smooth: true, lineStyle: { width: 2, color: '#ff4444' } }
                    );
                }
                if (bigTradesData?.bigBuys?.length > 0) {
                    const maxVal = bigTradesData.maxAbsValue || 1;
                    const calcSz = (data) => { const ratio = maxVal > 0 ? Math.abs(data[2]) / maxVal : 0; return Math.min(18, Math.max(4, 4 + ratio * 14)); };
                    const calcOp = (data) => { const ratio = maxVal > 0 ? Math.abs(data[2]) / maxVal : 0; return Math.min(0.6, Math.max(0.15, 0.15 + ratio * 0.45)); };
                    seriesList.push({
                        name: 'Big Buys', type: 'scatter', data: bigTradesData.bigBuys,
                        symbol: 'circle',
                        itemStyle: {
                            color: (params) => `rgba(74, 158, 255, ${calcOp(params.data)})`
                        },
                        symbolSize: calcSz,
                        label: { show: true, position: 'top', formatter: (param) => Math.abs(param.data[2]) / maxVal > 0.4 ? formatProfileLabel(param.data[2]) : '', color: '#a8d4ff', fontSize: 7, textShadowColor: 'rgba(0, 0, 0, 0.8)', textShadowBlur: 2 },
                        z: 15
                    });
                    legendData.push('Big Buys');
                }
                if (bigTradesData?.bigSells?.length > 0) {
                    const maxVal = bigTradesData.maxAbsValue || 1;
                    const calcSz = (data) => { const ratio = maxVal > 0 ? Math.abs(data[2]) / maxVal : 0; return Math.min(18, Math.max(4, 4 + ratio * 14)); };
                    const calcOp = (data) => { const ratio = maxVal > 0 ? Math.abs(data[2]) / maxVal : 0; return Math.min(0.6, Math.max(0.15, 0.15 + ratio * 0.45)); };
                    seriesList.push({
                        name: 'Big Sells', type: 'scatter', data: bigTradesData.bigSells,
                        symbol: 'circle',
                        itemStyle: {
                            color: (params) => `rgba(255, 68, 68, ${calcOp(params.data)})`
                        },
                        symbolSize: calcSz,
                        label: { show: true, position: 'bottom', formatter: (param) => Math.abs(param.data[2]) / maxVal > 0.4 ? formatProfileLabel(param.data[2]) : '', color: '#ffaaaa', fontSize: 7, textShadowColor: 'rgba(0, 0, 0, 0.8)', textShadowBlur: 2 },
                        z: 15
                    });
                    legendData.push('Big Sells');
                }

                return {
                    animation: true, animationDuration: 100, animationEasing: 'cubicOut', animationDurationUpdate: 0, backgroundColor: 'transparent', tooltip: commonTooltip,
                    legend: { data: legendData, textStyle: { color: '#e8e8e8' }, top: 5 },
                    grid: commonGrid, xAxis: commonXAxis, yAxis: { ...commonYAxis, min: 'dataMin', max: 'dataMax', boundaryGap: ['2%', '2%'], axisLabel: { ...commonYAxis.axisLabel, formatter: (value) => typeof value === 'number' ? value.toFixed(2) : value } }, dataZoom: [{ type: 'inside', start: config.zoomState.start, end: config.zoomState.end, zoomOnMouseWheel: true, moveOnMouseMove: true, filterMode: 'none', rangeMode: ['percent', 'percent'] }],
                    series: seriesList
                };
            };
            const getEvolutionOption = (config, dataSource, specialData) => {
                const group = EVOLUTION_GROUPS.find(g => g.key === config.type);
                if (!group) return {};
                const { rows, timestampHeader, headers } = dataSource;
                const series = group.metrics.map((metric, idx) => {
                    const isNeto = metric.toLowerCase().includes('neto');
                    const metricValue = rows.map(r => [r[timestampHeader], group.invertPut && metric === 'Delta Put' ? -((r[metric] || 0)) : r[metric] || 0]);
                    let areaStyle = undefined;
                    if (metric.toLowerCase().includes('call')) areaStyle = { color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [{ offset: 0, color: 'rgba(74, 158, 255, 0.25)' }, { offset: 1, color: 'rgba(74, 158, 255, 0.01)' }]) };
                    else if (metric.toLowerCase().includes('put')) areaStyle = { color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [{ offset: 0, color: 'rgba(255, 68, 68, 0.25)' }, { offset: 1, color: 'rgba(255, 68, 68, 0.01)' }]) };
                    else if (isNeto) areaStyle = { color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [{ offset: 0, color: 'rgba(144, 144, 144, 0.2)' }, { offset: 1, color: 'rgba(144, 144, 144, 0.01)' }]) };
                    return { name: metric, type: 'line', data: metricValue, smooth: true, showSymbol: false, lineStyle: { width: 1.8, color: group.colors[idx] }, areaStyle };
                });
                const legendData = [...group.metrics];
                return { animation: true, animationDuration: 100, animationEasing: 'cubicOut', animationDurationUpdate: 0, backgroundColor: 'transparent', tooltip: commonTooltip, legend: { data: legendData, textStyle: { color: '#e8e8e8' }, top: 5 }, grid: commonGrid, xAxis: commonXAxis, yAxis: commonYAxis, dataZoom: [{ type: 'inside', start: config.zoomState.start, end: config.zoomState.end, zoomOnMouseWheel: true, moveOnMouseMove: true }], series };
            };
            const getSignalOption = (config, signals) => {
                if (!signals) return {};
                const metrics = getMetricsForType(config.type);
                if (!metrics) return {};
                const kamaPeriod = config.parameters.kamaPeriod || 100;
                return {
                    animation: true, animationDuration: 100, animationEasing: 'cubicOut', animationDurationUpdate: 0, backgroundColor: 'transparent', tooltip: commonTooltip,
                    legend: { data: [`${metrics.name} Neto`, `KAMA(${kamaPeriod})`, 'Net Flow'], textStyle: { color: '#e8e8e8' }, top: 5 },
                    grid: [{ ...commonGrid, height: '60%' }, { ...commonGrid, top: '75%', height: '18%' }],
                    xAxis: [{ ...commonXAxis, gridIndex: 0, axisLabel: { ...commonXAxis.axisLabel, show: false } }, { ...commonXAxis, gridIndex: 1 }],
                    yAxis: [{ ...commonYAxis, gridIndex: 0 }, { ...commonYAxis, gridIndex: 1 }],
                    dataZoom: [{ type: 'inside', xAxisIndex: [0, 1], start: config.zoomState.start, end: config.zoomState.end, zoomOnMouseWheel: true, moveOnMouseMove: true }],
                    series: [
                        { name: `${metrics.name} Neto`, type: 'line', data: signals.map((d) => [d.time, d.netoValue]), showSymbol: false, smooth: true, lineStyle: { color: '#666', width: 1.5 }, areaStyle: { color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [{ offset: 0, color: 'rgba(102, 102, 102, 0.15)' }, { offset: 1, color: 'rgba(102, 102, 102, 0.01)' }]) }, xAxisIndex: 0, yAxisIndex: 0 },
                        { name: `KAMA(${kamaPeriod})`, type: 'line', data: signals.map((d) => [d.time, d.kamaValue]), showSymbol: false, smooth: true, lineStyle: { color: COLORS.KAMA_LINE, width: 2.5 }, areaStyle: { color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [{ offset: 0, color: 'rgba(112, 123, 133, 0.25)' }, { offset: 1, color: 'rgba(112, 123, 133, 0.01)' }]) }, xAxisIndex: 0, yAxisIndex: 0 },
                        { name: 'BUY Signal', type: 'scatter', data: signals.filter((d) => d.signal === 'BUY').map((d) => [d.time, d.netoValue]), symbolSize: 10, itemStyle: { color: COLORS.BULLISH_SIGNAL }, xAxisIndex: 0, yAxisIndex: 0 },
                        { name: 'SELL Signal', type: 'scatter', data: signals.filter((d) => d.signal === 'SELL').map((d) => [d.time, d.netoValue]), symbolSize: 10, itemStyle: { color: COLORS.BEARISH_SIGNAL }, xAxisIndex: 0, yAxisIndex: 0 },
                        { name: 'Net Flow', type: 'bar', data: signals.map((d) => [d.time, d.netFlow]), itemStyle: { color: (p) => p.value[1] > 0 ? 'rgba(74, 158, 255, 0.5)' : 'rgba(255, 68, 68, 0.5)' }, xAxisIndex: 1, yAxisIndex: 1 }
                    ]
                };
            };
            const getImbalanceOption = (config, dataSource, specialData) => {
                const { rows, timestampHeader } = dataSource;
                const metrics = getMetricsForType(config.type);
                if (!metrics) return {};
                const callData = rows.map(r => (r[metrics.call] || 0));
                const putData = rows.map(r => (r[metrics.put] || 0));
                if (config.type.endsWith('-velocity')) {
                    const imbalanceData = rows.map((r, i) => [r[timestampHeader], calcImbalance(callData[i], putData[i])]);
                    const imbValues = imbalanceData.map(d => d[1]);
                    const velocityData = imbValues.map((_, i) => [rows[i][timestampHeader], i > 10 ? imbValues[i] - imbValues[i - 10] : null]);
                    const accelData = velocityData.map((d, i) => [rows[i][timestampHeader], i > 10 && d[1] != null && velocityData[i - 10][1] != null ? d[1] - velocityData[i - 10][1] : null]);
                    return {
                        animation: true, animationDuration: 100, animationEasing: 'cubicOut', animationDurationUpdate: 0, backgroundColor: 'transparent', tooltip: commonTooltip,
                        legend: { data: ['Imbalance', 'Velocity', 'Acceleration'], textStyle: { color: '#e8e8e8' }, top: 5 },
                        grid: [{ ...commonGrid, height: '45%' }, { ...commonGrid, top: '55%', height: '38%' }],
                        xAxis: [{ ...commonXAxis, gridIndex: 0, axisLabel: { ...commonXAxis.axisLabel, show: false } }, { ...commonXAxis, gridIndex: 1 }],
                        yAxis: [{ ...commonYAxis, gridIndex: 0, name: 'Imbalance %' }, { ...commonYAxis, gridIndex: 1, name: 'Velocity' }, { ...commonYAxis, gridIndex: 1, name: 'Acceleration', position: 'right', splitLine: { show: false } },],
                        dataZoom: [{ type: 'inside', xAxisIndex: [0, 1], start: config.zoomState.start, end: config.zoomState.end, zoomOnMouseWheel: true, moveOnMouseMove: true }],
                        series: [
                            { name: 'Imbalance', type: 'line', data: imbalanceData, showSymbol: false, smooth: true, lineStyle: { color: '#4fc3f7', width: 2 }, areaStyle: { color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [{ offset: 0, color: 'rgba(79, 195, 247, 0.35)' }, { offset: 0.6, color: 'rgba(79, 195, 247, 0.12)' }, { offset: 1, color: 'rgba(79, 195, 247, 0.02)' }]) }, xAxisIndex: 0, yAxisIndex: 0 },
                            { name: 'Velocity', type: 'bar', data: velocityData, itemStyle: { color: (p) => p.value[1] > 0 ? 'rgba(74, 158, 255, 0.5)' : 'rgba(255, 68, 68, 0.5)' }, xAxisIndex: 1, yAxisIndex: 1 },
                            { name: 'Acceleration', type: 'line', data: accelData, showSymbol: false, smooth: true, lineStyle: { color: '#fff', width: 1.5 }, areaStyle: { color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [{ offset: 0, color: 'rgba(255, 255, 255, 0.15)' }, { offset: 0.7, color: 'rgba(255, 255, 255, 0.04)' }, { offset: 1, color: 'rgba(255, 255, 255, 0.01)' }]) }, xAxisIndex: 1, yAxisIndex: 2 }
                        ]
                    }
                }
                if (config.type.endsWith('-er')) {
                    const lookback = config.parameters.erLookback || 100;
                    const erNetoValues = calcER(rows.map(r => ((r[metrics.call] || 0)) - ((r[metrics.put] || 0))), lookback);
                    const erNetoData = erNetoValues.map((v, i) => [rows[i][timestampHeader], v]);
                    return {
                        animation: true, animationDuration: 100, animationEasing: 'cubicOut', animationDurationUpdate: 0, backgroundColor: 'transparent', tooltip: commonTooltip,
                        legend: { data: ['ER Neto'], textStyle: { color: '#e8e8e8' }, top: 5 }, grid: commonGrid, xAxis: commonXAxis, yAxis: commonYAxis,
                        dataZoom: [{ type: 'inside', start: config.zoomState.start, end: config.zoomState.end, zoomOnMouseWheel: true, moveOnMouseMove: true }],
                        series: [{ name: 'ER Neto', type: 'line', data: erNetoData, showSymbol: false, smooth: true, lineStyle: { color: '#fff', width: 2 }, areaStyle: { color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [{ offset: 0, color: 'rgba(255, 255, 255, 0.25)' }, { offset: 0.6, color: 'rgba(255, 255, 255, 0.08)' }, { offset: 1, color: 'rgba(255, 255, 255, 0.01)' }]) } }]
                    };
                }
                if (config.type.endsWith('-spikes')) {
                    const data = specialData;
                    if (!data) return {};
                    const showSMA = config.parameters.showSma ?? true;
                    const series = [
                        { name: 'Imbalance', type: 'line', data: data.imbalanceData, xAxisIndex: 0, yAxisIndex: 0, smooth: true, showSymbol: false, lineStyle: { width: 2, color: '#4fc3f7' }, areaStyle: { color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [{ offset: 0, color: 'rgba(79, 195, 247, 0.35)' }, { offset: 0.6, color: 'rgba(79, 195, 247, 0.12)' }, { offset: 1, color: 'rgba(79, 195, 247, 0.02)' }]) } },
                        { name: 'SMA', type: 'line', data: showSMA ? data.smaData : [], xAxisIndex: 0, yAxisIndex: 0, smooth: true, showSymbol: false, lineStyle: { width: 1.5, color: 'rgba(150, 150, 150, 0.6)' } },
                        { name: 'Call Vol Spike', type: 'line', data: data.callVolSpikes, xAxisIndex: 1, yAxisIndex: 1, smooth: true, showSymbol: false, lineStyle: { width: 2, color: COLORS.CALL }, areaStyle: { color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [{ offset: 0, color: 'rgba(74, 158, 255, 0.3)' }, { offset: 0.6, color: 'rgba(74, 158, 255, 0.1)' }, { offset: 1, color: 'rgba(74, 158, 255, 0.02)' }]) } },
                        { name: 'Put Vol Spike', type: 'line', data: data.putVolSpikes, xAxisIndex: 1, yAxisIndex: 1, smooth: true, showSymbol: false, lineStyle: { width: 2, color: COLORS.PUT }, areaStyle: { color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [{ offset: 0, color: 'rgba(255, 68, 68, 0.3)' }, { offset: 0.6, color: 'rgba(255, 68, 68, 0.1)' }, { offset: 1, color: 'rgba(255, 68, 68, 0.02)' }]) } },
                        { name: 'Call Intensity', type: 'line', data: data.callIntensityData, xAxisIndex: 2, yAxisIndex: 2, smooth: true, showSymbol: false, lineStyle: { width: 2, color: COLORS.CALL }, areaStyle: { color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [{ offset: 0, color: 'rgba(74, 158, 255, 0.3)' }, { offset: 0.6, color: 'rgba(74, 158, 255, 0.1)' }, { offset: 1, color: 'rgba(74, 158, 255, 0.02)' }]) } },
                        { name: 'Put Intensity', type: 'line', data: data.putIntensityData, xAxisIndex: 2, yAxisIndex: 2, smooth: true, showSymbol: false, lineStyle: { width: 2, color: COLORS.PUT }, areaStyle: { color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [{ offset: 0, color: 'rgba(255, 68, 68, 0.3)' }, { offset: 0.6, color: 'rgba(255, 68, 68, 0.1)' }, { offset: 1, color: 'rgba(255, 68, 68, 0.02)' }]) } }
                    ];
                    return {
                        animation: true, animationDuration: 100, animationEasing: 'cubicOut', animationDurationUpdate: 0, backgroundColor: 'transparent', tooltip: commonTooltip,
                        legend: { data: ['Imbalance', 'SMA', 'Call Vol Spike', 'Put Vol Spike', 'Call Intensity', 'Put Intensity'], textStyle: { color: '#e0e0e0', fontSize: 10 }, top: 5 },
                        grid: [{ left: 50, right: 18, top: 30, height: '28%' }, { left: 50, right: 18, top: '36%', height: '28%' }, { left: 50, right: 18, top: '67%', bottom: 15 }],
                        xAxis: [{ type: 'time', gridIndex: 0, axisLine: { lineStyle: { color: '#333333' } }, axisLabel: { show: false }, splitLine: { show: false } }, { type: 'time', gridIndex: 1, axisLine: { lineStyle: { color: '#333333' } }, axisLabel: { show: false }, splitLine: { show: false } }, { type: 'time', gridIndex: 2, axisLine: { lineStyle: { color: '#333333' } }, axisLabel: { color: '#808080', fontSize: 10 }, splitLine: { show: false } }],
                        yAxis: [{ ...commonYAxis, gridIndex: 0, name: 'Imbalance %', nameTextStyle: { color: '#808080', fontSize: 10 } }, { ...commonYAxis, gridIndex: 1, name: 'Volume Spike', nameTextStyle: { color: '#808080', fontSize: 10 } }, { ...commonYAxis, gridIndex: 2, name: 'Intensity', nameTextStyle: { color: '#808080', fontSize: 10 } }],
                        dataZoom: [{ type: 'inside', xAxisIndex: [0, 1, 2], start: config.zoomState.start, end: config.zoomState.end, zoomOnMouseWheel: true, moveOnMouseMove: true }],
                        series
                    };
                }
                if (config.type.endsWith('-dominance-index')) {
                    const lookback = config.parameters.lookback ?? 30;
                    const { rollingCallSums, rollingPutSums } = calculateDominanceIndex(callData, putData, lookback);
                    const callFlowData = rollingCallSums.map((v, i) => [rows[i][timestampHeader], v]);
                    const putFlowData = rollingPutSums.map((v, i) => [rows[i][timestampHeader], v]);
                    return {
                        animation: true, animationDuration: 100, animationEasing: 'cubicOut', animationDurationUpdate: 0, backgroundColor: 'transparent',
                        tooltip: { ...commonTooltip, formatter: (params) => { if (!params || params.length === 0) return ''; const date = new Date(params[0].axisValue).toLocaleString(); let tooltip = `${date}<br/>`; params.forEach((param) => { tooltip += `<span style="display:inline-block;margin-right:5px;border-radius:10px;width:10px;height:10px;background-color:${param.color};"></span>${param.seriesName}: <strong>${formatNumber(param.value[1])}</strong><br/>`; }); return tooltip; } },
                        legend: { data: [`Call Flow`, `Put Flow`], textStyle: { color: '#e8e8e8' }, top: 5 }, grid: commonGrid, xAxis: commonXAxis, yAxis: commonYAxis,
                        dataZoom: [{ type: 'inside', start: config.zoomState.start, end: config.zoomState.end, zoomOnMouseWheel: true, moveOnMouseMove: true }],
                        series: [{ name: `Call Flow`, type: 'line', data: callFlowData, showSymbol: false, smooth: true, lineStyle: { color: COLORS.CALL, width: 2 }, areaStyle: { color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [{ offset: 0, color: 'rgba(74, 158, 255, 0.5)' }, { offset: 0.5, color: 'rgba(74, 158, 255, 0.2)' }, { offset: 1, color: 'rgba(74, 158, 255, 0.02)' }]) } }, { name: `Put Flow`, type: 'line', data: putFlowData, showSymbol: false, smooth: true, lineStyle: { color: COLORS.PUT, width: 2 }, areaStyle: { color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [{ offset: 0, color: 'rgba(255, 68, 68, 0.5)' }, { offset: 0.5, color: 'rgba(255, 68, 68, 0.2)' }, { offset: 1, color: 'rgba(255, 68, 68, 0.02)' }]) } }]
                    };
                }
                if (config.type.endsWith('-macd-dominance')) {
                    const lookback = config.parameters.lookback ?? 30; const fastPeriod = config.parameters.fastPeriod ?? 8; const slowPeriod = config.parameters.slowPeriod ?? 20; const signalPeriod = config.parameters.signalPeriod ?? 5;
                    const macdData = calculateMACDDominance(callData, putData, lookback, fastPeriod, slowPeriod, signalPeriod);
                    const callMACDData = macdData.call.macd.map((v, i) => [rows[i][timestampHeader], v]); const callSignalData = macdData.call.signal.map((v, i) => [rows[i][timestampHeader], v]); const callHistogramData = macdData.call.histogram.map((v, i) => [rows[i][timestampHeader], v]);
                    const putMACDData = macdData.put.macd.map((v, i) => [rows[i][timestampHeader], v]); const putSignalData = macdData.put.signal.map((v, i) => [rows[i][timestampHeader], v]); const putHistogramData = macdData.put.histogram.map((v, i) => [rows[i][timestampHeader], v]);
                    return {
                        animation: true, animationDuration: 100, animationEasing: 'cubicOut', animationDurationUpdate: 0, backgroundColor: 'transparent', tooltip: commonTooltip,
                        legend: { data: ['Call MACD', 'Call Signal', 'Call Histogram', 'Put MACD', 'Put Signal', 'Put Histogram'], textStyle: { color: '#e0e0e0', fontSize: 10 }, top: 5 },
                        grid: [{ left: 50, right: 18, top: 30, height: '42%' }, { left: 50, right: 18, top: '51%', bottom: 15 }],
                        xAxis: [{ type: 'time', gridIndex: 0, axisLine: { lineStyle: { color: '#333333' } }, axisLabel: { show: false }, splitLine: { show: false } }, { type: 'time', gridIndex: 1, axisLine: { lineStyle: { color: '#333333' } }, axisLabel: { color: '#808080', fontSize: 10 }, splitLine: { show: false } }],
                        yAxis: [{ ...commonYAxis, gridIndex: 0, name: 'Call MACD', nameTextStyle: { color: COLORS.CALL, fontSize: 10 } }, { ...commonYAxis, gridIndex: 1, name: 'Put MACD', nameTextStyle: { color: COLORS.PUT, fontSize: 10 } }],
                        dataZoom: [{ type: 'inside', xAxisIndex: [0, 1], start: config.zoomState.start, end: config.zoomState.end, zoomOnMouseWheel: true, moveOnMouseMove: true }],
                        series: [
                            { name: 'Call MACD', type: 'line', data: callMACDData, xAxisIndex: 0, yAxisIndex: 0, showSymbol: false, smooth: true, lineStyle: { color: COLORS.CALL, width: 2 }, areaStyle: { color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [{ offset: 0, color: 'rgba(74, 158, 255, 0.35)' }, { offset: 1, color: 'rgba(74, 158, 255, 0.02)' }]) }, z: 3 },
                            { name: 'Call Signal', type: 'line', data: callSignalData, xAxisIndex: 0, yAxisIndex: 0, showSymbol: false, smooth: true, lineStyle: { color: 'rgba(255, 255, 255, 0.6)', width: 1.2 }, z: 2 },
                            { name: 'Call Histogram', type: 'bar', data: callHistogramData, xAxisIndex: 0, yAxisIndex: 0, itemStyle: { color: (params) => params.value[1] >= 0 ? 'rgba(74, 158, 255, 0.4)' : 'rgba(255, 68, 68, 0.3)' }, barWidth: '60%', z: 1 },
                            { name: 'Put MACD', type: 'line', data: putMACDData, xAxisIndex: 1, yAxisIndex: 1, showSymbol: false, smooth: true, lineStyle: { color: COLORS.PUT, width: 2 }, areaStyle: { color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [{ offset: 0, color: 'rgba(255, 68, 68, 0.35)' }, { offset: 1, color: 'rgba(255, 68, 68, 0.02)' }]) }, z: 3 },
                            { name: 'Put Signal', type: 'line', data: putSignalData, xAxisIndex: 1, yAxisIndex: 1, showSymbol: false, smooth: true, lineStyle: { color: 'rgba(255, 255, 255, 0.6)', width: 1.2 }, z: 2 },
                            { name: 'Put Histogram', type: 'bar', data: putHistogramData, xAxisIndex: 1, yAxisIndex: 1, itemStyle: { color: (params) => params.value[1] >= 0 ? 'rgba(255, 68, 68, 0.4)' : 'rgba(74, 158, 255, 0.3)' }, barWidth: '60%', z: 1 }
                        ]
                    };
                }
                if (config.type.endsWith('-macd-net')) {
                    const lookback = config.parameters.lookback ?? 30; const fastPeriod = config.parameters.fastPeriod ?? 8; const slowPeriod = config.parameters.slowPeriod ?? 20; const signalPeriod = config.parameters.signalPeriod ?? 5;
                    const macdData = calculateMACDDominance(callData, putData, lookback, fastPeriod, slowPeriod, signalPeriod);
                    const macdNetData = calculateMACDNet(callData, putData, lookback, fastPeriod, slowPeriod, signalPeriod);
                    const netMACDData = macdNetData.macd.map((v, i) => [rows[i][timestampHeader], v]);
                    const netSignalData = macdNetData.signal.map((v, i) => [rows[i][timestampHeader], v]);
                    const netHistogramData = macdNetData.histogram.map((v, i) => [rows[i][timestampHeader], v]);
                    return {
                        animation: true, animationDuration: 100, animationEasing: 'cubicOut', animationDurationUpdate: 0, backgroundColor: 'transparent', tooltip: commonTooltip,
                        legend: { data: ['Net MACD', 'Net Signal', 'Net Histogram'], textStyle: { color: '#e0e0e0', fontSize: 10 }, top: 5 },
                        grid: commonGrid, xAxis: commonXAxis, yAxis: { ...commonYAxis, name: 'MACD Neto (Call - Put)', nameTextStyle: { color: '#909090', fontSize: 10 } },
                        dataZoom: [{ type: 'inside', start: config.zoomState.start, end: config.zoomState.end, zoomOnMouseWheel: true, moveOnMouseMove: true }],
                        series: [
                            { name: 'Net MACD', type: 'line', data: netMACDData, showSymbol: false, smooth: true, lineStyle: { color: '#909090', width: 2 }, areaStyle: { color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [{ offset: 0, color: 'rgba(144, 144, 144, 0.35)' }, { offset: 1, color: 'rgba(144, 144, 144, 0.02)' }]) }, z: 3 },
                            { name: 'Net Signal', type: 'line', data: netSignalData, showSymbol: false, smooth: true, lineStyle: { color: 'rgba(255, 255, 255, 0.6)', width: 1.2 }, z: 2 },
                            { name: 'Net Histogram', type: 'bar', data: netHistogramData, itemStyle: { color: (params) => params.value[1] >= 0 ? 'rgba(74, 158, 255, 0.4)' : 'rgba(255, 68, 68, 0.4)' }, barWidth: '60%', z: 1 }
                        ]
                    };
                }
                return {};
            };
            const getTugOfWarOption = (config, dataSource, towData) => {
                if (!towData || !towData.bullishForce || !towData.bearishForce || !towData.netForce) return {};
                const { rows, timestampHeader } = dataSource;
                const timestamps = rows.map(r => r[timestampHeader]);
                const bullishForceData = towData.bullishForce.map((v, i) => [timestamps[i], v]);
                const bearishForceData = towData.bearishForce.map((v, i) => [timestamps[i], v]);
                const netForceData = towData.netForce.map((v, i) => [timestamps[i], v]);

                // Colores personalizados
                const callColor = config.parameters?.callColor || '#4a9eff';
                const putColor = config.parameters?.putColor || '#ff4444';
                const smaPeriod = config.parameters?.smaPeriod || 14;

                // Helper para convertir hex a rgba
                const hexToRgba = (hex, alpha) => {
                    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                    if (!result) return `rgba(74, 158, 255, ${alpha})`;
                    return `rgba(${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)}, ${alpha})`;
                };

                // Calcular SMA
                const smaData = [];
                for (let i = 0; i < towData.netForce.length; i++) {
                    let sma = towData.netForce[i];
                    if (i >= smaPeriod - 1) {
                        let sum = 0;
                        for (let j = 0; j < smaPeriod; j++) sum += towData.netForce[i - j];
                        sma = sum / smaPeriod;
                    }
                    smaData.push([timestamps[i], sma]);
                }

                // Grid espec√≠fico para TOW
                const towGrid = { left: 50, right: 18, top: 30, bottom: 25, containLabel: false };
                const commonSettings = { animation: true, animationDuration: 100, animationEasing: 'cubicOut', animationDurationUpdate: 0, backgroundColor: 'transparent', tooltip: commonTooltip, xAxis: commonXAxis, yAxis: commonYAxis, dataZoom: [{ type: 'inside', start: config.zoomState.start, end: config.zoomState.end, zoomOnMouseWheel: true, moveOnMouseMove: true }] };
                if (config.type.endsWith('-dual')) {
                    return {
                        ...commonSettings, legend: { data: ['Bullish Force', 'Bearish Force'], textStyle: { color: '#e8e8e8' }, top: 5 }, grid: towGrid,
                        series: [
                            { name: 'Bullish Force', type: 'line', data: bullishForceData, showSymbol: false, smooth: true, lineStyle: { color: callColor, width: 2 }, areaStyle: { color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [{ offset: 0, color: hexToRgba(callColor, 0.3) }, { offset: 1, color: hexToRgba(callColor, 0.02) }]) } },
                            { name: 'Bearish Force', type: 'line', data: bearishForceData, showSymbol: false, smooth: true, lineStyle: { color: putColor, width: 2 }, areaStyle: { color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [{ offset: 0, color: hexToRgba(putColor, 0.3) }, { offset: 1, color: hexToRgba(putColor, 0.02) }]) } }
                        ]
                    };
                }
                if (config.type.endsWith('-net')) {
                    return {
                        ...commonSettings,
                        legend: { data: ['Net Force', 'SMA'], textStyle: { color: '#e8e8e8' }, top: 5 },
                        grid: towGrid,
                        series: [
                            { name: 'Net Force', type: 'line', data: netForceData, showSymbol: false, smooth: true, lineStyle: { color: '#909090', width: 2 }, areaStyle: { color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [{ offset: 0, color: 'rgba(144, 144, 144, 0.3)' }, { offset: 1, color: 'rgba(144, 144, 144, 0.02)' }]) } },
                            { name: 'SMA', type: 'line', data: smaData, showSymbol: false, smooth: true, lineStyle: { color: 'rgba(150, 150, 150, 0.6)', width: 1.5 } }
                        ]
                    };
                }
                if (config.type.endsWith('-panel')) {
                    const netForceSmaData = towData.netForceSma.map((v, i) => [timestamps[i], v]);
                    return {
                        ...commonSettings,
                        legend: { data: ['Bullish Force', 'Bearish Force', 'Net Force', 'Signal Line'], textStyle: { color: '#e8e8e8' }, top: 5 },
                        grid: [{ ...towGrid, height: '45%' }, { ...towGrid, top: '55%', height: '38%' }],
                        xAxis: [{ ...commonXAxis, gridIndex: 0, axisLabel: { ...commonXAxis.axisLabel, show: false } }, { ...commonXAxis, gridIndex: 1 }],
                        yAxis: [{ ...commonYAxis, gridIndex: 0 }, { ...commonYAxis, gridIndex: 1 }],
                        dataZoom: [{ type: 'inside', xAxisIndex: [0, 1], start: config.zoomState.start, end: config.zoomState.end, zoomOnMouseWheel: true, moveOnMouseMove: true }],
                        series: [
                            { name: 'Bullish Force', type: 'line', data: bullishForceData, xAxisIndex: 0, yAxisIndex: 0, showSymbol: false, smooth: true, lineStyle: { color: callColor, width: 2 }, areaStyle: { color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [{ offset: 0, color: hexToRgba(callColor, 0.3) }, { offset: 1, color: hexToRgba(callColor, 0.02) }]) } },
                            { name: 'Bearish Force', type: 'line', data: bearishForceData, xAxisIndex: 0, yAxisIndex: 0, showSymbol: false, smooth: true, lineStyle: { color: putColor, width: 2 }, areaStyle: { color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [{ offset: 0, color: hexToRgba(putColor, 0.3) }, { offset: 1, color: hexToRgba(putColor, 0.02) }]) } },
                            { name: 'Net Force', type: 'bar', data: netForceData, xAxisIndex: 1, yAxisIndex: 1, itemStyle: { color: (p) => p.value[1] > 0 ? hexToRgba(callColor, 0.5) : hexToRgba(putColor, 0.5) } },
                            { name: 'Signal Line', type: 'line', data: netForceSmaData, xAxisIndex: 1, yAxisIndex: 1, showSymbol: false, smooth: true, lineStyle: { color: 'rgba(150, 150, 150, 0.6)', width: 1.5 } }
                        ]
                    };
                }
                return {};
            };

            // ===== GR√ÅFICOS DE DOMINANCIA DIRECCIONAL =====
            const getDominanceOption = (config, dataSource) => {
                const { rows, timestampHeader } = dataSource;
                if (!rows || rows.length === 0) return {};

                const { calculateDominanceIndex, formatNumber } = services.signalCalculator;
                const lookback = config.parameters.lookback ?? 30;

                // Determinar qu√© columnas usar seg√∫n el tipo
                let callColumn, putColumn, title;
                switch (config.type) {
                    case 'dominance-money-flow':
                        callColumn = 'Call_Money_Flow';
                        putColumn = 'Put_Money_Flow';
                        title = 'Money Flow';
                        break;
                    case 'dominance-delta-flow':
                        callColumn = 'Call_Delta_Flow';
                        putColumn = 'Put_Delta_Flow';
                        title = 'Delta Flow';
                        break;
                    case 'dominance-iv-flow':
                        callColumn = 'Call_IV_Flow';
                        putColumn = 'Put_IV_Flow';
                        title = 'IV Flow';
                        break;
                    case 'dominance-otm-impact':
                        callColumn = 'Call_OTM_Impact';
                        putColumn = 'Put_OTM_Impact';
                        title = 'OTM Impact';
                        break;
                    case 'dominance-itm-impact':
                        callColumn = 'Call_ITM_Impact';
                        putColumn = 'Put_ITM_Impact';
                        title = 'ITM Impact';
                        break;
                    case 'dominance-gex':
                        callColumn = 'Call_GEX';
                        putColumn = 'Put_GEX';
                        title = 'GEX';
                        break;
                    case 'dominance-vanna-flow':
                        callColumn = 'Call_Vanna_Flow';
                        putColumn = 'Put_Vanna_Flow';
                        title = 'Vanna Flow';
                        break;
                    case 'dominance-charm':
                        callColumn = 'Call_Charm';
                        putColumn = 'Put_Charm';
                        title = 'Charm';
                        break;
                    case 'dominance-iv-flow-itm':
                        callColumn = 'Call_IV_Flow_ITM';
                        putColumn = 'Put_IV_Flow_ITM';
                        title = 'IV Flow ITM';
                        break;
                    case 'dominance-iv-flow-otm':
                        callColumn = 'Call_IV_Flow_OTM';
                        putColumn = 'Put_IV_Flow_OTM';
                        title = 'IV Flow OTM';
                        break;
                    case 'dominance-iv-net':
                        callColumn = 'Call_IV_Net';
                        putColumn = 'Put_IV_Net';
                        title = 'IV Net';
                        break;
                    case 'dominance-vol-imbalance':
                        callColumn = 'Call_Vol_Imbalance';
                        putColumn = 'Put_Vol_Imbalance';
                        title = 'Vol Imbalance';
                        break;
                    case 'dominance-smart-money':
                        callColumn = 'Call_Smart_Money';
                        putColumn = 'Put_Smart_Money';
                        title = 'Smart Money';
                        break;
                    case 'dominance-hedge-pressure':
                        callColumn = 'Call_Hedge_Pressure';
                        putColumn = 'Put_Hedge_Pressure';
                        title = 'Hedge Pressure';
                        break;
                    default:
                        return {};
                }

                // Verificar que las columnas existan
                if (!dataSource.headers.includes(callColumn) || !dataSource.headers.includes(putColumn)) {
                    return {};
                }

                // Extraer datos
                const callData = rows.map(r => r[callColumn] || 0);
                const putData = rows.map(r => r[putColumn] || 0);

                // Calcular Dominance Index
                const { rollingCallSums, rollingPutSums } = calculateDominanceIndex(callData, putData, lookback);

                // Preparar datos para el gr√°fico
                const callFlowData = rollingCallSums.map((v, i) => [rows[i][timestampHeader], v]);
                const putFlowData = rollingPutSums.map((v, i) => [rows[i][timestampHeader], v]);

                const callColor = config.parameters?.callColor || '#4a9eff';
                const putColor = config.parameters?.putColor || '#ff4444';

                // Helper para convertir hex a rgba
                const hexToRgba = (hex, alpha) => {
                    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                    if (!result) return `rgba(74, 158, 255, ${alpha})`;
                    return `rgba(${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)}, ${alpha})`;
                };

                return {
                    animation: true,
                    animationDuration: 100,
                    animationEasing: 'cubicOut',
                    animationDurationUpdate: 0,
                    backgroundColor: 'transparent',
                    tooltip: {
                        trigger: 'axis',
                        backgroundColor: 'rgba(20, 20, 20, 0.95)',
                        borderColor: 'rgba(74, 74, 74, 0.6)',
                        textStyle: { color: '#e8e8e8', fontSize: 11 },
                        axisPointer: { type: 'cross', crossStyle: { color: '#666' } },
                        formatter: (params) => {
                            if (!params || params.length === 0) return '';
                            const date = new Date(params[0].axisValue).toLocaleString();
                            let tooltip = `${date}<br/>`;
                            params.forEach((param) => {
                                tooltip += `<span style="display:inline-block;margin-right:5px;border-radius:10px;width:10px;height:10px;background-color:${param.color};"></span>${param.seriesName}: <strong>${formatNumber(param.value[1])}</strong><br/>`;
                            });
                            return tooltip;
                        }
                    },
                    legend: {
                        data: ['Call Flow', 'Put Flow'],
                        textStyle: { color: '#e8e8e8' },
                        top: 5
                    },
                    grid: {
                        left: 50,
                        right: 18,
                        top: 30,
                        bottom: 25,
                        containLabel: false
                    },
                    xAxis: {
                        type: 'time',
                        axisLine: { lineStyle: { color: '#333' } },
                        axisLabel: { color: '#888' },
                        splitLine: { show: false }
                    },
                    yAxis: {
                        type: 'value',
                        scale: true,
                        axisLine: { lineStyle: { color: '#333' } },
                        axisLabel: { color: '#888' },
                        splitLine: { lineStyle: { color: '#222' } }
                    },
                    dataZoom: [
                        {
                            type: 'inside',
                            start: config.zoomState?.start || 0,
                            end: config.zoomState?.end || 100,
                            zoomOnMouseWheel: true,
                            moveOnMouseMove: true
                        }
                    ],
                    series: [
                        {
                            name: 'Call Flow',
                            type: 'line',
                            data: callFlowData,
                            showSymbol: false,
                            smooth: true,
                            lineStyle: { color: callColor, width: 2 },
                            areaStyle: {
                                color: {
                                    type: 'linear',
                                    x: 0, y: 0, x2: 0, y2: 1,
                                    colorStops: [
                                        { offset: 0, color: hexToRgba(callColor, 0.5) },
                                        { offset: 0.5, color: hexToRgba(callColor, 0.2) },
                                        { offset: 1, color: hexToRgba(callColor, 0.02) }
                                    ]
                                }
                            }
                        },
                        {
                            name: 'Put Flow',
                            type: 'line',
                            data: putFlowData,
                            showSymbol: false,
                            smooth: true,
                            lineStyle: { color: putColor, width: 2 },
                            areaStyle: {
                                color: {
                                    type: 'linear',
                                    x: 0, y: 0, x2: 0, y2: 1,
                                    colorStops: [
                                        { offset: 0, color: hexToRgba(putColor, 0.5) },
                                        { offset: 0.5, color: hexToRgba(putColor, 0.2) },
                                        { offset: 1, color: hexToRgba(putColor, 0.02) }
                                    ]
                                }
                            }
                        }
                    ]
                };
            };



            // ===== GR√ÅFICO DE EVOLUTION METRIC (Call + Put + Neto con SMA) =====
            const getEvolutionMetricOption = (config, dataSource) => {
                const { rows, timestampHeader, headers } = dataSource;
                if (!rows || rows.length === 0) return {};

                const { formatNumber } = services.signalCalculator;
                const smaPeriod = config.parameters?.smaPeriod || 14;

                // Determinar columnas seg√∫n el tipo
                let callColumn, putColumn, title;
                switch (config.type) {
                    case 'evo-money-flow':
                        callColumn = 'Call_Money_Flow';
                        putColumn = 'Put_Money_Flow';
                        title = 'Evolution: Money Flow';
                        break;
                    case 'evo-delta-flow':
                        callColumn = 'Call_Delta_Flow';
                        putColumn = 'Put_Delta_Flow';
                        title = 'Evolution: Delta Flow';
                        break;
                    case 'evo-iv-flow':
                        callColumn = 'Call_IV_Flow';
                        putColumn = 'Put_IV_Flow';
                        title = 'Evolution: IV Flow';
                        break;
                    case 'evo-otm-impact':
                        callColumn = 'Call_OTM_Impact';
                        putColumn = 'Put_OTM_Impact';
                        title = 'Evolution: OTM Impact';
                        break;
                    case 'evo-itm-impact':
                        callColumn = 'Call_ITM_Impact';
                        putColumn = 'Put_ITM_Impact';
                        title = 'Evolution: ITM Impact';
                        break;
                    case 'evo-gex':
                        callColumn = 'Call_GEX';
                        putColumn = 'Put_GEX';
                        title = 'Evolution: GEX';
                        break;
                    case 'evo-vanna-flow':
                        callColumn = 'Call_Vanna_Flow';
                        putColumn = 'Put_Vanna_Flow';
                        title = 'Evolution: Vanna Flow';
                        break;
                    case 'evo-charm':
                        callColumn = 'Call_Charm';
                        putColumn = 'Put_Charm';
                        title = 'Evolution: Charm';
                        break;
                    case 'evo-iv-flow-itm':
                        callColumn = 'Call_IV_Flow_ITM';
                        putColumn = 'Put_IV_Flow_ITM';
                        title = 'Evolution: IV Flow ITM';
                        break;
                    case 'evo-iv-flow-otm':
                        callColumn = 'Call_IV_Flow_OTM';
                        putColumn = 'Put_IV_Flow_OTM';
                        title = 'Evolution: IV Flow OTM';
                        break;
                    case 'evo-iv-net':
                        callColumn = 'Call_IV_Net';
                        putColumn = 'Put_IV_Net';
                        title = 'Evolution: IV Net';
                        break;
                    case 'evo-vol-imbalance':
                        callColumn = 'Call_Vol_Imbalance';
                        putColumn = 'Put_Vol_Imbalance';
                        title = 'Evolution: Vol Imbalance';
                        break;
                    case 'evo-smart-money':
                        callColumn = 'Call_Smart_Money';
                        putColumn = 'Put_Smart_Money';
                        title = 'Evolution: Smart Money';
                        break;
                    case 'evo-hedge-pressure':
                        callColumn = 'Call_Hedge_Pressure';
                        putColumn = 'Put_Hedge_Pressure';
                        title = 'Evolution: Hedge Pressure';
                        break;
                    default:
                        return {};
                }

                if (!headers.includes(callColumn) || !headers.includes(putColumn)) {
                    return {};
                }

                // Extraer datos
                const callData = rows.map(r => r[callColumn] || 0);
                const putData = rows.map(r => r[putColumn] || 0);
                const netoData = rows.map((r, i) => callData[i] - putData[i]);
                const timestamps = rows.map(r => r[timestampHeader]);

                // Calcular SMA del Neto
                const netoSMA = [];
                for (let i = 0; i < netoData.length; i++) {
                    if (i < smaPeriod - 1) {
                        netoSMA.push(null);
                    } else {
                        let sum = 0;
                        for (let j = 0; j < smaPeriod; j++) {
                            sum += netoData[i - j];
                        }
                        netoSMA.push(sum / smaPeriod);
                    }
                }

                const COLORS = {
                    CALL: config.parameters?.callColor || '#4a9eff',
                    PUT: config.parameters?.putColor || '#ff4444',
                    NETO: '#909090',
                    SMA: '#ffcc00'
                };

                return {
                    animation: true,
                    animationDuration: 100,
                    animationEasing: 'cubicOut',
                    backgroundColor: 'transparent',
                    tooltip: {
                        trigger: 'axis',
                        backgroundColor: 'rgba(20, 20, 20, 0.95)',
                        borderColor: '#333',
                        textStyle: { color: '#fff', fontSize: 12 },
                        axisPointer: { type: 'cross' },
                        formatter: (params) => {
                            if (!params || params.length === 0) return '';
                            const time = new Date(params[0].axisValue).toLocaleString();
                            let html = `<div style="font-weight:bold;">${time}</div>`;
                            params.forEach(p => {
                                html += `<div style="margin-top:4px;">
                                    <span style="display:inline-block;width:10px;height:10px;border-radius:50%;background:${p.color};margin-right:5px;"></span>
                                    ${p.seriesName}: <strong>${formatNumber(p.value[1])}</strong>
                                </div>`;
                            });
                            return html;
                        }
                    },
                    legend: {
                        data: ['Call', 'Put', 'Neto', `SMA(${smaPeriod})`],
                        textStyle: { color: '#999' },
                        top: 5
                    },
                    grid: {
                        left: 50,
                        right: 18,
                        top: 40,
                        bottom: 30,
                        containLabel: false
                    },
                    xAxis: {
                        type: 'time',
                        axisLine: { lineStyle: { color: '#333' } },
                        axisLabel: { color: '#888', fontSize: 10, formatter: (val) => new Date(val).toLocaleTimeString() },
                        splitLine: { show: false }
                    },
                    yAxis: {
                        type: 'value',
                        axisLine: { lineStyle: { color: '#333' } },
                        axisLabel: { color: '#888', fontSize: 10, formatter: (val) => formatNumber(val) },
                        splitLine: { lineStyle: { color: '#222' } }
                    },
                    dataZoom: [{ type: 'inside', start: config.zoomState?.start || 0, end: config.zoomState?.end || 100, zoomOnMouseWheel: true, moveOnMouseMove: true }],
                    series: [
                        {
                            name: 'Call',
                            type: 'line',
                            data: timestamps.map((t, i) => [t, callData[i]]),
                            smooth: true,
                            showSymbol: false,
                            lineStyle: { width: 1.8, color: COLORS.CALL },
                            areaStyle: { color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [{ offset: 0, color: 'rgba(74, 158, 255, 0.25)' }, { offset: 1, color: 'rgba(74, 158, 255, 0.01)' }]) }
                        },
                        {
                            name: 'Put',
                            type: 'line',
                            data: timestamps.map((t, i) => [t, putData[i]]),
                            smooth: true,
                            showSymbol: false,
                            lineStyle: { width: 1.8, color: COLORS.PUT },
                            areaStyle: { color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [{ offset: 0, color: 'rgba(255, 68, 68, 0.25)' }, { offset: 1, color: 'rgba(255, 68, 68, 0.01)' }]) }
                        },
                        {
                            name: 'Neto',
                            type: 'line',
                            data: timestamps.map((t, i) => [t, netoData[i]]),
                            smooth: true,
                            showSymbol: false,
                            lineStyle: { width: 2, color: COLORS.NETO },
                            areaStyle: { color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [{ offset: 0, color: 'rgba(144, 144, 144, 0.2)' }, { offset: 1, color: 'rgba(144, 144, 144, 0.01)' }]) }
                        },
                        {
                            name: `SMA(${smaPeriod})`,
                            type: 'line',
                            data: timestamps.map((t, i) => [t, netoSMA[i]]),
                            smooth: true,
                            showSymbol: false,
                            lineStyle: { width: 2, color: COLORS.SMA, type: 'solid', opacity: 0.7 },
                            areaStyle: { color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [{ offset: 0, color: 'rgba(255, 204, 0, 0.12)' }, { offset: 0.7, color: 'rgba(255, 204, 0, 0.04)' }, { offset: 1, color: 'rgba(255, 204, 0, 0.01)' }]) }
                        }
                    ]
                };
            };

            // ===== GR√ÅFICO DE INTENSITY (basado en NinjaTrader) =====
            const getIntensityOption = (config, dataSource) => {
                const { rows, timestampHeader, headers } = dataSource;
                if (!rows || rows.length === 0) return {};

                const { formatNumber } = services.signalCalculator;
                const smaPeriod = config.parameters?.smaPeriod || 8;

                // Determinar columnas seg√∫n el tipo
                let callColumn, putColumn, title;
                switch (config.type) {
                    case 'intensity-money-flow':
                        callColumn = 'Call_Money_Flow';
                        putColumn = 'Put_Money_Flow';
                        title = 'Money Flow Intensity';
                        break;
                    case 'intensity-delta-flow':
                        callColumn = 'Call_Delta_Flow';
                        putColumn = 'Put_Delta_Flow';
                        title = 'Delta Flow Intensity';
                        break;
                    case 'intensity-iv-flow':
                        callColumn = 'Call_IV_Flow';
                        putColumn = 'Put_IV_Flow';
                        title = 'IV Flow Intensity';
                        break;
                    case 'intensity-otm-impact':
                        callColumn = 'Call_OTM_Impact';
                        putColumn = 'Put_OTM_Impact';
                        title = 'OTM Impact Intensity';
                        break;
                    case 'intensity-itm-impact':
                        callColumn = 'Call_ITM_Impact';
                        putColumn = 'Put_ITM_Impact';
                        title = 'ITM Impact Intensity';
                        break;
                    case 'intensity-gex':
                        callColumn = 'Call_GEX';
                        putColumn = 'Put_GEX';
                        title = 'GEX Intensity';
                        break;
                    case 'intensity-vanna-flow':
                        callColumn = 'Call_Vanna_Flow';
                        putColumn = 'Put_Vanna_Flow';
                        title = 'Vanna Flow Intensity';
                        break;
                    case 'intensity-charm':
                        callColumn = 'Call_Charm';
                        putColumn = 'Put_Charm';
                        title = 'Charm Intensity';
                        break;
                    case 'intensity-iv-flow-itm':
                        callColumn = 'Call_IV_Flow_ITM';
                        putColumn = 'Put_IV_Flow_ITM';
                        title = 'IV Flow ITM Intensity';
                        break;
                    case 'intensity-iv-flow-otm':
                        callColumn = 'Call_IV_Flow_OTM';
                        putColumn = 'Put_IV_Flow_OTM';
                        title = 'IV Flow OTM Intensity';
                        break;
                    case 'intensity-iv-net':
                        callColumn = 'Call_IV_Net';
                        putColumn = 'Put_IV_Net';
                        title = 'IV Net Intensity';
                        break;
                    case 'intensity-vol-imbalance':
                        callColumn = 'Call_Vol_Imbalance';
                        putColumn = 'Put_Vol_Imbalance';
                        title = 'Vol Imbalance Intensity';
                        break;
                    case 'intensity-smart-money':
                        callColumn = 'Call_Smart_Money';
                        putColumn = 'Put_Smart_Money';
                        title = 'Smart Money Intensity';
                        break;
                    case 'intensity-hedge-pressure':
                        callColumn = 'Call_Hedge_Pressure';
                        putColumn = 'Put_Hedge_Pressure';
                        title = 'Hedge Pressure Intensity';
                        break;
                    default:
                        return {};
                }

                if (!headers.includes(callColumn) || !headers.includes(putColumn)) {
                    return {};
                }

                // Extraer datos
                const callData = rows.map(r => Math.abs(r[callColumn] || 0));
                const putData = rows.map(r => Math.abs(r[putColumn] || 0));
                const timestamps = rows.map(r => r[timestampHeader]);

                // Calcular intensidades (algoritmo de NinjaTrader)
                const callIntensity = [];
                const putIntensity = [];

                for (let i = 0; i < rows.length; i++) {
                    const call = callData[i];
                    const put = putData[i];
                    const total = call + put;

                    if (total > 0) {
                        // Calcular imbalance: (call - put) / total * 100
                        const imbalance = ((call - put) / total) * 100;
                        const absImbalance = Math.abs(imbalance);

                        if (imbalance > 0) {
                            // Call dominant
                            callIntensity.push([timestamps[i], call * (absImbalance / 100)]);
                            putIntensity.push([timestamps[i], 0]);
                        } else if (imbalance < 0) {
                            // Put dominant
                            callIntensity.push([timestamps[i], 0]);
                            putIntensity.push([timestamps[i], put * (absImbalance / 100)]);
                        } else {
                            callIntensity.push([timestamps[i], 0]);
                            putIntensity.push([timestamps[i], 0]);
                        }
                    } else {
                        callIntensity.push([timestamps[i], 0]);
                        putIntensity.push([timestamps[i], 0]);
                    }
                }

                // Calcular SMAs
                const callSMA = [];
                const putSMA = [];

                for (let i = 0; i < callIntensity.length; i++) {
                    if (i < smaPeriod - 1) {
                        callSMA.push([timestamps[i], 0]);
                        putSMA.push([timestamps[i], 0]);
                    } else {
                        let callSum = 0;
                        let putSum = 0;
                        for (let j = 0; j < smaPeriod; j++) {
                            callSum += callIntensity[i - j][1];
                            putSum += putIntensity[i - j][1];
                        }
                        callSMA.push([timestamps[i], callSum / smaPeriod]);
                        putSMA.push([timestamps[i], putSum / smaPeriod]);
                    }
                }

                const COLORS = {
                    CALL: config.parameters?.callColor || '#4a9eff',
                    PUT: config.parameters?.putColor || '#ff4444',
                    CALL_SMA: config.parameters?.callColor ? adjustColor(config.parameters.callColor, -30) : '#1e90ff',
                    PUT_SMA: config.parameters?.putColor ? adjustColor(config.parameters.putColor, -30) : '#dc143c'
                };

                // Helper para ajustar brillo del color
                function adjustColor(hex, percent) {
                    const num = parseInt(hex.replace('#', ''), 16);
                    const amt = Math.round(2.55 * percent);
                    const R = Math.max(0, Math.min(255, (num >> 16) + amt));
                    const G = Math.max(0, Math.min(255, ((num >> 8) & 0x00FF) + amt));
                    const B = Math.max(0, Math.min(255, (num & 0x0000FF) + amt));
                    return '#' + (0x1000000 + (R << 16) + (G << 8) + B).toString(16).slice(1);
                }

                return {
                    animation: true,
                    animationDuration: 100,
                    animationEasing: 'cubicOut',
                    backgroundColor: 'transparent',
                    tooltip: {
                        trigger: 'axis',
                        backgroundColor: 'rgba(20, 20, 20, 0.95)',
                        borderColor: '#333',
                        textStyle: { color: '#fff', fontSize: 12 },
                        axisPointer: { type: 'cross' },
                        formatter: (params) => {
                            if (!params || params.length === 0) return '';
                            const time = new Date(params[0].axisValue).toLocaleString();
                            let html = `<div style="font-weight:bold;">${time}</div>`;
                            params.forEach(p => {
                                if (p.value[1] > 0) {
                                    html += `<div style="margin-top:4px;">
                                        <span style="display:inline-block;width:10px;height:10px;border-radius:50%;background:${p.color};margin-right:5px;"></span>
                                        ${p.seriesName}: <strong>${formatNumber(p.value[1])}</strong>
                                    </div>`;
                                }
                            });
                            return html;
                        }
                    },
                    legend: {
                        data: ['Call Intensity', 'Put Intensity', 'Call SMA', 'Put SMA'],
                        textStyle: { color: '#999' },
                        top: 5
                    },
                    grid: {
                        left: 50,
                        right: 18,
                        top: 40,
                        bottom: 30,
                        containLabel: false
                    },
                    xAxis: {
                        type: 'time',
                        boundaryGap: false,
                        axisLine: { lineStyle: { color: '#333' } },
                        axisLabel: { color: '#999', fontSize: 10 },
                        splitLine: { show: false }
                    },
                    yAxis: {
                        type: 'value',
                        name: title,
                        nameTextStyle: { color: '#999', fontSize: 11 },
                        axisLine: { lineStyle: { color: '#333' } },
                        axisLabel: {
                            color: '#999',
                            fontSize: 10,
                            formatter: (v) => formatNumber(v)
                        },
                        splitLine: { lineStyle: { color: '#222' } }
                    },
                    dataZoom: [{ type: 'inside', start: config.zoomState?.start || 0, end: config.zoomState?.end || 100, zoomOnMouseWheel: true, moveOnMouseMove: true }],
                    series: [
                        {
                            name: 'Call Intensity',
                            type: 'line',
                            data: callIntensity,
                            showSymbol: false,
                            smooth: true,
                            lineStyle: { color: COLORS.CALL, width: 2 },
                            areaStyle: {
                                color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
                                    { offset: 0, color: COLORS.CALL + '66' },
                                    { offset: 1, color: COLORS.CALL + '0D' }
                                ])
                            },
                            z: 2
                        },
                        {
                            name: 'Put Intensity',
                            type: 'line',
                            data: putIntensity,
                            showSymbol: false,
                            smooth: true,
                            lineStyle: { color: COLORS.PUT, width: 2 },
                            areaStyle: {
                                color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
                                    { offset: 0, color: COLORS.PUT + '66' },
                                    { offset: 1, color: COLORS.PUT + '0D' }
                                ])
                            },
                            z: 1
                        },
                        {
                            name: 'Call SMA',
                            type: 'line',
                            data: callSMA,
                            showSymbol: false,
                            smooth: true,
                            lineStyle: { color: 'rgba(150, 150, 150, 0.6)', width: 1.5 },
                            z: 10
                        },
                        {
                            name: 'Put SMA',
                            type: 'line',
                            data: putSMA,
                            showSymbol: false,
                            smooth: true,
                            lineStyle: { color: 'rgba(150, 150, 150, 0.6)', width: 1.5 },
                            z: 10
                        }
                    ]
                };
            };

            // ===== GR√ÅFICO TUG-OF-WAR FORCES (basado en NinjaTrader) =====
            const getTugOfWarMetricOption = (config, dataSource) => {
                const { rows, timestampHeader, headers } = dataSource;
                if (!rows || rows.length === 0) return {};

                const { formatNumber } = services.signalCalculator;

                // Par√°metros del Tug-of-War (como en NinjaTrader)
                const lookback = config.parameters?.towLookback || 20;
                const velocityPeriod = config.parameters?.towVelocityPeriod || 5;
                const signalSmaPeriod = config.parameters?.towSignalSmaPeriod || 8;

                // Determinar columnas seg√∫n el tipo
                let callColumn, putColumn, title;
                switch (config.type) {
                    case 'tow-money-flow':
                        callColumn = 'Call_Money_Flow';
                        putColumn = 'Put_Money_Flow';
                        title = 'Money Flow Tug-of-War';
                        break;
                    case 'tow-delta-flow':
                        callColumn = 'Call_Delta_Flow';
                        putColumn = 'Put_Delta_Flow';
                        title = 'Delta Flow Tug-of-War';
                        break;
                    case 'tow-iv-flow':
                        callColumn = 'Call_IV_Flow';
                        putColumn = 'Put_IV_Flow';
                        title = 'IV Flow Tug-of-War';
                        break;
                    case 'tow-otm-impact':
                        callColumn = 'Call_OTM_Impact';
                        putColumn = 'Put_OTM_Impact';
                        title = 'OTM Impact Tug-of-War';
                        break;
                    case 'tow-itm-impact':
                        callColumn = 'Call_ITM_Impact';
                        putColumn = 'Put_ITM_Impact';
                        title = 'ITM Impact Tug-of-War';
                        break;
                    case 'tow-gex':
                        callColumn = 'Call_GEX';
                        putColumn = 'Put_GEX';
                        title = 'GEX Tug-of-War';
                        break;
                    case 'tow-vanna-flow':
                        callColumn = 'Call_Vanna_Flow';
                        putColumn = 'Put_Vanna_Flow';
                        title = 'Vanna Flow Tug-of-War';
                        break;
                    case 'tow-charm':
                        callColumn = 'Call_Charm';
                        putColumn = 'Put_Charm';
                        title = 'Charm Tug-of-War';
                        break;
                    case 'tow-iv-flow-itm':
                        callColumn = 'Call_IV_Flow_ITM';
                        putColumn = 'Put_IV_Flow_ITM';
                        title = 'IV Flow ITM Tug-of-War';
                        break;
                    case 'tow-iv-flow-otm':
                        callColumn = 'Call_IV_Flow_OTM';
                        putColumn = 'Put_IV_Flow_OTM';
                        title = 'IV Flow OTM Tug-of-War';
                        break;
                    case 'tow-iv-net':
                        callColumn = 'Call_IV_Net';
                        putColumn = 'Put_IV_Net';
                        title = 'IV Net Tug-of-War';
                        break;
                    case 'tow-vol-imbalance':
                        callColumn = 'Call_Vol_Imbalance';
                        putColumn = 'Put_Vol_Imbalance';
                        title = 'Vol Imbalance Tug-of-War';
                        break;
                    case 'tow-smart-money':
                        callColumn = 'Call_Smart_Money';
                        putColumn = 'Put_Smart_Money';
                        title = 'Smart Money Tug-of-War';
                        break;
                    case 'tow-hedge-pressure':
                        callColumn = 'Call_Hedge_Pressure';
                        putColumn = 'Put_Hedge_Pressure';
                        title = 'Hedge Pressure Tug-of-War';
                        break;
                    default:
                        return {};
                }

                if (!headers.includes(callColumn) || !headers.includes(putColumn)) {
                    return {};
                }

                // Extraer datos
                const callValues = rows.map(r => Math.abs(r[callColumn] || 0));
                const putValues = rows.map(r => Math.abs(r[putColumn] || 0));
                const timestamps = rows.map(r => r[timestampHeader]);
                const n = rows.length;

                // 1. Calcular rolling sums directos (para velocity)
                const callRollingSum = new Array(n).fill(0);
                const putRollingSum = new Array(n).fill(0);

                for (let i = 0; i < n; i++) {
                    const start = Math.max(0, i - lookback + 1);
                    let callSum = 0, putSum = 0;
                    for (let j = start; j <= i; j++) {
                        callSum += callValues[j];
                        putSum += putValues[j];
                    }
                    callRollingSum[i] = callSum;
                    putRollingSum[i] = putSum;
                }

                // 2. Calcular velocidades
                const callVelocity = new Array(n).fill(0);
                const putVelocity = new Array(n).fill(0);

                for (let i = velocityPeriod; i < n; i++) {
                    callVelocity[i] = callRollingSum[i] - callRollingSum[i - velocityPeriod];
                    putVelocity[i] = putRollingSum[i] - putRollingSum[i - velocityPeriod];
                }

                // 3. Calcular Forces
                const bullishForce = [];
                const bearishForce = [];
                const netForce = new Array(n).fill(0);

                for (let i = 0; i < n; i++) {
                    const callMom = callVelocity[i];
                    const putMom = putVelocity[i];

                    // BullishForce = max(0, callVelocity) + max(0, -putVelocity)
                    const bf = Math.max(0, callMom) + Math.max(0, -putMom);
                    // BearishForce = max(0, putVelocity) + max(0, -callVelocity)
                    const ef = Math.max(0, putMom) + Math.max(0, -callMom);

                    bullishForce.push([timestamps[i], bf]);
                    bearishForce.push([timestamps[i], ef]);
                    netForce[i] = bf - ef;
                }

                // 4. Calcular SMAs para Bullish y Bearish Forces
                const bullishSMA = [];
                const bearishSMA = [];

                for (let i = 0; i < n; i++) {
                    if (i < signalSmaPeriod - 1) {
                        bullishSMA.push([timestamps[i], bullishForce[i][1]]); // Start with value to avoid gaps or 0
                        bearishSMA.push([timestamps[i], bearishForce[i][1]]);
                    } else {
                        let sumBull = 0;
                        let sumBear = 0;
                        for (let j = 0; j < signalSmaPeriod; j++) {
                            sumBull += bullishForce[i - j][1];
                            sumBear += bearishForce[i - j][1];
                        }
                        bullishSMA.push([timestamps[i], sumBull / signalSmaPeriod]);
                        bearishSMA.push([timestamps[i], sumBear / signalSmaPeriod]);
                    }
                }

                const COLORS = {
                    BULLISH: config.parameters.callColor || '#4a9eff',
                    BEARISH: config.parameters.putColor || '#ff4444',
                    SMA: config.parameters.smaColor || 'rgba(150, 150, 150, 0.6)'
                };

                return {
                    animation: true,
                    animationDuration: 100,
                    animationEasing: 'cubicOut',
                    backgroundColor: 'transparent',
                    tooltip: {
                        trigger: 'axis',
                        backgroundColor: 'rgba(20, 20, 20, 0.95)',
                        borderColor: '#333',
                        textStyle: { color: '#fff', fontSize: 12 },
                        axisPointer: { type: 'cross' },
                        formatter: (params) => {
                            if (!params || params.length === 0) return '';
                            const time = new Date(params[0].axisValue).toLocaleString();
                            let html = `<div style="font-weight:bold;">${time}</div>`;
                            params.forEach(p => {
                                html += `<div style="margin-top:4px;">
                                    <span style="display:inline-block;width:10px;height:10px;border-radius:50%;background:${p.color};margin-right:5px;"></span>
                                    ${p.seriesName}: <strong>${formatNumber(p.value[1])}</strong>
                                </div>`;
                            });
                            return html;
                        }
                    },
                    legend: {
                        data: ['Bullish Force', 'Bullish SMA', 'Bearish Force', 'Bearish SMA'],
                        textStyle: { color: '#999' },
                        top: 5
                    },
                    grid: {
                        left: 50,
                        right: 18,
                        top: 40,
                        bottom: 30,
                        containLabel: false
                    },
                    xAxis: {
                        type: 'time',
                        boundaryGap: false,
                        axisLine: { lineStyle: { color: '#333' } },
                        axisLabel: { color: '#999', fontSize: 10 },
                        splitLine: { show: false }
                    },
                    yAxis: {
                        type: 'value',
                        name: title,
                        nameTextStyle: { color: '#999', fontSize: 11 },
                        axisLine: { lineStyle: { color: '#333' } },
                        axisLabel: {
                            color: '#999',
                            fontSize: 10,
                            formatter: (v) => formatNumber(v)
                        },
                        splitLine: { lineStyle: { color: '#222' } }
                    },
                    dataZoom: [{ type: 'inside', start: config.zoomState?.start || 0, end: config.zoomState?.end || 100, zoomOnMouseWheel: true, moveOnMouseMove: true }],
                    series: [
                        {
                            name: 'Bullish Force',
                            type: 'line',
                            data: bullishForce,
                            showSymbol: false,
                            smooth: true,
                            lineStyle: { color: COLORS.BULLISH, width: 2 },
                            areaStyle: {
                                color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
                                    { offset: 0, color: COLORS.BULLISH + '66' }, // 40% opacity
                                    { offset: 1, color: COLORS.BULLISH + '0D' }  // 5% opacity
                                ])
                            }
                        },
                        {
                            name: 'Bullish SMA',
                            type: 'line',
                            data: bullishSMA,
                            showSymbol: false,
                            smooth: true,
                            lineStyle: { color: 'rgba(150, 150, 150, 0.6)', width: 1.5 },
                            z: 10
                        },
                        {
                            name: 'Bearish Force',
                            type: 'line',
                            data: bearishForce,
                            showSymbol: false,
                            smooth: true,
                            lineStyle: { color: COLORS.BEARISH, width: 2 },
                            areaStyle: {
                                color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
                                    { offset: 0, color: COLORS.BEARISH + '66' },
                                    { offset: 1, color: COLORS.BEARISH + '0D' }
                                ])
                            }
                        },
                        {
                            name: 'Bearish SMA',
                            type: 'line',
                            data: bearishSMA,
                            showSymbol: false,
                            smooth: true,
                            lineStyle: { color: 'rgba(150, 150, 150, 0.6)', width: 1.5 },
                            z: 10
                        }
                    ]
                };
            };

            // ===== MODIFIED Z-SCORE =====
            // Oscilador normalizado que muestra lecturas extremas usando mediana y MAD
            const getCombinedOption = (config, dataSource) => {
                const { rows, timestampHeader, headers } = dataSource;
                if (!rows || rows.length === 0) return {};

                const lookbackPeriod = config.parameters?.lookback ?? 50;

                // Mapeo de columnas seg√∫n el tipo de chart
                let putCol, callCol, title;
                switch (config.type) {
                    case 'combined-money-flow':
                        putCol = 'Put_Money_Flow';
                        callCol = 'Call_Money_Flow';
                        title = 'Z-Score Money Flow';
                        break;
                    case 'combined-delta-flow':
                        putCol = 'Put_Delta_Flow';
                        callCol = 'Call_Delta_Flow';
                        title = 'Z-Score Delta Flow';
                        break;
                    case 'combined-iv-flow':
                        putCol = 'Put_IV_Flow';
                        callCol = 'Call_IV_Flow';
                        title = 'Z-Score IV Flow';
                        break;
                    case 'combined-otm-impact':
                        putCol = 'Put_OTM_Impact';
                        callCol = 'Call_OTM_Impact';
                        title = 'Z-Score OTM Impact';
                        break;
                    case 'combined-itm-impact':
                        putCol = 'Put_ITM_Impact';
                        callCol = 'Call_ITM_Impact';
                        title = 'Z-Score ITM Impact';
                        break;
                    case 'combined-gex':
                        putCol = 'Put_GEX';
                        callCol = 'Call_GEX';
                        title = 'Z-Score GEX';
                        break;
                    case 'combined-vanna-flow':
                        putCol = 'Put_Vanna_Flow';
                        callCol = 'Call_Vanna_Flow';
                        title = 'Z-Score Vanna Flow';
                        break;
                    case 'combined-charm':
                        putCol = 'Put_Charm';
                        callCol = 'Call_Charm';
                        title = 'Z-Score Charm';
                        break;
                    case 'combined-iv-flow-itm':
                        putCol = 'Put_IV_Flow_ITM';
                        callCol = 'Call_IV_Flow_ITM';
                        title = 'Z-Score IV Flow ITM';
                        break;
                    case 'combined-iv-flow-otm':
                        putCol = 'Put_IV_Flow_OTM';
                        callCol = 'Call_IV_Flow_OTM';
                        title = 'Z-Score IV Flow OTM';
                        break;
                    case 'combined-iv-net':
                        putCol = 'Put_IV_Net';
                        callCol = 'Call_IV_Net';
                        title = 'Z-Score IV Net';
                        break;
                    case 'combined-vol-imbalance':
                        putCol = 'Put_Vol_Imbalance';
                        callCol = 'Call_Vol_Imbalance';
                        title = 'Z-Score Vol Imbalance';
                        break;
                    case 'combined-smart-money':
                        putCol = 'Put_Smart_Money';
                        callCol = 'Call_Smart_Money';
                        title = 'Z-Score Smart Money';
                        break;
                    case 'combined-hedge-pressure':
                        putCol = 'Put_Hedge_Pressure';
                        callCol = 'Call_Hedge_Pressure';
                        title = 'Z-Score Hedge Pressure';
                        break;
                    default:
                        putCol = 'Put_Money_Flow';
                        callCol = 'Call_Money_Flow';
                        title = 'Z-Score Money Flow';
                }

                // Obtener datos
                const getColumnData = (colName) => {
                    if (!headers.includes(colName)) return null;
                    return rows.map(r => r[colName] || 0);
                };

                const putData = getColumnData(putCol);
                const callData = getColumnData(callCol);

                if (!putData || !callData) return {};

                const n = rows.length;
                const period = lookbackPeriod;

                // Calcular Net Flow (Call - Put) para el Z-Score
                const netFlow = callData.map((c, i) => c - putData[i]);

                // Funci√≥n para calcular mediana de un array
                const median = (arr) => {
                    const sorted = [...arr].sort((a, b) => a - b);
                    const mid = Math.floor(sorted.length / 2);
                    return sorted.length % 2 !== 0 ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) / 2;
                };

                // Funci√≥n para calcular Mean Absolute Deviation around Median
                const mad = (arr, med) => {
                    const absDeviations = arr.map(v => Math.abs(v - med));
                    return absDeviations.reduce((a, b) => a + b, 0) / arr.length;
                };

                // Calcular Modified Z-Score solo para Net Flow
                const zScoreNet = [];

                for (let i = 0; i < n; i++) {
                    const start = Math.max(0, i - period + 1);
                    const windowNet = netFlow.slice(start, i + 1);
                    const medNet = median(windowNet);
                    const madNet = mad(windowNet, medNet) || 1;
                    const zNet = (netFlow[i] - medNet) / madNet;
                    zScoreNet.push(Math.max(-5, Math.min(5, zNet)));
                }

                // Preparar datos para ECharts
                const timestamps = rows.map(r => r[timestampHeader]);

                return {
                    animation: true,
                    animationDuration: 100,
                    backgroundColor: 'transparent',
                    tooltip: {
                        trigger: 'axis',
                        backgroundColor: 'rgba(20, 20, 20, 0.95)',
                        borderColor: '#333',
                        textStyle: { color: '#fff', fontSize: 11 },
                        axisPointer: { type: 'cross' },
                        formatter: (params) => {
                            if (!params || params.length === 0) return '';
                            const time = new Date(params[0].axisValue).toLocaleString();
                            let html = `<div style="font-weight:bold;margin-bottom:4px;">${time}</div>`;
                            params.forEach(p => {
                                if (p.value[1] !== null && p.seriesName !== '+2œÉ' && p.seriesName !== '-2œÉ' && p.seriesName !== 'Zero') {
                                    const val = p.value[1].toFixed(2);
                                    let signal = '';
                                    if (p.value[1] > 2) signal = ' BULLISH';
                                    else if (p.value[1] < -2) signal = ' üîª BEARISH';
                                    html += `<div style="margin:2px 0;">
                                        <span style="display:inline-block;width:10px;height:10px;border-radius:50%;background:${p.color};margin-right:5px;"></span>
                                        ${p.seriesName}: <strong>${val}</strong>${signal}
                                    </div>`;
                                }
                            });
                            return html;
                        }
                    },
                    legend: {
                        data: ['Z-Score'],
                        textStyle: { color: '#999', fontSize: 10 },
                        top: 5,
                        right: 10
                    },
                    grid: {
                        left: 50,
                        right: 18,
                        top: 40,
                        bottom: 30
                    },
                    dataZoom: [
                        {
                            type: 'inside',
                            xAxisIndex: 0,
                            start: 0,
                            end: 100,
                            zoomOnMouseWheel: true,
                            moveOnMouseMove: true
                        }
                    ],
                    xAxis: {
                        type: 'time',
                        boundaryGap: false,
                        axisLine: { lineStyle: { color: '#333' } },
                        axisLabel: { color: '#666', fontSize: 9 },
                        splitLine: { show: false }
                    },
                    yAxis: {
                        type: 'value',
                        name: title,
                        nameTextStyle: { color: '#888', fontSize: 10 },
                        min: -5,
                        max: 5,
                        axisLine: { lineStyle: { color: '#333' } },
                        axisLabel: { color: '#888', fontSize: 10 },
                        splitLine: { lineStyle: { color: '#222', type: 'dashed' } }
                    },
                    series: [
                        // Zona +2 (Bullish extremo)
                        {
                            name: '+2œÉ',
                            type: 'line',
                            data: timestamps.map(t => [t, 2]),
                            showSymbol: false,
                            lineStyle: { color: 'rgba(150, 150, 150, 0.6)', width: 1.5 },
                            z: 0,
                            silent: true
                        },
                        // Zona -2 (Bearish extremo)
                        {
                            name: '-2œÉ',
                            type: 'line',
                            data: timestamps.map(t => [t, -2]),
                            showSymbol: false,
                            lineStyle: { color: 'rgba(150, 150, 150, 0.6)', width: 1.5 },
                            z: 0,
                            silent: true
                        },
                        // L√≠nea cero
                        {
                            name: 'Zero',
                            type: 'line',
                            data: timestamps.map(t => [t, 0]),
                            showSymbol: false,
                            lineStyle: { color: '#555', width: 1, type: 'solid' },
                            z: 0,
                            silent: true
                        },
                        // Z-Score Net - Blanco (principal)
                        {
                            name: 'Z-Score',
                            type: 'line',
                            data: zScoreNet.map((v, i) => [timestamps[i], v]),
                            showSymbol: false,
                            smooth: true,
                            lineStyle: { color: '#ffffff', width: 2 },
                            areaStyle: {
                                color: {
                                    type: 'linear',
                                    x: 0, y: 0, x2: 0, y2: 1,
                                    colorStops: [
                                        { offset: 0, color: 'rgba(33, 150, 243, 0.3)' },
                                        { offset: 0.5, color: 'rgba(255, 255, 255, 0.05)' },
                                        { offset: 1, color: 'rgba(204, 51, 51, 0.3)' }
                                    ]
                                }
                            },
                            z: 3
                        }
                    ]
                };
            };

            // ===== GR√ÅFICOS DE RATIOS =====
            const getRatioOption = (config, dataSource) => {
                const { rows, timestampHeader, headers } = dataSource;
                if (!rows || rows.length === 0) return {};

                const { formatNumber } = services.signalCalculator;

                let column, title, color;
                switch (config.type) {
                    case 'ratio-mf':
                        column = 'MF_Ratio';
                        title = 'MF Ratio';
                        color = '#f0ad4e';
                        break;
                    case 'ratio-df':
                        column = 'DF_Ratio';
                        title = 'DF Ratio';
                        color = '#5bc0de';
                        break;
                    case 'ratio-ivf':
                        column = 'IVF_Ratio';
                        title = 'IVF Ratio';
                        color = '#d9534f';
                        break;
                    case 'ratio-vanna':
                        column = 'Vanna_Ratio';
                        title = 'Vanna Ratio';
                        color = '#9b59b6';
                        break;
                    case 'ratio-iv-net':
                        column = 'IV_Net';
                        title = 'IV Net';
                        color = '#1abc9c';
                        break;
                    case 'ratio-vol-imbalance':
                        column = 'Vol_Imbalance_Ratio';
                        title = 'Vol Imbalance Ratio';
                        color = '#e67e22';
                        break;
                    case 'ratio-smart-money':
                        column = 'Smart_Money_Ratio';
                        title = 'Smart Money Ratio';
                        color = '#f39c12';
                        break;
                    case 'ratio-skew-pressure':
                        column = 'Skew_Pressure';
                        title = 'Skew Pressure';
                        color = '#e74c3c';
                        break;
                    case 'ratio-skew-intensity':
                        column = 'Skew_Intensity';
                        title = 'Skew Intensity';
                        color = '#c0392b';
                        break;
                    case 'ratio-cash-net':
                        column = 'Cash_Net';
                        title = 'Cash Net';
                        color = '#27ae60';
                        break;
                    default:
                        return {};
                }

                if (!headers.includes(column)) return {};

                const data = rows.map(r => [r[timestampHeader], r[column] || null]);

                return {
                    animation: true,
                    animationDuration: 100,
                    animationEasing: 'cubicOut',
                    backgroundColor: 'transparent',
                    tooltip: {
                        trigger: 'axis',
                        backgroundColor: 'rgba(20, 20, 20, 0.95)',
                        borderColor: 'rgba(74, 74, 74, 0.6)',
                        textStyle: { color: '#e8e8e8', fontSize: 11 },
                        axisPointer: { type: 'cross' },
                        formatter: (params) => {
                            if (!params || params.length === 0) return '';
                            const date = new Date(params[0].axisValue).toLocaleString();
                            const value = params[0].value[1];
                            return `${date}<br/><span style="display:inline-block;margin-right:5px;border-radius:10px;width:10px;height:10px;background-color:${color};"></span>${title}: <strong>${formatNumber(value)}</strong>`;
                        }
                    },
                    legend: { data: [title], textStyle: { color: '#e8e8e8' }, top: 5 },
                    grid: { left: 50, right: 18, top: 30, bottom: 25 },
                    xAxis: { type: 'time', axisLine: { lineStyle: { color: '#333' } }, axisLabel: { color: '#888' }, splitLine: { show: false } },
                    yAxis: { type: 'value', scale: true, axisLine: { lineStyle: { color: '#333' } }, axisLabel: { color: '#888' }, splitLine: { lineStyle: { color: '#222' } } },
                    dataZoom: [{ type: 'inside', start: config.zoomState?.start || 0, end: config.zoomState?.end || 100, zoomOnMouseWheel: true, moveOnMouseMove: true }],
                    series: [{
                        name: title,
                        type: 'line',
                        data: data,
                        showSymbol: false,
                        smooth: true,
                        lineStyle: { color: color, width: 2.5 }
                    }]
                };
            };

            // ===== GR√ÅFICOS DE NETS =====
            // ===== KELTNER CHANNEL para m√©tricas NET =====
            // Canal con EMA central y bandas basadas en ATR
            const getNetOption = (config, dataSource, specialData) => {
                const { rows, timestampHeader, headers } = dataSource;
                if (!rows || rows.length === 0) return {};

                const { formatNumber } = services.signalCalculator;
                // Usar los par√°metros correctos de Keltner
                const lookbackPeriod = config.parameters?.keltnerEmaPeriod ?? 20;
                const atrMultiplier = config.parameters?.keltnerAtrMult ?? 3.0;

                console.log(`üé® getNetOption [${config.type}]: EMA=${lookbackPeriod}, ATR=${atrMultiplier}`);

                let column, title, color;
                switch (config.type) {
                    case 'net-money-flow':
                        column = 'Net_Money_Flow';
                        title = 'Keltner Money Flow';
                        color = '#4a9eff';  // Primary blue
                        break;
                    case 'net-delta-flow':
                        column = 'Net_Delta_Flow';
                        title = 'Keltner Delta Flow';
                        color = '#5eaaff';  // Lighter blue
                        break;
                    case 'net-iv-flow':
                        column = 'Net_IV_Flow';
                        title = 'Keltner IV Flow';
                        color = '#7bbfff';  // Even lighter blue
                        break;
                    case 'net-otm-impact':
                        column = 'Net_OTM_Impact';
                        title = 'Keltner OTM Impact';
                        color = '#ff6b6b';  // Light red
                        break;
                    case 'net-itm-impact':
                        column = 'Net_ITM_Impact';
                        title = 'Keltner ITM Impact';
                        color = '#3d8bff';  // Deep blue
                        break;
                    case 'net-gex':
                        column = 'Net_GEX';
                        title = 'Keltner GEX';
                        color = '#ffd700';  // Gold (neutral)
                        break;
                    case 'net-vanna-flow':
                        column = 'Net_Vanna_Flow';
                        title = 'Keltner Vanna Flow';
                        color = '#8e9eff';  // Soft blue-purple
                        break;
                    case 'net-charm':
                        column = 'Charm_Pressure';
                        title = 'Keltner Charm';
                        color = '#6ecfff';  // Cyan-blue
                        break;
                    case 'net-iv-flow-itm':
                        column = 'Net_IV_Flow_ITM';
                        title = 'Keltner IV Flow ITM';
                        color = '#4dd4ff';  // Bright cyan-blue
                        break;
                    case 'net-iv-flow-otm':
                        column = 'Net_IV_Flow_OTM';
                        title = 'Keltner IV Flow OTM';
                        color = '#66d9ff';  // Light cyan
                        break;
                    case 'net-iv-net':
                        column = 'IV_Net';
                        title = 'Keltner IV Net';
                        color = '#88e0ff';  // Soft cyan
                        break;
                    case 'net-vol-imbalance':
                        column = 'Net_Vol_Imbalance';
                        title = 'Keltner Vol Imbalance';
                        color = '#ff9966';  // Orange-red
                        break;
                    case 'net-smart-money':
                        column = 'Net_Smart_Money';
                        title = 'Keltner Smart Money';
                        color = '#5bc0ff';  // Soft blue
                        break;
                    case 'net-hedge-pressure':
                        column = 'Net_Hedge_Pressure';
                        title = 'Keltner Hedge Pressure';
                        color = '#ff5555';  // Red variant
                        break;
                    default:
                        return {};
                }

                if (!headers.includes(column)) return {};

                const rawData = rows.map(r => r[column] || 0);
                const timestamps = rows.map(r => r[timestampHeader]);
                const n = rawData.length;

                // Calcular EMA (Exponential Moving Average) - L√≠nea central
                const calculateEMA = (data, period) => {
                    const result = [];
                    const multiplier = 2 / (period + 1);
                    let ema = data[0];
                    result.push(ema);
                    for (let i = 1; i < data.length; i++) {
                        ema = (data[i] - ema) * multiplier + ema;
                        result.push(ema);
                    }
                    return result;
                };

                // Calcular ATR (Average True Range) adaptado para flujos
                const calculateATR = (data, period) => {
                    const trueRange = [0];
                    for (let i = 1; i < data.length; i++) {
                        // True Range = diferencia absoluta entre valores consecutivos
                        trueRange.push(Math.abs(data[i] - data[i - 1]));
                    }
                    return calculateEMA(trueRange, period);
                };

                const emaCenter = calculateEMA(rawData, lookbackPeriod);
                const atr = calculateATR(rawData, lookbackPeriod);

                // Bandas del Keltner Channel
                const upperBand = emaCenter.map((ema, i) => ema + (atr[i] * atrMultiplier));
                const lowerBand = emaCenter.map((ema, i) => ema - (atr[i] * atrMultiplier));

                // Helper para colores
                const hexToRgba = (hex, alpha) => {
                    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                    if (!result) return `rgba(255, 255, 255, ${alpha})`;
                    return `rgba(${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)}, ${alpha})`;
                };

                return {
                    animation: true,
                    animationDuration: 100,
                    backgroundColor: 'transparent',
                    tooltip: {
                        trigger: 'axis',
                        backgroundColor: 'rgba(20, 20, 20, 0.95)',
                        borderColor: '#333',
                        textStyle: { color: '#fff', fontSize: 11 },
                        axisPointer: { type: 'cross' },
                        formatter: (params) => {
                            if (!params || params.length === 0) return '';
                            const time = new Date(params[0].axisValue).toLocaleString();
                            let html = `<div style="font-weight:bold;margin-bottom:4px;">${time}</div>`;
                            params.forEach(p => {
                                if (p.value[1] !== null) {
                                    html += `<div style="margin:2px 0;">
                                        <span style="display:inline-block;width:10px;height:10px;border-radius:50%;background:${p.color};margin-right:5px;"></span>
                                        ${p.seriesName}: <strong>${formatNumber(p.value[1])}</strong>
                                    </div>`;
                                }
                            });
                            // A√±adir info de se√±al si est√° disponible
                            if (specialData && specialData.length > 0) {
                                const timeStr = params[0].axisValue;
                                const signalData = specialData.find(s => s.time === timeStr);
                                if (signalData) {
                                    const signalColorMap = { 'BULLISH': '#4a9eff', 'BEARISH': '#ff4444', 'FLAT': '#888888' };
                                    const signalColor = signalColorMap[signalData.state] || '#888888';
                                    const stateLabel = signalData.state === 'FLAT' ? 'LATERAL' : signalData.state;
                                    const bandLabel = signalData.bandPosition === 'ABOVE' ? '‚Üë Encima' : signalData.bandPosition === 'BELOW' ? '‚Üì Debajo' : '‚óã Dentro';
                                    const slopeLabel = signalData.slopeDirection === 'UP' ? 'Subiendo' : signalData.slopeDirection === 'DOWN' ? 'Bajando' : 'Neutral';
                                    html += `<div style="margin-top:4px;padding-top:4px;border-top:1px solid #444;">
                                        <span style="color:${signalColor};font-weight:bold;">Signal: ${stateLabel}</span>
                                        <br/><span style="color:#aaa;font-size:10px;">Banda: ${bandLabel}</span>
                                        <br/><span style="color:#aaa;font-size:10px;">Slope: ${slopeLabel} (${signalData.slope?.toFixed(4) || 0})</span>
                                    </div>`;
                                }
                            }
                            return html;
                        }
                    },
                    legend: {
                        data: ['Value', 'EMA', 'Upper', 'Lower'],
                        textStyle: { color: '#999', fontSize: 10 },
                        top: 5,
                        right: 10
                    },
                    grid: {
                        left: 50,
                        right: 18,
                        top: 40,
                        bottom: 30
                    },
                    dataZoom: [{
                        type: 'inside',
                        start: config.zoomState?.start || 0,
                        end: config.zoomState?.end || 100,
                        zoomOnMouseWheel: true,
                        moveOnMouseMove: true
                    }],
                    xAxis: {
                        type: 'time',
                        boundaryGap: false,
                        axisLine: { lineStyle: { color: '#333' } },
                        axisLabel: { color: '#666', fontSize: 9 },
                        splitLine: { show: false }
                    },
                    yAxis: {
                        type: 'value',
                        name: title,
                        nameTextStyle: { color: '#888', fontSize: 10 },
                        scale: true,
                        axisLine: { lineStyle: { color: '#333' } },
                        axisLabel: { color: '#888', fontSize: 10 },
                        splitLine: { lineStyle: { color: '#222', type: 'dashed' } }
                    },
                    series: [
                        // Banda superior
                        {
                            name: 'Upper',
                            type: 'line',
                            data: upperBand.map((v, i) => [timestamps[i], v]),
                            showSymbol: false,
                            lineStyle: { color: 'rgba(150, 150, 150, 0.6)', width: 1.5 },
                            z: 1
                        },
                        // Banda inferior
                        {
                            name: 'Lower',
                            type: 'line',
                            data: lowerBand.map((v, i) => [timestamps[i], v]),
                            showSymbol: false,
                            lineStyle: { color: 'rgba(150, 150, 150, 0.6)', width: 1.5 },
                            z: 1
                        },
                        // L√≠nea central EMA (sutil)
                        {
                            name: 'EMA',
                            type: 'line',
                            data: emaCenter.map((v, i) => [timestamps[i], v]),
                            showSymbol: false,
                            smooth: true,
                            lineStyle: { color: '#888888', width: 1, opacity: 0.6 },
                            z: 2
                        },
                        // Valor actual (l√≠nea principal)
                        {
                            name: 'Value',
                            type: 'line',
                            data: rawData.map((v, i) => [timestamps[i], v]),
                            showSymbol: false,
                            smooth: false,
                            lineStyle: { color: color, width: 1.5, opacity: 0.8 },
                            z: 3
                        }
                    ]
                };
            };

            // ===== GAUGE / MEDIDOR DE PRESI√ìN para Skew =====
            const getGaugeOption = (config, dataSource) => {
                const { rows, timestampHeader, headers } = dataSource;
                if (!rows || rows.length === 0) return {};

                const { formatNumber } = services.signalCalculator;

                let column, title, unit;
                switch (config.type) {
                    case 'gauge-skew-pressure':
                        column = 'Skew_Pressure';
                        title = 'Skew Pressure';
                        unit = '';
                        break;
                    case 'gauge-skew-intensity':
                        column = 'Skew_Intensity';
                        title = 'Skew Intensity';
                        unit = '';
                        break;
                    case 'gauge-cash-net':
                        column = 'Cash_Net';
                        title = 'Cash Net';
                        unit = '$';
                        break;
                    default:
                        return {};
                }

                if (!headers.includes(column)) return {};

                // Obtener el √∫ltimo valor y calcular min/max hist√≥rico
                const allValues = rows.map(r => r[column] || 0).filter(v => !isNaN(v));
                const currentValue = allValues[allValues.length - 1] || 0;
                const minValue = Math.min(...allValues);
                const maxValue = Math.max(...allValues);
                const range = Math.max(Math.abs(minValue), Math.abs(maxValue));

                // Preparar datos hist√≥ricos para mini-chart
                const timestamps = rows.map(r => r[timestampHeader]);
                const historyData = allValues.map((v, i) => [timestamps[i], v]);

                // Determinar color seg√∫n valor (positivo=bullish, negativo=bearish)
                const getValueColor = (val) => {
                    if (val > 0) return '#2196F3'; // Azul bullish
                    if (val < 0) return '#ff4444'; // Rojo bearish
                    return '#888888'; // Gris neutral
                };

                const valueColor = getValueColor(currentValue);

                // Calcular porcentaje para el gauge (-100 a +100)
                const percentage = range > 0 ? (currentValue / range) * 100 : 0;

                return {
                    animation: true,
                    animationDuration: 500,
                    backgroundColor: 'transparent',
                    tooltip: {
                        trigger: 'item',
                        backgroundColor: 'rgba(20, 20, 20, 0.95)',
                        borderColor: '#333',
                        textStyle: { color: '#fff', fontSize: 11 },
                        formatter: () => {
                            return `<div style="font-weight:bold;margin-bottom:4px;">${title}</div>
                                <div>Current: <strong style="color:${valueColor}">${formatNumber(currentValue)}</strong></div>
                                <div>Min: ${formatNumber(minValue)}</div>
                                <div>Max: ${formatNumber(maxValue)}</div>`;
                        }
                    },
                    grid: [
                        { left: '5%', right: '5%', top: '55%', bottom: '10%' }
                    ],
                    xAxis: [{
                        type: 'time',
                        gridIndex: 0,
                        show: false
                    }],
                    yAxis: [{
                        type: 'value',
                        gridIndex: 0,
                        show: false
                    }],
                    series: [
                        // Gauge principal
                        {
                            name: title,
                            type: 'gauge',
                            center: ['50%', '35%'],
                            radius: '70%',
                            startAngle: 180,
                            endAngle: 0,
                            min: -100,
                            max: 100,
                            splitNumber: 4,
                            pointer: {
                                icon: 'path://M12.8,0.7l12,40.1H0.7L12.8,0.7z',
                                length: '55%',
                                width: 8,
                                offsetCenter: [0, '-10%'],
                                itemStyle: {
                                    color: valueColor
                                }
                            },
                            axisLine: {
                                lineStyle: {
                                    width: 15,
                                    color: [
                                        [0.25, '#ff4444'],  // Bearish fuerte
                                        [0.45, '#ff8888'],  // Bearish leve
                                        [0.55, '#888888'],  // Neutral
                                        [0.75, '#88aaff'],  // Bullish leve
                                        [1, '#2196F3']      // Bullish fuerte
                                    ]
                                }
                            },
                            axisTick: {
                                length: 5,
                                lineStyle: { color: '#666' }
                            },
                            splitLine: {
                                length: 10,
                                lineStyle: { color: '#666', width: 2 }
                            },
                            axisLabel: {
                                color: '#888',
                                fontSize: 10,
                                distance: 20,
                                formatter: (value) => {
                                    if (value === -100) return 'PUT';
                                    if (value === 100) return 'CALL';
                                    if (value === 0) return '0';
                                    return '';
                                }
                            },
                            title: {
                                show: true,
                                offsetCenter: [0, '25%'],
                                fontSize: 12,
                                color: '#999'
                            },
                            detail: {
                                valueAnimation: true,
                                formatter: (val) => formatNumber(currentValue),
                                fontSize: 16,
                                fontWeight: 'bold',
                                color: valueColor,
                                offsetCenter: [0, '50%']
                            },
                            data: [{ value: percentage, name: title }]
                        },
                        // Mini-chart hist√≥rico debajo
                        {
                            name: 'History',
                            type: 'line',
                            xAxisIndex: 0,
                            yAxisIndex: 0,
                            data: historyData,
                            showSymbol: false,
                            smooth: true,
                            lineStyle: { color: '#666', width: 1 },
                            areaStyle: {
                                color: {
                                    type: 'linear',
                                    x: 0, y: 0, x2: 0, y2: 1,
                                    colorStops: [
                                        { offset: 0, color: 'rgba(33, 150, 243, 0.3)' },
                                        { offset: 0.5, color: 'rgba(100, 100, 100, 0.1)' },
                                        { offset: 1, color: 'rgba(255, 68, 68, 0.3)' }
                                    ]
                                }
                            }
                        }
                    ]
                };
            };

            // ===== POWER METER CHART - 5 BARRAS VERTICALES =====
            const getPowerMeterChartOption = (config, dataSource) => {
                const { rows, timestampHeader, headers } = dataSource;
                if (!rows || rows.length === 0) return {};

                const { formatNumber, getMetricsForType } = services.signalCalculator;
                const metrics = getMetricsForType(config.type);
                if (!metrics) return {};

                const callCol = metrics.call;
                const putCol = metrics.put;
                if (!headers.includes(callCol) || !headers.includes(putCol)) return {};

                // Colores
                const callColor = config.parameters?.callColor || '#4a9eff';
                const putColor = config.parameters?.putColor || '#ff4444';
                const netColor = '#ffffff';
                const net60Color = '#00e5ff';
                const net300Color = '#b388ff';

                // Calcular valores actuales
                const n = rows.length;
                const currentCall = parseFloat(rows[n - 1][callCol]) || 0;
                const currentPut = Math.abs(parseFloat(rows[n - 1][putCol])) || 0;
                const currentNet = currentCall - currentPut;

                // Calcular deltas de 60 segundos (din√°mico - busca el m√°s cercano a 60s)
                let delta60Call = 0;
                let delta60Put = 0;
                let delta60Net = 0;
                let pct60Net = 0;
                let actual60Seconds = 0;
                if (n > 1) {
                    const now = new Date(rows[n - 1][timestampHeader]).getTime();
                    let idx60 = 0;
                    let bestDiff60 = Infinity;
                    for (let i = n - 2; i >= 0; i--) {
                        const t = new Date(rows[i][timestampHeader]).getTime();
                        const diff = now - t;
                        if (diff >= 60000) {
                            if (Math.abs(diff - 60000) < bestDiff60) {
                                bestDiff60 = Math.abs(diff - 60000);
                                idx60 = i;
                            }
                            break;
                        }
                        idx60 = i; // Si no hay 60s, usa el m√°s antiguo disponible
                    }
                    const oldCall60 = parseFloat(rows[idx60][callCol]) || 0;
                    const oldPut60 = Math.abs(parseFloat(rows[idx60][putCol])) || 0;
                    const oldNet60 = oldCall60 - oldPut60;
                    delta60Call = currentCall - oldCall60;
                    delta60Put = currentPut - oldPut60;
                    delta60Net = currentNet - oldNet60;
                    pct60Net = oldNet60 !== 0 ? ((delta60Net / Math.abs(oldNet60)) * 100) : 0;
                    actual60Seconds = Math.round((now - new Date(rows[idx60][timestampHeader]).getTime()) / 1000);
                }

                // Calcular deltas de 300 segundos (din√°mico - busca el m√°s cercano a 5min)
                let delta300Net = 0;
                let pct300Net = 0;
                let actual300Seconds = 0;
                if (n > 1) {
                    const now = new Date(rows[n - 1][timestampHeader]).getTime();
                    let idx300 = 0;
                    let bestDiff300 = Infinity;
                    for (let i = n - 2; i >= 0; i--) {
                        const t = new Date(rows[i][timestampHeader]).getTime();
                        const diff = now - t;
                        if (diff >= 300000) {
                            if (Math.abs(diff - 300000) < bestDiff300) {
                                bestDiff300 = Math.abs(diff - 300000);
                                idx300 = i;
                            }
                            break;
                        }
                        idx300 = i; // Si no hay 300s, usa el m√°s antiguo disponible
                    }
                    const oldCall300 = parseFloat(rows[idx300][callCol]) || 0;
                    const oldPut300 = Math.abs(parseFloat(rows[idx300][putCol])) || 0;
                    const oldNet300 = oldCall300 - oldPut300;
                    delta300Net = currentNet - oldNet300;
                    pct300Net = oldNet300 !== 0 ? ((delta300Net / Math.abs(oldNet300)) * 100) : 0;
                    actual300Seconds = Math.round((now - new Date(rows[idx300][timestampHeader]).getTime()) / 1000);
                }

                // Formatear tiempo din√°mico
                const formatTime = (seconds) => {
                    if (seconds < 60) return `${seconds}s`;
                    const mins = Math.floor(seconds / 60);
                    const secs = seconds % 60;
                    return secs > 0 ? `${mins}m${secs}s` : `${mins}m`;
                };

                // Normalizar DELTAS de 60s para las barras CALL/PUT (pueden ser positivos o negativos)
                const deltaCallPutMax = Math.max(Math.abs(delta60Call), Math.abs(delta60Put), 1);
                const normDeltaCall = (delta60Call / deltaCallPutMax) * 100;
                const normDeltaPut = (delta60Put / deltaCallPutMax) * 100;

                // Para NET, calcular max hist√≥rico de net
                const netValues = rows.map(r => {
                    const c = parseFloat(r[callCol]) || 0;
                    const p = Math.abs(parseFloat(r[putCol])) || 0;
                    return c - p;
                });
                const netMax = Math.max(...netValues.map(v => Math.abs(v)), 1);
                const normNet = (currentNet / netMax) * 100;

                // Para deltas NET, normalizar tambi√©n
                const deltaMax = Math.max(Math.abs(delta60Net), Math.abs(delta300Net), netMax * 0.1, 1);
                const normDelta60 = (delta60Net / deltaMax) * 100;
                const normDelta300 = (delta300Net / deltaMax) * 100;

                // Calcular porcentajes Call vs Put para mostrar
                const totalDeltaAbs = Math.abs(delta60Call) + Math.abs(delta60Put);
                const callPct = totalDeltaAbs > 0 ? Math.round((Math.abs(delta60Call) / totalDeltaAbs) * 100) : 50;
                const putPct = 100 - callPct;

                // Calcular Skew Pressure din√°mico (del CSV si existe, sino calculado)
                const hasSkewPressure = headers.includes('Skew_Pressure');
                const hasSkewIntensity = headers.includes('Skew_Intensity');

                const currentSkewP = hasSkewPressure ? (parseFloat(rows[n - 1]['Skew_Pressure']) || 0) : (currentCall - currentPut);
                const currentSkewI = hasSkewIntensity ? (parseFloat(rows[n - 1]['Skew_Intensity']) || 0) : (currentPut > 0 ? currentCall / currentPut : 1);

                // Skew Pressure hace 60 y 300 segundos
                let skewP60 = 0, skewPDelta60 = 0, skewPPct60 = 0;
                let skewP300 = 0, skewPDelta300 = 0, skewPPct300 = 0;
                let skewI60 = 0, skewIDelta60 = 0, skewIPct60 = 0;
                let skewI300 = 0, skewIDelta300 = 0, skewIPct300 = 0;

                if (n > 1) {
                    const now = new Date(rows[n - 1][timestampHeader]).getTime();

                    // Buscar √≠ndice para 60s
                    let idx60 = 0;
                    for (let i = n - 2; i >= 0; i--) {
                        const t = new Date(rows[i][timestampHeader]).getTime();
                        if (now - t >= 60000) { idx60 = i; break; }
                        idx60 = i;
                    }

                    // Buscar √≠ndice para 300s
                    let idx300 = 0;
                    for (let i = n - 2; i >= 0; i--) {
                        const t = new Date(rows[i][timestampHeader]).getTime();
                        if (now - t >= 300000) { idx300 = i; break; }
                        idx300 = i;
                    }

                    // Skew Pressure 60s
                    const oldCall60 = parseFloat(rows[idx60][callCol]) || 0;
                    const oldPut60 = Math.abs(parseFloat(rows[idx60][putCol])) || 0;
                    skewP60 = hasSkewPressure ? (parseFloat(rows[idx60]['Skew_Pressure']) || 0) : (oldCall60 - oldPut60);
                    skewPDelta60 = currentSkewP - skewP60;
                    skewPPct60 = skewP60 !== 0 ? ((skewPDelta60 / Math.abs(skewP60)) * 100) : 0;

                    // Skew Pressure 300s
                    const oldCall300 = parseFloat(rows[idx300][callCol]) || 0;
                    const oldPut300 = Math.abs(parseFloat(rows[idx300][putCol])) || 0;
                    skewP300 = hasSkewPressure ? (parseFloat(rows[idx300]['Skew_Pressure']) || 0) : (oldCall300 - oldPut300);
                    skewPDelta300 = currentSkewP - skewP300;
                    skewPPct300 = skewP300 !== 0 ? ((skewPDelta300 / Math.abs(skewP300)) * 100) : 0;

                    // Skew Intensity 60s
                    skewI60 = hasSkewIntensity ? (parseFloat(rows[idx60]['Skew_Intensity']) || 0) : (oldPut60 > 0 ? oldCall60 / oldPut60 : 1);
                    skewIDelta60 = currentSkewI - skewI60;
                    skewIPct60 = skewI60 !== 0 ? ((skewIDelta60 / Math.abs(skewI60)) * 100) : 0;

                    // Skew Intensity 300s
                    skewI300 = hasSkewIntensity ? (parseFloat(rows[idx300]['Skew_Intensity']) || 0) : (oldPut300 > 0 ? oldCall300 / oldPut300 : 1);
                    skewIDelta300 = currentSkewI - skewI300;
                    skewIPct300 = skewI300 !== 0 ? ((skewIDelta300 / Math.abs(skewI300)) * 100) : 0;
                }

                // Normalizar skew deltas (-100 a 100)
                const skewPMax = Math.max(Math.abs(skewPDelta60), Math.abs(skewPDelta300), 0.1);
                const normSkewP60 = (skewPDelta60 / skewPMax) * 100;
                const normSkewP300 = (skewPDelta300 / skewPMax) * 100;

                const skewIMax = Math.max(Math.abs(skewIDelta60), Math.abs(skewIDelta300), 0.01);
                const normSkewI60 = (skewIDelta60 / skewIMax) * 100;
                const normSkewI300 = (skewIDelta300 / skewIMax) * 100;

                // Funci√≥n para oscurecer color hex
                const darkenColor = (hex, factor = 0.3) => {
                    const r = parseInt(hex.slice(1, 3), 16);
                    const g = parseInt(hex.slice(3, 5), 16);
                    const b = parseInt(hex.slice(5, 7), 16);
                    return `rgb(${Math.floor(r * factor)}, ${Math.floor(g * factor)}, ${Math.floor(b * factor)})`;
                };

                // Determinar se√±al overall - TODOS los indicadores de tiempo deben alinearse
                const allTimeBullish = delta60Net > 0 && delta300Net > 0 && skewPDelta60 > 0 && skewPDelta300 > 0 && skewIDelta60 > 0 && skewIDelta300 > 0;
                const allTimeBearish = delta60Net < 0 && delta300Net < 0 && skewPDelta60 < 0 && skewPDelta300 < 0 && skewIDelta60 < 0 && skewIDelta300 < 0;
                const allBullish = currentNet > 0 && allTimeBullish;
                const allBearish = currentNet < 0 && allTimeBearish;
                const signalColor = allBullish ? callColor : (allBearish ? putColor : '#888');

                // Fondo del gr√°fico basado en alineaci√≥n de tiempo
                const bgColor = allTimeBullish ? 'rgba(74, 158, 255, 0.08)' : (allTimeBearish ? 'rgba(255, 68, 68, 0.08)' : 'transparent');

                return {
                    animation: false,
                    backgroundColor: bgColor,
                    tooltip: {
                        trigger: 'item',
                        backgroundColor: 'rgba(10, 10, 10, 0.95)',
                        borderColor: '#333',
                        borderWidth: 1,
                        textStyle: { color: '#fff', fontSize: 11 },
                        formatter: (params) => {
                            const name = params.name;
                            const value = params.data.rawValue;
                            const pct = params.data.pct;
                            const arrow = value >= 0 ? '‚ñ≤' : '‚ñº';
                            const pctStr = pct !== null ? ` (${pct >= 0 ? '+' : ''}${pct.toFixed(1)}%)` : '';
                            return `<div style="font-weight:bold;color:${params.color}">${name}</div><div>${arrow} ${formatNumber(value)}${pctStr}</div>`;
                        }
                    },
                    grid: [
                        // Grid para CALL/PUT (0-100) - 20%
                        { left: '2%', right: '78%', top: 35, bottom: 50 },
                        // Grid para NET/Deltas (-100 a 100) - 27%
                        { left: '24%', right: '49%', top: 35, bottom: 50 },
                        // Grid para SKEW Pressure (-100 a 100) - 24%
                        { left: '53%', right: '25%', top: 35, bottom: 50 },
                        // Grid para SKEW Intensity (-100 a 100) - 24%
                        { left: '77%', right: '2%', top: 35, bottom: 50 }
                    ],
                    xAxis: [
                        // Eje X para CALL/PUT
                        {
                            type: 'category',
                            gridIndex: 0,
                            data: ['CALL', 'PUT'],
                            axisLine: { lineStyle: { color: '#333' } },
                            axisLabel: { color: '#aaa', fontSize: 8, fontWeight: 'bold' },
                            axisTick: { show: false }
                        },
                        // Eje X para NET/Deltas
                        {
                            type: 'category',
                            gridIndex: 1,
                            data: ['NET', `Œî${formatTime(actual60Seconds)}`, `Œî${formatTime(actual300Seconds)}`],
                            axisLine: { lineStyle: { color: '#333' } },
                            axisLabel: { color: '#aaa', fontSize: 7, fontWeight: 'bold' },
                            axisTick: { show: false }
                        },
                        // Eje X para SKEW Pressure
                        {
                            type: 'category',
                            gridIndex: 2,
                            data: [`Œî${formatTime(actual60Seconds)}`, `Œî${formatTime(actual300Seconds)}`],
                            axisLine: { lineStyle: { color: '#333' } },
                            axisLabel: { color: '#aaa', fontSize: 7, fontWeight: 'bold' },
                            axisTick: { show: false }
                        },
                        // Eje X para SKEW Intensity
                        {
                            type: 'category',
                            gridIndex: 3,
                            data: [`Œî${formatTime(actual60Seconds)}`, `Œî${formatTime(actual300Seconds)}`],
                            axisLine: { lineStyle: { color: '#333' } },
                            axisLabel: { color: '#aaa', fontSize: 7, fontWeight: 'bold' },
                            axisTick: { show: false }
                        }
                    ],
                    yAxis: [
                        // Eje Y para CALL/PUT (-100 a 100, puede ir arriba o abajo)
                        {
                            type: 'value',
                            gridIndex: 0,
                            min: -100,
                            max: 100,
                            splitNumber: 4,
                            axisLine: { show: false },
                            axisLabel: { show: false },
                            splitLine: { lineStyle: { color: '#1a1a1a' } }
                        },
                        // Eje Y para NET/Deltas (-100 a 100)
                        {
                            type: 'value',
                            gridIndex: 1,
                            min: -100,
                            max: 100,
                            splitNumber: 4,
                            axisLine: { show: false },
                            axisLabel: { show: false },
                            splitLine: { lineStyle: { color: '#1a1a1a' } }
                        },
                        // Eje Y para SKEW Pressure (-100 a 100)
                        {
                            type: 'value',
                            gridIndex: 2,
                            min: -100,
                            max: 100,
                            splitNumber: 4,
                            axisLine: { show: false },
                            axisLabel: { show: false },
                            splitLine: { lineStyle: { color: '#1a1a1a' } }
                        },
                        // Eje Y para SKEW Intensity (-100 a 100)
                        {
                            type: 'value',
                            gridIndex: 3,
                            min: -100,
                            max: 100,
                            splitNumber: 4,
                            axisLine: { show: false },
                            axisLabel: { show: false },
                            splitLine: { lineStyle: { color: '#1a1a1a' } }
                        }
                    ],
                    series: [
                        // Serie CALL/PUT - DELTAS de 60s (pueden ser positivos o negativos)
                        {
                            name: 'Volume',
                            type: 'bar',
                            xAxisIndex: 0,
                            yAxisIndex: 0,
                            barWidth: '60%',
                            data: [
                                {
                                    value: normDeltaCall,
                                    rawValue: delta60Call,
                                    pct: null,
                                    itemStyle: {
                                        color: {
                                            type: 'linear',
                                            x: 0, y: normDeltaCall >= 0 ? 1 : 0, x2: 0, y2: normDeltaCall >= 0 ? 0 : 1,
                                            colorStops: [{ offset: 0, color: callColor }, { offset: 1, color: darkenColor(callColor) }]
                                        },
                                        borderRadius: normDeltaCall >= 0 ? [3, 3, 0, 0] : [0, 0, 3, 3],
                                        shadowColor: callColor,
                                        shadowBlur: 8
                                    },
                                    label: {
                                        show: true,
                                        position: normDeltaCall >= 0 ? 'top' : 'bottom',
                                        formatter: `{a|${delta60Call >= 0 ? '‚ñ≤' : '‚ñº'}${formatNumber(Math.abs(delta60Call))}}`,
                                        rich: { a: { color: callColor, fontSize: 8, fontWeight: 'bold' } }
                                    }
                                },
                                {
                                    value: normDeltaPut,
                                    rawValue: delta60Put,
                                    pct: null,
                                    itemStyle: {
                                        color: {
                                            type: 'linear',
                                            x: 0, y: normDeltaPut >= 0 ? 1 : 0, x2: 0, y2: normDeltaPut >= 0 ? 0 : 1,
                                            colorStops: [{ offset: 0, color: putColor }, { offset: 1, color: darkenColor(putColor) }]
                                        },
                                        borderRadius: normDeltaPut >= 0 ? [3, 3, 0, 0] : [0, 0, 3, 3],
                                        shadowColor: putColor,
                                        shadowBlur: 8
                                    },
                                    label: {
                                        show: true,
                                        position: normDeltaPut >= 0 ? 'top' : 'bottom',
                                        formatter: `{a|${delta60Put >= 0 ? '‚ñ≤' : '‚ñº'}${formatNumber(Math.abs(delta60Put))}}`,
                                        rich: { a: { color: putColor, fontSize: 8, fontWeight: 'bold' } }
                                    }
                                }
                            ],
                            markLine: {
                                symbol: 'none',
                                silent: true,
                                data: [{ yAxis: 0, lineStyle: { color: '#444', width: 1 } }]
                            }
                        },
                        // Serie NET/Deltas
                        {
                            name: 'Delta',
                            type: 'bar',
                            xAxisIndex: 1,
                            yAxisIndex: 1,
                            barWidth: '50%',
                            data: [
                                {
                                    value: normNet,
                                    rawValue: currentNet,
                                    pct: null,
                                    itemStyle: {
                                        color: {
                                            type: 'linear',
                                            x: 0, y: normNet >= 0 ? 1 : 0, x2: 0, y2: normNet >= 0 ? 0 : 1,
                                            colorStops: [{ offset: 0, color: currentNet >= 0 ? callColor : putColor }, { offset: 1, color: darkenColor(currentNet >= 0 ? callColor : putColor) }]
                                        },
                                        borderRadius: normNet >= 0 ? [3, 3, 0, 0] : [0, 0, 3, 3],
                                        shadowColor: currentNet >= 0 ? callColor : putColor,
                                        shadowBlur: 6
                                    },
                                    label: {
                                        show: true,
                                        position: normNet >= 0 ? 'top' : 'bottom',
                                        formatter: `{a|${currentNet >= 0 ? '‚ñ≤' : '‚ñº'}${formatNumber(currentNet)}}`,
                                        rich: { a: { color: currentNet >= 0 ? callColor : putColor, fontSize: 7, fontWeight: 'bold' } }
                                    }
                                },
                                {
                                    value: normDelta60,
                                    rawValue: delta60Net,
                                    pct: pct60Net,
                                    itemStyle: {
                                        color: {
                                            type: 'linear',
                                            x: 0, y: normDelta60 >= 0 ? 1 : 0, x2: 0, y2: normDelta60 >= 0 ? 0 : 1,
                                            colorStops: [{ offset: 0, color: delta60Net >= 0 ? callColor : putColor }, { offset: 1, color: darkenColor(delta60Net >= 0 ? callColor : putColor) }]
                                        },
                                        borderRadius: normDelta60 >= 0 ? [3, 3, 0, 0] : [0, 0, 3, 3],
                                        shadowColor: delta60Net >= 0 ? callColor : putColor,
                                        shadowBlur: 6
                                    },
                                    label: {
                                        show: true,
                                        position: normDelta60 >= 0 ? 'top' : 'bottom',
                                        formatter: `{a|${delta60Net >= 0 ? '‚ñ≤' : '‚ñº'}${formatNumber(delta60Net)}}`,
                                        rich: { a: { color: delta60Net >= 0 ? callColor : putColor, fontSize: 7, fontWeight: 'bold' } }
                                    }
                                },
                                {
                                    value: normDelta300,
                                    rawValue: delta300Net,
                                    pct: pct300Net,
                                    itemStyle: {
                                        color: {
                                            type: 'linear',
                                            x: 0, y: normDelta300 >= 0 ? 1 : 0, x2: 0, y2: normDelta300 >= 0 ? 0 : 1,
                                            colorStops: [{ offset: 0, color: delta300Net >= 0 ? callColor : putColor }, { offset: 1, color: darkenColor(delta300Net >= 0 ? callColor : putColor) }]
                                        },
                                        borderRadius: normDelta300 >= 0 ? [3, 3, 0, 0] : [0, 0, 3, 3],
                                        shadowColor: delta300Net >= 0 ? callColor : putColor,
                                        shadowBlur: 6
                                    },
                                    label: {
                                        show: true,
                                        position: normDelta300 >= 0 ? 'top' : 'bottom',
                                        formatter: `{a|${delta300Net >= 0 ? '‚ñ≤' : '‚ñº'}${formatNumber(delta300Net)}}`,
                                        rich: { a: { color: delta300Net >= 0 ? callColor : putColor, fontSize: 7, fontWeight: 'bold' } }
                                    }
                                }
                            ],
                            markLine: {
                                symbol: 'none',
                                silent: true,
                                data: [{ yAxis: 0, lineStyle: { color: '#333', width: 1, type: 'dashed' } }]
                            }
                        },
                        // Serie Skew Pressure
                        {
                            name: 'Pressure',
                            type: 'bar',
                            xAxisIndex: 2,
                            yAxisIndex: 2,
                            barWidth: '60%',
                            data: [
                                {
                                    value: normSkewP60,
                                    rawValue: skewPDelta60,
                                    pct: skewPPct60,
                                    itemStyle: {
                                        color: {
                                            type: 'linear',
                                            x: 0, y: normSkewP60 >= 0 ? 1 : 0, x2: 0, y2: normSkewP60 >= 0 ? 0 : 1,
                                            colorStops: [{ offset: 0, color: skewPDelta60 >= 0 ? callColor : putColor }, { offset: 1, color: darkenColor(skewPDelta60 >= 0 ? callColor : putColor) }]
                                        },
                                        borderRadius: normSkewP60 >= 0 ? [3, 3, 0, 0] : [0, 0, 3, 3],
                                        shadowColor: skewPDelta60 >= 0 ? callColor : putColor,
                                        shadowBlur: 6
                                    },
                                    label: {
                                        show: true,
                                        position: normSkewP60 >= 0 ? 'top' : 'bottom',
                                        formatter: `{a|${skewPDelta60 >= 0 ? '‚ñ≤' : '‚ñº'}${formatNumber(skewPDelta60)}}`,
                                        rich: { a: { color: skewPDelta60 >= 0 ? callColor : putColor, fontSize: 7, fontWeight: 'bold' } }
                                    }
                                },
                                {
                                    value: normSkewP300,
                                    rawValue: skewPDelta300,
                                    pct: skewPPct300,
                                    itemStyle: {
                                        color: {
                                            type: 'linear',
                                            x: 0, y: normSkewP300 >= 0 ? 1 : 0, x2: 0, y2: normSkewP300 >= 0 ? 0 : 1,
                                            colorStops: [{ offset: 0, color: skewPDelta300 >= 0 ? callColor : putColor }, { offset: 1, color: darkenColor(skewPDelta300 >= 0 ? callColor : putColor) }]
                                        },
                                        borderRadius: normSkewP300 >= 0 ? [3, 3, 0, 0] : [0, 0, 3, 3],
                                        shadowColor: skewPDelta300 >= 0 ? callColor : putColor,
                                        shadowBlur: 6
                                    },
                                    label: {
                                        show: true,
                                        position: normSkewP300 >= 0 ? 'top' : 'bottom',
                                        formatter: `{a|${skewPDelta300 >= 0 ? '‚ñ≤' : '‚ñº'}${formatNumber(skewPDelta300)}}`,
                                        rich: { a: { color: skewPDelta300 >= 0 ? callColor : putColor, fontSize: 7, fontWeight: 'bold' } }
                                    }
                                }
                            ],
                            markLine: {
                                symbol: 'none',
                                silent: true,
                                data: [{ yAxis: 0, lineStyle: { color: '#333', width: 1, type: 'dashed' } }]
                            }
                        },
                        // Serie Skew Intensity
                        {
                            name: 'Intensity',
                            type: 'bar',
                            xAxisIndex: 3,
                            yAxisIndex: 3,
                            barWidth: '60%',
                            data: [
                                {
                                    value: normSkewI60,
                                    rawValue: skewIDelta60,
                                    pct: skewIPct60,
                                    itemStyle: {
                                        color: {
                                            type: 'linear',
                                            x: 0, y: normSkewI60 >= 0 ? 1 : 0, x2: 0, y2: normSkewI60 >= 0 ? 0 : 1,
                                            colorStops: [{ offset: 0, color: skewIDelta60 >= 0 ? callColor : putColor }, { offset: 1, color: darkenColor(skewIDelta60 >= 0 ? callColor : putColor) }]
                                        },
                                        borderRadius: normSkewI60 >= 0 ? [3, 3, 0, 0] : [0, 0, 3, 3],
                                        shadowColor: skewIDelta60 >= 0 ? callColor : putColor,
                                        shadowBlur: 6
                                    },
                                    label: {
                                        show: true,
                                        position: normSkewI60 >= 0 ? 'top' : 'bottom',
                                        formatter: `{a|${skewIDelta60 >= 0 ? '‚ñ≤' : '‚ñº'}${skewIDelta60.toFixed(2)}}`,
                                        rich: { a: { color: skewIDelta60 >= 0 ? callColor : putColor, fontSize: 7, fontWeight: 'bold' } }
                                    }
                                },
                                {
                                    value: normSkewI300,
                                    rawValue: skewIDelta300,
                                    pct: skewIPct300,
                                    itemStyle: {
                                        color: {
                                            type: 'linear',
                                            x: 0, y: normSkewI300 >= 0 ? 1 : 0, x2: 0, y2: normSkewI300 >= 0 ? 0 : 1,
                                            colorStops: [{ offset: 0, color: skewIDelta300 >= 0 ? callColor : putColor }, { offset: 1, color: darkenColor(skewIDelta300 >= 0 ? callColor : putColor) }]
                                        },
                                        borderRadius: normSkewI300 >= 0 ? [3, 3, 0, 0] : [0, 0, 3, 3],
                                        shadowColor: skewIDelta300 >= 0 ? callColor : putColor,
                                        shadowBlur: 6
                                    },
                                    label: {
                                        show: true,
                                        position: normSkewI300 >= 0 ? 'top' : 'bottom',
                                        formatter: `{a|${skewIDelta300 >= 0 ? '‚ñ≤' : '‚ñº'}${skewIDelta300.toFixed(2)}}`,
                                        rich: { a: { color: skewIDelta300 >= 0 ? callColor : putColor, fontSize: 7, fontWeight: 'bold' } }
                                    }
                                }
                            ],
                            markLine: {
                                symbol: 'none',
                                silent: true,
                                data: [{ yAxis: 0, lineStyle: { color: '#333', width: 1, type: 'dashed' } }]
                            }
                        }
                    ],
                    graphic: [
                        // T√≠tulo "VOLUME" con tiempo din√°mico y porcentajes
                        {
                            type: 'text',
                            left: '9%',
                            top: 10,
                            style: { text: `Œî${formatTime(actual60Seconds)}`, fill: allTimeBullish ? callColor : (allTimeBearish ? putColor : '#666'), font: 'bold 9px sans-serif', textAlign: 'center' }
                        },
                        {
                            type: 'text',
                            left: '9%',
                            top: 22,
                            style: { text: `C:${callPct}% P:${putPct}%`, fill: '#888', font: '7px sans-serif', textAlign: 'center' }
                        },
                        // T√≠tulo "MOMENTUM"
                        {
                            type: 'text',
                            left: '32%',
                            top: 15,
                            style: { text: 'MOMENTUM', fill: allTimeBullish ? callColor : (allTimeBearish ? putColor : '#444'), font: 'bold 8px sans-serif', textAlign: 'center' }
                        },
                        // T√≠tulo "PRESSURE"
                        {
                            type: 'text',
                            left: '57%',
                            top: 15,
                            style: { text: 'PRESSURE', fill: allTimeBullish ? callColor : (allTimeBearish ? putColor : '#444'), font: 'bold 8px sans-serif', textAlign: 'center' }
                        },
                        // T√≠tulo "INTENSITY"
                        {
                            type: 'text',
                            left: '82%',
                            top: 15,
                            style: { text: 'INTENSITY', fill: allTimeBullish ? callColor : (allTimeBearish ? putColor : '#444'), font: 'bold 8px sans-serif', textAlign: 'center' }
                        },
                        // L√≠neas separadoras
                        {
                            type: 'line',
                            shape: { x1: 0, y1: 0, x2: 0, y2: 1000 },
                            left: '22%',
                            top: 30,
                            style: { stroke: '#2a2a2a', lineWidth: 1 }
                        },
                        {
                            type: 'line',
                            shape: { x1: 0, y1: 0, x2: 0, y2: 1000 },
                            left: '47%',
                            top: 30,
                            style: { stroke: '#2a2a2a', lineWidth: 1 }
                        },
                        {
                            type: 'line',
                            shape: { x1: 0, y1: 0, x2: 0, y2: 1000 },
                            left: '72%',
                            top: 30,
                            style: { stroke: '#2a2a2a', lineWidth: 1 }
                        },
                        // Signal badge
                        {
                            type: 'group',
                            left: 'center',
                            bottom: 10,
                            children: [
                                {
                                    type: 'rect',
                                    shape: { width: 90, height: 20, r: 3 },
                                    style: {
                                        fill: allBullish ? 'rgba(74, 158, 255, 0.25)' : (allBearish ? 'rgba(255, 68, 68, 0.25)' : 'rgba(136, 136, 136, 0.15)'),
                                        stroke: signalColor,
                                        lineWidth: 1
                                    },
                                    x: -45
                                },
                                {
                                    type: 'text',
                                    style: {
                                        text: allBullish ? '‚óè BULLISH' : (allBearish ? '‚óè BEARISH' : '‚óã MIXED'),
                                        fill: signalColor,
                                        font: 'bold 10px sans-serif',
                                        textAlign: 'center'
                                    },
                                    x: 0,
                                    y: 5
                                }
                            ]
                        }
                    ]
                };
            };

            // ===== PULSE RSI CHART (Lyro RS) - Adaptado para flujos de opciones =====
            const getPulseRsiChartOption = (config, dataSource) => {
                const { rows, timestampHeader, headers } = dataSource;
                if (!rows || rows.length === 0) return {};

                const len = config.parameters?.rsiLength || 14; // Respeta globalConfig.rsiPeriod
                const upColor = config.parameters?.upColor || '#E117B7';
                const downColor = config.parameters?.downColor || '#30FDCF';

                // Obtener m√©trica del tipo de chart
                const chartType = config.type || 'pulse-rsi-money-flow';
                const metricPart = chartType.replace('pulse-rsi-', '') || 'money-flow';

                // Mapeo de m√©tricas a columnas
                const metricToColumns = {
                    'money-flow': { call: 'Call_Money_Flow', put: 'Put_Money_Flow', net: 'Net_Money_Flow' },
                    'delta-flow': { call: 'Call_Delta_Flow', put: 'Put_Delta_Flow', net: 'Net_Delta_Flow' },
                    'iv-flow': { call: 'Call_IV_Flow', put: 'Put_IV_Flow', net: 'Net_IV_Flow' },
                    'otm-impact': { call: 'Call_OTM_Impact', put: 'Put_OTM_Impact', net: 'Net_OTM_Impact' },
                    'itm-impact': { call: 'Call_ITM_Impact', put: 'Put_ITM_Impact', net: 'Net_ITM_Impact' },
                    'gex': { call: 'Call_GEX', put: 'Put_GEX', net: 'Net_GEX' },
                    'vanna-flow': { call: 'Call_Vanna_Flow', put: 'Put_Vanna_Flow', net: 'Net_Vanna_Flow' },
                    'charm': { call: 'Call_Charm', put: 'Put_Charm', net: 'Charm_Pressure' },
                    'smart-money': { call: 'Call_Smart_Money', put: 'Put_Smart_Money', net: 'Net_Smart_Money' },
                    'hedge-pressure': { call: 'Call_Hedge_Pressure', put: 'Put_Hedge_Pressure', net: 'Net_Hedge_Pressure' }
                };

                const columns = metricToColumns[metricPart] || metricToColumns['money-flow'];
                const callCol = columns.call;
                const putCol = columns.put;
                const netCol = columns.net;
                const metricName = metricPart.replace(/-/g, ' ').toUpperCase();

                // Verificar columnas disponibles
                const hasCallPut = headers.includes(callCol) && headers.includes(putCol);
                const hasNet = headers.includes(netCol);
                if (!hasCallPut && !hasNet) {
                    return { title: { text: `Pulse RSI - Columnas no encontradas (${metricName})`, left: 'center', top: 'center', textStyle: { color: '#666' } } };
                }

                // Extraer datos
                const timestamps = [];
                const callValues = [];
                const putValues = [];
                const netValues = [];

                rows.forEach(row => {
                    const ts = row[timestampHeader] || '';
                    const tsStr = String(ts);
                    timestamps.push(tsStr.split(' ').pop() || tsStr);

                    if (hasCallPut) {
                        const c = parseFloat(row[callCol]) || 0;
                        const p = Math.abs(parseFloat(row[putCol])) || 0;
                        callValues.push(c);
                        putValues.push(p);
                        netValues.push(c - p);
                    } else {
                        const n = parseFloat(row[netCol]) || 0;
                        netValues.push(n);
                        callValues.push(n > 0 ? n : 0);
                        putValues.push(n < 0 ? Math.abs(n) : 0);
                    }
                });

                if (netValues.length < len + 5) {
                    return { title: { text: 'Pulse RSI - Datos insuficientes', left: 'center', top: 'center', textStyle: { color: '#666' } } };
                }

                // Funciones de c√°lculo
                const sma = (arr, period) => {
                    const result = [];
                    for (let i = 0; i < arr.length; i++) {
                        if (i < period - 1) result.push(null);
                        else {
                            let sum = 0;
                            for (let j = 0; j < period; j++) sum += arr[i - j];
                            result.push(sum / period);
                        }
                    }
                    return result;
                };

                const ema = (arr, period) => {
                    const result = [];
                    const mult = 2 / (period + 1);
                    let emaVal = null;
                    for (let i = 0; i < arr.length; i++) {
                        if (arr[i] === null) result.push(null);
                        else if (emaVal === null) { emaVal = arr[i]; result.push(emaVal); }
                        else { emaVal = (arr[i] - emaVal) * mult + emaVal; result.push(emaVal); }
                    }
                    return result;
                };

                // C√°lculo RSI modificado: escala de -100 a +100 (0 es neutral)
                // Positivo = CALL dominante (azul), Negativo = PUT dominante (rojo)
                const absFlow = netValues.map((n, i) => Math.abs(callValues[i]) + Math.abs(putValues[i]) + 1);
                const weightedNet = netValues.map((n, i) => n * Math.sqrt(absFlow[i]));
                const smoothed = sma(weightedNet, Math.min(len, 5));

                const u = [], d = [];
                for (let i = 0; i < smoothed.length; i++) {
                    if (i === 0 || smoothed[i] === null || smoothed[i - 1] === null) { u.push(0); d.push(0); }
                    else {
                        u.push(Math.max(smoothed[i] - smoothed[i - 1], 0));
                        d.push(Math.max(smoothed[i - 1] - smoothed[i], 0));
                    }
                }

                const emaU = ema(u, len);
                const emaD = ema(d, len);

                // RSI tradicional (0-100) convertido a escala -100 a +100
                const pulseRsi = emaU.map((eu, i) => {
                    if (eu === null || emaD[i] === null || (emaD[i] === 0 && eu === 0)) return 0;
                    if (emaD[i] === 0) return 100;
                    const rs = eu / emaD[i];
                    const rsi0to100 = 100 - 100 / (1 + rs);
                    // Convertir de 0-100 a -100 a +100: (rsi - 50) * 2
                    return (rsi0to100 - 50) * 2;
                });

                // Filtrar datos v√°lidos
                const validData = [], validTimestamps = [];
                for (let i = 0; i < pulseRsi.length; i++) {
                    if (pulseRsi[i] !== null && !isNaN(pulseRsi[i])) {
                        validData.push(Math.max(-100, Math.min(100, pulseRsi[i])));
                        validTimestamps.push(timestamps[i] || i);
                    }
                }

                // Detectar se√±ales (cruce de cero)
                const bullishSignals = [], bearishSignals = [];
                for (let i = 1; i < validData.length; i++) {
                    const prev = validData[i - 1], curr = validData[i];
                    if (prev <= 0 && curr > 0) bullishSignals.push({ coord: [i, curr], symbol: 'triangle', symbolSize: 8, itemStyle: { color: upColor } });
                    if (prev >= 0 && curr < 0) bearishSignals.push({ coord: [i, curr], symbol: 'triangle', symbolSize: 8, symbolRotate: 180, itemStyle: { color: downColor } });
                }

                const lastRsi = validData.length > 0 ? validData[validData.length - 1].toFixed(1) : '--';
                const lastColor = validData.length > 0 ? (validData[validData.length - 1] > 0 ? upColor : downColor) : '#666';

                return {
                    animation: false,
                    backgroundColor: 'transparent',
                    title: {
                        text: `Pulse RSI | ${metricName}`,
                        subtext: `RSI: ${lastRsi} | L: ${bullishSignals.length} S: ${bearishSignals.length}`,
                        left: 10, top: 5,
                        textStyle: { color: lastColor, fontSize: 11 },
                        subtextStyle: { color: '#888', fontSize: 9 }
                    },
                    grid: { left: 50, right: 18, top: 35, bottom: 25 },
                    tooltip: {
                        trigger: 'axis',
                        backgroundColor: 'rgba(23,23,23,0.95)',
                        borderColor: '#333',
                        textStyle: { color: '#fff', fontSize: 10 },
                        axisPointer: { type: 'cross' }
                    },
                    xAxis: {
                        type: 'category',
                        data: validTimestamps,
                        axisLine: { lineStyle: { color: '#333' } },
                        axisLabel: { color: '#666', fontSize: 8, rotate: 45, interval: Math.floor(validTimestamps.length / 8) },
                        splitLine: { show: false }
                    },
                    yAxis: {
                        type: 'value', min: -100, max: 100,
                        axisLine: { lineStyle: { color: '#333' } },
                        axisLabel: { color: '#666', fontSize: 9 },
                        splitLine: { lineStyle: { color: '#222' } }
                    },
                    dataZoom: [{ type: 'inside', xAxisIndex: [0], start: 0, end: 100 }],
                    series: [
                        // √Årea positiva (roja) - valores > 0
                        {
                            name: 'RSI Positive',
                            type: 'line',
                            data: validData.map(v => v > 0 ? v : 0),
                            smooth: true,
                            symbol: 'none',
                            lineStyle: { width: 0 },
                            areaStyle: {
                                color: {
                                    type: 'linear', x: 0, y: 1, x2: 0, y2: 0,
                                    colorStops: [
                                        { offset: 0, color: 'rgba(255, 68, 68, 0.02)' },
                                        { offset: 0.5, color: 'rgba(255, 68, 68, 0.15)' },
                                        { offset: 1, color: 'rgba(255, 68, 68, 0.35)' }
                                    ]
                                }
                            },
                            z: 1
                        },
                        // √Årea negativa (azul) - valores < 0
                        {
                            name: 'RSI Negative',
                            type: 'line',
                            data: validData.map(v => v < 0 ? v : 0),
                            smooth: true,
                            symbol: 'none',
                            lineStyle: { width: 0 },
                            areaStyle: {
                                color: {
                                    type: 'linear', x: 0, y: 0, x2: 0, y2: 1,
                                    colorStops: [
                                        { offset: 0, color: 'rgba(74, 158, 255, 0.02)' },
                                        { offset: 0.5, color: 'rgba(74, 158, 255, 0.15)' },
                                        { offset: 1, color: 'rgba(74, 158, 255, 0.35)' }
                                    ]
                                }
                            },
                            z: 1
                        },
                        // L√≠nea roja (parte positiva)
                        {
                            name: 'RSI+',
                            type: 'line',
                            data: validData.map((v, i, arr) => {
                                if (v >= 0) return v;
                                // Incluir punto de cruce para continuidad
                                if (i > 0 && arr[i - 1] >= 0) return 0;
                                if (i < arr.length - 1 && arr[i + 1] >= 0) return 0;
                                return null;
                            }),
                            smooth: true,
                            symbol: 'none',
                            lineStyle: { width: 2, color: '#ff4444' },
                            connectNulls: false,
                            z: 10
                        },
                        // L√≠nea azul (parte negativa)
                        {
                            name: 'RSI-',
                            type: 'line',
                            data: validData.map((v, i, arr) => {
                                if (v < 0) return v;
                                // Incluir punto de cruce para continuidad
                                if (i > 0 && arr[i - 1] < 0) return 0;
                                if (i < arr.length - 1 && arr[i + 1] < 0) return 0;
                                return null;
                            }),
                            smooth: true,
                            symbol: 'none',
                            lineStyle: { width: 2, color: '#4a9eff' },
                            connectNulls: false,
                            markLine: {
                                silent: true, symbol: 'none',
                                data: [
                                    { yAxis: 0, lineStyle: { color: 'rgba(255,255,255,0.5)', width: 1, type: 'solid' } },
                                    { yAxis: -50, lineStyle: { color: 'rgba(74, 158, 255, 0.4)', width: 1, type: 'dotted' } },
                                    { yAxis: 50, lineStyle: { color: 'rgba(255, 68, 68, 0.4)', width: 1, type: 'dotted' } }
                                ]
                            },
                            z: 10
                        }
                    ]
                };
            };

            // ===== CORRELATION PULSE RSI (4 Instrumentos - √çndice combinado) =====
            const getCorrelationPulseRsiOption = (config, dataSource, specialData) => {
                const allDataSources = specialData?.allDataSources;
                if (!allDataSources) return {};

                const len = config.parameters?.rsiLength || 50;
                const upColor = '#E117B7';
                const downColor = '#30FDCF';
                const instrumentColors = ['#4a9eff', '#ff6b6b', '#ffd93d', '#6bcb77'];

                // Obtener m√©trica
                const chartType = config.type || 'correlation-pulse-rsi-money-flow';
                const metricPart = chartType.replace('correlation-pulse-rsi-', '') || 'money-flow';

                const metricToColumns = {
                    'money-flow': { call: 'Call_Money_Flow', put: 'Put_Money_Flow', net: 'Net_Money_Flow' },
                    'delta-flow': { call: 'Call_Delta_Flow', put: 'Put_Delta_Flow', net: 'Net_Delta_Flow' },
                    'iv-flow': { call: 'Call_IV_Flow', put: 'Put_IV_Flow', net: 'Net_IV_Flow' },
                    'otm-impact': { call: 'Call_OTM_Impact', put: 'Put_OTM_Impact', net: 'Net_OTM_Impact' },
                    'itm-impact': { call: 'Call_ITM_Impact', put: 'Put_ITM_Impact', net: 'Net_ITM_Impact' },
                    'gex': { call: 'Call_GEX', put: 'Put_GEX', net: 'Net_GEX' },
                    'smart-money': { call: 'Call_Smart_Money', put: 'Put_Smart_Money', net: 'Net_Smart_Money' }
                };

                const columns = metricToColumns[metricPart] || metricToColumns['money-flow'];
                const metricName = metricPart.replace(/-/g, ' ').toUpperCase();

                // Funciones de c√°lculo
                const sma = (arr, period) => {
                    const result = [];
                    for (let i = 0; i < arr.length; i++) {
                        if (i < period - 1) result.push(null);
                        else {
                            let sum = 0;
                            for (let j = 0; j < period; j++) sum += arr[i - j];
                            result.push(sum / period);
                        }
                    }
                    return result;
                };

                const ema = (arr, period) => {
                    const result = [];
                    const mult = 2 / (period + 1);
                    let emaVal = null;
                    for (let i = 0; i < arr.length; i++) {
                        if (arr[i] === null) result.push(null);
                        else if (emaVal === null) { emaVal = arr[i]; result.push(emaVal); }
                        else { emaVal = (arr[i] - emaVal) * mult + emaVal; result.push(emaVal); }
                    }
                    return result;
                };

                const calcPulseRsi = (netValues, callValues, putValues, period) => {
                    const absFlow = netValues.map((n, i) => Math.abs(callValues[i]) + Math.abs(putValues[i]) + 1);
                    const weightedNet = netValues.map((n, i) => n * Math.sqrt(absFlow[i]));
                    const smoothed = sma(weightedNet, Math.min(period, 5));

                    const u = [], d = [];
                    for (let i = 0; i < smoothed.length; i++) {
                        if (i === 0 || smoothed[i] === null || smoothed[i - 1] === null) { u.push(0); d.push(0); }
                        else {
                            u.push(Math.max(smoothed[i] - smoothed[i - 1], 0));
                            d.push(Math.max(smoothed[i - 1] - smoothed[i], 0));
                        }
                    }

                    const emaU = ema(u, period);
                    const emaD = ema(d, period);

                    // RSI escalado de -100 a +100 (0 es neutral)
                    return emaU.map((eu, i) => {
                        if (eu === null || emaD[i] === null || (emaD[i] === 0 && eu === 0)) return 0;
                        if (emaD[i] === 0) return 100;
                        if (eu === 0) return -100;
                        const rs = eu / emaD[i];
                        return Math.max(-100, Math.min(100, ((rs - 1) / (rs + 1)) * 100));
                    });
                };

                // Recopilar datos de los 4 slots
                const instrumentsRsi = [];
                let commonTimestamps = null;
                let maxLen = 0;

                for (let i = 0; i < 4; i++) {
                    const slotId = String(i + 3);
                    const ds = allDataSources.get(slotId);
                    if (!ds || !ds.rows || ds.rows.length === 0) continue;

                    const { rows, timestampHeader, headers } = ds;
                    const hasCallPut = headers.includes(columns.call) && headers.includes(columns.put);
                    const hasNet = headers.includes(columns.net);
                    if (!hasCallPut && !hasNet) continue;

                    const timestamps = rows.map(r => String(r[timestampHeader] || '').split(' ').pop());
                    let callValues, putValues, netValues;

                    if (hasCallPut) {
                        callValues = rows.map(r => parseFloat(r[columns.call]) || 0);
                        putValues = rows.map(r => Math.abs(parseFloat(r[columns.put])) || 0);
                        netValues = callValues.map((c, idx) => c - putValues[idx]);
                    } else {
                        netValues = rows.map(r => parseFloat(r[columns.net]) || 0);
                        callValues = netValues.map(n => n > 0 ? n : 0);
                        putValues = netValues.map(n => n < 0 ? Math.abs(n) : 0);
                    }

                    const rsiData = calcPulseRsi(netValues, callValues, putValues, len);
                    const fileName = ds.fileName || slotId;
                    const displayName = fileName.replace('.csv', '').replace('_unified', '').substring(0, 6).toUpperCase();

                    instrumentsRsi.push({
                        slotId,
                        displayName,
                        timestamps,
                        rsiData,
                        color: instrumentColors[i]
                    });

                    if (!commonTimestamps || timestamps.length > maxLen) {
                        commonTimestamps = timestamps;
                        maxLen = timestamps.length;
                    }
                }

                if (instrumentsRsi.length === 0) {
                    return {
                        backgroundColor: 'transparent',
                        graphic: { type: 'text', left: 'center', top: 'center', style: { text: 'Load CSV in Correlation Slots (S3-S6)', fill: '#666', font: '14px sans-serif' } }
                    };
                }

                // Calcular √≠ndice promedio
                const indexRsi = [];
                for (let t = 0; t < maxLen; t++) {
                    let sum = 0, count = 0;
                    instrumentsRsi.forEach(inst => {
                        if (inst.rsiData[t] !== null && !isNaN(inst.rsiData[t])) {
                            sum += inst.rsiData[t];
                            count++;
                        }
                    });
                    indexRsi.push(count > 0 ? sum / count : 0);
                }

                // Se√±ales del √≠ndice (cruces de 0)
                const bullishSignals = [], bearishSignals = [];
                for (let i = 1; i < indexRsi.length; i++) {
                    if (indexRsi[i - 1] <= 0 && indexRsi[i] > 0) bullishSignals.push({ coord: [i, indexRsi[i]], symbol: 'triangle', symbolSize: 10, itemStyle: { color: upColor } });
                    if (indexRsi[i - 1] >= 0 && indexRsi[i] < 0) bearishSignals.push({ coord: [i, indexRsi[i]], symbol: 'triangle', symbolSize: 10, symbolRotate: 180, itemStyle: { color: downColor } });
                }

                const lastIdx = indexRsi[indexRsi.length - 1]?.toFixed(1) || '--';
                const lastColor = indexRsi[indexRsi.length - 1] > 0 ? upColor : downColor;

                // Series: √≠ndice + l√≠neas individuales
                const series = [
                    // √Årea positiva (roja) - valores > 0
                    {
                        name: 'Index Positive',
                        type: 'line',
                        data: indexRsi.map(v => v > 0 ? v : 0),
                        smooth: true,
                        symbol: 'none',
                        lineStyle: { width: 0 },
                        areaStyle: {
                            color: {
                                type: 'linear', x: 0, y: 1, x2: 0, y2: 0,
                                colorStops: [
                                    { offset: 0, color: 'rgba(255, 68, 68, 0.02)' },
                                    { offset: 0.5, color: 'rgba(255, 68, 68, 0.12)' },
                                    { offset: 1, color: 'rgba(255, 68, 68, 0.3)' }
                                ]
                            }
                        },
                        z: 1
                    },
                    // √Årea negativa (azul) - valores < 0
                    {
                        name: 'Index Negative',
                        type: 'line',
                        data: indexRsi.map(v => v < 0 ? v : 0),
                        smooth: true,
                        symbol: 'none',
                        lineStyle: { width: 0 },
                        areaStyle: {
                            color: {
                                type: 'linear', x: 0, y: 0, x2: 0, y2: 1,
                                colorStops: [
                                    { offset: 0, color: 'rgba(74, 158, 255, 0.02)' },
                                    { offset: 0.5, color: 'rgba(74, 158, 255, 0.12)' },
                                    { offset: 1, color: 'rgba(74, 158, 255, 0.3)' }
                                ]
                            }
                        },
                        z: 1
                    },
                    // L√≠nea roja del √≠ndice (parte positiva)
                    {
                        name: 'INDEX+',
                        type: 'line',
                        data: indexRsi.map((v, i, arr) => {
                            if (v >= 0) return v;
                            if (i > 0 && arr[i - 1] >= 0) return 0;
                            if (i < arr.length - 1 && arr[i + 1] >= 0) return 0;
                            return null;
                        }),
                        smooth: true,
                        symbol: 'none',
                        lineStyle: { width: 2, color: '#ff4444' },
                        connectNulls: false,
                        z: 10
                    },
                    // L√≠nea azul del √≠ndice (parte negativa)
                    {
                        name: 'INDEX-',
                        type: 'line',
                        data: indexRsi.map((v, i, arr) => {
                            if (v < 0) return v;
                            if (i > 0 && arr[i - 1] < 0) return 0;
                            if (i < arr.length - 1 && arr[i + 1] < 0) return 0;
                            return null;
                        }),
                        smooth: true,
                        symbol: 'none',
                        lineStyle: { width: 2, color: '#4a9eff' },
                        connectNulls: false,
                        markLine: {
                            silent: true, symbol: 'none',
                            data: [
                                { yAxis: 0, lineStyle: { color: 'rgba(255,255,255,0.5)', width: 1, type: 'solid' } },
                                { yAxis: -50, lineStyle: { color: 'rgba(74, 158, 255, 0.4)', width: 1, type: 'dotted' } },
                                { yAxis: 50, lineStyle: { color: 'rgba(255, 68, 68, 0.4)', width: 1, type: 'dotted' } }
                            ]
                        },
                        z: 10
                    }
                ];

                // L√≠neas individuales de cada instrumento
                instrumentsRsi.forEach(inst => {
                    series.push({
                        name: inst.displayName,
                        type: 'line',
                        data: inst.rsiData,
                        smooth: true,
                        symbol: 'none',
                        lineStyle: { width: 1, color: inst.color, opacity: 0.6 },
                        z: 5
                    });
                });

                const legendData = [...instrumentsRsi.map(i => i.displayName)];

                // Ocultar instrumentos individuales por defecto, solo mostrar el indice
                const legendSelected = {};
                instrumentsRsi.forEach(inst => {
                    legendSelected[inst.displayName] = false;
                });

                return {
                    animation: false,
                    backgroundColor: 'transparent',
                    title: {
                        text: `Correlation Pulse RSI | ${metricName}`,
                        subtext: `Index: ${lastIdx} | ${instrumentsRsi.length} instruments | L: ${bullishSignals.length} S: ${bearishSignals.length}`,
                        left: 10, top: 5,
                        textStyle: { color: lastColor, fontSize: 11 },
                        subtextStyle: { color: '#888', fontSize: 9 }
                    },
                    legend: {
                        data: legendData,
                        selected: legendSelected,
                        top: 5, right: 10,
                        textStyle: { color: '#888', fontSize: 8 }
                    },
                    grid: { left: 50, right: 18, top: 35, bottom: 25 },
                    tooltip: {
                        trigger: 'axis',
                        backgroundColor: 'rgba(23,23,23,0.95)',
                        borderColor: '#333',
                        textStyle: { color: '#fff', fontSize: 10 },
                        axisPointer: { type: 'cross' }
                    },
                    xAxis: {
                        type: 'category',
                        data: commonTimestamps,
                        axisLine: { lineStyle: { color: '#333' } },
                        axisLabel: { color: '#666', fontSize: 8, rotate: 45, interval: Math.floor(maxLen / 8) },
                        splitLine: { show: false }
                    },
                    yAxis: {
                        type: 'value', min: -100, max: 100,
                        axisLine: { lineStyle: { color: '#333' } },
                        axisLabel: { color: '#666', fontSize: 9 },
                        splitLine: { lineStyle: { color: '#222' } }
                    },
                    dataZoom: [{ type: 'inside', xAxisIndex: [0], start: 0, end: 100 }],
                    series: series
                };
            };

            // ===== CORRELATION POWER METER (3 HORIZONTAL BARS PER INSTRUMENT ROW) =====
            const getOtmCorrelationPowerMeterOption = (config, dataSource, specialData) => {
                const allDataSources = specialData?.allDataSources;
                if (!allDataSources) return {};

                const { formatNumber } = services.signalCalculator;
                const windowSeconds = config.parameters?.correlationWindow || 60;

                // Obtener m√©trica del tipo de chart (ej: otm-correlation-money-flow -> money-flow)
                const chartType = config.type || 'otm-correlation-otm-impact';
                const metricPart = chartType.replace('otm-correlation-', '');

                // Mapeo de m√©tricas a columnas (nombres MAPEADOS por el parser CSV)
                const metricToColumns = {
                    'money-flow': { call: 'Call_Money_Flow', put: 'Put_Money_Flow' },
                    'delta-flow': { call: 'Call_Delta_Flow', put: 'Put_Delta_Flow' },
                    'iv-flow': { call: 'Call_IV_Flow', put: 'Put_IV_Flow' },
                    'otm-impact': { call: 'Call_OTM_Impact', put: 'Put_OTM_Impact' },
                    'itm-impact': { call: 'Call_ITM_Impact', put: 'Put_ITM_Impact' },
                    'gex': { call: 'Call_GEX', put: 'Put_GEX' },
                    'vanna-flow': { call: 'Call_Vanna_Flow', put: 'Put_Vanna_Flow' },
                    'charm': { call: 'Call_Charm', put: 'Put_Charm' },
                    'iv-flow-itm': { call: 'Call_IV_Flow_ITM', put: 'Put_IV_Flow_ITM' },
                    'iv-flow-otm': { call: 'Call_IV_Flow_OTM', put: 'Put_IV_Flow_OTM' },
                    'iv-net': { call: 'Call_IV_Flow', put: 'Put_IV_Flow' },
                    'vol-imbalance': { call: 'Call_Vol_Imbalance', put: 'Put_Vol_Imbalance' },
                    'smart-money': { call: 'Call_Smart_Money', put: 'Put_Smart_Money' },
                    'hedge-pressure': { call: 'Call_Hedge_Pressure', put: 'Put_Hedge_Pressure' }
                };

                const columns = metricToColumns[metricPart] || metricToColumns['otm-impact'];
                const callCol = columns.call;
                const putCol = columns.put;
                const metricName = metricPart.replace(/-/g, ' ').toUpperCase();

                // Colores base - CALL (azul), PUT (rojo)
                const callColorBright = '#4a9eff';  // Azul brillante (positivo/aumentando)
                const callColorDim = '#1a4a7a';     // Azul oscuro (negativo/disminuyendo)
                const putColorBright = '#ff4444';   // Rojo brillante (positivo/aumentando)
                const putColorDim = '#7a1a1a';      // Rojo oscuro (negativo/disminuyendo)

                // Funci√≥n para obtener color seg√∫n si el valor es positivo o negativo
                const getCallColor = (value) => value >= 0 ? callColorBright : callColorDim;
                const getPutColor = (value) => value >= 0 ? putColorBright : putColorDim;
                const getNetColor = (value) => value >= 0 ? callColorBright : putColorBright;

                const darkenColor = (hex, factor = 0.3) => {
                    // Manejar formato rgb()
                    if (hex.startsWith('rgb')) {
                        const matches = hex.match(/\d+/g);
                        if (matches) {
                            return `rgb(${Math.floor(parseInt(matches[0]) * factor)}, ${Math.floor(parseInt(matches[1]) * factor)}, ${Math.floor(parseInt(matches[2]) * factor)})`;
                        }
                    }
                    const r = parseInt(hex.slice(1, 3), 16);
                    const g = parseInt(hex.slice(3, 5), 16);
                    const b = parseInt(hex.slice(5, 7), 16);
                    return `rgb(${Math.floor(r * factor)}, ${Math.floor(g * factor)}, ${Math.floor(b * factor)})`;
                };

                const formatTime = (seconds) => {
                    if (seconds < 60) return `${seconds}s`;
                    const mins = Math.floor(seconds / 60);
                    const secs = seconds % 60;
                    return secs > 0 ? `${mins}m${secs}s` : `${mins}m`;
                };

                // Calcular datos para cada slot
                const slotsData = [];
                let vixData = null; // Separar VIX
                for (let i = 0; i < 4; i++) {
                    const slotId = String(i + 3);
                    const ds = allDataSources.get(slotId);
                    if (!ds || !ds.rows || ds.rows.length === 0) continue;

                    const { rows, timestampHeader, headers } = ds;
                    if (!headers.includes(callCol) || !headers.includes(putCol)) continue;

                    const n = rows.length;
                    let currentCall = parseFloat(rows[n - 1][callCol]) || 0;
                    let currentPut = Math.abs(parseFloat(rows[n - 1][putCol])) || 0;

                    const now = new Date(rows[n - 1][timestampHeader]).getTime();
                    let idx60 = 0;
                    for (let j = n - 2; j >= 0; j--) {
                        const t = new Date(rows[j][timestampHeader]).getTime();
                        if (now - t >= windowSeconds * 1000) { idx60 = j; break; }
                        idx60 = j;
                    }

                    let oldCall = parseFloat(rows[idx60][callCol]) || 0;
                    let oldPut = Math.abs(parseFloat(rows[idx60][putCol])) || 0;

                    // Detectar si es VIX (slot 2 del usuario)
                    const fileName = ds.fileName || slotId;
                    const displayName = fileName.replace('.csv', '').replace('_unified', '').substring(0, 8).toUpperCase();
                    const isVIX = slotId === '2' || displayName.includes('VIX');

                    // INVERTIR valores para VIX (cuando VIX sube = bearish, cuando baja = bullish)
                    if (isVIX) {
                        [currentCall, currentPut] = [-currentPut, -currentCall];
                        [oldCall, oldPut] = [-oldPut, -oldCall];
                    }

                    const deltaCall = currentCall - oldCall;
                    const deltaPut = currentPut - oldPut;
                    const deltaNet = deltaCall - deltaPut;

                    const actualSeconds = Math.round((now - new Date(rows[idx60][timestampHeader]).getTime()) / 1000);

                    const totalAbs = Math.abs(deltaCall) + Math.abs(deltaPut);
                    const callPct = totalAbs > 0 ? Math.round((Math.abs(deltaCall) / totalAbs) * 100) : 50;
                    const putPct = 100 - callPct;

                    const slotData = {
                        slotId, displayName,
                        deltaCall, deltaPut, deltaNet,
                        callPct, putPct, actualSeconds,
                        isVIX
                    };

                    // Separar VIX de los dem√°s instrumentos
                    if (isVIX) {
                        vixData = slotData;
                    } else {
                        slotsData.push(slotData);
                    }
                }

                if (slotsData.length === 0) {
                    return {
                        backgroundColor: 'transparent',
                        graphic: {
                            type: 'text',
                            left: 'center',
                            top: 'center',
                            style: { text: 'Load CSV files in Correlation Slots (S3-S6)', fill: '#666', font: '14px sans-serif' }
                        }
                    };
                }

                // Calcular se√±al general
                const bullishCount = slotsData.filter(s => s.deltaNet > 0).length;
                const bearishCount = slotsData.filter(s => s.deltaNet < 0).length;
                const allBullish = bullishCount === slotsData.length;
                const allBearish = bearishCount === slotsData.length;
                const signalColor = allBullish ? callColorBright : (allBearish ? putColorBright : '#888');
                const bgColor = allBullish ? 'rgba(74, 158, 255, 0.08)' : (allBearish ? 'rgba(255, 68, 68, 0.08)' : 'transparent');

                // Calcular TOTALES POR PORCENTAJE (cada instrumento contribuye equitativamente)
                // Sumamos los porcentajes de CALL de cada instrumento y dividimos por el n√∫mero de instrumentos
                const totalCallPct = slotsData.reduce((acc, s) => acc + s.callPct, 0) / slotsData.length; // Promedio de % CALL
                const totalPutPct = 100 - totalCallPct; // El resto es PUT
                const totalNetPct = totalCallPct - totalPutPct; // NET como diferencia de porcentajes (-100 a +100)
                const avgSeconds = Math.round(slotsData.reduce((acc, s) => acc + s.actualSeconds, 0) / slotsData.length);

                // Estructura: cada instrumento es una FILA con 3 barras HORIZONTALES (CALL, PUT, NET)
                // N instrumentos + 1 fila TOTAL + (1 fila VIX si existe) = N+1 o N+2 filas
                const numSlots = slotsData.length;
                const hasVIX = vixData !== null;
                const totalRows = numSlots + 1 + (hasVIX ? 1 : 0); // instrumentos + TOTAL + VIX opcional
                const instrumentRowHeight = 60 / numSlots; // 60% para los instrumentos
                const totalRowHeight = 10; // 10% para la fila TOTAL
                const vixRowHeight = hasVIX ? 12 : 0; // 12% para la fila VIX (m√°s destacada)
                const grids = [];
                const xAxes = [];
                const yAxes = [];
                const series = [];
                const graphics = [];

                slotsData.forEach((slot, rowIdx) => {
                    const topPct = 6 + rowIdx * instrumentRowHeight;
                    const slotBullish = slot.deltaNet > 0;
                    const slotSignalColor = slotBullish ? callColorBright : putColorBright;

                    // Normalizar valores RELATIVOS A CADA INSTRUMENTO (no globalmente)
                    // Cada instrumento tiene su propio m√°ximo para que las barras sean comparables dentro del mismo instrumento
                    const slotMaxVal = Math.max(Math.abs(slot.deltaCall), Math.abs(slot.deltaPut), Math.abs(slot.deltaNet), 1);
                    const normCall = (slot.deltaCall / slotMaxVal) * 100;
                    const normPut = (slot.deltaPut / slotMaxVal) * 100;
                    const normNet = (slot.deltaNet / slotMaxVal) * 100;

                    // 3 barras horizontales lado a lado: CALL, PUT, NET
                    // Color brillante si aumenta (positivo), oscuro si disminuye (negativo)
                    const bars = [
                        { name: 'CALL', value: slot.deltaCall, norm: normCall, pct: slot.callPct, color: getCallColor(slot.deltaCall) },
                        { name: 'PUT', value: slot.deltaPut, norm: normPut, pct: slot.putPct, color: getPutColor(slot.deltaPut) },
                        { name: 'NET', value: slot.deltaNet, norm: normNet, pct: 100, color: getNetColor(slot.deltaNet) }
                    ];

                    const barWidth = 28; // % ancho de cada barra
                    const startLeft = 8; // % inicio

                    bars.forEach((bar, barIdx) => {
                        const gridIdx = rowIdx * 3 + barIdx;
                        const leftPct = startLeft + barIdx * (barWidth + 2);

                        // Grid para esta barra horizontal
                        grids.push({
                            left: `${leftPct}%`,
                            width: `${barWidth}%`,
                            top: `${topPct + 6}%`,
                            height: `${instrumentRowHeight - 14}%`
                        });

                        // xAxis (valor, -100 a 100)
                        xAxes.push({
                            type: 'value',
                            gridIndex: gridIdx,
                            min: -100,
                            max: 100,
                            axisLine: { show: false },
                            axisLabel: { show: false },
                            axisTick: { show: false },
                            splitLine: {
                                show: true,
                                lineStyle: { color: '#1a1a1a', width: 1 }
                            }
                        });

                        // yAxis (categor√≠a)
                        yAxes.push({
                            type: 'category',
                            gridIndex: gridIdx,
                            data: [''],
                            axisLine: { show: false },
                            axisLabel: { show: false },
                            axisTick: { show: false }
                        });

                        // Serie (barra horizontal)
                        series.push({
                            name: `${slot.displayName}_${bar.name}`,
                            type: 'bar',
                            xAxisIndex: gridIdx,
                            yAxisIndex: gridIdx,
                            barWidth: '85%',
                            data: [{
                                value: bar.norm,
                                itemStyle: {
                                    color: {
                                        type: 'linear',
                                        x: bar.norm >= 0 ? 0 : 1, y: 0, x2: bar.norm >= 0 ? 1 : 0, y2: 0,
                                        colorStops: [
                                            { offset: 0, color: darkenColor(bar.color, 0.3) },
                                            { offset: 1, color: bar.color }
                                        ]
                                    },
                                    borderRadius: bar.norm >= 0 ? [0, 4, 4, 0] : [4, 0, 0, 4],
                                    shadowColor: bar.color,
                                    shadowBlur: 10,
                                    shadowOffsetX: bar.norm >= 0 ? 2 : -2
                                }
                            }]
                        });

                        // Valor con flecha y porcentaje (ARRIBA de la barra)
                        const arrow = bar.value >= 0 ? '‚ñ≤' : '‚ñº';
                        graphics.push({
                            type: 'text',
                            left: `${leftPct + barWidth / 2}%`,
                            top: `${topPct}%`,
                            style: {
                                text: `${arrow} ${bar.value >= 0 ? '+' : ''}${formatNumber(bar.value)} (${bar.pct}%)`,
                                fill: bar.color,
                                font: 'bold 12px sans-serif',
                                textAlign: 'center'
                            }
                        });

                        // Nombre de la barra (DEBAJO)
                        graphics.push({
                            type: 'text',
                            left: `${leftPct + barWidth / 2}%`,
                            top: `${topPct + instrumentRowHeight - 4}%`,
                            style: {
                                text: `${bar.name} Œî${formatTime(slot.actualSeconds)}`,
                                fill: '#666',
                                font: '9px sans-serif',
                                textAlign: 'center'
                            }
                        });
                    });

                    // Nombre del instrumento (izquierda)
                    graphics.push({
                        type: 'text',
                        left: '1%',
                        top: `${topPct + instrumentRowHeight / 2 - 2}%`,
                        style: {
                            text: slot.displayName,
                            fill: slotSignalColor,
                            font: 'bold 10px sans-serif',
                            textAlign: 'left'
                        }
                    });

                    // Indicador de se√±al (derecha)
                    graphics.push({
                        type: 'circle',
                        right: '1%',
                        top: `${topPct + instrumentRowHeight / 2}%`,
                        shape: { r: 4 },
                        style: {
                            fill: slotSignalColor,
                            shadowColor: slotSignalColor,
                            shadowBlur: 6
                        }
                    });

                    // L√≠nea separadora entre instrumentos
                    graphics.push({
                        type: 'line',
                        shape: { x1: 0, y1: 0, x2: 2000, y2: 0 },
                        left: '0%',
                        top: `${topPct + instrumentRowHeight - 1}%`,
                        style: { stroke: '#2a2a2a', lineWidth: 1 }
                    });
                });

                // ===== FILA 5: TOTAL NET POR PORCENTAJE =====
                const totalRowTop = 6 + numSlots * instrumentRowHeight + 1;
                const totalColor = totalNetPct >= 0 ? callColorBright : putColorBright;
                const totalGridIdx = numSlots * 3; // √≠ndice despu√©s de todos los grids de instrumentos

                // Grid para TOTAL NET (m√°s peque√±o)
                grids.push({
                    left: '12%',
                    width: '76%',
                    top: `${totalRowTop + 3}%`,
                    height: `${totalRowHeight - 6}%`
                });

                // xAxis para TOTAL
                xAxes.push({
                    type: 'value',
                    gridIndex: totalGridIdx,
                    min: -100,
                    max: 100,
                    axisLine: { show: false },
                    axisLabel: { show: false },
                    axisTick: { show: false },
                    splitLine: {
                        show: true,
                        lineStyle: { color: '#1a1a1a', width: 1 }
                    }
                });

                // yAxis para TOTAL
                yAxes.push({
                    type: 'category',
                    gridIndex: totalGridIdx,
                    data: [''],
                    axisLine: { show: false },
                    axisLabel: { show: false },
                    axisTick: { show: false }
                });

                // Serie TOTAL NET (barra horizontal - usa totalNetPct directamente, ya est√° en escala -100 a +100)
                series.push({
                    name: 'TOTAL_NET',
                    type: 'bar',
                    xAxisIndex: totalGridIdx,
                    yAxisIndex: totalGridIdx,
                    barWidth: '100%',
                    data: [{
                        value: totalNetPct,
                        itemStyle: {
                            color: {
                                type: 'linear',
                                x: totalNetPct >= 0 ? 0 : 1, y: 0, x2: totalNetPct >= 0 ? 1 : 0, y2: 0,
                                colorStops: [
                                    { offset: 0, color: darkenColor(totalColor, 0.3) },
                                    { offset: 1, color: totalColor }
                                ]
                            },
                            borderRadius: totalNetPct >= 0 ? [0, 4, 4, 0] : [4, 0, 0, 4],
                            shadowColor: totalColor,
                            shadowBlur: 10,
                            shadowOffsetX: totalNetPct >= 0 ? 2 : -2
                        }
                    }]
                });

                // Etiqueta TOTAL (izquierda)
                graphics.push({
                    type: 'text',
                    left: '1%',
                    top: `${totalRowTop + totalRowHeight / 2 - 1}%`,
                    style: {
                        text: 'TOTAL',
                        fill: totalColor,
                        font: 'bold 10px sans-serif',
                        textAlign: 'left'
                    }
                });

                // Valor TOTAL con porcentajes (ARRIBA de la barra)
                const totalArrow = totalNetPct >= 0 ? '‚ñ≤' : '‚ñº';
                graphics.push({
                    type: 'text',
                    left: '50%',
                    top: `${totalRowTop - 1}%`,
                    style: {
                        text: `${totalArrow} CALL ${totalCallPct.toFixed(0)}% | PUT ${totalPutPct.toFixed(0)}% | NET ${totalNetPct >= 0 ? '+' : ''}${totalNetPct.toFixed(0)}%`,
                        fill: totalColor,
                        font: 'bold 11px sans-serif',
                        textAlign: 'center'
                    }
                });

                // Tiempo delta (DEBAJO de la barra)
                graphics.push({
                    type: 'text',
                    left: '50%',
                    top: `${totalRowTop + totalRowHeight}%`,
                    style: {
                        text: `TOTAL NET Œî${formatTime(avgSeconds)}`,
                        fill: '#666',
                        font: '9px sans-serif',
                        textAlign: 'center'
                    }
                });

                // Indicador de se√±al TOTAL (derecha)
                graphics.push({
                    type: 'circle',
                    right: '1%',
                    top: `${totalRowTop + totalRowHeight / 2 - 1}%`,
                    shape: { r: 5 },
                    style: {
                        fill: totalColor,
                        shadowColor: totalColor,
                        shadowBlur: 8
                    }
                });

                // ===== FILA VIX INVERTIDA (si existe) =====
                if (vixData) {
                    const vixRowTop = totalRowTop + totalRowHeight + 2;
                    const vixBullish = vixData.deltaNet > 0;
                    const vixColor = vixBullish ? callColorBright : putColorBright;
                    const vixGridIdx = numSlots * 3 + 1; // despu√©s del grid TOTAL

                    // Normalizar valor VIX
                    const vixMaxVal = Math.max(Math.abs(vixData.deltaCall), Math.abs(vixData.deltaPut), Math.abs(vixData.deltaNet), 1);
                    const vixNormNet = (vixData.deltaNet / vixMaxVal) * 100;

                    // Barra de fondo (contexto visual) - verde/rojo transl√∫cido
                    graphics.push({
                        type: 'rect',
                        left: '12%',
                        top: `${vixRowTop}%`,
                        shape: { width: 1600, height: `${vixRowHeight - 2}%` },
                        style: {
                            fill: vixBullish ? 'rgba(74, 158, 255, 0.1)' : 'rgba(255, 68, 68, 0.1)',
                            stroke: vixBullish ? 'rgba(74, 158, 255, 0.3)' : 'rgba(255, 68, 68, 0.3)',
                            lineWidth: 1
                        }
                    });

                    // Grid para barra VIX
                    grids.push({
                        left: '12%',
                        width: '76%',
                        top: `${vixRowTop + 2}%`,
                        height: `${vixRowHeight - 4}%`
                    });

                    // xAxis para VIX
                    xAxes.push({
                        type: 'value',
                        gridIndex: vixGridIdx,
                        min: -100,
                        max: 100,
                        axisLine: { show: false },
                        axisLabel: { show: false },
                        axisTick: { show: false },
                        splitLine: {
                            show: true,
                            lineStyle: { color: '#1a1a1a', width: 1 }
                        }
                    });

                    // yAxis para VIX
                    yAxes.push({
                        type: 'category',
                        gridIndex: vixGridIdx,
                        data: [''],
                        axisLine: { show: false },
                        axisLabel: { show: false },
                        axisTick: { show: false }
                    });

                    // Serie VIX (barra horizontal)
                    series.push({
                        name: 'VIX_INVERTED',
                        type: 'bar',
                        xAxisIndex: vixGridIdx,
                        yAxisIndex: vixGridIdx,
                        barWidth: '100%',
                        data: [{
                            value: vixNormNet,
                            itemStyle: {
                                color: {
                                    type: 'linear',
                                    x: vixNormNet >= 0 ? 0 : 1, y: 0, x2: vixNormNet >= 0 ? 1 : 0, y2: 0,
                                    colorStops: [
                                        { offset: 0, color: darkenColor(vixColor, 0.2) },
                                        { offset: 0.5, color: vixColor },
                                        { offset: 1, color: vixColor }
                                    ]
                                },
                                borderRadius: vixNormNet >= 0 ? [0, 6, 6, 0] : [6, 0, 0, 6],
                                shadowColor: vixColor,
                                shadowBlur: 15,
                                shadowOffsetX: vixNormNet >= 0 ? 3 : -3
                            }
                        }]
                    });

                    // Etiqueta VOLATILITY (izquierda) con rayo
                    graphics.push({
                        type: 'text',
                        left: '1%',
                        top: `${vixRowTop + vixRowHeight / 2 - 0.5}%`,
                        style: {
                            text: 'VOLATILITY',
                            fill: vixColor,
                            font: 'bold 11px sans-serif',
                            textAlign: 'left',
                            textShadowColor: vixColor,
                            textShadowBlur: 8
                        }
                    });

                    // Icono rayo decorativo
                    graphics.push({
                        type: 'text',
                        left: '1%',
                        top: `${vixRowTop + vixRowHeight / 2 - 3}%`,
                        style: {
                            text: '‚ö°',
                            fill: vixColor,
                            font: 'bold 16px sans-serif',
                            textAlign: 'left'
                        }
                    });

                    // Estado VIX (arriba de la barra)
                    const vixArrow = vixBullish ? '‚ñº' : '‚ñ≤'; // Invertido: down=bullish, up=bearish
                    const vixState = vixBullish ? 'LOW (BULLISH)' : 'HIGH (BEARISH)';
                    graphics.push({
                        type: 'text',
                        left: '50%',
                        top: `${vixRowTop - 1.5}%`,
                        style: {
                            text: `${vixArrow} ${vixState} | ${vixData.callPct}% / ${vixData.putPct}% | NET ${vixData.deltaNet >= 0 ? '+' : ''}${formatNumber(vixData.deltaNet)}`,
                            fill: vixColor,
                            font: 'bold 11px sans-serif',
                            textAlign: 'center',
                            textShadowColor: vixColor,
                            textShadowBlur: 10
                        }
                    });

                    // Tiempo delta (debajo de la barra)
                    graphics.push({
                        type: 'text',
                        left: '50%',
                        top: `${vixRowTop + vixRowHeight}%`,
                        style: {
                            text: `VIX Œî${formatTime(vixData.actualSeconds)} (INVERTED)`,
                            fill: '#888',
                            font: 'bold 9px sans-serif',
                            textAlign: 'center'
                        }
                    });

                    // Indicador circular (derecha)
                    graphics.push({
                        type: 'circle',
                        right: '1%',
                        top: `${vixRowTop + vixRowHeight / 2 - 0.5}%`,
                        shape: { r: 6 },
                        style: {
                            fill: vixColor,
                            shadowColor: vixColor,
                            shadowBlur: 12
                        }
                    });
                }

                return {
                    animation: false,
                    backgroundColor: bgColor,
                    _correlationSignal: {
                        signal: allBullish ? 'BULLISH' : (allBearish ? 'BEARISH' : 'MIXED'),
                        signalColor: signalColor,
                        bullishCount: bullishCount,
                        bearishCount: bearishCount,
                        totalNet: slotsData.reduce((acc, s) => acc + s.deltaNet, 0),
                        windowSeconds: windowSeconds
                    },
                    tooltip: {
                        trigger: 'item',
                        backgroundColor: 'rgba(10, 10, 10, 0.95)',
                        borderColor: '#333',
                        borderWidth: 1,
                        textStyle: { color: '#fff', fontSize: 11 },
                        formatter: (params) => {
                            const [name, type] = params.seriesName.split('_');
                            const slot = slotsData.find(s => s.displayName === name);
                            if (!slot) return '';
                            const val = type === 'CALL' ? slot.deltaCall : (type === 'PUT' ? slot.deltaPut : slot.deltaNet);
                            return `<b>${name} - ${type}</b><br/>Œî${formatTime(slot.actualSeconds)}: ${val >= 0 ? '+' : ''}${formatNumber(val)}`;
                        }
                    },
                    grid: grids,
                    xAxis: xAxes,
                    yAxis: yAxes,
                    series: series,
                    graphic: graphics
                };
            };

            // ===== CORRELATION KELTNER INDEX (4 Instrumentos combinados) =====
            const getCorrelationKeltnerOption = (config, dataSource, specialData) => {
                const allDataSources = specialData?.allDataSources;
                if (!allDataSources) return {};

                const { formatNumber } = services.signalCalculator;

                // Obtener m√©trica del tipo de chart
                const chartType = config.type || 'correlation-keltner-otm-impact';
                const metricPart = chartType.replace('correlation-keltner-', '');

                // Mapeo de m√©tricas a columna NET (nombres MAPEADOS por el parser)
                const metricToNetColumn = {
                    'money-flow': 'Net_Money_Flow',
                    'delta-flow': 'Net_Delta_Flow',
                    'iv-flow': 'Net_IV_Flow',
                    'otm-impact': 'Net_OTM_Impact',
                    'itm-impact': 'Net_ITM_Impact',
                    'gex': 'Net_GEX',
                    'vanna-flow': 'Net_Vanna_Flow',
                    'charm': 'Charm_Pressure',
                    'iv-flow-itm': 'Net_IV_Flow_ITM',
                    'iv-flow-otm': 'Net_IV_Flow_OTM',
                    'iv-net': 'IV_Net',
                    'vol-imbalance': 'Net_Vol_Imbalance',
                    'smart-money': 'Net_Smart_Money',
                    'hedge-pressure': 'Net_Hedge_Pressure'
                };

                const netColumn = metricToNetColumn[metricPart] || 'Net_OTM_Impact';
                const metricName = metricPart.replace(/-/g, ' ').toUpperCase();

                // Par√°metros de Keltner
                const lookbackPeriod = config.parameters?.keltnerEmaPeriod ?? 20;
                const atrMultiplier = config.parameters?.keltnerAtrMult ?? 3.0;

                // Mapeo de m√©tricas a columnas Call/Put (nombres MAPEADOS por el parser)
                const metricToCallPut = {
                    'money-flow': { call: 'Call_Money_Flow', put: 'Put_Money_Flow' },
                    'delta-flow': { call: 'Call_Delta_Flow', put: 'Put_Delta_Flow' },
                    'iv-flow': { call: 'Call_IV_Flow', put: 'Put_IV_Flow' },
                    'otm-impact': { call: 'Call_OTM_Impact', put: 'Put_OTM_Impact' },
                    'itm-impact': { call: 'Call_ITM_Impact', put: 'Put_ITM_Impact' },
                    'gex': { call: 'Call_GEX', put: 'Put_GEX' },
                    'vanna-flow': { call: 'Call_Vanna_Flow', put: 'Put_Vanna_Flow' },
                    'charm': { call: 'Call_Charm', put: 'Put_Charm' },
                    'iv-flow-itm': { call: 'Call_IV_Flow_ITM', put: 'Put_IV_Flow_ITM' },
                    'iv-flow-otm': { call: 'Call_IV_Flow_OTM', put: 'Put_IV_Flow_OTM' },
                    'iv-net': { call: 'Call_IV_Flow', put: 'Put_IV_Flow' },
                    'vol-imbalance': { call: 'Call_Vol_Imbalance', put: 'Put_Vol_Imbalance' },
                    'smart-money': { call: 'Call_Smart_Money', put: 'Put_Smart_Money' },
                    'hedge-pressure': { call: 'Call_Hedge_Pressure', put: 'Put_Hedge_Pressure' }
                };
                const callPutCols = metricToCallPut[metricPart] || metricToCallPut['otm-impact'];

                // Colores para cada instrumento
                const instrumentColors = ['#4a9eff', '#ff6b6b', '#ffd93d', '#6bcb77'];

                // Recopilar datos de los 4 slots de correlaci√≥n
                const instrumentsData = [];
                let commonTimestamps = null;

                for (let i = 0; i < 4; i++) {
                    const slotId = String(i + 3);
                    const ds = allDataSources.get(slotId);
                    if (!ds || !ds.rows || ds.rows.length === 0) continue;

                    const { rows, timestampHeader, headers } = ds;

                    // Intentar usar columna NET directa, o calcular desde Call/Put
                    let values;
                    if (netColumn && headers.includes(netColumn)) {
                        values = rows.map(r => parseFloat(r[netColumn]) || 0);
                    } else if (headers.includes(callPutCols.call) && headers.includes(callPutCols.put)) {
                        // Calcular NET = Call - |Put|
                        values = rows.map(r => {
                            const call = parseFloat(r[callPutCols.call]) || 0;
                            const put = Math.abs(parseFloat(r[callPutCols.put])) || 0;
                            return call - put;
                        });
                    } else {
                        continue; // No hay datos disponibles para este slot
                    }

                    const timestamps = rows.map(r => r[timestampHeader]);

                    const fileName = ds.fileName || slotId;
                    const displayName = fileName.replace('.csv', '').replace('_unified', '').substring(0, 6).toUpperCase();

                    instrumentsData.push({
                        slotId,
                        displayName,
                        timestamps,
                        values,
                        color: instrumentColors[i]
                    });

                    // Usar los timestamps del primer instrumento como referencia
                    if (!commonTimestamps) {
                        commonTimestamps = timestamps;
                    }
                }

                if (instrumentsData.length === 0 || !commonTimestamps) {
                    return {
                        backgroundColor: 'transparent',
                        graphic: {
                            type: 'text',
                            left: 'center',
                            top: 'center',
                            style: { text: 'Load CSV files in Correlation Slots (S3-S6)', fill: '#666', font: '14px sans-serif' }
                        }
                    };
                }

                // Calcular √≠ndice combinado (promedio normalizado de los 4 instrumentos)
                const n = commonTimestamps.length;
                const indexValues = [];

                for (let t = 0; t < n; t++) {
                    let sum = 0;
                    let count = 0;
                    instrumentsData.forEach(inst => {
                        if (inst.values[t] !== undefined) {
                            // Normalizar cada instrumento por su propio rango para igualar peso
                            const maxAbs = Math.max(...inst.values.map(Math.abs), 1);
                            sum += (inst.values[t] / maxAbs) * 100; // Normalizar a escala -100 a +100
                            count++;
                        }
                    });
                    indexValues.push(count > 0 ? sum / count : 0);
                }

                // Calcular EMA
                const calculateEMA = (data, period) => {
                    const result = [];
                    const multiplier = 2 / (period + 1);
                    let ema = data[0];
                    result.push(ema);
                    for (let i = 1; i < data.length; i++) {
                        ema = (data[i] - ema) * multiplier + ema;
                        result.push(ema);
                    }
                    return result;
                };

                // Calcular ATR
                const calculateATR = (data, period) => {
                    const trueRange = [0];
                    for (let i = 1; i < data.length; i++) {
                        trueRange.push(Math.abs(data[i] - data[i - 1]));
                    }
                    return calculateEMA(trueRange, period);
                };

                const emaCenter = calculateEMA(indexValues, lookbackPeriod);
                const atr = calculateATR(indexValues, lookbackPeriod);

                // Bandas del Keltner
                const upperBand = emaCenter.map((ema, i) => ema + (atr[i] * atrMultiplier));
                const lowerBand = emaCenter.map((ema, i) => ema - (atr[i] * atrMultiplier));

                // Determinar se√±al actual
                const lastIdx = n - 1;
                const lastValue = indexValues[lastIdx];
                const lastUpper = upperBand[lastIdx];
                const lastLower = lowerBand[lastIdx];
                const lastEma = emaCenter[lastIdx];

                // Calcular slope
                const slopeWindow = Math.min(5, n - 1);
                const slope = slopeWindow > 0 ? (emaCenter[lastIdx] - emaCenter[lastIdx - slopeWindow]) / slopeWindow : 0;

                let signalState = 'FLAT';
                let signalColor = '#888888';
                if (lastValue > lastUpper && slope > 0) {
                    signalState = 'BULLISH';
                    signalColor = '#4a9eff';
                } else if (lastValue < lastLower && slope < 0) {
                    signalState = 'BEARISH';
                    signalColor = '#ff4444';
                }

                // Series para cada instrumento (l√≠neas individuales m√°s tenues)
                const instrumentSeries = instrumentsData.map((inst, idx) => ({
                    name: inst.displayName,
                    type: 'line',
                    data: inst.values.map((v, i) => {
                        // Normalizar para mostrar en la misma escala
                        const maxAbs = Math.max(...inst.values.map(Math.abs), 1);
                        return [commonTimestamps[i], (v / maxAbs) * 100];
                    }),
                    showSymbol: false,
                    lineStyle: { color: inst.color, width: 1, opacity: 0.4 },
                    z: 1
                }));

                return {
                    animation: true,
                    animationDuration: 100,
                    backgroundColor: 'transparent',
                    tooltip: {
                        trigger: 'axis',
                        backgroundColor: 'rgba(20, 20, 20, 0.95)',
                        borderColor: '#333',
                        textStyle: { color: '#fff', fontSize: 11 },
                        axisPointer: { type: 'cross' },
                        formatter: (params) => {
                            if (!params || params.length === 0) return '';
                            const time = new Date(params[0].axisValue).toLocaleString();
                            let html = `<div style="font-weight:bold;margin-bottom:4px;">${time}</div>`;
                            params.forEach(p => {
                                if (p.value[1] !== null) {
                                    html += `<div style="margin:2px 0;">
                                        <span style="display:inline-block;width:10px;height:10px;border-radius:50%;background:${p.color};margin-right:5px;"></span>
                                        ${p.seriesName}: <strong>${p.value[1].toFixed(2)}</strong>
                                    </div>`;
                                }
                            });
                            html += `<div style="margin-top:4px;padding-top:4px;border-top:1px solid #444;">
                                <span style="color:${signalColor};font-weight:bold;">Signal: ${signalState}</span>
                            </div>`;
                            return html;
                        }
                    },
                    legend: {
                        data: ['INDEX', 'EMA', 'Upper', 'Lower', ...instrumentsData.map(i => i.displayName)],
                        textStyle: { color: '#999', fontSize: 9 },
                        top: 5,
                        right: 10,
                        selected: {
                            'INDEX': true,
                            'EMA': true,  // L√≠nea media del canal visible
                            'Upper': true,
                            'Lower': true,
                            ...Object.fromEntries(instrumentsData.map(i => [i.displayName, false]))  // Instrumentos ocultos por defecto
                        }
                    },
                    grid: {
                        left: 35,
                        right: 10,
                        top: 40,
                        bottom: 30
                    },
                    dataZoom: [{
                        type: 'inside',
                        start: config.zoomState?.start || 0,
                        end: config.zoomState?.end || 100,
                        zoomOnMouseWheel: true,
                        moveOnMouseMove: true
                    }],
                    xAxis: {
                        type: 'time',
                        boundaryGap: false,
                        axisLine: { lineStyle: { color: '#333' } },
                        axisLabel: { color: '#666', fontSize: 9 },
                        splitLine: { show: false }
                    },
                    yAxis: {
                        type: 'value',
                        name: `Correlation Index: ${metricName}`,
                        nameTextStyle: { color: '#888', fontSize: 10 },
                        scale: true,
                        axisLine: { lineStyle: { color: '#333' } },
                        axisLabel: { color: '#888', fontSize: 10, formatter: v => v.toFixed(0) },
                        splitLine: { lineStyle: { color: '#222', type: 'dashed' } }
                    },
                    series: [
                        // Banda superior
                        {
                            name: 'Upper',
                            type: 'line',
                            data: upperBand.map((v, i) => [commonTimestamps[i], v]),
                            showSymbol: false,
                            lineStyle: { color: 'rgba(150, 150, 150, 0.6)', width: 1.5 },
                            z: 2
                        },
                        // Banda inferior
                        {
                            name: 'Lower',
                            type: 'line',
                            data: lowerBand.map((v, i) => [commonTimestamps[i], v]),
                            showSymbol: false,
                            lineStyle: { color: 'rgba(150, 150, 150, 0.6)', width: 1.5 },
                            z: 2
                        },
                        // L√≠nea central EMA
                        {
                            name: 'EMA',
                            type: 'line',
                            data: emaCenter.map((v, i) => [commonTimestamps[i], v]),
                            showSymbol: false,
                            smooth: true,
                            lineStyle: { color: '#888888', width: 1, opacity: 0.6 },
                            z: 3
                        },
                        // √çndice combinado (l√≠nea principal)
                        {
                            name: 'INDEX',
                            type: 'line',
                            data: indexValues.map((v, i) => [commonTimestamps[i], v]),
                            showSymbol: false,
                            smooth: false,
                            lineStyle: { color: '#ffffff', width: 2 },
                            z: 4
                        },
                        // L√≠neas de cada instrumento
                        ...instrumentSeries
                    ]
                };
            };

            // ===== CORRELATION EVOLUTION INDEX (4 Instrumentos combinados) =====
            const getCorrelationEvolutionOption = (config, dataSource, specialData) => {
                const allDataSources = specialData?.allDataSources;
                if (!allDataSources) return {};

                const { formatNumber } = services.signalCalculator;
                const smaPeriod = config.parameters?.smaPeriod || 14;

                // Obtener m√©trica del tipo de chart
                const chartType = config.type || 'correlation-evolution-otm-impact';
                const metricPart = chartType.replace('correlation-evolution-', '');

                // Mapeo de m√©tricas a columnas CALL/PUT (nombres MAPEADOS por el parser CSV)
                const metricToColumns = {
                    'money-flow': { call: 'Call_Money_Flow', put: 'Put_Money_Flow' },
                    'delta-flow': { call: 'Call_Delta_Flow', put: 'Put_Delta_Flow' },
                    'iv-flow': { call: 'Call_IV_Flow', put: 'Put_IV_Flow' },
                    'otm-impact': { call: 'Call_OTM_Impact', put: 'Put_OTM_Impact' },
                    'itm-impact': { call: 'Call_ITM_Impact', put: 'Put_ITM_Impact' },
                    'gex': { call: 'Call_GEX', put: 'Put_GEX' },
                    'vanna-flow': { call: 'Call_Vanna_Flow', put: 'Put_Vanna_Flow' },
                    'charm': { call: 'Call_Charm', put: 'Put_Charm' },
                    'iv-flow-itm': { call: 'Call_IV_Flow_ITM', put: 'Put_IV_Flow_ITM' },
                    'iv-flow-otm': { call: 'Call_IV_Flow_OTM', put: 'Put_IV_Flow_OTM' },
                    'iv-net': { call: 'Call_IV_Flow', put: 'Put_IV_Flow' },
                    'vol-imbalance': { call: 'Call_Vol_Imbalance', put: 'Put_Vol_Imbalance' },
                    'smart-money': { call: 'Call_Smart_Money', put: 'Put_Smart_Money' },
                    'hedge-pressure': { call: 'Call_Hedge_Pressure', put: 'Put_Hedge_Pressure' }
                };

                const columns = metricToColumns[metricPart] || metricToColumns['otm-impact'];
                const callCol = columns.call;
                const putCol = columns.put;
                const metricName = metricPart.replace(/-/g, ' ').toUpperCase();

                // Mapeo de m√©tricas a columna NET (nombres MAPEADOS por el parser)
                const metricToNetColumn = {
                    'money-flow': 'Net_Money_Flow',
                    'delta-flow': 'Net_Delta_Flow',
                    'iv-flow': 'Net_IV_Flow',
                    'otm-impact': 'Net_OTM_Impact',
                    'itm-impact': 'Net_ITM_Impact',
                    'gex': 'Net_GEX',
                    'vanna-flow': 'Net_Vanna_Flow',
                    'charm': 'Charm_Pressure',
                    'iv-flow-itm': 'Net_IV_Flow_ITM',
                    'iv-flow-otm': 'Net_IV_Flow_OTM',
                    'iv-net': 'IV_Net',
                    'vol-imbalance': 'Net_Vol_Imbalance',
                    'smart-money': 'Net_Smart_Money',
                    'hedge-pressure': 'Net_Hedge_Pressure'
                };
                const netCol = metricToNetColumn[metricPart] || 'Net_OTM_Impact';

                // Colores para cada instrumento
                const instrumentColors = ['#4a9eff', '#ff6b6b', '#ffd93d', '#6bcb77'];

                // Recopilar datos de los 4 slots de correlaci√≥n
                const instrumentsData = [];
                let commonTimestamps = null;
                let maxLen = 0;

                for (let i = 0; i < 4; i++) {
                    const slotId = String(i + 3);
                    const ds = allDataSources.get(slotId);
                    if (!ds || !ds.rows || ds.rows.length === 0) continue;

                    const { rows, timestampHeader, headers } = ds;

                    // Verificar qu√© columnas est√°n disponibles
                    const hasCallPut = headers.includes(callCol) && headers.includes(putCol);
                    const hasNet = headers.includes(netCol);

                    // Necesitamos al menos Call/Put O Net
                    if (!hasCallPut && !hasNet) continue;

                    const timestamps = rows.map(r => r[timestampHeader]);
                    let callValues, putValues, netValues;

                    if (hasCallPut) {
                        // Usar columnas Call/Put directamente
                        callValues = rows.map(r => parseFloat(r[callCol]) || 0);
                        putValues = rows.map(r => Math.abs(parseFloat(r[putCol])) || 0);
                        netValues = callValues.map((c, idx) => c - putValues[idx]);
                    } else {
                        // Derivar Call/Put desde Net:
                        // Si Net > 0: Call dominante, Call = Net, Put = 0
                        // Si Net < 0: Put dominante, Call = 0, Put = |Net|
                        netValues = rows.map(r => parseFloat(r[netCol]) || 0);
                        callValues = netValues.map(n => n > 0 ? n : 0);
                        putValues = netValues.map(n => n < 0 ? Math.abs(n) : 0);
                    }

                    const fileName = ds.fileName || slotId;
                    const displayName = fileName.replace('.csv', '').replace('_unified', '').substring(0, 6).toUpperCase();

                    instrumentsData.push({
                        slotId,
                        displayName,
                        timestamps,
                        callValues,
                        putValues,
                        netValues,
                        color: instrumentColors[i]
                    });

                    if (!commonTimestamps || timestamps.length > maxLen) {
                        commonTimestamps = timestamps;
                        maxLen = timestamps.length;
                    }
                }

                if (instrumentsData.length === 0 || !commonTimestamps || maxLen === 0) {
                    return {
                        backgroundColor: 'transparent',
                        graphic: {
                            type: 'text',
                            left: 'center',
                            top: 'center',
                            style: { text: 'Load CSV files in Correlation Slots (S3-S6)', fill: '#666', font: '14px sans-serif' }
                        }
                    };
                }

                const n = commonTimestamps.length;

                // Calcular √≠ndices combinados (promedio normalizado de porcentajes)
                const indexCall = [];
                const indexPut = [];
                const indexNet = [];

                // Primero calcular los m√°ximos por instrumento (para Call, Put y Net)
                const instrumentMaxes = instrumentsData.map(inst => ({
                    maxCall: Math.max(...inst.callValues.map(Math.abs), 1),
                    maxPut: Math.max(...inst.putValues.map(Math.abs), 1),
                    maxNet: Math.max(...inst.netValues.map(Math.abs), 1)
                }));

                for (let t = 0; t < n; t++) {
                    let callSum = 0, putSum = 0, netSum = 0;
                    let count = 0;

                    instrumentsData.forEach((inst, idx) => {
                        if (t < inst.callValues.length) {
                            const { maxCall, maxPut, maxNet } = instrumentMaxes[idx];
                            callSum += (inst.callValues[t] / maxCall) * 100;
                            putSum += (inst.putValues[t] / maxPut) * 100;
                            netSum += (inst.netValues[t] / maxNet) * 100;
                            count++;
                        }
                    });

                    indexCall.push(count > 0 ? callSum / count : 0);
                    indexPut.push(count > 0 ? putSum / count : 0);
                    indexNet.push(count > 0 ? netSum / count : 0);
                }

                // Calcular SMA del Neto Index
                const netoSMA = [];
                for (let i = 0; i < indexNet.length; i++) {
                    if (i < smaPeriod - 1) {
                        netoSMA.push(null);
                    } else {
                        let sum = 0;
                        for (let j = 0; j < smaPeriod; j++) {
                            sum += indexNet[i - j];
                        }
                        netoSMA.push(sum / smaPeriod);
                    }
                }

                // Series de instrumentos individuales (ocultas por defecto) - normalizadas
                const instrumentNetSeries = instrumentsData.map((inst, idx) => ({
                    name: `${inst.displayName}`,
                    type: 'line',
                    data: inst.netValues.map((v) => {
                        const maxAbs = instrumentMaxes[idx].maxNet;
                        return (v / maxAbs) * 100;
                    }),
                    showSymbol: false,
                    lineStyle: { color: inst.color, width: 1.5, opacity: 0.7 },
                    z: 1
                }));

                const COLORS = {
                    CALL: '#4a9eff',   // Azul
                    PUT: '#ff4444',    // Rojo
                    NET: '#ffffff',    // Blanco
                    SMA: 'rgba(150, 150, 150, 0.6)'     // Gris sutil
                };

                return {
                    animation: true,
                    animationDuration: 100,
                    backgroundColor: 'transparent',
                    tooltip: {
                        trigger: 'axis',
                        backgroundColor: 'rgba(20, 20, 20, 0.95)',
                        borderColor: '#333',
                        textStyle: { color: '#fff', fontSize: 11 },
                        axisPointer: { type: 'cross' },
                        formatter: (params) => {
                            if (!params || params.length === 0) return '';
                            let time = params[0].axisValue;
                            try { time = new Date(params[0].axisValue).toLocaleString(); } catch (e) { }
                            let html = `<div style="font-weight:bold;margin-bottom:4px;">${time}</div>`;
                            params.forEach(p => {
                                const val = typeof p.value === 'number' ? p.value : p.value?.[1];
                                if (val !== null && val !== undefined) {
                                    html += `<div style="margin:2px 0;">
                                        <span style="display:inline-block;width:10px;height:10px;border-radius:50%;background:${p.color};margin-right:5px;"></span>
                                        ${p.seriesName}: <strong>${val.toFixed(2)}</strong>
                                    </div>`;
                                }
                            });
                            return html;
                        }
                    },
                    legend: {
                        data: ['Call Index', 'Put Index', 'Net Index', 'SMA', ...instrumentsData.map(i => i.displayName)],
                        textStyle: { color: '#999', fontSize: 9 },
                        top: 5,
                        right: 10,
                        selected: {
                            'Call Index': true,
                            'Put Index': true,
                            'Net Index': true,
                            'SMA': true,
                            ...Object.fromEntries(instrumentsData.map(i => [i.displayName, false]))
                        }
                    },
                    grid: {
                        left: 35,
                        right: 10,
                        top: 40,
                        bottom: 30
                    },
                    dataZoom: [{
                        type: 'inside',
                        start: config.zoomState?.start || 0,
                        end: config.zoomState?.end || 100,
                        zoomOnMouseWheel: true,
                        moveOnMouseMove: true
                    }],
                    xAxis: {
                        type: 'category',
                        data: commonTimestamps,
                        boundaryGap: false,
                        axisLine: { lineStyle: { color: '#333' } },
                        axisLabel: {
                            color: '#666', fontSize: 9, formatter: (v) => {
                                try {
                                    const d = new Date(v);
                                    return d.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
                                } catch (e) { return v; }
                            }
                        },
                        splitLine: { show: false }
                    },
                    yAxis: {
                        type: 'value',
                        name: `Correlation Evolution: ${metricName}`,
                        nameTextStyle: { color: '#888', fontSize: 10 },
                        scale: true,
                        axisLine: { lineStyle: { color: '#333' } },
                        axisLabel: { color: '#888', fontSize: 10, formatter: v => v.toFixed(0) },
                        splitLine: { lineStyle: { color: '#222', type: 'dashed' } }
                    },
                    series: [
                        // Call Index (azul)
                        {
                            name: 'Call Index',
                            type: 'line',
                            data: indexCall,
                            showSymbol: false,
                            smooth: true,
                            lineStyle: { color: COLORS.CALL, width: 1.5 },
                            areaStyle: { color: 'rgba(74, 158, 255, 0.1)' },
                            z: 2
                        },
                        // Put Index (rojo, hacia arriba para comparar con Call)
                        {
                            name: 'Put Index',
                            type: 'line',
                            data: indexPut,
                            showSymbol: false,
                            smooth: true,
                            lineStyle: { color: COLORS.PUT, width: 1.5 },
                            areaStyle: { color: 'rgba(255, 68, 68, 0.1)' },
                            z: 2
                        },
                        // Net Index (blanco, l√≠nea principal)
                        {
                            name: 'Net Index',
                            type: 'line',
                            data: indexNet,
                            showSymbol: false,
                            smooth: false,
                            lineStyle: { color: COLORS.NET, width: 2 },
                            z: 4
                        },
                        // SMA del Net Index (sutil y delgada)
                        {
                            name: 'SMA',
                            type: 'line',
                            data: netoSMA,
                            showSymbol: false,
                            smooth: true,
                            lineStyle: { color: 'rgba(150, 150, 150, 0.6)', width: 1.5 },
                            z: 3
                        },
                        // Series de instrumentos individuales (ocultas por defecto)
                        ...instrumentNetSeries
                    ]
                };
            };

            // ===== CORRELATION DOMINANCE INDEX (4 Instrumentos combinados) =====
            // Igual que Dominance Index pero combinando los 4 instrumentos (S3-S6)
            // Muestra Call Flow y Put Flow como √°reas superpuestas
            const getCorrelationDominanceOption = (config, dataSource, specialData) => {
                const allDataSources = specialData?.allDataSources;
                if (!allDataSources) return {};

                const { formatNumber, calculateDominanceIndex } = services.signalCalculator;
                const lookback = config.parameters?.lookback || 30;

                // Obtener m√©trica del tipo de chart
                const chartType = config.type || 'correlation-dominance-otm-impact';
                const metricPart = chartType.replace('correlation-dominance-', '');

                // Mapeo de m√©tricas a columnas CALL/PUT (nombres MAPEADOS por el parser CSV)
                const metricToColumns = {
                    'money-flow': { call: 'Call_Money_Flow', put: 'Put_Money_Flow' },
                    'delta-flow': { call: 'Call_Delta_Flow', put: 'Put_Delta_Flow' },
                    'iv-flow': { call: 'Call_IV_Flow', put: 'Put_IV_Flow' },
                    'otm-impact': { call: 'Call_OTM_Impact', put: 'Put_OTM_Impact' },
                    'itm-impact': { call: 'Call_ITM_Impact', put: 'Put_ITM_Impact' },
                    'gex': { call: 'Call_GEX', put: 'Put_GEX' },
                    'vanna-flow': { call: 'Call_Vanna_Flow', put: 'Put_Vanna_Flow' },
                    'charm': { call: 'Call_Charm', put: 'Put_Charm' },
                    'iv-flow-itm': { call: 'Call_IV_Flow_ITM', put: 'Put_IV_Flow_ITM' },
                    'iv-flow-otm': { call: 'Call_IV_Flow_OTM', put: 'Put_IV_Flow_OTM' },
                    'iv-net': { call: 'Call_IV_Flow', put: 'Put_IV_Flow' },
                    'vol-imbalance': { call: 'Call_Vol_Imbalance', put: 'Put_Vol_Imbalance' },
                    'smart-money': { call: 'Call_Smart_Money', put: 'Put_Smart_Money' },
                    'hedge-pressure': { call: 'Call_Hedge_Pressure', put: 'Put_Hedge_Pressure' }
                };

                const columns = metricToColumns[metricPart] || metricToColumns['otm-impact'];
                const callCol = columns.call;
                const putCol = columns.put;
                const metricName = metricPart.replace(/-/g, ' ').toUpperCase();

                // Colores
                const callColor = '#4a9eff';
                const putColor = '#ff4444';

                // Colores para cada instrumento
                const instrumentColors = ['#4a9eff', '#ff6b6b', '#ffd93d', '#6bcb77'];

                // Recopilar datos de los 4 slots de correlaci√≥n
                const instrumentsData = [];
                let commonTimestamps = null;
                let maxLen = 0;

                for (let i = 0; i < 4; i++) {
                    const slotId = String(i + 3);
                    const ds = allDataSources.get(slotId);
                    if (!ds || !ds.rows || ds.rows.length === 0) continue;

                    const { rows, timestampHeader, headers } = ds;
                    if (!headers.includes(callCol) || !headers.includes(putCol)) continue;

                    const timestamps = rows.map(r => r[timestampHeader]);
                    const callValues = rows.map(r => parseFloat(r[callCol]) || 0);
                    const putValues = rows.map(r => parseFloat(r[putCol]) || 0);

                    const fileName = ds.fileName || slotId;
                    const displayName = fileName.replace('.csv', '').replace('_unified', '').substring(0, 6).toUpperCase();

                    instrumentsData.push({
                        slotId,
                        displayName,
                        timestamps,
                        callValues,
                        putValues,
                        color: instrumentColors[i]
                    });

                    if (!commonTimestamps || timestamps.length > maxLen) {
                        commonTimestamps = timestamps;
                        maxLen = timestamps.length;
                    }
                }

                if (instrumentsData.length === 0 || !commonTimestamps || maxLen === 0) {
                    return {
                        backgroundColor: 'transparent',
                        graphic: {
                            type: 'text',
                            left: 'center',
                            top: 'center',
                            style: { text: 'Load CSV files in Correlation Slots (S3-S6)', fill: '#666', font: '14px sans-serif' }
                        }
                    };
                }

                const n = commonTimestamps.length;

                // Calcular deltas positivos para cada instrumento y luego promediarlos
                // Primero calculamos el Dominance Index para cada instrumento
                const allCallSums = [];
                const allPutSums = [];

                instrumentsData.forEach(inst => {
                    const { rollingCallSums, rollingPutSums } = calculateDominanceIndex(inst.callValues, inst.putValues, lookback);
                    allCallSums.push(rollingCallSums);
                    allPutSums.push(rollingPutSums);
                });

                // Combinar los rolling sums de todos los instrumentos (promedio normalizado)
                const combinedCallFlow = [];
                const combinedPutFlow = [];

                // Calcular m√°ximos por instrumento para normalizaci√≥n
                const instMaxes = allCallSums.map((callSums, idx) => {
                    const maxCall = Math.max(...callSums.filter(v => v !== null).map(Math.abs), 1);
                    const maxPut = Math.max(...allPutSums[idx].filter(v => v !== null).map(Math.abs), 1);
                    return { maxCall, maxPut };
                });

                for (let t = 0; t < n; t++) {
                    let callSum = 0, putSum = 0;
                    let count = 0;

                    allCallSums.forEach((callSums, idx) => {
                        if (callSums[t] !== null && allPutSums[idx][t] !== null) {
                            // Normalizar cada instrumento por su m√°ximo
                            callSum += (callSums[t] / instMaxes[idx].maxCall) * 100;
                            putSum += (allPutSums[idx][t] / instMaxes[idx].maxPut) * 100;
                            count++;
                        }
                    });

                    combinedCallFlow.push(count > 0 ? callSum / count : null);
                    combinedPutFlow.push(count > 0 ? putSum / count : null);
                }

                // Preparar datos para el gr√°fico (solo valores para xAxis category)
                const callFlowData = combinedCallFlow;
                const putFlowData = combinedPutFlow;

                // Helper para convertir hex a rgba
                const hexToRgba = (hex, alpha) => {
                    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                    if (!result) return `rgba(74, 158, 255, ${alpha})`;
                    return `rgba(${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)}, ${alpha})`;
                };

                // Series de instrumentos individuales (Call Flow por instrumento)
                const instrumentCallSeries = instrumentsData.map((inst, idx) => ({
                    name: `${inst.displayName} Call`,
                    type: 'line',
                    data: allCallSums[idx].map((v, i) => v !== null ? (v / instMaxes[idx].maxCall) * 100 : null),
                    showSymbol: false,
                    smooth: true,
                    lineStyle: { color: inst.color, width: 1, opacity: 0.3 },
                    z: 1
                }));

                const instrumentPutSeries = instrumentsData.map((inst, idx) => ({
                    name: `${inst.displayName} Put`,
                    type: 'line',
                    data: allPutSums[idx].map((v, i) => v !== null ? (v / instMaxes[idx].maxPut) * 100 : null),
                    showSymbol: false,
                    smooth: true,
                    lineStyle: { color: 'rgba(150, 150, 150, 0.4)', width: 1 },
                    z: 1
                }));

                return {
                    animation: true,
                    animationDuration: 100,
                    animationEasing: 'cubicOut',
                    animationDurationUpdate: 0,
                    backgroundColor: 'transparent',
                    tooltip: {
                        trigger: 'axis',
                        backgroundColor: 'rgba(20, 20, 20, 0.95)',
                        borderColor: 'rgba(74, 74, 74, 0.6)',
                        textStyle: { color: '#e8e8e8', fontSize: 11 },
                        axisPointer: { type: 'cross', crossStyle: { color: '#666' } },
                        formatter: (params) => {
                            if (!params || params.length === 0) return '';
                            const date = new Date(params[0].axisValue).toLocaleString();
                            let tooltip = `<div style="font-weight:bold;margin-bottom:4px;">${date}</div>`;
                            params.forEach((param) => {
                                if (param.value !== null && param.value !== undefined) {
                                    tooltip += `<span style="display:inline-block;margin-right:5px;border-radius:10px;width:10px;height:10px;background-color:${param.color};"></span>${param.seriesName}: <strong>${formatNumber(param.value)}</strong><br/>`;
                                }
                            });
                            return tooltip;
                        }
                    },
                    legend: {
                        data: ['Call Flow', 'Put Flow', ...instrumentsData.flatMap(i => [`${i.displayName} Call`, `${i.displayName} Put`])],
                        textStyle: { color: '#e8e8e8', fontSize: 9 },
                        top: 5,
                        selected: {
                            'Call Flow': true,
                            'Put Flow': true,
                            ...Object.fromEntries(instrumentsData.flatMap(i => [[`${i.displayName} Call`, false], [`${i.displayName} Put`, false]]))
                        }
                    },
                    grid: {
                        left: 40,
                        right: 10,
                        top: 30,
                        bottom: 25,
                        containLabel: false
                    },
                    xAxis: {
                        type: 'category',
                        data: commonTimestamps,
                        axisLine: { lineStyle: { color: '#333' } },
                        axisLabel: {
                            color: '#888', fontSize: 9, formatter: v => {
                                try { return new Date(v).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }); }
                                catch (e) { return v; }
                            }
                        },
                        splitLine: { show: false }
                    },
                    dataZoom: [{
                        type: 'inside',
                        start: config.zoomState?.start || 0,
                        end: config.zoomState?.end || 100,
                        zoomOnMouseWheel: true,
                        moveOnMouseMove: true
                    }],
                    yAxis: {
                        type: 'value',
                        name: `Dominance: ${metricName}`,
                        nameTextStyle: { color: '#888', fontSize: 10 },
                        scale: true,
                        axisLine: { lineStyle: { color: '#333' } },
                        axisLabel: { color: '#888', fontSize: 10 },
                        splitLine: { lineStyle: { color: '#222' } }
                    },
                    series: [
                        {
                            name: 'Call Flow',
                            type: 'line',
                            data: callFlowData,
                            showSymbol: false,
                            smooth: true,
                            lineStyle: { color: callColor, width: 2.5, shadowColor: callColor, shadowBlur: 10 },
                            areaStyle: {
                                color: {
                                    type: 'linear',
                                    x: 0, y: 0, x2: 0, y2: 1,
                                    colorStops: [
                                        { offset: 0, color: hexToRgba(callColor, 0.5) },
                                        { offset: 0.5, color: hexToRgba(callColor, 0.2) },
                                        { offset: 1, color: hexToRgba(callColor, 0.02) }
                                    ]
                                }
                            },
                            z: 3
                        },
                        {
                            name: 'Put Flow',
                            type: 'line',
                            data: putFlowData,
                            showSymbol: false,
                            smooth: true,
                            lineStyle: { color: putColor, width: 2.5, shadowColor: putColor, shadowBlur: 10 },
                            areaStyle: {
                                color: {
                                    type: 'linear',
                                    x: 0, y: 0, x2: 0, y2: 1,
                                    colorStops: [
                                        { offset: 0, color: hexToRgba(putColor, 0.5) },
                                        { offset: 0.5, color: hexToRgba(putColor, 0.2) },
                                        { offset: 1, color: hexToRgba(putColor, 0.02) }
                                    ]
                                }
                            },
                            z: 2
                        },
                        // Series individuales por instrumento (ocultas por defecto)
                        ...instrumentCallSeries,
                        ...instrumentPutSeries
                    ]
                };
            };

            // ===== CORRELATION Z-SCORE INDEX (4 Instrumentos combinados) =====
            // Combina los 4 instrumentos (S3-S6) calculando Z-Score con mediana y MAD
            const getCorrelationZScoreOption = (config, dataSource, specialData) => {
                const allDataSources = specialData?.allDataSources;
                if (!allDataSources) return {};

                const { formatNumber } = services.signalCalculator;

                // Obtener tipo de m√©trica (otm-impact, money-flow, etc)
                const chartType = config.type || 'correlation-zscore-otm-impact';
                const metricPart = chartType.replace('correlation-zscore-', '');

                // Mapear m√©tricas a columnas (UPPERCASE para parser)
                const metricToColumns = {
                    'otm-impact': { call: 'Call_OTM_Impact', put: 'Put_OTM_Impact' },
                    'money-flow': { call: 'Call_Money_Flow', put: 'Put_Money_Flow' },
                    'delta-flow': { call: 'Call_Delta_Flow', put: 'Put_Delta_Flow' },
                    'iv-flow': { call: 'Call_IV_Flow', put: 'Put_IV_Flow' },
                    'itm-impact': { call: 'Call_ITM_Impact', put: 'Put_ITM_Impact' },
                    'gex': { call: 'Call_GEX', put: 'Put_GEX' },
                    'vanna-flow': { call: 'Call_Vanna_Flow', put: 'Put_Vanna_Flow' },
                    'charm': { call: 'Call_Charm', put: 'Put_Charm' }
                };

                const columns = metricToColumns[metricPart] || metricToColumns['otm-impact'];
                const metricName = metricPart.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());

                // Slots de correlaci√≥n (S3-S6)
                const correlationSlots = ['3', '4', '5', '6'];
                const instrumentsData = [];

                // Colores para instrumentos
                const instrumentColors = ['#ff9800', '#2196f3', '#4caf50', '#e91e63'];

                // Recopilar datos de cada instrumento
                correlationSlots.forEach((slotId, idx) => {
                    const ds = allDataSources.get(slotId);
                    if (!ds || !ds.rows || ds.rows.length === 0) return;

                    const displayName = ds.priceHeader ? ds.priceHeader.replace('.LAST', '').replace('.Last', '') : `Inst ${idx + 1}`;

                    instrumentsData.push({
                        slotId,
                        displayName,
                        rows: ds.rows,
                        timestampHeader: ds.timestampHeader,
                        headers: ds.headers,
                        color: instrumentColors[idx]
                    });
                });

                if (instrumentsData.length === 0) return {};

                // Par√°metros
                const lookback = config.parameters?.lookback || 50;
                const callColor = config.parameters?.callColor || '#4a9eff';
                const putColor = config.parameters?.putColor || '#ff4444';

                // Encontrar timestamps comunes
                const allTimestampSets = instrumentsData.map(inst => new Set(inst.rows.map(r => r[inst.timestampHeader])));
                let commonTimestamps = [...allTimestampSets[0]].filter(ts => allTimestampSets.every(set => set.has(ts))).sort();

                if (commonTimestamps.length === 0) {
                    commonTimestamps = instrumentsData[0].rows.map(r => r[instrumentsData[0].timestampHeader]);
                }

                // Funci√≥n para calcular mediana
                const median = (arr) => {
                    const sorted = [...arr].filter(v => v !== null && !isNaN(v)).sort((a, b) => a - b);
                    if (sorted.length === 0) return 0;
                    const mid = Math.floor(sorted.length / 2);
                    return sorted.length % 2 !== 0 ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) / 2;
                };

                // Funci√≥n para calcular MAD (Mean Absolute Deviation)
                const mad = (arr, med) => {
                    const validArr = arr.filter(v => v !== null && !isNaN(v));
                    if (validArr.length === 0) return 1;
                    const absDeviations = validArr.map(v => Math.abs(v - med));
                    return absDeviations.reduce((a, b) => a + b, 0) / validArr.length || 1;
                };

                // Calcular Net Flow (Call - Put) para cada instrumento en cada timestamp
                const allNetFlows = [];  // Por instrumento
                const combinedNetFlow = []; // Promedio normalizado

                instrumentsData.forEach((inst, idx) => {
                    const rowMap = new Map(inst.rows.map(r => [r[inst.timestampHeader], r]));
                    const netFlows = [];

                    commonTimestamps.forEach(ts => {
                        const row = rowMap.get(ts);
                        if (row) {
                            const callVal = parseFloat(row[columns.call]) || 0;
                            const putVal = parseFloat(row[columns.put]) || 0;
                            netFlows.push(callVal - putVal);
                        } else {
                            netFlows.push(null);
                        }
                    });

                    allNetFlows.push(netFlows);
                });

                // Calcular Z-Score combinado normalizado por instrumento
                const allZScores = []; // Z-Scores por instrumento
                const combinedZScore = [];

                // Primero calcular Z-Score para cada instrumento
                allNetFlows.forEach((netFlows, instIdx) => {
                    const zScores = [];
                    const n = netFlows.length;

                    for (let i = 0; i < n; i++) {
                        if (netFlows[i] === null) {
                            zScores.push(null);
                            continue;
                        }

                        const start = Math.max(0, i - lookback + 1);
                        const window = netFlows.slice(start, i + 1).filter(v => v !== null);

                        if (window.length < 3) {
                            zScores.push(0);
                            continue;
                        }

                        const med = median(window);
                        const madVal = mad(window, med);
                        const z = (netFlows[i] - med) / madVal;
                        zScores.push(Math.max(-5, Math.min(5, z))); // Clamp entre -5 y 5
                    }

                    allZScores.push(zScores);
                });

                // Combinar Z-Scores (promedio)
                for (let i = 0; i < commonTimestamps.length; i++) {
                    let sum = 0;
                    let count = 0;

                    allZScores.forEach(zScores => {
                        if (zScores[i] !== null) {
                            sum += zScores[i];
                            count++;
                        }
                    });

                    combinedZScore.push(count > 0 ? sum / count : null);
                }

                // Series de instrumentos individuales
                const instrumentSeries = instrumentsData.map((inst, idx) => ({
                    name: `${inst.displayName}`,
                    type: 'line',
                    data: allZScores[idx],
                    showSymbol: false,
                    smooth: true,
                    lineStyle: { color: inst.color, width: 1, opacity: 0.4 },
                    z: 1
                }));

                return {
                    animation: true,
                    animationDuration: 100,
                    animationEasing: 'cubicOut',
                    animationDurationUpdate: 0,
                    backgroundColor: 'transparent',
                    tooltip: {
                        trigger: 'axis',
                        backgroundColor: 'rgba(20, 20, 20, 0.95)',
                        borderColor: 'rgba(74, 74, 74, 0.6)',
                        textStyle: { color: '#e8e8e8', fontSize: 11 },
                        axisPointer: { type: 'cross', crossStyle: { color: '#666' } },
                        formatter: (params) => {
                            if (!params || params.length === 0) return '';
                            const date = new Date(params[0].axisValue).toLocaleString();
                            let tooltip = `<div style="font-weight:bold;margin-bottom:4px;">${date}</div>`;
                            params.forEach((param) => {
                                if (param.value !== null && param.value !== undefined && param.seriesName !== '+2œÉ' && param.seriesName !== '-2œÉ' && param.seriesName !== 'Zero') {
                                    const val = typeof param.value === 'number' ? param.value.toFixed(2) : param.value;
                                    let signal = '';
                                    if (param.value > 2) signal = ' BULLISH';
                                    else if (param.value < -2) signal = ' üîª BEARISH';
                                    tooltip += `<span style="display:inline-block;margin-right:5px;border-radius:10px;width:10px;height:10px;background-color:${param.color};"></span>${param.seriesName}: <strong>${val}</strong>${signal}<br/>`;
                                }
                            });
                            return tooltip;
                        }
                    },
                    legend: {
                        data: ['Z-Score', '+2œÉ', '-2œÉ', ...instrumentsData.map(i => i.displayName)],
                        textStyle: { color: '#e8e8e8', fontSize: 9 },
                        top: 5,
                        selected: {
                            'Z-Score': true,
                            '+2œÉ': true,
                            '-2œÉ': true,
                            ...Object.fromEntries(instrumentsData.map(i => [i.displayName, false]))
                        }
                    },
                    grid: {
                        left: 40,
                        right: 10,
                        top: 30,
                        bottom: 25,
                        containLabel: false
                    },
                    dataZoom: [{
                        type: 'inside',
                        start: config.zoomState?.start || 0,
                        end: config.zoomState?.end || 100,
                        zoomOnMouseWheel: true,
                        moveOnMouseMove: true
                    }],
                    xAxis: {
                        type: 'category',
                        data: commonTimestamps,
                        axisLine: { lineStyle: { color: '#333' } },
                        axisLabel: {
                            color: '#888', fontSize: 9, formatter: v => {
                                try { return new Date(v).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }); }
                                catch (e) { return v; }
                            }
                        },
                        splitLine: { show: false }
                    },
                    yAxis: {
                        type: 'value',
                        name: `Z-Score: ${metricName}`,
                        nameTextStyle: { color: '#888', fontSize: 10 },
                        min: -5,
                        max: 5,
                        axisLine: { lineStyle: { color: '#333' } },
                        axisLabel: { color: '#888', fontSize: 10 },
                        splitLine: { lineStyle: { color: '#222', type: 'dashed' } }
                    },
                    series: [
                        // Zona +2 (Bullish extremo)
                        {
                            name: '+2œÉ',
                            type: 'line',
                            data: commonTimestamps.map(() => 2),
                            showSymbol: false,
                            lineStyle: { color: 'rgba(150, 150, 150, 0.6)', width: 1.5 },
                            z: 0,
                            silent: true
                        },
                        // Zona -2 (Bearish extremo)
                        {
                            name: '-2œÉ',
                            type: 'line',
                            data: commonTimestamps.map(() => -2),
                            showSymbol: false,
                            lineStyle: { color: 'rgba(150, 150, 150, 0.6)', width: 1.5 },
                            z: 0,
                            silent: true
                        },
                        // L√≠nea cero
                        {
                            name: 'Zero',
                            type: 'line',
                            data: commonTimestamps.map(() => 0),
                            showSymbol: false,
                            lineStyle: { color: '#555', width: 1, type: 'solid' },
                            z: 0,
                            silent: true
                        },
                        // Z-Score combinado - Blanco (principal)
                        {
                            name: 'Z-Score',
                            type: 'line',
                            data: combinedZScore,
                            showSymbol: false,
                            smooth: true,
                            lineStyle: { color: '#ffffff', width: 2 },
                            areaStyle: {
                                color: {
                                    type: 'linear',
                                    x: 0, y: 0, x2: 0, y2: 1,
                                    colorStops: [
                                        { offset: 0, color: 'rgba(33, 150, 243, 0.3)' },
                                        { offset: 0.5, color: 'rgba(255, 255, 255, 0.05)' },
                                        { offset: 1, color: 'rgba(204, 51, 51, 0.3)' }
                                    ]
                                }
                            },
                            z: 3
                        },
                        // Series individuales por instrumento (ocultas por defecto)
                        ...instrumentSeries
                    ]
                };
            };

            // ===== CORRELATION TUG-OF-WAR (4 Instrumentos combinados) =====
            // Combina los 4 instrumentos (S3-S6) calculando Bullish/Bearish Force
            const getCorrelationTugOfWarOption = (config, dataSource, specialData) => {
                const allDataSources = specialData?.allDataSources;
                if (!allDataSources) return {};

                const { formatNumber } = services.signalCalculator;
                const echarts = window.echarts;

                // Obtener tipo de m√©trica
                const chartType = config.type || 'correlation-tow-otm-impact';
                const metricPart = chartType.replace('correlation-tow-', '');

                // Mapear m√©tricas a columnas (UPPERCASE para parser)
                const metricToColumns = {
                    'otm-impact': { call: 'Call_OTM_Impact', put: 'Put_OTM_Impact' },
                    'money-flow': { call: 'Call_Money_Flow', put: 'Put_Money_Flow' },
                    'delta-flow': { call: 'Call_Delta_Flow', put: 'Put_Delta_Flow' },
                    'iv-flow': { call: 'Call_IV_Flow', put: 'Put_IV_Flow' },
                    'itm-impact': { call: 'Call_ITM_Impact', put: 'Put_ITM_Impact' },
                    'gex': { call: 'Call_GEX', put: 'Put_GEX' },
                    'vanna-flow': { call: 'Call_Vanna_Flow', put: 'Put_Vanna_Flow' },
                    'charm': { call: 'Call_Charm', put: 'Put_Charm' }
                };

                const columns = metricToColumns[metricPart] || metricToColumns['otm-impact'];
                const metricName = metricPart.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());

                // Slots de correlaci√≥n (S3-S6)
                const correlationSlots = ['3', '4', '5', '6'];
                const instrumentsData = [];

                // Colores para instrumentos
                const instrumentColors = ['#ff9800', '#2196f3', '#4caf50', '#e91e63'];

                // Recopilar datos de cada instrumento
                correlationSlots.forEach((slotId, idx) => {
                    const ds = allDataSources.get(slotId);
                    if (!ds || !ds.rows || ds.rows.length === 0) return;

                    const displayName = ds.priceHeader ? ds.priceHeader.replace('.LAST', '').replace('.Last', '') : `Inst ${idx + 1}`;

                    instrumentsData.push({
                        slotId,
                        displayName,
                        rows: ds.rows,
                        timestampHeader: ds.timestampHeader,
                        headers: ds.headers,
                        color: instrumentColors[idx]
                    });
                });

                if (instrumentsData.length === 0) return {};

                // Par√°metros del Tug-of-War
                const lookback = config.parameters?.towLookback || 20;
                const velocityPeriod = config.parameters?.towVelocityPeriod || 5;
                const signalSmaPeriod = config.parameters?.towSignalSmaPeriod || 8;
                const callColor = config.parameters?.callColor || '#4a9eff';
                const putColor = config.parameters?.putColor || '#ff4444';

                // Encontrar timestamps comunes
                const allTimestampSets = instrumentsData.map(inst => new Set(inst.rows.map(r => r[inst.timestampHeader])));
                let commonTimestamps = [...allTimestampSets[0]].filter(ts => allTimestampSets.every(set => set.has(ts))).sort();

                if (commonTimestamps.length === 0) {
                    commonTimestamps = instrumentsData[0].rows.map(r => r[instrumentsData[0].timestampHeader]);
                }

                const n = commonTimestamps.length;

                // Para cada instrumento, calcular Call y Put values alineados a timestamps comunes
                const allCallValues = [];
                const allPutValues = [];

                instrumentsData.forEach(inst => {
                    const rowMap = new Map(inst.rows.map(r => [r[inst.timestampHeader], r]));
                    const callVals = [];
                    const putVals = [];

                    commonTimestamps.forEach(ts => {
                        const row = rowMap.get(ts);
                        if (row) {
                            callVals.push(Math.abs(parseFloat(row[columns.call]) || 0));
                            putVals.push(Math.abs(parseFloat(row[columns.put]) || 0));
                        } else {
                            callVals.push(0);
                            putVals.push(0);
                        }
                    });

                    allCallValues.push(callVals);
                    allPutValues.push(putVals);
                });

                // Normalizar cada instrumento y promediar
                const normalizeArray = (arr) => {
                    const max = Math.max(...arr.filter(v => v !== null && !isNaN(v)));
                    return max > 0 ? arr.map(v => (v / max) * 100) : arr;
                };

                const normalizedCallValues = allCallValues.map(arr => normalizeArray(arr));
                const normalizedPutValues = allPutValues.map(arr => normalizeArray(arr));

                // Combinar (promediar)
                const combinedCall = new Array(n).fill(0);
                const combinedPut = new Array(n).fill(0);

                for (let i = 0; i < n; i++) {
                    let callSum = 0, putSum = 0, count = 0;
                    normalizedCallValues.forEach(arr => {
                        callSum += arr[i] || 0;
                        count++;
                    });
                    normalizedPutValues.forEach(arr => {
                        putSum += arr[i] || 0;
                    });
                    combinedCall[i] = count > 0 ? callSum / count : 0;
                    combinedPut[i] = count > 0 ? putSum / count : 0;
                }

                // 1. Calcular rolling sums
                const callRollingSum = new Array(n).fill(0);
                const putRollingSum = new Array(n).fill(0);

                for (let i = 0; i < n; i++) {
                    const start = Math.max(0, i - lookback + 1);
                    let callSum = 0, putSum = 0;
                    for (let j = start; j <= i; j++) {
                        callSum += combinedCall[j];
                        putSum += combinedPut[j];
                    }
                    callRollingSum[i] = callSum;
                    putRollingSum[i] = putSum;
                }

                // 2. Calcular velocidades
                const callVelocity = new Array(n).fill(0);
                const putVelocity = new Array(n).fill(0);

                for (let i = velocityPeriod; i < n; i++) {
                    callVelocity[i] = callRollingSum[i] - callRollingSum[i - velocityPeriod];
                    putVelocity[i] = putRollingSum[i] - putRollingSum[i - velocityPeriod];
                }

                // 3. Calcular Forces
                const bullishForce = [];
                const bearishForce = [];

                for (let i = 0; i < n; i++) {
                    const callMom = callVelocity[i];
                    const putMom = putVelocity[i];

                    // BullishForce = max(0, callVelocity) + max(0, -putVelocity)
                    const bf = Math.max(0, callMom) + Math.max(0, -putMom);
                    // BearishForce = max(0, putVelocity) + max(0, -callVelocity)
                    const ef = Math.max(0, putMom) + Math.max(0, -callMom);

                    bullishForce.push(bf);
                    bearishForce.push(ef);
                }

                // 4. Calcular SMAs
                const bullishSMA = [];
                const bearishSMA = [];

                for (let i = 0; i < n; i++) {
                    if (i < signalSmaPeriod - 1) {
                        bullishSMA.push(bullishForce[i]);
                        bearishSMA.push(bearishForce[i]);
                    } else {
                        let sumBull = 0, sumBear = 0;
                        for (let j = 0; j < signalSmaPeriod; j++) {
                            sumBull += bullishForce[i - j];
                            sumBear += bearishForce[i - j];
                        }
                        bullishSMA.push(sumBull / signalSmaPeriod);
                        bearishSMA.push(sumBear / signalSmaPeriod);
                    }
                }

                return {
                    animation: true,
                    animationDuration: 100,
                    animationEasing: 'cubicOut',
                    animationDurationUpdate: 0,
                    backgroundColor: 'transparent',
                    tooltip: {
                        trigger: 'axis',
                        backgroundColor: 'rgba(20, 20, 20, 0.95)',
                        borderColor: 'rgba(74, 74, 74, 0.6)',
                        textStyle: { color: '#e8e8e8', fontSize: 11 },
                        axisPointer: { type: 'cross', crossStyle: { color: '#666' } },
                        formatter: (params) => {
                            if (!params || params.length === 0) return '';
                            const date = new Date(params[0].axisValue).toLocaleString();
                            let tooltip = `<div style="font-weight:bold;margin-bottom:4px;">${date}</div>`;
                            params.forEach((param) => {
                                if (param.value !== null && param.value !== undefined) {
                                    tooltip += `<span style="display:inline-block;margin-right:5px;border-radius:10px;width:10px;height:10px;background-color:${param.color};"></span>${param.seriesName}: <strong>${formatNumber(param.value)}</strong><br/>`;
                                }
                            });
                            return tooltip;
                        }
                    },
                    legend: {
                        data: ['Bullish Force', 'Bullish SMA', 'Bearish Force', 'Bearish SMA'],
                        textStyle: { color: '#e8e8e8', fontSize: 9 },
                        top: 5
                    },
                    grid: {
                        left: 40,
                        right: 10,
                        top: 30,
                        bottom: 25,
                        containLabel: false
                    },
                    dataZoom: [{
                        type: 'inside',
                        start: config.zoomState?.start || 0,
                        end: config.zoomState?.end || 100,
                        zoomOnMouseWheel: true,
                        moveOnMouseMove: true
                    }],
                    xAxis: {
                        type: 'category',
                        data: commonTimestamps,
                        axisLine: { lineStyle: { color: '#333' } },
                        axisLabel: {
                            color: '#888', fontSize: 9, formatter: v => {
                                try { return new Date(v).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }); }
                                catch (e) { return v; }
                            }
                        },
                        splitLine: { show: false }
                    },
                    yAxis: {
                        type: 'value',
                        name: `Tug-of-War: ${metricName}`,
                        nameTextStyle: { color: '#888', fontSize: 10 },
                        axisLine: { lineStyle: { color: '#333' } },
                        axisLabel: { color: '#888', fontSize: 10, formatter: v => formatNumber(v) },
                        splitLine: { lineStyle: { color: '#222' } }
                    },
                    series: [
                        {
                            name: 'Bullish Force',
                            type: 'line',
                            data: bullishForce,
                            showSymbol: false,
                            smooth: true,
                            lineStyle: { color: callColor, width: 2 },
                            areaStyle: {
                                color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
                                    { offset: 0, color: callColor + '66' },
                                    { offset: 1, color: callColor + '0D' }
                                ])
                            },
                            z: 2
                        },
                        {
                            name: 'Bullish SMA',
                            type: 'line',
                            data: bullishSMA,
                            showSymbol: false,
                            smooth: true,
                            lineStyle: { color: 'rgba(150, 150, 150, 0.6)', width: 1.5 },
                            z: 10
                        },
                        {
                            name: 'Bearish Force',
                            type: 'line',
                            data: bearishForce,
                            showSymbol: false,
                            smooth: true,
                            lineStyle: { color: putColor, width: 2 },
                            areaStyle: {
                                color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
                                    { offset: 0, color: putColor + '66' },
                                    { offset: 1, color: putColor + '0D' }
                                ])
                            },
                            z: 1
                        },
                        {
                            name: 'Bearish SMA',
                            type: 'line',
                            data: bearishSMA,
                            showSymbol: false,
                            smooth: true,
                            lineStyle: { color: 'rgba(150, 150, 150, 0.6)', width: 1.5 },
                            z: 10
                        }
                    ]
                };
            };

            // ===== CORRELATION INTENSITY INDEX (4 Instrumentos combinados) =====
            // Combina los 4 instrumentos (S3-S6) mostrando Call/Put Intensity como barras
            const getCorrelationIntensityOption = (config, dataSource, specialData) => {
                const allDataSources = specialData?.allDataSources;
                if (!allDataSources) return {};

                const { formatNumber } = services.signalCalculator;
                const echarts = window.echarts;

                // Obtener tipo de m√©trica
                const chartType = config.type || 'correlation-intensity-otm-impact';
                const metricPart = chartType.replace('correlation-intensity-', '');

                // Mapear m√©tricas a columnas
                const metricToColumns = {
                    'otm-impact': { call: 'Call_OTM_Impact', put: 'Put_OTM_Impact' },
                    'money-flow': { call: 'Call_Money_Flow', put: 'Put_Money_Flow' },
                    'delta-flow': { call: 'Call_Delta_Flow', put: 'Put_Delta_Flow' },
                    'iv-flow': { call: 'Call_IV_Flow', put: 'Put_IV_Flow' },
                    'itm-impact': { call: 'Call_ITM_Impact', put: 'Put_ITM_Impact' },
                    'gex': { call: 'Call_GEX', put: 'Put_GEX' },
                    'vanna-flow': { call: 'Call_Vanna_Flow', put: 'Put_Vanna_Flow' },
                    'charm': { call: 'Call_Charm', put: 'Put_Charm' }
                };

                const columns = metricToColumns[metricPart] || metricToColumns['otm-impact'];
                const metricName = metricPart.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());

                // Slots de correlaci√≥n (S3-S6)
                const correlationSlots = ['3', '4', '5', '6'];
                const instrumentsData = [];

                correlationSlots.forEach((slotId, idx) => {
                    const ds = allDataSources.get(slotId);
                    if (!ds || !ds.rows || ds.rows.length === 0) return;

                    const displayName = ds.priceHeader ? ds.priceHeader.replace('.LAST', '').replace('.Last', '') : `Inst ${idx + 1}`;

                    instrumentsData.push({
                        slotId,
                        displayName,
                        rows: ds.rows,
                        timestampHeader: ds.timestampHeader,
                        headers: ds.headers
                    });
                });

                if (instrumentsData.length === 0) return {};

                const smaPeriod = config.parameters?.smaPeriod || 8;
                const callColor = config.parameters?.callColor || '#4a9eff';
                const putColor = config.parameters?.putColor || '#ff4444';

                // Encontrar timestamps comunes
                const allTimestampSets = instrumentsData.map(inst => new Set(inst.rows.map(r => r[inst.timestampHeader])));
                let commonTimestamps = [...allTimestampSets[0]].filter(ts => allTimestampSets.every(set => set.has(ts))).sort();

                if (commonTimestamps.length === 0) {
                    commonTimestamps = instrumentsData[0].rows.map(r => r[instrumentsData[0].timestampHeader]);
                }

                const n = commonTimestamps.length;

                // Recopilar valores de cada instrumento
                const allCallValues = [];
                const allPutValues = [];

                instrumentsData.forEach(inst => {
                    const rowMap = new Map(inst.rows.map(r => [r[inst.timestampHeader], r]));
                    const callVals = [];
                    const putVals = [];

                    commonTimestamps.forEach(ts => {
                        const row = rowMap.get(ts);
                        if (row) {
                            callVals.push(Math.abs(parseFloat(row[columns.call]) || 0));
                            putVals.push(Math.abs(parseFloat(row[columns.put]) || 0));
                        } else {
                            callVals.push(0);
                            putVals.push(0);
                        }
                    });

                    allCallValues.push(callVals);
                    allPutValues.push(putVals);
                });

                // Normalizar y combinar
                const normalizeArray = (arr) => {
                    const max = Math.max(...arr.filter(v => !isNaN(v)));
                    return max > 0 ? arr.map(v => (v / max) * 100) : arr;
                };

                const normalizedCallValues = allCallValues.map(arr => normalizeArray(arr));
                const normalizedPutValues = allPutValues.map(arr => normalizeArray(arr));

                // Promediar
                const combinedCall = new Array(n).fill(0);
                const combinedPut = new Array(n).fill(0);

                for (let i = 0; i < n; i++) {
                    let callSum = 0, putSum = 0, count = normalizedCallValues.length;
                    normalizedCallValues.forEach(arr => { callSum += arr[i] || 0; });
                    normalizedPutValues.forEach(arr => { putSum += arr[i] || 0; });
                    combinedCall[i] = count > 0 ? callSum / count : 0;
                    combinedPut[i] = count > 0 ? putSum / count : 0;
                }

                // Calcular intensidades
                const callIntensity = [];
                const putIntensity = [];

                for (let i = 0; i < n; i++) {
                    const call = combinedCall[i];
                    const put = combinedPut[i];
                    const total = call + put;

                    if (total > 0) {
                        const imbalance = ((call - put) / total) * 100;
                        const absImbalance = Math.abs(imbalance);

                        if (imbalance > 0) {
                            callIntensity.push(call * (absImbalance / 100));
                            putIntensity.push(0);
                        } else if (imbalance < 0) {
                            callIntensity.push(0);
                            putIntensity.push(put * (absImbalance / 100));
                        } else {
                            callIntensity.push(0);
                            putIntensity.push(0);
                        }
                    } else {
                        callIntensity.push(0);
                        putIntensity.push(0);
                    }
                }

                // Calcular SMAs
                const callSMA = [];
                const putSMA = [];

                for (let i = 0; i < n; i++) {
                    if (i < smaPeriod - 1) {
                        callSMA.push(0);
                        putSMA.push(0);
                    } else {
                        let callSum = 0, putSum = 0;
                        for (let j = 0; j < smaPeriod; j++) {
                            callSum += callIntensity[i - j];
                            putSum += putIntensity[i - j];
                        }
                        callSMA.push(callSum / smaPeriod);
                        putSMA.push(putSum / smaPeriod);
                    }
                }

                return {
                    animation: true,
                    animationDuration: 100,
                    animationEasing: 'cubicOut',
                    animationDurationUpdate: 0,
                    backgroundColor: 'transparent',
                    tooltip: {
                        trigger: 'axis',
                        backgroundColor: 'rgba(20, 20, 20, 0.95)',
                        borderColor: 'rgba(74, 74, 74, 0.6)',
                        textStyle: { color: '#e8e8e8', fontSize: 11 },
                        axisPointer: { type: 'cross', crossStyle: { color: '#666' } },
                        formatter: (params) => {
                            if (!params || params.length === 0) return '';
                            const date = new Date(params[0].axisValue).toLocaleString();
                            let tooltip = `<div style="font-weight:bold;margin-bottom:4px;">${date}</div>`;
                            params.forEach((param) => {
                                if (param.value !== null && param.value !== undefined && param.value > 0) {
                                    tooltip += `<span style="display:inline-block;margin-right:5px;border-radius:10px;width:10px;height:10px;background-color:${param.color};"></span>${param.seriesName}: <strong>${formatNumber(param.value)}</strong><br/>`;
                                }
                            });
                            return tooltip;
                        }
                    },
                    legend: {
                        data: ['Call Intensity', 'Put Intensity', 'Call SMA', 'Put SMA'],
                        textStyle: { color: '#e8e8e8', fontSize: 9 },
                        top: 5
                    },
                    grid: {
                        left: 40,
                        right: 10,
                        top: 30,
                        bottom: 25,
                        containLabel: false
                    },
                    dataZoom: [{
                        type: 'inside',
                        start: config.zoomState?.start || 0,
                        end: config.zoomState?.end || 100,
                        zoomOnMouseWheel: true,
                        moveOnMouseMove: true
                    }],
                    xAxis: {
                        type: 'category',
                        data: commonTimestamps,
                        axisLine: { lineStyle: { color: '#333' } },
                        axisLabel: {
                            color: '#888', fontSize: 9, formatter: v => {
                                try { return new Date(v).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }); }
                                catch (e) { return v; }
                            }
                        },
                        splitLine: { show: false }
                    },
                    yAxis: {
                        type: 'value',
                        name: `Intensity: ${metricName}`,
                        nameTextStyle: { color: '#888', fontSize: 10 },
                        axisLine: { lineStyle: { color: '#333' } },
                        axisLabel: { color: '#888', fontSize: 10, formatter: v => formatNumber(v) },
                        splitLine: { lineStyle: { color: '#222' } }
                    },
                    series: [
                        {
                            name: 'Call Intensity',
                            type: 'line',
                            data: callIntensity,
                            showSymbol: false,
                            smooth: true,
                            lineStyle: { color: callColor, width: 2 },
                            areaStyle: {
                                color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
                                    { offset: 0, color: callColor + '66' },
                                    { offset: 1, color: callColor + '0D' }
                                ])
                            },
                            z: 2
                        },
                        {
                            name: 'Put Intensity',
                            type: 'line',
                            data: putIntensity,
                            showSymbol: false,
                            smooth: true,
                            lineStyle: { color: putColor, width: 2 },
                            areaStyle: {
                                color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
                                    { offset: 0, color: putColor + '66' },
                                    { offset: 1, color: putColor + '0D' }
                                ])
                            },
                            z: 1
                        },
                        {
                            name: 'Call SMA',
                            type: 'line',
                            data: callSMA,
                            showSymbol: false,
                            smooth: true,
                            lineStyle: { color: 'rgba(150, 150, 150, 0.6)', width: 1.5 },
                            z: 10
                        },
                        {
                            name: 'Put SMA',
                            type: 'line',
                            data: putSMA,
                            showSymbol: false,
                            smooth: true,
                            lineStyle: { color: 'rgba(150, 150, 150, 0.6)', width: 1.5 },
                            z: 10
                        }
                    ]
                };
            };

            // ===== CORRELATION TOW INDICATOR (4 Instrumentos combinados) - NinjaTrader Style =====
            // Net Force con barras de colores variables seg√∫n intensidad
            const getCorrelationTOWIndicatorOption = (config, dataSource, specialData) => {
                const allDataSources = specialData?.allDataSources;
                if (!allDataSources) return {};

                const { formatNumber } = services.signalCalculator;
                const echarts = window.echarts;

                // Obtener tipo de m√©trica
                const chartType = config.type || 'correlation-towind-otm-impact';
                const metricPart = chartType.replace('correlation-towind-', '');

                // Mapear m√©tricas a columnas
                const metricToColumns = {
                    'otm-impact': { call: 'Call_OTM_Impact', put: 'Put_OTM_Impact' },
                    'money-flow': { call: 'Call_Money_Flow', put: 'Put_Money_Flow' },
                    'delta-flow': { call: 'Call_Delta_Flow', put: 'Put_Delta_Flow' },
                    'iv-flow': { call: 'Call_IV_Flow', put: 'Put_IV_Flow' },
                    'itm-impact': { call: 'Call_ITM_Impact', put: 'Put_ITM_Impact' },
                    'gex': { call: 'Call_GEX', put: 'Put_GEX' },
                    'vanna-flow': { call: 'Call_Vanna_Flow', put: 'Put_Vanna_Flow' },
                    'charm': { call: 'Call_Charm', put: 'Put_Charm' }
                };

                const columns = metricToColumns[metricPart] || metricToColumns['otm-impact'];
                const metricName = metricPart.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());

                // Slots de correlaci√≥n (S3-S6)
                const correlationSlots = ['3', '4', '5', '6'];
                const instrumentsData = [];

                correlationSlots.forEach((slotId, idx) => {
                    const ds = allDataSources.get(slotId);
                    if (!ds || !ds.rows || ds.rows.length === 0) return;

                    instrumentsData.push({
                        slotId,
                        rows: ds.rows,
                        timestampHeader: ds.timestampHeader,
                        headers: ds.headers
                    });
                });

                if (instrumentsData.length === 0) return {};

                // Par√°metros
                const lookback = config.parameters?.towLookback || 20;
                const velocityPeriod = config.parameters?.towVelocityPeriod || 5;
                const signalSmaPeriod = config.parameters?.towSignalSmaPeriod || 8;
                const brightIntensity = config.parameters?.brightIntensity || 1.0;
                const darkIntensity = config.parameters?.darkIntensity || 0.3;

                // Colores
                const parseHexColor = (hex, fallback) => {
                    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                    if (result) {
                        return { r: parseInt(result[1], 16), g: parseInt(result[2], 16), b: parseInt(result[3], 16) };
                    }
                    return fallback;
                };

                const positiveBaseColor = parseHexColor(config.parameters?.callColor, { r: 74, g: 158, b: 255 });
                const negativeBaseColor = parseHexColor(config.parameters?.putColor, { r: 255, g: 68, b: 68 });

                // Encontrar timestamps comunes
                const allTimestampSets = instrumentsData.map(inst => new Set(inst.rows.map(r => r[inst.timestampHeader])));
                let commonTimestamps = [...allTimestampSets[0]].filter(ts => allTimestampSets.every(set => set.has(ts))).sort();

                if (commonTimestamps.length === 0) {
                    commonTimestamps = instrumentsData[0].rows.map(r => r[instrumentsData[0].timestampHeader]);
                }

                const n = commonTimestamps.length;

                // Recopilar valores
                const allCallValues = [];
                const allPutValues = [];

                instrumentsData.forEach(inst => {
                    const rowMap = new Map(inst.rows.map(r => [r[inst.timestampHeader], r]));
                    const callVals = [];
                    const putVals = [];

                    commonTimestamps.forEach(ts => {
                        const row = rowMap.get(ts);
                        if (row) {
                            callVals.push(Math.abs(parseFloat(row[columns.call]) || 0));
                            putVals.push(Math.abs(parseFloat(row[columns.put]) || 0));
                        } else {
                            callVals.push(0);
                            putVals.push(0);
                        }
                    });

                    allCallValues.push(callVals);
                    allPutValues.push(putVals);
                });

                // Normalizar y combinar
                const normalizeArray = (arr) => {
                    const max = Math.max(...arr.filter(v => !isNaN(v)));
                    return max > 0 ? arr.map(v => (v / max) * 100) : arr;
                };

                const normalizedCallValues = allCallValues.map(arr => normalizeArray(arr));
                const normalizedPutValues = allPutValues.map(arr => normalizeArray(arr));

                const combinedCall = new Array(n).fill(0);
                const combinedPut = new Array(n).fill(0);

                for (let i = 0; i < n; i++) {
                    let callSum = 0, putSum = 0, count = normalizedCallValues.length;
                    normalizedCallValues.forEach(arr => { callSum += arr[i] || 0; });
                    normalizedPutValues.forEach(arr => { putSum += arr[i] || 0; });
                    combinedCall[i] = count > 0 ? callSum / count : 0;
                    combinedPut[i] = count > 0 ? putSum / count : 0;
                }

                // Rolling sums
                const callRollingSum = new Array(n).fill(0);
                const putRollingSum = new Array(n).fill(0);

                for (let i = 0; i < n; i++) {
                    const start = Math.max(0, i - lookback + 1);
                    let callSum = 0, putSum = 0;
                    for (let j = start; j <= i; j++) {
                        callSum += combinedCall[j];
                        putSum += combinedPut[j];
                    }
                    callRollingSum[i] = callSum;
                    putRollingSum[i] = putSum;
                }

                // Velocidades
                const callVelocity = new Array(n).fill(0);
                const putVelocity = new Array(n).fill(0);

                for (let i = velocityPeriod; i < n; i++) {
                    callVelocity[i] = callRollingSum[i] - callRollingSum[i - velocityPeriod];
                    putVelocity[i] = putRollingSum[i] - putRollingSum[i - velocityPeriod];
                }

                // Forces
                const bullishForce = new Array(n).fill(0);
                const bearishForce = new Array(n).fill(0);
                const netForce = new Array(n).fill(0);
                let maxNetForce = 1.0;

                for (let i = 0; i < n; i++) {
                    const callMom = callVelocity[i];
                    const putMom = putVelocity[i];

                    bullishForce[i] = Math.max(0, callMom) + Math.max(0, -putMom);
                    bearishForce[i] = Math.max(0, putMom) + Math.max(0, -callMom);
                    netForce[i] = bullishForce[i] - bearishForce[i];

                    maxNetForce = Math.max(maxNetForce, Math.abs(netForce[i]));
                }

                // Signal line
                const signalLine = new Array(n).fill(0);
                for (let i = signalSmaPeriod - 1; i < n; i++) {
                    let sum = 0;
                    for (let j = 0; j < signalSmaPeriod; j++) {
                        sum += netForce[i - j];
                    }
                    signalLine[i] = sum / signalSmaPeriod;
                }

                // Intensidad y colores
                const getIntensity = (nf, sl) => {
                    if ((nf > 0 && nf > sl) || (nf < 0 && nf < sl)) {
                        const normalizedIntensity = Math.abs(nf) / maxNetForce;
                        return darkIntensity + (normalizedIntensity * (brightIntensity - darkIntensity));
                    }
                    return darkIntensity;
                };

                const netForceData = [];
                for (let i = 0; i < n; i++) {
                    const nf = netForce[i];
                    const sl = signalLine[i];
                    const intensity = getIntensity(nf, sl);

                    let color;
                    if (nf >= 0) {
                        color = `rgb(${Math.round(positiveBaseColor.r * intensity)}, ${Math.round(positiveBaseColor.g * intensity)}, ${Math.round(positiveBaseColor.b * intensity)})`;
                    } else {
                        color = `rgb(${Math.round(negativeBaseColor.r * intensity)}, ${Math.round(negativeBaseColor.g * intensity)}, ${Math.round(negativeBaseColor.b * intensity)})`;
                    }

                    netForceData.push({
                        value: nf,
                        itemStyle: { color: color }
                    });
                }

                const bias = netForce[n - 1] > signalLine[n - 1] ? 'BULLISH' : 'BEARISH';

                return {
                    animation: true,
                    animationDuration: 100,
                    animationEasing: 'cubicOut',
                    animationDurationUpdate: 0,
                    backgroundColor: 'transparent',
                    tooltip: {
                        trigger: 'axis',
                        backgroundColor: 'rgba(20, 20, 20, 0.95)',
                        borderColor: 'rgba(74, 74, 74, 0.6)',
                        textStyle: { color: '#e8e8e8', fontSize: 11 },
                        axisPointer: { type: 'cross', crossStyle: { color: '#666' } },
                        formatter: (params) => {
                            if (!params || params.length === 0) return '';
                            const date = new Date(params[0].axisValue).toLocaleString();
                            let tooltip = `<div style="font-weight:bold;margin-bottom:4px;">${date}</div>`;
                            params.forEach((param) => {
                                const val = typeof param.value === 'object' ? param.value.value : param.value;
                                if (val !== null && val !== undefined) {
                                    const color = param.seriesName === 'Signal Line' ? '#ffffff' : (val >= 0 ? '#4a9eff' : '#ff4444');
                                    tooltip += `<span style="display:inline-block;margin-right:5px;border-radius:10px;width:10px;height:10px;background-color:${color};"></span>${param.seriesName}: <strong>${formatNumber(val)}</strong><br/>`;
                                }
                            });
                            tooltip += `<div style="margin-top:8px;padding-top:8px;border-top:1px solid #333;">
                                <span style="color:${bias === 'BULLISH' ? '#4a9eff' : '#ff4444'};">BIAS: ${bias}</span>
                            </div>`;
                            return tooltip;
                        }
                    },
                    legend: {
                        data: ['Net Force', 'Signal Line'],
                        textStyle: { color: '#e8e8e8', fontSize: 9 },
                        top: 5
                    },
                    grid: {
                        left: 40,
                        right: 10,
                        top: 30,
                        bottom: 25,
                        containLabel: false
                    },
                    xAxis: {
                        type: 'category',
                        data: commonTimestamps,
                        axisLine: { lineStyle: { color: '#333' } },
                        axisLabel: {
                            color: '#888', fontSize: 9, formatter: v => {
                                try { return new Date(v).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }); }
                                catch (e) { return v; }
                            }
                        },
                        splitLine: { show: false }
                    },
                    yAxis: {
                        type: 'value',
                        name: `TOW Indicator: ${metricName}`,
                        nameTextStyle: { color: '#888', fontSize: 10 },
                        scale: true,
                        axisLine: { lineStyle: { color: '#333' } },
                        axisLabel: { color: '#888', fontSize: 10, formatter: v => formatNumber(v) },
                        splitLine: { lineStyle: { color: '#222' } }
                    },
                    dataZoom: [{
                        type: 'inside',
                        start: config.zoomState?.start || 0,
                        end: config.zoomState?.end || 100,
                        zoomOnMouseWheel: true,
                        moveOnMouseMove: true
                    }],
                    series: [
                        {
                            name: 'Net Force',
                            type: 'bar',
                            data: netForceData,
                            barWidth: '70%',
                            z: 5
                        },
                        {
                            name: 'Signal Line',
                            type: 'line',
                            data: signalLine,
                            showSymbol: false,
                            smooth: false,
                            lineStyle: { color: 'rgba(150, 150, 150, 0.6)', width: 1.5 },
                            z: 10
                        }
                    ]
                };
            };

            // ===== INDICADOR TUG-OF-WAR NET FORCE (NinjaTrader Style) =====
            const getTOWIndicatorOption = (config, dataSource) => {
                const { rows, timestampHeader, headers } = dataSource;
                if (!rows || rows.length === 0) return {};

                const { formatNumber } = services.signalCalculator;
                const echarts = window.echarts;

                // Par√°metros del indicador (como en NinjaTrader)
                const lookback = config.parameters?.towLookback || 20;
                const velocityPeriod = config.parameters?.towVelocityPeriod || 5;
                const signalSmaPeriod = config.parameters?.towSignalSmaPeriod || 8;
                const brightIntensity = config.parameters?.brightIntensity || 1.0;
                const darkIntensity = config.parameters?.darkIntensity || 0.3;

                // Colores personalizados (parseados de hex)
                const parseHexColor = (hex, fallback) => {
                    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                    if (result) {
                        return { r: parseInt(result[1], 16), g: parseInt(result[2], 16), b: parseInt(result[3], 16) };
                    }
                    return fallback;
                };

                const positiveBaseColor = parseHexColor(config.parameters?.callColor, { r: 30, g: 144, b: 255 });
                const negativeBaseColor = parseHexColor(config.parameters?.putColor, { r: 255, g: 68, b: 68 });
                const signalLineColor = 'rgba(150, 150, 150, 0.6)';

                // Determinar columnas seg√∫n el tipo
                let callColumn, putColumn, title;
                switch (config.type) {
                    case 'towind-money-flow':
                        callColumn = 'Call_Money_Flow';
                        putColumn = 'Put_Money_Flow';
                        title = 'Money Flow';
                        break;
                    case 'towind-delta-flow':
                        callColumn = 'Call_Delta_Flow';
                        putColumn = 'Put_Delta_Flow';
                        title = 'Delta Flow';
                        break;
                    case 'towind-iv-flow':
                        callColumn = 'Call_IV_Flow';
                        putColumn = 'Put_IV_Flow';
                        title = 'IV Flow';
                        break;
                    case 'towind-otm-impact':
                        callColumn = 'Call_OTM_Impact';
                        putColumn = 'Put_OTM_Impact';
                        title = 'OTM Impact';
                        break;
                    case 'towind-itm-impact':
                        callColumn = 'Call_ITM_Impact';
                        putColumn = 'Put_ITM_Impact';
                        title = 'ITM Impact';
                        break;
                    case 'towind-gex':
                        callColumn = 'Call_GEX';
                        putColumn = 'Put_GEX';
                        title = 'GEX';
                        break;
                    case 'towind-vanna-flow':
                        callColumn = 'Call_Vanna_Flow';
                        putColumn = 'Put_Vanna_Flow';
                        title = 'Vanna Flow';
                        break;
                    case 'towind-charm':
                        callColumn = 'Call_Charm';
                        putColumn = 'Put_Charm';
                        title = 'Charm';
                        break;
                    case 'towind-iv-flow-itm':
                        callColumn = 'Call_IV_Flow_ITM';
                        putColumn = 'Put_IV_Flow_ITM';
                        title = 'IV Flow ITM';
                        break;
                    case 'towind-iv-flow-otm':
                        callColumn = 'Call_IV_Flow_OTM';
                        putColumn = 'Put_IV_Flow_OTM';
                        title = 'IV Flow OTM';
                        break;
                    case 'towind-iv-net':
                        callColumn = 'Call_IV_Net';
                        putColumn = 'Put_IV_Net';
                        title = 'IV Net';
                        break;
                    case 'towind-vol-imbalance':
                        callColumn = 'Call_Vol_Imbalance';
                        putColumn = 'Put_Vol_Imbalance';
                        title = 'Vol Imbalance';
                        break;
                    case 'towind-smart-money':
                        callColumn = 'Call_Smart_Money';
                        putColumn = 'Put_Smart_Money';
                        title = 'Smart Money';
                        break;
                    case 'towind-hedge-pressure':
                        callColumn = 'Call_Hedge_Pressure';
                        putColumn = 'Put_Hedge_Pressure';
                        title = 'Hedge Pressure';
                        break;
                    default:
                        return {};
                }

                if (!headers.includes(callColumn) || !headers.includes(putColumn)) {
                    return {};
                }

                // Extraer datos
                const callValues = rows.map(r => Math.abs(r[callColumn] || 0));
                const putValues = rows.map(r => Math.abs(r[putColumn] || 0));
                const timestamps = rows.map(r => r[timestampHeader]);
                const n = rows.length;

                // 1. Calcular Rolling Sums
                const callRollingSum = new Array(n).fill(0);
                const putRollingSum = new Array(n).fill(0);

                for (let i = 0; i < n; i++) {
                    const start = Math.max(0, i - lookback + 1);
                    let callSum = 0, putSum = 0;
                    for (let j = start; j <= i; j++) {
                        callSum += callValues[j];
                        putSum += putValues[j];
                    }
                    callRollingSum[i] = callSum;
                    putRollingSum[i] = putSum;
                }

                // 2. Calcular Velocidades
                const callVelocity = new Array(n).fill(0);
                const putVelocity = new Array(n).fill(0);

                for (let i = velocityPeriod; i < n; i++) {
                    callVelocity[i] = callRollingSum[i] - callRollingSum[i - velocityPeriod];
                    putVelocity[i] = putRollingSum[i] - putRollingSum[i - velocityPeriod];
                }

                // 3. Calcular Bullish/Bearish Force y Net Force
                const bullishForce = new Array(n).fill(0);
                const bearishForce = new Array(n).fill(0);
                const netForce = new Array(n).fill(0);
                let maxNetForce = 1.0;

                for (let i = 0; i < n; i++) {
                    const callMom = callVelocity[i];
                    const putMom = putVelocity[i];

                    bullishForce[i] = Math.max(0, callMom) + Math.max(0, -putMom);
                    bearishForce[i] = Math.max(0, putMom) + Math.max(0, -callMom);
                    netForce[i] = bullishForce[i] - bearishForce[i];

                    maxNetForce = Math.max(maxNetForce, Math.abs(netForce[i]));
                }

                // 4. Calcular Signal Line (SMA del NetForce)
                const signalLine = new Array(n).fill(0);
                for (let i = signalSmaPeriod - 1; i < n; i++) {
                    let sum = 0;
                    for (let j = 0; j < signalSmaPeriod; j++) {
                        sum += netForce[i - j];
                    }
                    signalLine[i] = sum / signalSmaPeriod;
                }

                // 5. Calcular intensidad del gradiente para cada barra
                const getIntensity = (nf, sl) => {
                    // Si est√° por encima de SMA (bullish) o por debajo (bearish) ‚Üí m√°s intenso
                    if ((nf > 0 && nf > sl) || (nf < 0 && nf < sl)) {
                        const normalizedIntensity = Math.abs(nf) / maxNetForce;
                        return darkIntensity + (normalizedIntensity * (brightIntensity - darkIntensity));
                    } else {
                        return darkIntensity;
                    }
                };

                // 6. Preparar datos con colores para cada barra
                const netForceData = [];
                for (let i = 0; i < n; i++) {
                    const nf = netForce[i];
                    const sl = signalLine[i];
                    const intensity = getIntensity(nf, sl);

                    let color;
                    if (nf >= 0) {
                        color = `rgb(${Math.round(positiveBaseColor.r * intensity)}, ${Math.round(positiveBaseColor.g * intensity)}, ${Math.round(positiveBaseColor.b * intensity)})`;
                    } else {
                        color = `rgb(${Math.round(negativeBaseColor.r * intensity)}, ${Math.round(negativeBaseColor.g * intensity)}, ${Math.round(negativeBaseColor.b * intensity)})`;
                    }

                    netForceData.push({
                        value: [timestamps[i], nf],
                        itemStyle: { color: color }
                    });
                }

                const signalLineData = signalLine.map((v, i) => [timestamps[i], v]);

                // 7. Calcular m√©tricas actuales para el panel
                const lastIdx = n - 1;
                const prevIdx = Math.max(0, lastIdx - 1);
                const currentNetForce = netForce[lastIdx];
                const previousNetForce = netForce[prevIdx];
                const currentSignal = signalLine[lastIdx];
                const currentBullish = bullishForce[lastIdx];
                const currentBearish = bearishForce[lastIdx];

                const netForceTrend = previousNetForce !== 0 ?
                    ((currentNetForce - previousNetForce) / Math.abs(previousNetForce) * 100) : 0;
                const bias = currentNetForce > currentSignal ? 'BULLISH' : 'BEARISH';

                const fmtNum = (num) => {
                    const absNum = Math.abs(num);
                    if (absNum >= 1e9) return (num / 1e9).toFixed(2) + 'B';
                    if (absNum >= 1e6) return (num / 1e6).toFixed(2) + 'M';
                    if (absNum >= 1e3) return (num / 1e3).toFixed(1) + 'K';
                    return num.toFixed(0);
                };

                return {
                    animation: true,
                    animationDuration: 100,
                    backgroundColor: 'transparent',
                    tooltip: {
                        trigger: 'axis',
                        backgroundColor: 'rgba(15, 15, 20, 0.95)',
                        borderColor: 'rgba(60, 60, 70, 0.6)',
                        textStyle: { color: '#e8e8e8', fontSize: 11 },
                        axisPointer: { type: 'cross' },
                        formatter: (params) => {
                            if (!params || params.length === 0) return '';
                            const time = new Date(params[0].axisValue).toLocaleString();
                            let html = `<div style="font-weight:bold;margin-bottom:8px;">${time}</div>`;
                            params.forEach(p => {
                                const value = formatNumber(p.value[1]);
                                const color = p.seriesName === 'Signal Line' ? '#ffffff' :
                                    (p.value[1] >= 0 ? '#1e90ff' : '#ff4444');
                                html += `<div style="margin-top:4px;">
                                    <span style="display:inline-block;width:10px;height:10px;border-radius:2px;background:${color};margin-right:6px;"></span>
                                    ${p.seriesName}: <strong style="color:${color}">${value}</strong>
                                </div>`;
                            });
                            html += `<div style="margin-top:8px;padding-top:8px;border-top:1px solid #333;">
                                <span style="color:${bias === 'BULLISH' ? '#4a9eff' : '#ff4444'};">BIAS: ${bias}</span>
                            </div>`;
                            return html;
                        }
                    },
                    legend: {
                        data: ['Net Force', 'Signal Line'],
                        textStyle: { color: '#aaa', fontSize: 11 },
                        top: 5,
                        itemStyle: { borderWidth: 0 }
                    },
                    grid: {
                        left: 50,
                        right: 18,
                        top: 35,
                        bottom: 30
                    },
                    xAxis: {
                        type: 'time',
                        axisLine: { lineStyle: { color: '#333' } },
                        axisLabel: { color: '#888', fontSize: 10 },
                        splitLine: { show: false }
                    },
                    yAxis: {
                        type: 'value',
                        scale: true,
                        name: `${title} - Net Force`,
                        nameTextStyle: { color: '#999', fontSize: 10 },
                        axisLine: { lineStyle: { color: '#333' } },
                        axisLabel: {
                            color: '#888',
                            fontSize: 10,
                            formatter: (v) => formatNumber(v)
                        },
                        splitLine: { lineStyle: { color: '#222' } }
                    },
                    dataZoom: [{ type: 'inside', start: config.zoomState?.start || 0, end: config.zoomState?.end || 100, zoomOnMouseWheel: true, moveOnMouseMove: true }],
                    series: [
                        {
                            name: 'Net Force',
                            type: 'bar',
                            data: netForceData,
                            barWidth: '70%',
                            z: 5
                        },
                        {
                            name: 'Signal Line',
                            type: 'line',
                            data: signalLineData,
                            showSymbol: false,
                            smooth: false,
                            lineStyle: { color: signalLineColor, width: 1.5 },
                            z: 10
                        }
                    ]
                };
            };

            switch (config.category) {
                case 'price': return getPriceOption(config, dataSource, volumeProfile, bigTradesData);
                case 'evolution': return getEvolutionOption(config, dataSource, specialData);
                case 'evolution-metric': return getEvolutionMetricOption(config, dataSource);
                case 'signal': return getSignalOption(config, specialData);
                case 'imbalance': return getImbalanceOption(config, dataSource, specialData);
                case 'tug-of-war': return getTugOfWarOption(config, dataSource, specialData);
                case 'intensity': return getIntensityOption(config, dataSource);
                case 'tugofwar': return getTugOfWarMetricOption(config, dataSource);
                case 'towindicator': return getTOWIndicatorOption(config, dataSource);
                case 'dominance': return getDominanceOption(config, dataSource);
                case 'combined': return getCombinedOption(config, dataSource);
                case 'signal-2': return getCombinedOption(config, dataSource);
                case 'ratio': return getRatioOption(config, dataSource);
                case 'gauge': return getGaugeOption(config, dataSource);
                case 'net': return getNetOption(config, dataSource, specialData);
                case 'pulse-rsi': return getPulseRsiChartOption(config, dataSource);
                case 'correlation-pulse-rsi': return getCorrelationPulseRsiOption(config, dataSource, specialData);
                case 'otm-correlation': return getOtmCorrelationPowerMeterOption(config, dataSource, specialData);
                case 'correlation-keltner': return getCorrelationKeltnerOption(config, dataSource, specialData);
                case 'correlation-evolution': return getCorrelationEvolutionOption(config, dataSource, specialData);
                case 'correlation-dominance': return getCorrelationDominanceOption(config, dataSource, specialData);
                case 'correlation-zscore': return getCorrelationZScoreOption(config, dataSource, specialData);
                case 'correlation-tow': return getCorrelationTugOfWarOption(config, dataSource, specialData);
                case 'correlation-intensity': return getCorrelationIntensityOption(config, dataSource, specialData);
                case 'correlation-towind': return getCorrelationTOWIndicatorOption(config, dataSource, specialData);
                default: return {};
            }
        };
        // --- END: services/echartsOptions.ts ---

        // --- START: components/icons.tsx ---
        components.icons.PlusIcon = () => React.createElement('svg', { xmlns: "http://www.w3.org/2000/svg", className: "h-4 w-4", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor" }, React.createElement('path', { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M12 4v16m8-8H4" }));
        components.icons.GridIcon = () => React.createElement('svg', { xmlns: "http://www.w3.org/2000/svg", className: "h-4 w-4", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor" }, React.createElement('path', { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M4 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2V6zM14 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V6zM4 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2v-2zM14 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2v-2z" }));
        components.icons.LayoutIcon = () => React.createElement('svg', { xmlns: "http://www.w3.org/2000/svg", className: "h-4 w-4", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor" }, React.createElement('path', { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M4 6h16M4 12h16M4 18h16" }));
        components.icons.FileIcon = () => React.createElement('svg', { xmlns: "http://www.w3.org/2000/svg", className: "h-4 w-4", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor" }, React.createElement('path', { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" }));
        components.icons.SaveIcon = () => React.createElement('svg', { xmlns: "http://www.w3.org/2000/svg", className: "h-4 w-4", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor" }, React.createElement('path', { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M8 7H5a2 2 0 00-2 2v9a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-3m-1 4l-3 3m0 0l-3-3m3 3V4" }));
        components.icons.UploadIcon = () => React.createElement('svg', { xmlns: "http://www.w3.org/2000/svg", className: "h-4 w-4", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor" }, React.createElement('path', { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" }));
        components.icons.DownloadIcon = () => React.createElement('svg', { xmlns: "http://www.w3.org/2000/svg", className: "h-4 w-4", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor" }, React.createElement('path', { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" }));
        components.icons.CloseIcon = () => React.createElement('svg', { xmlns: "http://www.w3.org/2000/svg", className: "h-5 w-5", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor" }, React.createElement('path', { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M6 18L18 6M6 6l12 12" }));
        components.icons.CollapseIcon = () => React.createElement('svg', { xmlns: "http://www.w3.org/2000/svg", className: "h-4 w-4", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor" }, React.createElement('path', { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M20 12H4" }));
        components.icons.ExpandIcon = () => React.createElement('svg', { xmlns: "http://www.w3.org/2000/svg", className: "h-4 w-4", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor" }, React.createElement('path', { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M12 4v16m8-8H4" }));
        components.icons.FullscreenIcon = () => React.createElement('svg', { xmlns: "http://www.w3.org/2000/svg", className: "h-4 w-4", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor" }, React.createElement('path', { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M4 8V4h4m12 4V4h-4M4 16v4h4m12-4v4h-4" }));
        components.icons.ResetIcon = () => React.createElement('svg', { xmlns: "http://www.w3.org/2000/svg", className: "h-4 w-4", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor" }, React.createElement('path', { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M4 4v5h5M20 20v-5h-5M4 4l16 16" }));
        components.icons.TrashIcon = () => React.createElement('svg', { xmlns: "http://www.w3.org/2000/svg", className: "h-4 w-4", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor" }, React.createElement('path', { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" }));
        components.icons.PlayIcon = () => React.createElement('svg', { xmlns: "http://www.w3.org/2000/svg", className: "h-4 w-4", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor" }, React.createElement('path', { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z" }), React.createElement('path', { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M21 12a9 9 0 11-18 0 9 9 0 0118 0z" }));
        components.icons.PauseIcon = () => React.createElement('svg', { xmlns: "http://www.w3.org/2000/svg", className: "h-4 w-4", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor" }, React.createElement('path', { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z" }));
        components.icons.StopIcon = () => React.createElement('svg', { xmlns: "http://www.w3.org/2000/svg", className: "h-4 w-4", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor" }, React.createElement('path', { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M21 12a9 9 0 11-18 0 9 9 0 0118 0z" }), React.createElement('path', { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M9 9h6v6H9z" }));
        components.icons.NextIcon = () => React.createElement('svg', { xmlns: "http://www.w3.org/2000/svg", className: "h-4 w-4", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor" }, React.createElement('path', { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M13 5l7 7-7 7M5 5l7 7-7 7" }));
        components.icons.PrevIcon = () => React.createElement('svg', { xmlns: "http://www.w3.org/2000/svg", className: "h-4 w-4", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor" }, React.createElement('path', { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M11 19l-7-7 7-7m8 14l-7-7 7-7" }));
        components.icons.HistoryIcon = () => React.createElement('svg', { xmlns: "http://www.w3.org/2000/svg", className: "h-4 w-4", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor" }, React.createElement('path', { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" }));
        components.icons.CalculatorIcon = () => React.createElement('svg', { xmlns: "http://www.w3.org/2000/svg", className: "h-4 w-4", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor" }, React.createElement('path', { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M9 7h6m-6 4h6m-6 4h.01M5 5h14a2 2 0 012 2v10a2 2 0 01-2 2H5a2 2 0 01-2-2V7a2 2 0 012-2z" }));
        components.icons.VolumeUpIcon = () => React.createElement('svg', { xmlns: "http://www.w3.org/2000/svg", className: "h-4 w-4", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor" }, React.createElement('path', { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 12.728M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z" }));
        components.icons.VolumeOffIcon = () => React.createElement('svg', { xmlns: "http://www.w3.org/2000/svg", className: "h-4 w-4", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor" }, React.createElement('path', { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z" }), React.createElement('path', { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M17 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2" }));
        components.icons.BroadcastIcon = () => React.createElement('svg', { xmlns: "http://www.w3.org/2000/svg", className: "h-4 w-4", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", strokeWidth: "2" }, React.createElement('path', { strokeLinecap: "round", strokeLinejoin: "round", d: "M5.636 18.364c3.515 3.515 9.213 3.515 12.728 0M12 12V3m0 9c-3.142 0-6.028-1.16-8.246-3.11M12 12c3.142 0 6.028-1.16 8.246-3.11" }));
        components.icons.SendIcon = () => React.createElement('svg', { xmlns: "http://www.w3.org/2000/svg", className: "h-4 w-4", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor" }, React.createElement('path', { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M12 19l9 2-9-18-9 18 9-2zm0 0v-8" }));
        // --- END: components/icons.tsx ---

        // --- START: components/BacktestIndicator.tsx ---
        components.BacktestIndicator = ({ state }) => {
            const progress = state.total > 0 ? (state.currentIndex / state.total) * 100 : 0;
            return React.createElement('div', { className: "fixed top-[140px] left-4 bg-neutral-900/80 backdrop-blur-md border border-neutral-700 rounded-lg shadow-2xl p-3 w-72 z-40" },
                React.createElement('div', { className: "flex justify-between items-baseline mb-1" },
                    React.createElement('span', { className: "text-sm font-semibold text-gray-200" }, `Backtest Running (Slot ${state.slotId})`),
                    React.createElement('span', { className: "text-xs text-neutral-400" }, `${state.currentIndex}/${state.total} (${progress.toFixed(1)}%)`)
                ),
                React.createElement('div', { className: "w-full bg-neutral-700 rounded-full h-1.5 mb-2" },
                    React.createElement('div', { className: "bg-sky-500 h-1.5 rounded-full transition-all duration-200", style: { width: `${progress}%` } })
                ),
                React.createElement('div', { className: "text-xs text-center text-sky-300 font-mono tracking-wider" }, state.currentTime)
            );
        };
        // --- END: components/BacktestIndicator.tsx ---

        // --- START: components/BacktestResultsPanel.tsx ---
        components.BacktestResultsPanel = ({ results, onClose }) => {
            const { formatNumber } = services.signalCalculator;
            const Metric = ({ label, value, className = '' }) => (
                React.createElement('div', { className: "flex flex-col items-center justify-center p-2 bg-neutral-800/50 rounded-md text-center" },
                    React.createElement('span', { className: "text-xs text-neutral-400 uppercase tracking-wider" }, label),
                    React.createElement('span', { className: `text-lg font-semibold font-mono ${className}` }, value)
                )
            );
            const pnlColor = results.pnl >= 0 ? 'text-blue-400' : 'text-red-400';
            return (
                React.createElement('div', { className: "flex-shrink-0 bg-neutral-950/70 border-t-2 border-neutral-700 p-3" },
                    React.createElement('div', { className: "flex justify-between items-center mb-2" },
                        React.createElement('h4', { className: "text-sm font-semibold text-gray-200" }, "Backtest Results"),
                        React.createElement('button', { onClick: onClose, className: "p-1 rounded-full hover:bg-neutral-700" }, React.createElement(components.icons.CloseIcon))
                    ),
                    React.createElement('div', { className: "grid grid-cols-3 md:grid-cols-4 lg:grid-cols-7 gap-2" },
                        React.createElement(Metric, { label: "PnL", value: `$${formatNumber(results.pnl)}`, className: pnlColor }),
                        React.createElement(Metric, { label: "PnL %", value: `${results.pnlPercent.toFixed(2)}%`, className: pnlColor }),
                        React.createElement(Metric, { label: "Max Drawdown", value: `$${formatNumber(results.maxDrawdown)}`, className: "text-red-400" }),
                        React.createElement(Metric, { label: "Win Rate", value: `${results.winRate.toFixed(2)}%`, className: results.winRate > 50 ? 'text-blue-400' : 'text-red-400' }),
                        React.createElement(Metric, { label: "Total Trades", value: String(results.totalTrades) }),
                        React.createElement(Metric, { label: "Sharpe Ratio", value: results.sharpeRatio.toFixed(2), className: results.sharpeRatio > 1 ? 'text-blue-400' : results.sharpeRatio > 0 ? 'text-yellow-400' : 'text-red-400' }),
                        React.createElement(Metric, { label: "Avg PnL/Trade", value: `$${formatNumber(results.averagePnl)}`, className: results.averagePnl > 0 ? 'text-blue-400' : 'text-red-400' })
                    )
                )
            );
        };
        // --- END: components/BacktestResultsPanel.tsx ---

        // --- START: components/VolumeSurgeLevels.tsx ---
        // Componente simple sin hooks internos para evitar problemas
        components.VolumeSurgeLevels = function ({ volumeProfile, currentPrice }) {
            // Calcular datos directamente sin useMemo para evitar problemas
            let surgeData = null;
            try {
                if (volumeProfile && typeof volumeProfile.size === 'number' && volumeProfile.size > 0) {
                    surgeData = {
                        min5: services.csvParser.detectVolumeSurges(volumeProfile, 5, 2.0),
                        min15: services.csvParser.detectVolumeSurges(volumeProfile, 15, 2.0)
                    };
                }
            } catch (e) {
                console.error('VolumeSurgeLevels error:', e);
                surgeData = null;
            }

            if (!surgeData) {
                return React.createElement('div', {
                    className: "mb-4 bg-neutral-900/50 rounded-lg p-2 border border-neutral-700/30 text-center"
                },
                    React.createElement('span', { className: "text-[9px] text-neutral-500" }, "Esperando datos de Volume Profile...")
                );
            }

            const data5 = surgeData.min5 || { supports: [], resistances: [], hotZones: [] };
            const data15 = surgeData.min15 || { supports: [], resistances: [], hotZones: [] };
            const formatNum = services.signalCalculator.formatNumber;

            // Combinar zonas importantes de ambos timeframes
            const allResistances = [...(data5.resistances || []), ...(data15.resistances || [])];
            const allSupports = [...(data5.supports || []), ...(data15.supports || [])];

            // Remover duplicados por strike cercano y ordenar
            const uniqueResistances = allResistances.reduce((acc, zone) => {
                if (!acc.find(z => Math.abs(z.strike - zone.strike) < 1)) acc.push(zone);
                return acc;
            }, []).sort((a, b) => parseFloat(b.surgeRatio) - parseFloat(a.surgeRatio)).slice(0, 3);

            const uniqueSupports = allSupports.reduce((acc, zone) => {
                if (!acc.find(z => Math.abs(z.strike - zone.strike) < 1)) acc.push(zone);
                return acc;
            }, []).sort((a, b) => parseFloat(b.surgeRatio) - parseFloat(a.surgeRatio)).slice(0, 3);

            const renderLevel = function (zone, type) {
                if (!zone || typeof zone.strike !== 'number') return null;
                const isNear = currentPrice && Math.abs(zone.strike - currentPrice) / currentPrice < 0.005;
                const color = type === 'R' ? 'sky' : 'red';

                return React.createElement('div', {
                    key: zone.strike,
                    className: `flex items-center justify-between px-2 py-1 rounded bg-${color}-900/30 border border-${color}-700/40 ${isNear ? 'ring-1 ring-yellow-500/50' : ''}`
                },
                    React.createElement('span', { className: `text-[10px] font-bold text-${color}-400` }, zone.strike.toFixed(2)),
                    React.createElement('span', { className: "text-[8px] text-neutral-400" }, `${zone.surgeRatio}x`),
                    React.createElement('span', { className: `text-[8px] text-${color}-400` }, formatNum(zone.recentVol || 0))
                );
            };

            return React.createElement('div', { className: "mb-4 bg-neutral-900/50 rounded-lg p-2 border border-neutral-700/30" },
                // Header
                React.createElement('div', { className: "flex items-center justify-between mb-2" },
                    React.createElement('span', { className: "text-[9px] font-bold text-amber-400" }, "üî• VOLUME SURGES (>2x)"),
                    React.createElement('span', { className: "text-[8px] text-neutral-500" }, `5m + 15m combined`)
                ),
                // Grid
                React.createElement('div', { className: "grid grid-cols-2 gap-2" },
                    // Resistencias
                    React.createElement('div', null,
                        React.createElement('div', { className: "text-[8px] text-sky-400 font-bold mb-1" },
                            `‚ñ≤ RES (${uniqueResistances.length})`
                        ),
                        uniqueResistances.length > 0
                            ? React.createElement('div', { className: "space-y-1" },
                                uniqueResistances.map(z => renderLevel(z, 'R'))
                            )
                            : React.createElement('div', { className: "text-[8px] text-neutral-600 py-1" }, "-")
                    ),
                    // Soportes
                    React.createElement('div', null,
                        React.createElement('div', { className: "text-[8px] text-red-400 font-bold mb-1" },
                            `‚ñº SUP (${uniqueSupports.length})`
                        ),
                        uniqueSupports.length > 0
                            ? React.createElement('div', { className: "space-y-1" },
                                uniqueSupports.map(z => renderLevel(z, 'S'))
                            )
                            : React.createElement('div', { className: "text-[8px] text-neutral-600 py-1" }, "-")
                    )
                )
            );
        };
        // --- END: components/VolumeSurgeLevels.tsx ---

        // --- START: components/ImbalanceSpikesMetrics.tsx ---
        components.ImbalanceSpikesMetrics = ({ metrics }) => {
            const { formatNumber } = services.signalCalculator;
            const MetricDisplay = ({ label, value, className = '' }) => (
                React.createElement('div', { className: "flex flex-col text-center" },
                    React.createElement('span', { className: "text-[10px] text-neutral-400 uppercase tracking-wider" }, label),
                    React.createElement('span', { className: `text-sm font-semibold font-mono ${className}` }, value)
                )
            );
            return (
                React.createElement('div', { className: "flex-shrink-0 bg-neutral-800/30 border-t border-neutral-700 px-4 py-1.5" },
                    React.createElement('div', { className: "grid grid-cols-4 md:grid-cols-8 gap-2 items-center" },
                        React.createElement(MetricDisplay, { label: "Imbalance", value: `${metrics.currentImb.toFixed(1)}%`, className: metrics.currentImb > 0 ? 'text-sky-400' : 'text-red-400' }),
                        React.createElement(MetricDisplay, { label: "SMA", value: `${metrics.currentSMA.toFixed(1)}%`, className: "text-neutral-300" }),
                        React.createElement(MetricDisplay, { label: "Call Vol", value: formatNumber(metrics.currentCallVol), className: "text-sky-400" }),
                        React.createElement(MetricDisplay, { label: "Put Vol", value: formatNumber(metrics.currentPutVol), className: "text-red-400" }),
                        React.createElement(MetricDisplay, { label: "Call Spike", value: metrics.currentCallSpike.toFixed(2), className: "text-sky-400" }),
                        React.createElement(MetricDisplay, { label: "Put Spike", value: metrics.currentPutSpike.toFixed(2), className: "text-red-400" }),
                        React.createElement(MetricDisplay, { label: "Call Intensity", value: metrics.currentCallIntensity.toFixed(3), className: "text-sky-400" }),
                        React.createElement(MetricDisplay, { label: "Put Intensity", value: metrics.currentPutIntensity.toFixed(3), className: "text-red-400" })
                    )
                )
            );
        };
        // --- END: components/ImbalanceSpikesMetrics.tsx ---

        // --- START: components/SignalHistoryPanel.tsx ---
        components.SignalHistoryPanel = ({ history, onClose }) => {
            return (
                React.createElement('div', { className: "flex-shrink-0 bg-neutral-950/70 border-t border-neutral-700/50 p-1.5" },
                    React.createElement('div', { className: "flex justify-between items-center mb-1" },
                        React.createElement('span', { className: "text-[10px] font-bold text-neutral-400 uppercase" }, `History (${history.length})`),
                        React.createElement('button', { onClick: onClose, className: "p-0.5 rounded hover:bg-neutral-700 text-neutral-500" }, React.createElement(components.icons.CloseIcon))
                    ),
                    React.createElement('div', { className: "max-h-32 overflow-y-auto bg-neutral-800/20 rounded" },
                        React.createElement('table', { className: "w-full text-[9px]" },
                            React.createElement('thead', { className: "text-[8px] text-neutral-500 uppercase bg-neutral-800/40 sticky top-0" },
                                React.createElement('tr', null,
                                    React.createElement('th', { className: "px-2 py-0.5 text-left" }, "Time"),
                                    React.createElement('th', { className: "px-2 py-0.5 text-left" }, "Type"),
                                    React.createElement('th', { className: "px-2 py-0.5 text-right" }, "Price")
                                )
                            ),
                            React.createElement('tbody', null,
                                history.length > 0
                                    ? history.slice().reverse().map((signal, index) => (
                                        React.createElement('tr', { key: index, className: "border-b border-neutral-800/30 hover:bg-neutral-700/20" },
                                            React.createElement('td', { className: "px-2 py-0.5 text-neutral-400 font-mono" }, signal.time),
                                            React.createElement('td', { className: `px-2 py-0.5 font-bold ${signal.type === 'BUY' ? 'text-blue-400' : 'text-red-400'}` }, signal.type),
                                            React.createElement('td', { className: "px-2 py-0.5 text-neutral-300 font-mono text-right" }, signal.price.toFixed(2))
                                        )
                                    ))
                                    : React.createElement('tr', null,
                                        React.createElement('td', { colSpan: 3, className: "text-center py-2 text-neutral-600 text-[8px]" }, "No signals")
                                    )
                            )
                        )
                    )
                )
            );
        };
        // --- END: components/SignalHistoryPanel.tsx ---

        // --- START: components/SignalStatusCard.tsx ---
        components.SignalStatusCard = ({ signal, onSend }) => {
            const signalConfig = {
                BULLISH: { text: 'BULLISH', className: 'bg-blue-500/20 border-blue-500 text-blue-400' },
                BEARISH: { text: 'BEARISH', className: 'bg-red-500/20 border-red-500 text-red-400' },
            };
            const currentConfig = signalConfig[signal.state];
            if (!currentConfig) return null;
            return (
                React.createElement('div', { className: "bg-neutral-800/50 border border-neutral-700 rounded-lg p-3 flex flex-col justify-between gap-3 shadow-md hover:border-neutral-600 transition-all" },
                    React.createElement('div', null,
                        React.createElement('p', { className: "text-xs text-neutral-400 truncate", title: signal.chartTitle }, signal.chartTitle),
                        React.createElement('div', { className: "flex items-baseline gap-3 mt-1" },
                            React.createElement('p', { className: `text-xl font-bold tracking-wider ${currentConfig.className} rounded px-2 py-0.5 inline-block` }, currentConfig.text),
                            signal.value !== undefined && React.createElement('p', { className: "text-lg font-mono font-semibold text-neutral-200", title: "Signal Value" }, signal.value.toFixed(2))
                        )
                    ),
                    React.createElement('button', { onClick: () => onSend(signal), className: "w-full flex items-center justify-center gap-2 px-3 py-2 bg-sky-600 text-white rounded-md text-sm font-semibold hover:bg-sky-500 transition-all" },
                        React.createElement(components.icons.SendIcon),
                        React.createElement('span', null, "Send to MT5")
                    )
                )
            );
        };
        // --- END: components/SignalStatusCard.tsx ---

        // --- START: components/MT5SignalView.tsx ---
        components.MT5SignalView = ({ signals }) => {
            const [log, setLog] = React.useState([]);
            const handleSendSignal = (signal) => {
                const newLogEntry = {
                    timestamp: new Date().toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit', second: '2-digit' }),
                    chart: signal.chartTitle,
                    signal: signal.state,
                    value: signal.value,
                };
                setLog(prevLog => [newLogEntry, ...prevLog].slice(0, 100));
            };
            const signalEntries = Array.from(signals.values());
            return (
                React.createElement('div', { className: "p-4 bg-neutral-900 h-[calc(100vh-136px)] flex flex-col gap-4" },
                    React.createElement('header', null,
                        React.createElement('h1', { className: "text-2xl font-bold text-gray-100 tracking-wider" }, "MT5 Automatic Signal Terminal"),
                        React.createElement('p', { className: "text-sm text-neutral-400" }, "Consolidated real-time signals from your active dashboard charts.")
                    ),
                    React.createElement('div', { className: "flex-grow flex flex-col gap-4 overflow-hidden" },
                        React.createElement('div', { className: "flex-shrink-0" },
                            React.createElement('h3', { className: "text-sm font-bold text-neutral-400 uppercase tracking-wider mb-2 border-b border-neutral-700 pb-1" }, "Live Signal Status"),
                            React.createElement('div', { className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-3 max-h-[300px] overflow-y-auto pr-2" },
                                signalEntries.length > 0
                                    ? signalEntries.map(signal => React.createElement(components.SignalStatusCard, { key: signal.chartId, signal: signal, onSend: handleSendSignal }))
                                    : React.createElement('div', { className: "col-span-full text-center text-neutral-500 py-16 border-2 border-dashed border-neutral-700 rounded-lg" },
                                        React.createElement('p', { className: "text-lg" }, "No active signals."),
                                        React.createElement('p', { className: "text-sm mt-1" }, "Signals from your dashboard charts will appear here automatically.")
                                    )
                            )
                        ),
                        React.createElement('div', { className: "flex-grow flex flex-col min-h-0" },
                            React.createElement('h3', { className: "text-sm font-bold text-neutral-400 uppercase tracking-wider mb-2 border-b border-neutral-700 pb-1" }, "Signal Log"),
                            React.createElement('div', { className: "flex-grow overflow-y-auto bg-neutral-950/50 rounded-md border border-neutral-800" },
                                React.createElement('table', { className: "w-full text-sm text-left" },
                                    React.createElement('thead', { className: "text-xs text-neutral-400 uppercase bg-neutral-800/60 sticky top-0 z-10" },
                                        React.createElement('tr', null,
                                            React.createElement('th', { scope: "col", className: "px-4 py-2" }, "Time"),
                                            React.createElement('th', { scope: "col", className: "px-4 py-2" }, "Signal"),
                                            React.createElement('th', { scope: "col", className: "px-4 py-2" }, "Value"),
                                            React.createElement('th', { scope: "col", className: "px-4 py-2" }, "Source Indicator")
                                        )
                                    ),
                                    React.createElement('tbody', { className: "divide-y divide-neutral-800" },
                                        log.length > 0
                                            ? log.map((entry, index) => (
                                                React.createElement('tr', { key: index, className: "hover:bg-neutral-700/30" },
                                                    React.createElement('td', { className: "px-4 py-1.5 text-neutral-300 font-mono" }, entry.timestamp),
                                                    React.createElement('td', { className: `px-4 py-1.5 font-bold tracking-wider ${entry.signal === 'BULLISH' ? 'text-blue-400' : 'text-red-400'}` }, entry.signal),
                                                    React.createElement('td', { className: "px-4 py-1.5 text-neutral-300 font-mono" }, entry.value?.toFixed(2) ?? '-'),
                                                    React.createElement('td', { className: "px-4 py-1.5 text-neutral-400 text-xs truncate", title: entry.chart }, entry.chart)
                                                )
                                            ))
                                            : React.createElement('tr', null, React.createElement('td', { colSpan: 4, className: "text-center py-8 text-neutral-500" }, "No signals sent to MT5 yet."))
                                    )
                                )
                            )
                        )
                    )
                )
            );
        };
        // --- END: components/MT5SignalView.tsx ---

        // --- START: components/AddChartModal.tsx ---
        components.AddChartModal = ({ isOpen, onClose, onAddChart, dataSources }) => {
            const [selectedSlot, setSelectedSlot] = React.useState('');
            const [selectedChartType, setSelectedChartType] = React.useState('');
            const [selectedMetric, setSelectedMetric] = React.useState('');

            const hasDataInSelectedSlot = selectedSlot && dataSources.has(selectedSlot);

            React.useEffect(() => {
                if (!isOpen) {
                    setSelectedSlot('');
                    setSelectedChartType('');
                    setSelectedMetric('');
                }
            }, [isOpen]);

            if (!isOpen) return null;

            // Definir tipos de gr√°ficos disponibles
            const chartTypes = [
                { value: 'price-profile-bigtrades', label: 'üìä Price + Profile + Big Trades', category: 'price', prefix: 'price-profile-bt' },
                { value: 'evolution', label: 'Evolution', category: 'evolution-metric', prefix: 'evo' },
                { value: 'towindicator', label: 'TOW Indicator', category: 'towindicator', prefix: 'towind' },
                { value: 'intensity', label: 'Intensity', category: 'intensity', prefix: 'intensity' },
                { value: 'tugofwar', label: 'Tug-of-War', category: 'tugofwar', prefix: 'tow' },
                { value: 'combined', label: 'Z-Score', category: 'combined', prefix: 'combined' },
                { value: 'dominance', label: 'Dominance', category: 'dominance', prefix: 'dominance' },
                { value: 'net', label: 'Net (Keltner)', category: 'net', prefix: 'net' },
                { value: 'power-meter-pro', label: 'Power Meter Pro', category: 'power-meter-pro', prefix: 'power-meter-pro' },
                { value: 'ml-pattern', label: 'ML Pattern Analysis', category: 'ml-pattern', prefix: 'ml-pattern' },
                { value: 'pulse-rsi', label: 'Pulse RSI (Lyro)', category: 'pulse-rsi', prefix: 'pulse-rsi' },
                { value: 'correlation-pulse-rsi', label: 'Correlation Pulse RSI (4 Inst)', category: 'correlation-pulse-rsi', prefix: 'correlation-pulse-rsi' },
                { value: 'correlation-keltner', label: 'Correlation Keltner (4 Inst)', category: 'correlation-keltner', prefix: 'correlation-keltner' },
                { value: 'correlation-evolution', label: 'Correlation Evolution (4 Inst)', category: 'correlation-evolution', prefix: 'correlation-evolution' },
                { value: 'correlation-dominance', label: 'Correlation Dominance (4 Inst)', category: 'correlation-dominance', prefix: 'correlation-dominance' },
                { value: 'correlation-zscore', label: 'Correlation Z-Score (4 Inst)', category: 'correlation-zscore', prefix: 'correlation-zscore' },
                { value: 'correlation-tow', label: 'Correlation Tug-of-War (4 Inst)', category: 'correlation-tow', prefix: 'correlation-tow' },
                { value: 'correlation-intensity', label: 'Correlation Intensity (4 Inst)', category: 'correlation-intensity', prefix: 'correlation-intensity' },
                { value: 'correlation-towind', label: 'Correlation TOW Indicator (4 Inst)', category: 'correlation-towind', prefix: 'correlation-towind' }
            ];

            // Definir m√©tricas disponibles
            const metrics = [
                { value: 'money-flow', label: 'Money Flow' },
                { value: 'delta-flow', label: 'Delta Flow' },
                { value: 'iv-flow', label: 'IV Flow' },
                { value: 'otm-impact', label: 'OTM Impact' },
                { value: 'itm-impact', label: 'ITM Impact' },
                { value: 'gex', label: 'GEX' },
                { value: 'vanna-flow', label: 'Vanna Flow' },
                { value: 'charm', label: 'Charm' },
                { value: 'iv-flow-itm', label: 'IV Flow ITM' },
                { value: 'iv-flow-otm', label: 'IV Flow OTM' },
                { value: 'iv-net', label: 'IV Net' },
                { value: 'vol-imbalance', label: 'Vol Imbalance' },
                { value: 'smart-money', label: 'Smart Money' },
                { value: 'hedge-pressure', label: 'Hedge Pressure' }
            ];

            // M√©tricas para Big Trades (columnas Net del CSV)
            const bigTradeMetrics = [
                { value: 'Net_Money_Flow', label: 'Big Cash' },
                { value: 'Net_Delta_Flow', label: 'Big Delta' },
                { value: 'Net_OTM_Impact', label: 'Big OTM' },
                { value: 'Net_ITM_Impact', label: 'Big ITM' },
                { value: 'Net_GEX', label: 'Big GEX' },
                { value: 'Net_IV_Flow', label: 'Big IV Flow' },
                { value: 'Net_Vanna_Flow', label: 'Big Vanna' },
                { value: 'Net_Charm', label: 'Big Charm' },
                { value: 'Net_Smart_Money', label: 'Big Smart Money' },
                { value: 'Net_Vol_Imbalance', label: 'Big Vol Imbalance' }
            ];

            const handleAdd = () => {
                const chartTypeObj = chartTypes.find(ct => ct.value === selectedChartType);
                if (!chartTypeObj) return;

                // Price + Profile + Big Trades - tipo especial
                if (selectedChartType === 'price-profile-bigtrades') {
                    if (!selectedMetric || !selectedSlot) return;
                    // Crear chart con par√°metros especiales para Big Trades
                    onAddChart(selectedSlot, 'price', 'price-profile', {
                        showBigTrades: true,
                        bigTradesMetric: selectedMetric,
                        bigTradesStdDev: 2.0,
                        profileType: 'cash'
                    });
                    onClose();
                    return;
                }

                // Power Meter Pro tiene tipos fijos, no usa el selector de m√©tricas
                if (selectedChartType === 'power-meter-pro') {
                    const fullType = selectedMetric === 'correlation' ? 'power-meter-pro-correlation' : 'power-meter-pro-single';
                    const slotToUse = selectedMetric === 'correlation' ? '3' : selectedSlot;
                    onAddChart(slotToUse, chartTypeObj.category, fullType);
                    onClose();
                    return;
                }

                // ML Pattern Analysis tiene tipos fijos (single o correlation)
                if (selectedChartType === 'ml-pattern') {
                    const fullType = selectedMetric === 'correlation' ? 'ml-pattern-correlation' : 'ml-pattern-single';
                    const slotToUse = selectedMetric === 'correlation' ? '3' : selectedSlot;
                    onAddChart(slotToUse, chartTypeObj.category, fullType);
                    onClose();
                    return;
                }

                if (!selectedMetric) return;
                const metricObj = metrics.find(m => m.value === selectedMetric);
                if (!metricObj) return;

                // Construir el tipo completo usando el prefix definido
                const fullType = `${chartTypeObj.prefix}-${selectedMetric}`;

                // Para Correlation usar slot '3' como default (usa slots 3-6 internamente)
                const isCorrelationType = selectedChartType === 'otm-correlation' || selectedChartType === 'correlation-keltner';
                const slotToUse = isCorrelationType ? '3' : selectedSlot;
                onAddChart(slotToUse, chartTypeObj.category, fullType);
                onClose();
            };

            const chartTypeObj = chartTypes.find(ct => ct.value === selectedChartType);
            const isCorrelationChart = selectedChartType === 'otm-correlation' || selectedChartType === 'correlation-keltner' || selectedChartType === 'correlation-evolution' || selectedChartType === 'correlation-dominance' || selectedChartType === 'correlation-zscore' || selectedChartType === 'correlation-tow' || selectedChartType === 'correlation-intensity' || selectedChartType === 'correlation-towind' || selectedChartType === 'correlation-pulse-rsi';
            const isPowerMeterPro = selectedChartType === 'power-meter-pro';
            const isMLPattern = selectedChartType === 'ml-pattern';
            const isPriceProfileBigTrades = selectedChartType === 'price-profile-bigtrades';
            const isPowerMeterProCorrelation = isPowerMeterPro && selectedMetric === 'correlation';
            const isPowerMeterProSingle = isPowerMeterPro && selectedMetric === 'single';
            const isMLPatternCorrelation = isMLPattern && selectedMetric === 'correlation';
            const isMLPatternSingle = isMLPattern && selectedMetric === 'single';

            // Para Correlation y Power Meter Pro Correlation no se requiere slot espec√≠fico
            // Para Power Meter Pro Single s√≠ se requiere slot con datos
            const canAdd = isCorrelationChart || isPowerMeterProCorrelation || isMLPatternCorrelation
                ? (selectedChartType && selectedMetric)
                : isPowerMeterProSingle || isPriceProfileBigTrades || isMLPatternSingle
                    ? (selectedSlot && hasDataInSelectedSlot && selectedMetric)
                    : (selectedSlot && hasDataInSelectedSlot && selectedChartType && selectedMetric);

            return (
                React.createElement('div', { className: "fixed inset-0 bg-black/70 z-[100] flex items-center justify-center", onClick: onClose },
                    React.createElement('div', { className: "bg-neutral-900 border border-neutral-800 rounded-lg shadow-2xl w-full max-w-md flex flex-col", onClick: e => e.stopPropagation() },
                        React.createElement('div', { className: "flex justify-between items-center p-4 border-b border-neutral-700" },
                            React.createElement('h2', { className: "text-lg font-semibold" }, "Add Chart"),
                            React.createElement('button', { onClick: onClose, className: "p-1 rounded-full hover:bg-neutral-700" }, React.createElement(components.icons.CloseIcon))
                        ),
                        React.createElement('div', { className: "p-4 space-y-4" },
                            // Slot Selection (oculto para Correlation, Power Meter Pro Correlation y ML Pattern Correlation)
                            !isCorrelationChart && !isPowerMeterProCorrelation && !isMLPatternCorrelation && React.createElement('div', null,
                                React.createElement('label', { className: "block text-sm font-medium text-neutral-400 mb-2" }, "1. Select Data Slot:"),
                                React.createElement('select', {
                                    value: selectedSlot,
                                    onChange: e => setSelectedSlot(e.target.value),
                                    className: "w-full bg-neutral-800 border border-neutral-700 rounded-md px-3 py-2 text-gray-200 focus:outline-none focus:ring-2 focus:ring-sky-500"
                                },
                                    React.createElement('option', { value: "" }, "-- Select a slot --"),
                                    [...Array(6)].map((_, i) => React.createElement('option', { key: i + 1, value: String(i + 1) }, `Slot ${i + 1} ${dataSources.has(String(i + 1)) ? ' (Loaded)' : ''}`))
                                )
                            ),

                            // Info para Correlation
                            isCorrelationChart && React.createElement('div', { className: "bg-sky-900/20 border border-sky-700/50 rounded-lg p-3" },
                                React.createElement('p', { className: "text-sky-400 text-sm" }, "Correlation uses data from Slots 3-6 (Correlation Slots)"),
                                React.createElement('p', { className: "text-sky-300/70 text-xs mt-1" }, "Load CSV files in slots 3, 4, 5, and 6 for multi-instrument analysis")
                            ),

                            // Chart Type Selection (siempre visible)
                            React.createElement('div', null,
                                React.createElement('label', { className: "block text-sm font-medium text-neutral-400 mb-2" }, isCorrelationChart || isPowerMeterProCorrelation || isMLPatternCorrelation ? "1. Chart Type:" : "2. Select Chart Type:"),
                                React.createElement('select', {
                                    value: selectedChartType,
                                    onChange: e => setSelectedChartType(e.target.value),
                                    className: "w-full bg-neutral-800 border border-neutral-700 rounded-md px-3 py-2 text-gray-200 focus:outline-none focus:ring-2 focus:ring-sky-500"
                                },
                                    React.createElement('option', { value: "" }, "-- Select chart type --"),
                                    chartTypes.map(ct => React.createElement('option', { key: ct.value, value: ct.value }, ct.label))
                                )
                            ),

                            // Metric Selection (visible cuando hay chart type seleccionado)
                            // Para Power Meter Pro y ML Pattern, mostrar opciones especiales
                            selectedChartType && (isPowerMeterPro || isMLPattern || isCorrelationChart || (selectedSlot && hasDataInSelectedSlot)) && React.createElement('div', null,
                                React.createElement('label', { className: "block text-sm font-medium text-neutral-400 mb-2" },
                                    (isPowerMeterPro || isMLPattern) ? "2. Select Mode:" : (isCorrelationChart ? "2. Select Metric:" : "3. Select Metric:")
                                ),
                                React.createElement('select', {
                                    value: selectedMetric,
                                    onChange: e => setSelectedMetric(e.target.value),
                                    className: "w-full bg-neutral-800 border border-neutral-700 rounded-md px-3 py-2 text-gray-200 focus:outline-none focus:ring-2 focus:ring-sky-500"
                                },
                                    React.createElement('option', { value: "" }, (isPowerMeterPro || isMLPattern) ? "-- Select mode --" : isPriceProfileBigTrades ? "-- Select Big Trade metric --" : "-- Select metric --"),
                                    isPowerMeterPro
                                        ? [
                                            React.createElement('option', { key: 'single', value: 'single' }, 'Single Slot (Momentum/LongTerm/Volatility)'),
                                            React.createElement('option', { key: 'correlation', value: 'correlation' }, 'Correlation (4 Instruments - Slots 3-6)')
                                        ]
                                        : isMLPattern
                                            ? [
                                                React.createElement('option', { key: 'single', value: 'single' }, 'Single Slot (Analysis)'),
                                                React.createElement('option', { key: 'correlation', value: 'correlation' }, 'Correlation (4 Instruments - Slots 3-6)')
                                            ]
                                            : isPriceProfileBigTrades
                                                ? bigTradeMetrics.map(m => React.createElement('option', { key: m.value, value: m.value }, m.label))
                                                : metrics.map(m => React.createElement('option', { key: m.value, value: m.value }, m.label))
                                )
                            ),

                            // Info para ML Pattern
                            isMLPattern && React.createElement('div', { className: "bg-purple-900/20 border border-purple-700/50 rounded-lg p-3" },
                                React.createElement('p', { className: "text-purple-400 text-sm" }, "ML Pattern Recognition"),
                                React.createElement('p', { className: "text-purple-300/70 text-xs mt-1" }, "Analyzes historical price events (highs, lows, impulses) and finds metric coincidences to generate predictive signals")
                            ),

                            // Info para Price + Profile + Big Trades
                            isPriceProfileBigTrades && React.createElement('div', { className: "bg-emerald-900/20 border border-emerald-700/50 rounded-lg p-3" },
                                React.createElement('p', { className: "text-emerald-400 text-sm" }, "üìä Price chart with Volume Profile + Big Trades"),
                                React.createElement('p', { className: "text-emerald-300/70 text-xs mt-1" }, "Shows price, SMA, volume profile bars, and scatter points for big trades (>2œÉ)")
                            ),

                            // Info para Power Meter Pro Single
                            isPowerMeterPro && selectedMetric === 'single' && !selectedSlot && React.createElement('div', { className: "bg-amber-900/20 border border-amber-700/50 rounded-lg p-3" },
                                React.createElement('p', { className: "text-amber-400 text-sm" }, "Select a slot with data loaded"),
                                React.createElement('p', { className: "text-amber-300/70 text-xs mt-1" }, "The Power Meter Pro will show Momentum, Long Term, and Volatility meters")
                            ),

                            // Info para Power Meter Pro Correlation
                            isPowerMeterPro && selectedMetric === 'correlation' && React.createElement('div', { className: "bg-sky-900/20 border border-sky-700/50 rounded-lg p-3" },
                                React.createElement('p', { className: "text-sky-400 text-sm" }, "Uses data from Slots 3-6 (Correlation Slots)"),
                                React.createElement('p', { className: "text-sky-300/70 text-xs mt-1" }, "Shows 4 Power Meters side by side, one per instrument")
                            ),

                            // No data message (solo para non-correlation y non-power-meter-pro-correlation)
                            !isCorrelationChart && !isPowerMeterProCorrelation && selectedSlot && !hasDataInSelectedSlot && React.createElement('div', { className: "text-center text-neutral-500 p-8 border-2 border-dashed border-neutral-700 rounded-lg" },
                                React.createElement('p', null, `No data loaded in Slot ${selectedSlot}.`),
                                React.createElement('p', { className: "text-xs mt-1" }, "Please load a CSV file first.")
                            )
                        ),
                        React.createElement('div', { className: "p-4 border-t border-neutral-700 flex justify-end gap-2" },
                            React.createElement('button', { onClick: onClose, className: "px-4 py-2 bg-neutral-700 hover:bg-neutral-600 rounded-md text-sm font-semibold transition-colors" }, "Cancel"),
                            React.createElement('button', {
                                onClick: handleAdd,
                                disabled: !canAdd,
                                className: `px-4 py-2 rounded-md text-sm font-semibold transition-colors ${canAdd ? 'bg-sky-600 hover:bg-sky-500 text-white' : 'bg-neutral-800 text-neutral-600 cursor-not-allowed'}`
                            }, "Add Chart")
                        )
                    )
                )
            );
        };
        // --- END: components/AddChartModal.tsx ---

        // --- START: components/ChartWrapper.tsx ---
        components.ChartWrapper = ({ config, dataSource, volumeProfile, onDelete, onUpdate, onDominanceSignalUpdate, onSpikeSignalUpdate, onEvolutionSignalUpdate, onKeltnerSignalUpdate, allDataSources, gridLayout }) => {
            const { useState, useEffect, useRef, useCallback, useMemo } = React;
            const { formatNumber } = services.signalCalculator;
            const { CloseIcon, ExpandIcon, CollapseIcon, ResetIcon, FullscreenIcon, DownloadIcon, TrashIcon, CalculatorIcon, HistoryIcon } = components.icons;

            const DominanceSignalIndicator = ({ signal }) => {
                if (!signal || !signal.state) return null;
                const signalConfig = {
                    BULLISH: { text: 'ALCISTA', className: 'bg-blue-500/20 border-blue-500 text-blue-400 animate-pulse-blue' },
                    BEARISH: { text: 'BAJISTA', className: 'bg-red-500/20 border-red-500 text-red-400 animate-pulse-red' },
                    FLAT: { text: 'LATERAL', className: 'bg-neutral-700/20 border-neutral-600 text-neutral-400' }
                };
                const currentConfig = signalConfig[signal.state];
                if (!currentConfig) {
                    console.warn("Invalid signal state received:", signal.state);
                    return null;
                }
                return React.createElement('div', { className: `flex items-center gap-2 text-center px-2 py-0.5 rounded-md border text-xs font-bold tracking-wider transition-all duration-300 ${currentConfig.className}` },
                    React.createElement('span', null, currentConfig.text),
                    React.createElement('span', { className: "text-[10px] font-mono font-normal opacity-90", title: "Net Dominance" }, formatNumber(signal.value)),
                    React.createElement('style', null, `
                        @keyframes pulse-blue { 0%, 100% { box-shadow: 0 0 0 0 rgba(74, 158, 255, 0.4); } 50% { box-shadow: 0 0 4px 1px rgba(74, 158, 255, 0.1); } }
                        .animate-pulse-blue { animation: pulse-blue 2s infinite; }
                        @keyframes pulse-red { 0%, 100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.4); } 50% { box-shadow: 0 0 4px 1px rgba(239, 68, 68, 0.1); } }
                        .animate-pulse-red { animation: pulse-red 2s infinite; }
                    `)
                );
            };

            const chartRef = useRef(null);
            const chartInstance = useRef(null);
            const [isFullscreen, setIsFullscreen] = useState(false);
            const [backtestResults, setBacktestResults] = useState(null);
            const [isHistoryVisible, setIsHistoryVisible] = useState(false);
            const [isBacktestVisible, setIsBacktestVisible] = useState(false);
            const [isFullHistory, setIsFullHistory] = useState(false);

            const chartTitle = useMemo(() => {
                let title = `Slot ${config.slotId}: `;
                if (config.category === 'price') {
                    title += dataSource.priceHeader || 'Price';
                } else if (config.category === 'evolution') {
                    title += constants.EVOLUTION_GROUPS.find(g => g.key === config.type)?.name || 'Evolution';
                } else if (config.category === 'evolution-metric') {
                    const definition = constants.CHART_DEFINITIONS.main.find(c => c.type === config.type);
                    title += definition ? definition.name : 'Evolution: ' + config.type.replace('evo-', '').replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                } else if (config.category === 'otm-correlation') {
                    // Mostrar nombre descriptivo para Correlation Power Meter
                    const metricPart = (config.type || '').replace('otm-correlation-', '');
                    const metricName = metricPart.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    title = `Correlation Power Meter: ${metricName} (4 Instruments)`;
                } else if (config.category === 'correlation-keltner') {
                    // Mostrar nombre descriptivo para Correlation Keltner Index
                    const metricPart = (config.type || '').replace('correlation-keltner-', '');
                    const metricName = metricPart.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    title = `Correlation Keltner Index: ${metricName} (4 Instruments)`;
                } else if (config.category === 'correlation-evolution') {
                    // Mostrar nombre descriptivo para Correlation Evolution Index
                    const metricPart = (config.type || '').replace('correlation-evolution-', '');
                    const metricName = metricPart.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    title = `Correlation Evolution Index: ${metricName} (4 Instruments)`;
                } else if (config.category === 'correlation-dominance') {
                    // Mostrar nombre descriptivo para Correlation Dominance Index
                    const metricPart = (config.type || '').replace('correlation-dominance-', '');
                    const metricName = metricPart.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    title = `Correlation Dominance Index: ${metricName} (4 Instruments)`;
                } else if (config.category === 'correlation-zscore') {
                    // Mostrar nombre descriptivo para Correlation Z-Score Index
                    const metricPart = (config.type || '').replace('correlation-zscore-', '');
                    const metricName = metricPart.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    title = `Correlation Z-Score Index: ${metricName} (4 Instruments)`;
                } else if (config.category === 'correlation-tow') {
                    // Mostrar nombre descriptivo para Correlation Tug-of-War
                    const metricPart = (config.type || '').replace('correlation-tow-', '');
                    const metricName = metricPart.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    title = `Correlation Tug-of-War: ${metricName} (4 Instruments)`;
                } else if (config.category === 'correlation-intensity') {
                    // Mostrar nombre descriptivo para Correlation Intensity Index
                    const metricPart = (config.type || '').replace('correlation-intensity-', '');
                    const metricName = metricPart.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    title = `Correlation Intensity Index: ${metricName} (4 Instruments)`;
                } else if (config.category === 'correlation-towind') {
                    // Mostrar nombre descriptivo para Correlation TOW Indicator
                    const metricPart = (config.type || '').replace('correlation-towind-', '');
                    const metricName = metricPart.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    title = `Correlation TOW Indicator: ${metricName} (4 Instruments)`;
                } else {
                    const definition = [...constants.CHART_DEFINITIONS.main, ...constants.CHART_DEFINITIONS.advanced].find(c => c.type === config.type);
                    title += definition ? definition.name : config.type.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                }
                return title;
            }, [config.slotId, config.category, config.type, dataSource.priceHeader]);

            const isCollapsed = config.isCollapsed ?? false;

            const signalChartData = useMemo(() => {
                if (config.category !== 'signal' || dataSource.rows.length === 0) return { chartData: null, history: [] };
                const metrics = services.signalCalculator.getMetricsForType(config.type);
                if (!metrics) return { chartData: null, history: [] };
                const kamaPeriod = config.parameters.kamaPeriod || 100;
                const strengthThreshold = config.parameters.strengthThreshold || 10000000;
                return services.signalCalculator.calculateSignalData(dataSource.rows, dataSource.timestampHeader, config.slotId, metrics, kamaPeriod, strengthThreshold);
            }, [config, dataSource]);

            const evolutionSignalData = useMemo(() => {
                if (config.category !== 'evolution' || dataSource.rows.length < 2) return null;
                const metrics = services.signalCalculator.getMetricsForType(config.type);
                if (!metrics) return null;
                const threshold = config.parameters.evolutionThreshold ?? 100000;
                return services.signalCalculator.calculateEvolutionSignals(dataSource.rows, dataSource.timestampHeader, metrics.neto, threshold);
            }, [config.category, config.type, config.parameters, dataSource]);

            useEffect(() => {
                const lastSignalState = evolutionSignalData && evolutionSignalData.length > 0 ? evolutionSignalData[evolutionSignalData.length - 1].state : null;
                if (config.category === 'evolution') onEvolutionSignalUpdate(config.id, lastSignalState);
                return () => { if (config.category === 'evolution') onEvolutionSignalUpdate(config.id, null); };
            }, [evolutionSignalData, config.id, config.category, onEvolutionSignalUpdate]);

            // ===== KELTNER SIGNAL DATA =====
            const keltnerSignalData = useMemo(() => {
                if (config.category !== 'net' || dataSource.rows.length < 2) return null;

                // Determinar columna seg√∫n tipo
                let column;
                switch (config.type) {
                    case 'net-money-flow': column = 'Net_Money_Flow'; break;
                    case 'net-delta-flow': column = 'Net_Delta_Flow'; break;
                    case 'net-iv-flow': column = 'Net_IV_Flow'; break;
                    case 'net-otm-impact': column = 'Net_OTM_Impact'; break;
                    case 'net-itm-impact': column = 'Net_ITM_Impact'; break;
                    case 'net-gex': column = 'Net_GEX'; break;
                    case 'net-vanna-flow': column = 'Net_Vanna_Flow'; break;
                    case 'net-charm': column = 'Charm_Pressure'; break;
                    case 'net-iv-flow-itm': column = 'Net_IV_Flow_ITM'; break;
                    case 'net-iv-flow-otm': column = 'Net_IV_Flow_OTM'; break;
                    case 'net-iv-net': column = 'IV_Net'; break;
                    case 'net-vol-imbalance': column = 'Net_Vol_Imbalance'; break;
                    case 'net-smart-money': column = 'Net_Smart_Money'; break;
                    case 'net-hedge-pressure': column = 'Net_Hedge_Pressure'; break;
                    default: return null;
                }

                if (!dataSource.headers.includes(column)) return null;

                const emaPeriod = config.parameters?.keltnerEmaPeriod ?? 20;
                const atrMultiplier = config.parameters?.keltnerAtrMult ?? 3.0;
                const slopeThreshold = config.parameters?.keltnerSlopeThreshold ?? 10000;

                console.log(`Keltner [${config.id}]: EMA=${emaPeriod}, ATR=${atrMultiplier}, Slope=${slopeThreshold}`);

                return services.signalCalculator.calculateKeltnerSignals(
                    dataSource.rows,
                    dataSource.timestampHeader,
                    column,
                    emaPeriod,
                    atrMultiplier,
                    slopeThreshold
                );
            }, [config.category, config.type, config.parameters, dataSource]);

            useEffect(() => {
                const lastSignalState = keltnerSignalData && keltnerSignalData.length > 0 ? keltnerSignalData[keltnerSignalData.length - 1].state : null;
                if (config.category === 'net') onKeltnerSignalUpdate(config.id, lastSignalState);
                return () => { if (config.category === 'net') onKeltnerSignalUpdate(config.id, null); };
            }, [keltnerSignalData, config.id, config.category, onKeltnerSignalUpdate]);

            const imbalanceSpikesData = useMemo(() => {
                if (!config.type.endsWith('-spikes') || dataSource.rows.length < 2) return null;
                const metrics = services.signalCalculator.getMetricsForType(config.type);
                if (!metrics) return null;
                const smaPeriod = config.parameters.smaPeriod || 14;
                return services.signalCalculator.calculateImbalanceSpikesData(dataSource.rows, dataSource.timestampHeader, metrics, smaPeriod);
            }, [config.type, config.parameters, dataSource]);

            const spikesContextAndBacktest = useMemo(() => {
                if (!config.type.endsWith('-spikes') || !imbalanceSpikesData) return null;
                const spikeThreshold = config.parameters.spikeThreshold ?? 1.0;
                const intensityThreshold = config.parameters.intensityThreshold ?? 50;
                const contextSeries = services.signalCalculator.calculateSpikesContextSeries(imbalanceSpikesData, spikeThreshold, intensityThreshold);
                const backtest = services.signalCalculator.runSpikesContextBacktest(contextSeries, imbalanceSpikesData.imbalanceData);
                return { contextSeries, backtest };
            }, [config.type, config.parameters, imbalanceSpikesData]);

            const dominanceSignal = useMemo(() => {
                if (config.category !== 'imbalance' || !config.type.endsWith('-dominance-index') || dataSource.rows.length === 0) return null;
                const metrics = services.signalCalculator.getMetricsForType(config.type);
                if (!metrics) return null;
                const params = { dominanceRatio: config.parameters.dominanceRatio, smaPeriod: config.parameters.smaPeriod, lookback: config.parameters.lookback };
                return services.signalCalculator.calculateGlobalDominanceSignal(dataSource.rows, { call: metrics.call, put: metrics.put }, params);
            }, [config.category, config.type, config.parameters, dataSource]);

            const tugOfWarData = useMemo(() => {
                if (config.category !== 'tug-of-war' || dataSource.rows.length === 0) return null;
                const metrics = services.signalCalculator.getMetricsForType(config.type);
                if (!metrics) return null;
                const callData = dataSource.rows.map(r => r[metrics.call] || 0);
                const putData = dataSource.rows.map(r => r[metrics.put] || 0);
                const params = { lookback: config.parameters.towLookback ?? 20, velocityPeriod: config.parameters.towVelocityPeriod ?? 5, dominanceRatio: config.parameters.towDominanceRatio ?? 2, signalSmaPeriod: config.parameters.towSignalSmaPeriod ?? 8, dominanceFilterRatio: config.parameters.towDominanceFilterRatio ?? 1 };
                return services.signalCalculator.calculateTugOfWarMomentum(callData, putData, params);
            }, [config, dataSource]);

            const bigTradesData = useMemo(() => {
                if (config.category !== 'price' || !config.parameters.showBigTrades) return null;
                // Usar m√©trica seleccionada o default a 'Net_Money_Flow'
                const netoMetric = config.parameters.bigTradesMetric || 'Net_Money_Flow';
                // Buscar la columna en los headers (puede ser 'Cash Neto' legacy o nuevo formato)
                const hasMetric = dataSource.headers.includes(netoMetric) || dataSource.headers.includes('Cash Neto');
                if (!hasMetric) return null;
                const actualMetric = dataSource.headers.includes(netoMetric) ? netoMetric : 'Cash Neto';
                const stdDevMultiplier = config.parameters.bigTradesStdDev ?? 2.0;
                return services.signalCalculator.calculateBigTrades(dataSource.rows, dataSource.timestampHeader, dataSource.priceHeader, actualMetric, stdDevMultiplier);
            }, [config.category, config.parameters.showBigTrades, config.parameters.bigTradesStdDev, config.parameters.bigTradesMetric, dataSource]);

            useEffect(() => {
                let signalToUpdate = null;
                if (config.category === 'imbalance' && !config.type.endsWith('-spikes') && !config.type.endsWith('-er') && !config.type.endsWith('-velocity')) { signalToUpdate = dominanceSignal; }
                else if (config.category === 'tug-of-war') { signalToUpdate = tugOfWarData?.latest; }
                onDominanceSignalUpdate(config.id, signalToUpdate);
                return () => { onDominanceSignalUpdate(config.id, null); };
            }, [dominanceSignal, tugOfWarData, config.id, config.category, config.type, onDominanceSignalUpdate]);

            const macdSignal = useMemo(() => {
                if (!config.type.endsWith('-macd-dominance') || dataSource.rows.length === 0) return null;
                const metrics = services.signalCalculator.getMetricsForType(config.type); if (!metrics) return null;
                const { lookback = 30, fastPeriod = 8, slowPeriod = 20, signalPeriod = 5, dominanceRatio = 1.8 } = config.parameters;
                const callData = dataSource.rows.map(r => (r[metrics.call] || 0)); const putData = dataSource.rows.map(r => (r[metrics.put] || 0));
                const macdData = services.signalCalculator.calculateMACDDominance(callData, putData, lookback, fastPeriod, slowPeriod, signalPeriod);
                const syncSignals = services.signalCalculator.calculateMACDSyncSignals(macdData, dataSource.rows, dataSource.timestampHeader, dominanceRatio);
                return syncSignals.length > 0 ? syncSignals[syncSignals.length - 1].state : 'FLAT';
            }, [config.type, config.parameters, dataSource]);

            const macdNetSignal = useMemo(() => {
                if (!config.type.endsWith('-macd-net') || dataSource.rows.length === 0) return null;
                const metrics = services.signalCalculator.getMetricsForType(config.type); if (!metrics) return null;
                const { lookback = 30, fastPeriod = 8, slowPeriod = 20, signalPeriod = 5, dominanceRatio = 1.8 } = config.parameters;
                const callData = dataSource.rows.map(r => (r[metrics.call] || 0)); const putData = dataSource.rows.map(r => (r[metrics.put] || 0));
                const macdData = services.signalCalculator.calculateMACDDominance(callData, putData, lookback, fastPeriod, slowPeriod, signalPeriod);
                const macdNetData = services.signalCalculator.calculateMACDNet(callData, putData, lookback, fastPeriod, slowPeriod, signalPeriod);
                const netSignals = services.signalCalculator.calculateMACDNetSignals(macdNetData, macdData.call.rollingSum, macdData.put.rollingSum, dataSource.rows, dataSource.timestampHeader, dominanceRatio);
                return netSignals.length > 0 ? netSignals[netSignals.length - 1].state : 'FLAT';
            }, [config.type, config.parameters, dataSource]);

            useEffect(() => { if (config.type.endsWith('-macd-dominance')) onDominanceSignalUpdate(config.id, macdSignal); return () => { if (config.type.endsWith('-macd-dominance')) onDominanceSignalUpdate(config.id, null); }; }, [macdSignal, config.id, config.type, onDominanceSignalUpdate]);
            useEffect(() => { if (config.type.endsWith('-macd-net')) onDominanceSignalUpdate(config.id, macdNetSignal); return () => { if (config.type.endsWith('-macd-net')) onDominanceSignalUpdate(config.id, null); }; }, [macdNetSignal, config.id, config.type, onDominanceSignalUpdate]);

            useEffect(() => {
                const series = spikesContextAndBacktest?.contextSeries;
                const lastSignalState = series && series.length > 0 ? series[series.length - 1].state : 'FLAT';
                if (config.type.endsWith('-spikes')) onSpikeSignalUpdate(config.id, lastSignalState);
                return () => { if (config.type.endsWith('-spikes')) onSpikeSignalUpdate(config.id, null); };
            }, [spikesContextAndBacktest, config.id, config.type, onSpikeSignalUpdate]);

            const dominanceBacktestResults = useMemo(() => {
                if (!config.type.endsWith('-dominance-index') || dataSource.rows.length < 2) return null;
                const metrics = services.signalCalculator.getMetricsForType(config.type); if (!metrics) return null;
                const params = { dominanceRatio: config.parameters.dominanceRatio, smaPeriod: config.parameters.smaPeriod, lookback: config.parameters.lookback };
                const signalSeries = services.signalCalculator.calculateDominanceSignalSeries(dataSource.rows, metrics, params, dataSource.timestampHeader);
                return services.signalCalculator.runDominanceBacktest(signalSeries);
            }, [config.type, config.parameters, dataSource]);

            useEffect(() => {
                let observer;
                const chartElement = chartRef.current;
                if (chartElement) {
                    chartInstance.current = echarts.init(chartElement, 'dark');

                    const debounce = (func, delay) => {
                        let timeoutId;
                        return function (...args) {
                            clearTimeout(timeoutId);
                            timeoutId = window.setTimeout(() => func.apply(this, args), delay);
                        };
                    };

                    const handleResize = debounce(() => {
                        if (chartInstance.current && !chartInstance.current.isDisposed()) {
                            chartInstance.current.resize();
                        }
                    }, 150);

                    observer = new ResizeObserver(handleResize);
                    observer.observe(chartElement);

                    // Sincronizar zoomState cuando el usuario hace zoom manual
                    const handleDataZoom = debounce((params) => {
                        if (params.batch && params.batch.length > 0) {
                            const { start, end } = params.batch[0];
                            onUpdate(config.id, { zoomState: { start, end } });
                        } else if (params.start !== undefined && params.end !== undefined) {
                            onUpdate(config.id, { zoomState: { start: params.start, end: params.end } });
                        }
                    }, 300);
                    chartInstance.current.on('datazoom', handleDataZoom);

                    const totalRows = dataSource.rows.length;
                    if (totalRows > 0) {
                        const visibleStart = Math.max(0, totalRows - 15);
                        const startPercent = (visibleStart / totalRows) * 100;
                        onUpdate(config.id, { zoomState: { start: startPercent, end: 100 } });
                    }
                }

                return () => {
                    if (observer && chartElement) observer.unobserve(chartElement);
                    if (chartInstance.current && !chartInstance.current.isDisposed()) {
                        chartInstance.current.off('datazoom');
                        chartInstance.current.dispose();
                    }
                    chartInstance.current = null;
                };
            }, []);

            // ===== DOBLE CLIC: ALTERNAR ENTRE HISTORIAL COMPLETO Y √öLTIMOS 15 =====
            const handleDoubleClick = useCallback(() => {
                setIsFullHistory(prev => {
                    const totalRows = dataSource.rows.length;
                    if (totalRows === 0) return prev;

                    if (prev) {
                        // Volver a √∫ltimos 15 datos - SINCRONIZAR TODOS LOS GR√ÅFICOS
                        const visibleStart = Math.max(0, totalRows - 15);
                        const startPercent = (visibleStart / totalRows) * 100;
                        onUpdate(config.id, { zoomState: { start: startPercent, end: 100 } }, true);
                    } else {
                        // Mostrar historial completo - SINCRONIZAR TODOS LOS GR√ÅFICOS
                        onUpdate(config.id, { zoomState: { start: 0, end: 100 } }, true);
                    }
                    return !prev;
                });
            }, [dataSource.rows.length, config.id, onUpdate]);

            useEffect(() => {
                const chartElement = chartRef.current;
                if (!chartElement) return;

                chartElement.addEventListener('dblclick', handleDoubleClick);

                return () => {
                    if (chartElement) {
                        chartElement.removeEventListener('dblclick', handleDoubleClick);
                    }
                };
            }, [handleDoubleClick]);

            useEffect(() => {
                if (chartInstance.current && !chartInstance.current.isDisposed()) {
                    let option; let specialData;
                    if (config.category === 'signal') specialData = signalChartData.chartData;
                    else if (config.category === 'tug-of-war') specialData = tugOfWarData;
                    else if (config.type.endsWith('-spikes')) { if (imbalanceSpikesData) specialData = { ...imbalanceSpikesData, contextSeries: spikesContextAndBacktest?.contextSeries }; }
                    else if (config.category === 'evolution') specialData = evolutionSignalData;
                    else if (config.category === 'net') specialData = keltnerSignalData;
                    else if (config.category === 'otm-correlation') specialData = { allDataSources };
                    else if (config.category === 'correlation-keltner') specialData = { allDataSources };
                    else if (config.category === 'correlation-evolution') specialData = { allDataSources };
                    else if (config.category === 'correlation-dominance') specialData = { allDataSources };
                    else if (config.category === 'correlation-zscore') specialData = { allDataSources };
                    else if (config.category === 'correlation-tow') specialData = { allDataSources };
                    else if (config.category === 'correlation-intensity') specialData = { allDataSources };
                    else if (config.category === 'correlation-towind') specialData = { allDataSources };
                    else if (config.category === 'correlation-pulse-rsi') specialData = { allDataSources };
                    option = services.echartsOptions.getChartOption(config, dataSource, specialData, volumeProfile, bigTradesData);
                    if (option && Object.keys(option).length > 0) {
                        // Disable animation for smoother updates (prevents flickering during backtest replay)
                        option.animation = false;
                        option.animationDuration = 0;
                        option.animationDurationUpdate = 0;

                        chartInstance.current.setOption(option, {
                            notMerge: false,
                            replaceMerge: ['series'],
                            lazyUpdate: true  // Prevents immediate re-render, batches updates
                        });
                    }
                }
            }, [config, dataSource, signalChartData, imbalanceSpikesData, spikesContextAndBacktest, evolutionSignalData, keltnerSignalData, tugOfWarData, volumeProfile, bigTradesData, allDataSources]);

            const handleResetZoom = useCallback(() => {
                const totalRows = dataSource.rows.length;
                if (totalRows > 0) {
                    const visibleStart = Math.max(0, totalRows - 15);
                    const startPercent = (visibleStart / totalRows) * 100;
                    onUpdate(config.id, { zoomState: { start: startPercent, end: 100 } });
                } else {
                    onUpdate(config.id, { zoomState: { start: 0, end: 100 } });
                }
            }, [config.id, onUpdate, dataSource]);
            const handleDownload = () => { if (!chartInstance.current) return; const url = chartInstance.current.getDataURL({ type: 'png', pixelRatio: 2, backgroundColor: '#0a0a0a' }); const a = document.createElement('a'); a.href = url; a.download = `chart-${config.type}-${Date.now()}.png`; a.click(); };
            const toggleFullscreen = () => setIsFullscreen(!isFullscreen);
            const handleRunBacktest = () => { const results = services.signalCalculator.runBacktest(signalChartData.history); setBacktestResults(results); setIsBacktestVisible(true); };

            const renderControls = () => {
                // OTM Correlation chart needs window selector
                if (config.category === 'otm-correlation') {
                    const currentWindow = config.parameters?.correlationWindow || 60;
                    return React.createElement('div', { className: "flex items-center gap-1" },
                        React.createElement('span', { className: "text-[10px] text-neutral-500 uppercase" }, "Window:"),
                        React.createElement('select', {
                            value: currentWindow,
                            onChange: (e) => onUpdate(config.id, { parameters: { ...(config.parameters || {}), correlationWindow: parseInt(e.target.value) } }),
                            className: "bg-neutral-800 border border-neutral-700 rounded text-[10px] text-gray-200 px-1 py-0.5 focus:outline-none focus:ring-1 focus:ring-amber-500"
                        },
                            React.createElement('option', { value: 60 }, '60s'),
                            React.createElement('option', { value: 300 }, '5m'),
                            React.createElement('option', { value: 600 }, '10m')
                        )
                    );
                }
                // Price charts - controls for Big Trades and S/R Zones
                if (config.category === 'price') {
                    const controls = [];

                    // VWAP metric selector (always available for price charts)
                    const currentVWAPMetric = config.parameters?.vwapMetric || 'Total_Volume';
                    const vwapMetricLabels = {
                        'Total_Volume': 'Volume', 'Net_Money_Flow': 'Cash', 'Net_Delta_Flow': 'Delta', 'Net_OTM_Impact': 'OTM',
                        'Net_ITM_Impact': 'ITM', 'Net_GEX': 'GEX', 'Net_IV_Flow': 'IV',
                        'Net_Vanna_Flow': 'Vanna', 'Net_Charm': 'Charm', 'Net_Smart_Money': 'Smart$'
                    };
                    controls.push(
                        React.createElement('div', { key: 'vwap-metric', className: "flex items-center gap-1" },
                            React.createElement('span', { className: "text-[10px] text-neutral-500 uppercase" }, "VWAP:"),
                            React.createElement('select', {
                                value: currentVWAPMetric,
                                onChange: (e) => onUpdate(config.id, { parameters: { ...(config.parameters || {}), vwapMetric: e.target.value } }),
                                className: "bg-neutral-800 border border-neutral-700 rounded text-[10px] text-gray-200 px-1 py-0.5 focus:outline-none focus:ring-1 focus:ring-amber-500"
                            },
                                Object.entries(vwapMetricLabels).map(([value, label]) =>
                                    React.createElement('option', { key: value, value }, label)
                                )
                            )
                        )
                    );

                    // S/R Zones metric selector (when chart type is price-profile AND volumeProfile is loaded)
                    // El volumeProfile se pasa al ChartWrapper, verificar si est√° disponible
                    if (config.type === 'price-profile' && volumeProfile && volumeProfile.size > 0) {
                        const currentSRMetric = config.parameters?.srMetric || 'cash';
                        const currentSROpacity = config.parameters?.srOpacity ?? 1.0;
                        const srMetricLabels = { 'cash': 'Cash', 'delta': 'Delta', 'gex': 'GEX', 'vanna': 'Vanna', 'gamma': 'Gamma' };
                        controls.push(
                            React.createElement('div', { key: 'sr-metric', className: "flex items-center gap-1" },
                                React.createElement('span', { className: "text-[10px] text-neutral-500 uppercase" }, "S/R:"),
                                React.createElement('select', {
                                    value: currentSRMetric,
                                    onChange: (e) => onUpdate(config.id, { parameters: { ...(config.parameters || {}), srMetric: e.target.value } }),
                                    className: "bg-neutral-800 border border-neutral-700 rounded text-[10px] text-gray-200 px-1 py-0.5 focus:outline-none focus:ring-1 focus:ring-amber-500"
                                },
                                    Object.entries(srMetricLabels).map(([value, label]) =>
                                        React.createElement('option', { key: value, value }, label)
                                    )
                                )
                            ),
                            React.createElement('div', { key: 'sr-opacity', className: "flex items-center gap-1" },
                                React.createElement('span', { className: "text-[10px] text-neutral-500 uppercase" }, "Op:"),
                                React.createElement('select', {
                                    value: currentSROpacity,
                                    onChange: (e) => onUpdate(config.id, { parameters: { ...(config.parameters || {}), srOpacity: parseFloat(e.target.value) } }),
                                    className: "bg-neutral-800 border border-neutral-700 rounded text-[10px] text-gray-200 px-1 py-0.5 focus:outline-none focus:ring-1 focus:ring-amber-500"
                                },
                                    React.createElement('option', { value: 0.25 }, '25%'),
                                    React.createElement('option', { value: 0.5 }, '50%'),
                                    React.createElement('option', { value: 0.75 }, '75%'),
                                    React.createElement('option', { value: 1.0 }, '100%'),
                                    React.createElement('option', { value: 1.5 }, '150%'),
                                    React.createElement('option', { value: 2.0 }, '200%')
                                )
                            )
                        );
                    }

                    // Big Trades controls
                    if (config.parameters?.showBigTrades) {
                        const currentStdDev = config.parameters?.bigTradesStdDev ?? 2.0;
                        const currentMetric = config.parameters?.bigTradesMetric || 'Net_Money_Flow';
                        const metricLabels = {
                            'Net_Money_Flow': 'Cash', 'Net_Delta_Flow': 'Delta', 'Net_OTM_Impact': 'OTM',
                            'Net_ITM_Impact': 'ITM', 'Net_GEX': 'GEX', 'Net_IV_Flow': 'IV',
                            'Net_Vanna_Flow': 'Vanna', 'Net_Charm': 'Charm', 'Net_Smart_Money': 'Smart$',
                            'Net_Vol_Imbalance': 'Vol'
                        };
                        controls.push(
                            React.createElement('div', { key: 'bt-metric', className: "flex items-center gap-1" },
                                React.createElement('span', { className: "text-[10px] text-neutral-500 uppercase" }, "BT:"),
                                React.createElement('select', {
                                    value: currentMetric,
                                    onChange: (e) => onUpdate(config.id, { parameters: { ...(config.parameters || {}), bigTradesMetric: e.target.value } }),
                                    className: "bg-neutral-800 border border-neutral-700 rounded text-[10px] text-gray-200 px-1 py-0.5 focus:outline-none focus:ring-1 focus:ring-amber-500"
                                },
                                    Object.entries(metricLabels).map(([value, label]) =>
                                        React.createElement('option', { key: value, value }, label)
                                    )
                                )
                            ),
                            React.createElement('div', { key: 'bt-sigma', className: "flex items-center gap-1" },
                                React.createElement('span', { className: "text-[10px] text-neutral-500 uppercase" }, "œÉ:"),
                                React.createElement('select', {
                                    value: currentStdDev,
                                    onChange: (e) => onUpdate(config.id, { parameters: { ...(config.parameters || {}), bigTradesStdDev: parseFloat(e.target.value) } }),
                                    className: "bg-neutral-800 border border-neutral-700 rounded text-[10px] text-gray-200 px-1 py-0.5 focus:outline-none focus:ring-1 focus:ring-amber-500"
                                },
                                    React.createElement('option', { value: 0.5 }, '0.5œÉ'),
                                    React.createElement('option', { value: 0.75 }, '0.75œÉ'),
                                    React.createElement('option', { value: 1.0 }, '1.0œÉ'),
                                    React.createElement('option', { value: 1.25 }, '1.25œÉ'),
                                    React.createElement('option', { value: 1.5 }, '1.5œÉ'),
                                    React.createElement('option', { value: 1.75 }, '1.75œÉ'),
                                    React.createElement('option', { value: 2.0 }, '2.0œÉ'),
                                    React.createElement('option', { value: 2.5 }, '2.5œÉ'),
                                    React.createElement('option', { value: 3.0 }, '3.0œÉ'),
                                    React.createElement('option', { value: 4.0 }, '4.0œÉ')
                                )
                            )
                        );
                    }

                    if (controls.length > 0) {
                        return React.createElement('div', { className: "flex items-center gap-2" }, controls);
                    }
                }
                // Los controles de par√°metros ahora se manejan globalmente
                // Solo mantenemos los botones de interacci√≥n en el header
                return null;
            };

            const displaySignal = useMemo(() => {
                // Tug-of-War
                if (config.category === 'tug-of-war') return tugOfWarData?.latest;

                // Dominance Index
                if (config.category === 'imbalance' && config.type.endsWith('-dominance-index')) return dominanceSignal;

                // Intensity - check if above SMA
                if (config.category === 'intensity' && dataSource.rows.length > 0) {
                    const metrics = services.signalCalculator.getMetricsForType(config.type);
                    if (!metrics) return null;
                    const smaPeriod = config.parameters.smaPeriod || 14;
                    const ratio = config.parameters.bullishThreshold || 2.0;
                    const callData = dataSource.rows.map(r => parseFloat(r[metrics.call] || 0));
                    const putData = dataSource.rows.map(r => parseFloat(r[metrics.put] || 0));
                    const latest = callData.length > 0 ? callData[callData.length - 1] / (putData[putData.length - 1] || 1) : 1;
                    const sma = callData.slice(-smaPeriod).reduce((a, b, i, arr) => a + (callData[callData.length - smaPeriod + i] / (putData[putData.length - smaPeriod + i] || 1)) / arr.length, 0);
                    if (latest > sma && latest > ratio) return 'BULLISH';
                    if (latest < sma && latest < (1 / ratio)) return 'BEARISH';
                    return 'FLAT';
                }

                // Dominance (Signal 1): Dominance Index + Intensity
                if (config.category === 'dominance' && dataSource.rows.length > 0) {
                    const metrics = services.signalCalculator.getMetricsForType(config.type);
                    if (!metrics) return null;

                    const lookback = config.parameters.lookback || 30;
                    const smaPeriod = config.parameters.smaPeriod || 14;
                    const ratio = config.parameters.bullishThreshold || 2.0;
                    const rows = dataSource.rows;
                    const n = rows.length;

                    const callData = rows.map(r => parseFloat(r[metrics.call] || 0));
                    const putData = rows.map(r => parseFloat(r[metrics.put] || 0));

                    // 1. Dominance Index (Ratio of Rolling Sums)
                    const callRolling = new Array(n).fill(0);
                    const putRolling = new Array(n).fill(0);
                    for (let i = 0; i < n; i++) {
                        const start = Math.max(0, i - lookback + 1);
                        let cSum = 0, pSum = 0;
                        for (let j = start; j <= i; j++) { cSum += callData[j]; pSum += putData[j]; }
                        callRolling[i] = cSum; putRolling[i] = pSum;
                    }
                    const domRatios = callRolling.map((c, i) => c / (putRolling[i] || 1));
                    const domSMA = domRatios.slice(-smaPeriod).reduce((a, b) => a + b, 0) / Math.min(smaPeriod, domRatios.length);
                    const domBullish = domRatios[n - 1] > domSMA && domRatios[n - 1] > ratio;
                    const domBearish = domRatios[n - 1] < domSMA && domRatios[n - 1] < (1 / ratio);

                    // 2. Intensity (Ratio of Raw Values)
                    const intRatios = callData.map((c, i) => c / (putData[i] || 1));
                    const intSMA = intRatios.slice(-smaPeriod).reduce((a, b) => a + b, 0) / Math.min(smaPeriod, intRatios.length);
                    const intBullish = intRatios[n - 1] > intSMA && intRatios[n - 1] > ratio;
                    const intBearish = intRatios[n - 1] < intSMA && intRatios[n - 1] < (1 / ratio);

                    if (domBullish && intBullish) return 'BULLISH';
                    if (domBearish && intBearish) return 'BEARISH';
                    return 'FLAT';
                }

                // Combined - check ratio vs SMA
                if (config.category === 'combined' && dataSource.rows.length > 0) {
                    const metrics = services.signalCalculator.getMetricsForType(config.type);
                    if (!metrics) return null;
                    const smaPeriod = config.parameters.smaPeriod || 14;
                    const ratio = config.parameters.bullishThreshold || 2.0;
                    const callData = dataSource.rows.map(r => parseFloat(r[metrics.call] || 0));
                    const putData = dataSource.rows.map(r => parseFloat(r[metrics.put] || 0));
                    const ratios = callData.map((c, i) => c / (putData[i] || 1));
                    const latest = ratios[ratios.length - 1];
                    const sma = ratios.slice(-smaPeriod).reduce((a, b) => a + b, 0) / Math.min(smaPeriod, ratios.length);
                    if (latest > sma && latest > ratio) return 'BULLISH';
                    if (latest < sma && latest < (1 / ratio)) return 'BEARISH';
                    return 'FLAT';
                }

                // Net & TOW Indicator - use Keltner signal for NET category
                if ((config.category === 'net' || config.category === 'towindicator') && dataSource.rows.length > 0) {
                    // For NET category, use Keltner signal data if available
                    if (config.category === 'net' && keltnerSignalData && keltnerSignalData.length > 0) {
                        const lastKeltner = keltnerSignalData[keltnerSignalData.length - 1];
                        return lastKeltner.state || 'FLAT';
                    }

                    const metrics = services.signalCalculator.getMetricsForType(config.type);
                    if (!metrics) return null;
                    const smaPeriod = config.parameters.smaPeriod || 14;
                    const netData = dataSource.rows.map(r => parseFloat(r[metrics.call] || 0) - parseFloat(r[metrics.put] || 0));
                    const latest = netData[netData.length - 1];
                    const sma = netData.slice(-smaPeriod).reduce((a, b) => a + b, 0) / Math.min(smaPeriod, netData.length);
                    if (latest > sma && latest > 0) return 'BULLISH';
                    if (latest < sma && latest < 0) return 'BEARISH';
                    return 'FLAT';
                }

                // Power Meter - All 3 conditions must align (NET, Œî60s, Œî300s)
                if (config.category === 'power-meter' && dataSource.rows.length > 0) {
                    const metrics = services.signalCalculator.getMetricsForType(config.type);
                    if (!metrics) return null;
                    const rows = dataSource.rows;
                    const n = rows.length;
                    const timestampHeader = Object.keys(rows[0]).find(k => k.toLowerCase().includes('time') || k === 'Timestamp');

                    const currentCall = parseFloat(rows[n - 1][metrics.call]) || 0;
                    const currentPut = Math.abs(parseFloat(rows[n - 1][metrics.put])) || 0;
                    const currentNet = currentCall - currentPut;

                    // Delta 60s
                    const now = new Date(rows[n - 1][timestampHeader]).getTime();
                    let idx60 = n - 1, idx300 = 0;
                    for (let i = n - 2; i >= 0; i--) {
                        const t = new Date(rows[i][timestampHeader]).getTime();
                        if (now - t >= 60000 && idx60 === n - 1) idx60 = i;
                        if (now - t >= 300000) { idx300 = i; break; }
                    }
                    const oldNet60 = (parseFloat(rows[idx60][metrics.call]) || 0) - Math.abs(parseFloat(rows[idx60][metrics.put]) || 0);
                    const oldNet300 = (parseFloat(rows[idx300][metrics.call]) || 0) - Math.abs(parseFloat(rows[idx300][metrics.put]) || 0);
                    const delta60 = currentNet - oldNet60;
                    const delta300 = currentNet - oldNet300;

                    if (currentNet > 0 && delta60 > 0 && delta300 > 0) return 'BULLISH';
                    if (currentNet < 0 && delta60 < 0 && delta300 < 0) return 'BEARISH';
                    return 'FLAT';
                }

                // Signal 2: Combined Super Signal (Intensity + TOW Indicator + Tug-of-War)
                if (config.category === 'signal-2' && dataSource.rows.length > 0) {
                    let callCol, putCol;
                    if (config.type.includes('money-flow')) { callCol = 'Call_Money_Flow'; putCol = 'Put_Money_Flow'; }
                    else if (config.type.includes('delta-flow')) { callCol = 'Call_Delta_Flow'; putCol = 'Put_Delta_Flow'; }
                    else if (config.type.includes('iv-flow')) { callCol = 'Call_IV_Flow'; putCol = 'Put_IV_Flow'; }
                    else return null;

                    const lookback = config.parameters.lookback || 30;
                    const smaPeriod = config.parameters.smaPeriod || 14;
                    const ratio = config.parameters.bullishThreshold || 2.0;
                    const velocityPeriod = 5; // Standard velocity period

                    const rows = dataSource.rows;
                    const n = rows.length;

                    // 1. Intensity (Ratio > SMA AND Ratio > Threshold)
                    const callData = rows.map(r => parseFloat(r[callCol] || 0));
                    const putData = rows.map(r => parseFloat(r[putCol] || 0));
                    const ratios = callData.map((c, i) => c / (putData[i] || 1));
                    const intensitySMA = ratios.slice(-smaPeriod).reduce((a, b) => a + b, 0) / Math.min(smaPeriod, ratios.length);
                    const intensityBullish = ratios[n - 1] > intensitySMA && ratios[n - 1] > ratio;
                    const intensityBearish = ratios[n - 1] < intensitySMA && ratios[n - 1] < (1 / ratio);

                    // 2. Calculate Forces for TOW Indicator & Tug-of-War
                    // Rolling Sums
                    const callRolling = new Array(n).fill(0);
                    const putRolling = new Array(n).fill(0);
                    for (let i = 0; i < n; i++) {
                        const start = Math.max(0, i - lookback + 1);
                        let cSum = 0, pSum = 0;
                        for (let j = start; j <= i; j++) { cSum += callData[j]; pSum += putData[j]; }
                        callRolling[i] = cSum; putRolling[i] = pSum;
                    }

                    // Velocity
                    const callVel = new Array(n).fill(0);
                    const putVel = new Array(n).fill(0);
                    for (let i = velocityPeriod; i < n; i++) {
                        callVel[i] = callRolling[i] - callRolling[i - velocityPeriod];
                        putVel[i] = putRolling[i] - putRolling[i - velocityPeriod];
                    }

                    // Forces
                    const bullishForce = new Array(n).fill(0);
                    const bearishForce = new Array(n).fill(0);
                    const netForce = new Array(n).fill(0);
                    for (let i = 0; i < n; i++) {
                        const bf = Math.max(0, callVel[i]) + Math.max(0, -putVel[i]);
                        const ef = Math.max(0, putVel[i]) + Math.max(0, -callVel[i]);
                        bullishForce[i] = bf;
                        bearishForce[i] = ef;
                        netForce[i] = bf - ef;
                    }

                    // 3. TOW Indicator (Net Force > SMA)
                    const netForceSMA = netForce.slice(-smaPeriod).reduce((a, b) => a + b, 0) / Math.min(smaPeriod, netForce.length);
                    const towIndBullish = netForce[n - 1] > netForceSMA;
                    const towIndBearish = netForce[n - 1] < netForceSMA;

                    // 4. Tug-of-War (Ratio > 1 AND Ratio > SMA)
                    // Ratio of Forces
                    const forceRatios = bullishForce.map((bf, i) => bf / (bearishForce[i] || 1));
                    const forceRatioSMA = forceRatios.slice(-smaPeriod).reduce((a, b) => a + b, 0) / Math.min(smaPeriod, forceRatios.length);
                    const currentForceRatio = forceRatios[n - 1];
                    const towBullish = currentForceRatio > 1 && currentForceRatio > forceRatioSMA;
                    const towBearish = currentForceRatio < 1 && currentForceRatio < forceRatioSMA;

                    // COMBINED SIGNAL
                    if (intensityBullish && towIndBullish && towBullish) return 'BULLISH';
                    if (intensityBearish && towIndBearish && towBearish) return 'BEARISH';
                    return 'FLAT';
                }

                return null;
            }, [config.category, config.type, config.parameters, dominanceSignal, tugOfWarData, dataSource, keltnerSignalData]);

            // Calcular se√±al de correlaci√≥n (chart multi-instrumento)
            const correlationSignal = useMemo(() => {
                if (config.category !== 'otm-correlation' || !allDataSources) return null;

                const windowSeconds = config.parameters?.correlationWindow || 60;
                const callCol = 'Call_OTM_Impact';
                const putCol = 'Put_OTM_Impact';

                let bullishCount = 0;
                let bearishCount = 0;
                let totalNet = 0;
                let validSlots = 0;

                for (let i = 3; i <= 6; i++) {
                    const ds = allDataSources.get(String(i));
                    if (!ds || !ds.rows || ds.rows.length === 0) continue;
                    if (!ds.headers.includes(callCol) || !ds.headers.includes(putCol)) continue;

                    const { rows, timestampHeader } = ds;
                    const n = rows.length;
                    const currentCall = parseFloat(rows[n - 1][callCol]) || 0;
                    const currentPut = parseFloat(rows[n - 1][putCol]) || 0;

                    // Buscar √≠ndice para la ventana temporal
                    let oldIdx = 0;
                    const now = new Date(rows[n - 1][timestampHeader]).getTime();
                    const targetMs = windowSeconds * 1000;
                    for (let j = n - 2; j >= 0; j--) {
                        const t = new Date(rows[j][timestampHeader]).getTime();
                        if (now - t >= targetMs) { oldIdx = j; break; }
                        oldIdx = j;
                    }

                    const oldCall = parseFloat(rows[oldIdx][callCol]) || 0;
                    const oldPut = parseFloat(rows[oldIdx][putCol]) || 0;
                    // deltaCall > 0 = Calls subiendo (fuertes)
                    // deltaPut > 0 = Puts subiendo en magnitud (fuertes)
                    // netDelta = deltaCall - deltaPut: positivo si Calls dominan, negativo si Puts dominan
                    const deltaCall = currentCall - oldCall;
                    const deltaPut = Math.abs(currentPut) - Math.abs(oldPut);
                    const netDelta = deltaCall - deltaPut; // Calls fuertes + Puts d√©biles = BULLISH

                    totalNet += netDelta;
                    validSlots++;
                    if (netDelta > 0) bullishCount++;
                    else if (netDelta < 0) bearishCount++;
                }

                if (validSlots === 0) return null;

                const signal = bullishCount > bearishCount ? 'BULLISH' : (bearishCount > bullishCount ? 'BEARISH' : 'MIXED');
                return { signal, bullishCount, bearishCount, totalNet, windowSeconds };
            }, [config.category, config.parameters, allDataSources]);

            // Se√±al final para mostrar (combina todas las fuentes)
            const finalDisplaySignal = useMemo(() => {
                if (config.category === 'otm-correlation' && correlationSignal) {
                    return correlationSignal.signal === 'MIXED' ? 'FLAT' : correlationSignal.signal;
                }
                return displaySignal;
            }, [config.category, correlationSignal, displaySignal]);

            // Calcular color del header basado en se√±al
            const getHeaderColor = () => {
                if (!finalDisplaySignal || finalDisplaySignal === 'FLAT') return 'bg-neutral-800/50';
                if (finalDisplaySignal === 'BULLISH') return 'bg-gradient-to-r from-blue-900/40 via-neutral-800/50 to-neutral-800/50 border-l-4 border-blue-500';
                if (finalDisplaySignal === 'BEARISH') return 'bg-gradient-to-r from-red-900/40 via-neutral-800/50 to-neutral-800/50 border-l-4 border-red-500';
                return 'bg-neutral-800/50';
            };

            return React.createElement('div', { className: `flex flex-col ${isFullscreen ? 'bg-neutral-900 fixed inset-0 z-[100] m-0 rounded-none' : 'bg-neutral-900/60'} border border-neutral-800 rounded-lg overflow-hidden shadow-lg transition-all duration-300` },
                React.createElement('div', { className: `flex flex-wrap justify-between items-center gap-x-2 gap-y-2 p-2 ${getHeaderColor()} border-b border-neutral-700 flex-shrink-0 transition-colors duration-500` },
                    React.createElement('div', { className: "flex items-center gap-2 min-w-0 flex-shrink" },
                        React.createElement('h3', { className: "text-xs sm:text-sm font-semibold text-gray-200 truncate" }, chartTitle),
                        React.createElement(DominanceSignalIndicator, { signal: finalDisplaySignal })
                    ),
                    React.createElement('div', { className: "flex items-center flex-wrap gap-1.5 sm:gap-2 justify-end" },
                        renderControls(),
                        React.createElement('div', { className: "flex items-center gap-0.5 sm:gap-1 pl-1 sm:pl-2 ml-1 border-l border-neutral-700" },
                            (config.type === 'delta-signal' || config.type === 'cash-signal') && React.createElement(React.Fragment, null,
                                React.createElement('button', { className: "p-1 sm:p-1.5 rounded-md bg-neutral-700/50 hover:bg-neutral-600/70 text-gray-300", onClick: handleRunBacktest, title: "Run Backtest" }, React.createElement(CalculatorIcon)),
                                React.createElement('button', { className: "p-1 sm:p-1.5 rounded-md bg-neutral-700/50 hover:bg-neutral-600/70 text-gray-300", onClick: () => setIsHistoryVisible(!isHistoryVisible), title: "Toggle Signal History" }, React.createElement(HistoryIcon))
                            ),
                            React.createElement('button', { className: "p-1 sm:p-1.5 rounded-md bg-neutral-700/50 hover:bg-neutral-600/70 text-gray-300", onClick: () => onUpdate(config.id, { isCollapsed: !isCollapsed }), title: isCollapsed ? "Expand" : "Collapse" }, isCollapsed ? React.createElement(ExpandIcon) : React.createElement(CollapseIcon)),
                            React.createElement('button', { className: "p-1 sm:p-1.5 rounded-md bg-neutral-700/50 hover:bg-neutral-600/70 text-gray-300", onClick: handleResetZoom, title: "Reset Zoom" }, React.createElement(ResetIcon)),
                            React.createElement('button', { className: "p-1 sm:p-1.5 rounded-md bg-neutral-700/50 hover:bg-neutral-600/70 text-gray-300", onClick: toggleFullscreen, title: "Toggle Fullscreen" }, React.createElement(FullscreenIcon)),
                            React.createElement('button', { className: "p-1 sm:p-1.5 rounded-md bg-neutral-700/50 hover:bg-neutral-600/70 text-gray-300", onClick: handleDownload, title: "Download Chart" }, React.createElement(DownloadIcon)),
                            React.createElement('button', { className: "p-1 sm:p-1.5 rounded-md bg-neutral-700/50 hover:bg-red-500/50 text-gray-300", onClick: () => onDelete(config.id), title: "Delete Chart" }, React.createElement(TrashIcon))
                        )
                    )
                ),
                !isCollapsed && React.createElement('div', { className: `transition-all duration-300 ease-in-out flex-grow ${isFullscreen ? '!h-[calc(100vh-40px)]' : gridLayout === '4x4' ? 'min-h-[280px]' : 'min-h-[450px]'}` },
                    React.createElement('div', { ref: chartRef, className: "w-full h-full" })
                ),
                imbalanceSpikesData && React.createElement(components.ImbalanceSpikesMetrics, { metrics: imbalanceSpikesData.metrics }),
                isBacktestVisible && backtestResults && React.createElement(components.BacktestResultsPanel, { results: backtestResults, onClose: () => setIsBacktestVisible(false) }),
                isHistoryVisible && React.createElement(components.SignalHistoryPanel, { history: signalChartData.history, onClose: () => setIsHistoryVisible(false) })
            );
        };
        // --- END: components/ChartWrapper.tsx ---

        // ===== POWER METER PRO CHART COMPONENT =====
        // Replica el dise√±o del Power Meter del panel de Signals pero como chart independiente
        // Se actualiza cada 1 segundo leyendo datos frescos del CSV
        components.PowerMeterProChart = ({ config, dataSource, allDataSources, onDelete, onUpdate, gridLayout }) => {
            const { useState, useMemo, useEffect, useCallback, useRef } = React;
            // Leer m√©trica guardada de config.parameters o usar 'gex' por defecto
            const [selectedMetric, setSelectedMetric] = useState(config.parameters?.selectedMetric || 'gex');
            // Leer intervalo guardado de config.parameters o usar 1000ms por defecto
            const [refreshInterval, setRefreshInterval] = useState(config.parameters?.refreshInterval || 1000);
            const [updateTick, setUpdateTick] = useState(0); // Forzar re-render
            const { TrashIcon, BellIcon } = components.icons;
            const isCorrelation = config.type === 'power-meter-pro-correlation';

            // Historial de volatility para MA calculation (por slot)
            const volatilityHistoryRef = useRef(new Map()); // Map<slotId, Array<{timestamp, value}>>

            // ===== SISTEMA DE ALERTAS =====
            const [alertEnabled, setAlertEnabled] = useState(config.parameters?.alertEnabled ?? false);
            const [alertThreshold, setAlertThreshold] = useState(config.parameters?.alertThreshold || 10);
            const [alertCooldown, setAlertCooldown] = useState(config.parameters?.alertCooldown || 30); // segundos
            const [alertSound, setAlertSound] = useState(config.parameters?.alertSound || 'beep');
            const [isAlertTriggered, setIsAlertTriggered] = useState(false);
            const lastAlertTimeRef = useRef(0);
            const audioContextRef = useRef(null);

            // Funci√≥n para reproducir sonido de alerta
            const playAlertSound = useCallback((soundType) => {
                try {
                    if (!audioContextRef.current) {
                        audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)();
                    }
                    const ctx = audioContextRef.current;
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.connect(gain);
                    gain.connect(ctx.destination);

                    // Diferentes sonidos
                    switch (soundType) {
                        case 'ding':
                            osc.type = 'sine';
                            osc.frequency.setValueAtTime(880, ctx.currentTime);
                            osc.frequency.exponentialRampToValueAtTime(1760, ctx.currentTime + 0.1);
                            gain.gain.setValueAtTime(0.3, ctx.currentTime);
                            gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.3);
                            osc.start();
                            osc.stop(ctx.currentTime + 0.3);
                            break;
                        case 'alarm':
                            osc.type = 'sawtooth';
                            osc.frequency.setValueAtTime(440, ctx.currentTime);
                            for (let i = 0; i < 4; i++) {
                                osc.frequency.setValueAtTime(440, ctx.currentTime + i * 0.15);
                                osc.frequency.setValueAtTime(880, ctx.currentTime + i * 0.15 + 0.075);
                            }
                            gain.gain.setValueAtTime(0.2, ctx.currentTime);
                            gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.6);
                            osc.start();
                            osc.stop(ctx.currentTime + 0.6);
                            break;
                        case 'chime':
                            osc.type = 'sine';
                            const notes = [523, 659, 784, 1047];
                            notes.forEach((freq, i) => {
                                setTimeout(() => {
                                    const o = ctx.createOscillator();
                                    const g = ctx.createGain();
                                    o.connect(g);
                                    g.connect(ctx.destination);
                                    o.type = 'sine';
                                    o.frequency.value = freq;
                                    g.gain.setValueAtTime(0.2, ctx.currentTime);
                                    g.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.2);
                                    o.start();
                                    o.stop(ctx.currentTime + 0.2);
                                }, i * 100);
                            });
                            return;
                        case 'beep':
                        default:
                            osc.type = 'square';
                            osc.frequency.setValueAtTime(800, ctx.currentTime);
                            gain.gain.setValueAtTime(0.15, ctx.currentTime);
                            gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.2);
                            osc.start();
                            osc.stop(ctx.currentTime + 0.2);
                            break;
                    }
                } catch (e) {
                    console.warn('Audio alert failed:', e);
                }
            }, []);

            // Opciones de sonido
            const SOUND_OPTIONS = [
                { value: 'beep', label: 'Beep' },
                { value: 'ding', label: 'Ding' },
                { value: 'alarm', label: 'Alarm' },
                { value: 'chime', label: 'Chime' }
            ];

            // Opciones de cooldown
            const COOLDOWN_OPTIONS = [
                { value: 10, label: '10s' },
                { value: 30, label: '30s' },
                { value: 60, label: '1m' },
                { value: 120, label: '2m' },
                { value: 300, label: '5m' }
            ];

            // Opciones de intervalo de actualizaci√≥n
            const REFRESH_OPTIONS = [
                { value: 500, label: '0.5s' },
                { value: 1000, label: '1s' },
                { value: 2000, label: '2s' },
                { value: 5000, label: '5s' }
            ];

            // Actualizaci√≥n seg√∫n intervalo seleccionado
            useEffect(() => {
                const interval = setInterval(() => {
                    setUpdateTick(prev => prev + 1);
                }, refreshInterval);
                return () => clearInterval(interval);
            }, [refreshInterval]);

            // M√©tricas disponibles - TODAS LAS M√âTRICAS DEL CSV
            const METRICS = [
                { key: 'otm', label: 'OTM', call: 'Call_OTM_Impact', put: 'Put_OTM_Impact' },
                { key: 'itm', label: 'ITM', call: 'Call_ITM_Impact', put: 'Put_ITM_Impact' },
                { key: 'money', label: 'MONEY', call: 'Call_Money_Flow', put: 'Put_Money_Flow' },
                { key: 'delta', label: 'DELTA', call: 'Call_Delta_Flow', put: 'Put_Delta_Flow' },
                { key: 'gex', label: 'GEX', call: 'Call_GEX', put: 'Put_GEX' },
                { key: 'vanna', label: 'VANNA', call: 'Call_Vanna_Flow', put: 'Put_Vanna_Flow' },
                { key: 'charm', label: 'CHARM', call: 'Charm_Call', put: 'Charm_Put' },
                { key: 'iv', label: 'IV', call: 'Call_IV_Flow', put: 'Put_IV_Flow' },
                { key: 'ivitm', label: 'IV-ITM', call: 'Call_IV_Flow_ITM', put: 'Put_IV_Flow_ITM' },
                { key: 'ivotm', label: 'IV-OTM', call: 'Call_IV_Flow_OTM', put: 'Put_IV_Flow_OTM' },
                { key: 'vol', label: 'VOL', call: 'Call_Vol_Imbalance', put: 'Put_Vol_Imbalance' },
                { key: 'smart', label: 'SMART', call: 'Call_Smart_Money', put: 'Put_Smart_Money' },
                { key: 'hedge', label: 'HEDGE', call: 'Call_Hedge_Pressure', put: 'Put_Hedge_Pressure' }
            ];

            const currentMetric = METRICS.find(m => m.key === selectedMetric) || METRICS[2];

            // Calcular datos para un slot
            const calculateMeterData = (rows, cols, lookback = 20) => {
                const defaultData = { momentum: 0, longTerm: 0, volatility: 0, direction: 'NEUTRAL', callValue: 0, putValue: 0 };

                if (!rows?.length || rows.length < 10) return defaultData;

                const n = rows.length;
                const shortLookback = Math.min(lookback, n - 1);
                const longLookback = Math.min(50, n - 1);

                // Verificar columnas
                if (rows[0][cols.call] === undefined) return defaultData;

                // Calcular valores
                const values = [];
                for (let i = Math.max(0, n - longLookback); i < n; i++) {
                    const callVal = Math.abs(parseFloat(rows[i][cols.call]) || 0);
                    const putVal = Math.abs(parseFloat(rows[i][cols.put]) || 0);
                    values.push({ call: callVal, put: putVal, net: callVal - putVal });
                }

                if (values.length < 3) return defaultData;

                const current = values[values.length - 1];

                // Momentum (corto plazo - √∫ltimos 20)
                const shortValues = values.slice(-shortLookback);
                const avgNetShort = shortValues.slice(0, -1).reduce((s, v) => s + v.net, 0) / (shortValues.length - 1 || 1);
                const momentum = avgNetShort !== 0 ? ((current.net - avgNetShort) / Math.abs(avgNetShort)) * 100 : 0;

                // Long Term (todo el per√≠odo - 50)
                const avgNetLong = values.slice(0, -1).reduce((s, v) => s + v.net, 0) / (values.length - 1 || 1);
                const longTerm = avgNetLong !== 0 ? ((current.net - avgNetLong) / Math.abs(avgNetLong)) * 100 : 0;

                // Volatilidad (desviaci√≥n est√°ndar normalizada)
                const netValues = values.map(v => v.net);
                const mean = netValues.reduce((a, b) => a + b, 0) / netValues.length;
                const variance = netValues.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / netValues.length;
                const stdDev = Math.sqrt(variance);
                const volatility = mean !== 0 ? (stdDev / Math.abs(mean)) * 100 : 0;

                const direction = momentum > 10 ? 'BULLISH' : momentum < -10 ? 'BEARISH' : 'NEUTRAL';

                return {
                    momentum: Math.max(-100, Math.min(100, isNaN(momentum) ? 0 : momentum)),
                    longTerm: Math.max(-100, Math.min(100, isNaN(longTerm) ? 0 : longTerm)),
                    volatility: Math.max(0, Math.min(100, isNaN(volatility) ? 0 : volatility)),
                    direction,
                    callValue: current.call,
                    putValue: current.put
                };
            };

            // Datos para Single o Correlation - se recalcula cada segundo gracias a updateTick
            const meterData = useMemo(() => {
                const cols = { call: currentMetric.call, put: currentMetric.put };

                if (!isCorrelation) {
                    // Single slot - incluir VIX si slot 2 tiene datos
                    const mainSlot = { slot: config.slotId, data: calculateMeterData(dataSource?.rows, cols) };

                    // Intentar obtener VIX del slot 2
                    const vixDs = allDataSources?.get('2');
                    if (vixDs?.rows && vixDs.rows.length > 0) {
                        // Detectar VIX
                        const vixFileName = vixDs.fileName || '';
                        const isVIX = vixFileName.toUpperCase().includes('VIX');

                        if (isVIX) {
                            const vixData = calculateMeterData(vixDs.rows, cols);
                            // Invertir VIX: cuando sube (positivo) = bearish, cuando baja (negativo) = bullish
                            return [
                                mainSlot,
                                {
                                    slot: 2,
                                    isVIX: true,
                                    data: {
                                        ...vixData,
                                        momentum: -vixData.momentum,
                                        longTerm: -vixData.longTerm,
                                        direction: vixData.momentum > 10 ? 'BEARISH' : vixData.momentum < -10 ? 'BULLISH' : 'NEUTRAL'
                                    }
                                }
                            ];
                        }
                    }

                    return [mainSlot];
                } else {
                    // Correlation - √çNDICE COMBINADO de 4 slots (3-6)
                    const slotsData = [];
                    let totalCallValue = 0;
                    let totalPutValue = 0;
                    let validSlots = 0;

                    // Recolectar datos de todos los slots
                    for (let slotId = 3; slotId <= 6; slotId++) {
                        const ds = allDataSources?.get(String(slotId));
                        if (ds?.rows && ds.rows.length > 0) {
                            const slotData = calculateMeterData(ds.rows, cols);
                            slotsData.push(slotData);
                            totalCallValue += slotData.callValue;
                            totalPutValue += slotData.putValue;
                            validSlots++;
                        }
                    }

                    if (validSlots === 0) {
                        return [{ slot: 'INDEX', data: { momentum: 0, longTerm: 0, volatility: 0, direction: 'NEUTRAL', callValue: 0, putValue: 0 } }];
                    }

                    // Calcular PROMEDIO de m√©tricas (√≠ndice combinado)
                    const avgMomentum = slotsData.reduce((acc, d) => acc + d.momentum, 0) / validSlots;
                    const avgLongTerm = slotsData.reduce((acc, d) => acc + d.longTerm, 0) / validSlots;
                    const avgVolatility = slotsData.reduce((acc, d) => acc + d.volatility, 0) / validSlots;

                    // Calcular direcci√≥n del √≠ndice
                    const indexDirection = avgMomentum > 10 ? 'BULLISH' : avgMomentum < -10 ? 'BEARISH' : 'NEUTRAL';

                    // Detectar VIX en slot 2 para correlaci√≥n
                    const vixDs = allDataSources?.get('2');
                    let vixSlot = null;
                    if (vixDs?.rows && vixDs.rows.length > 0) {
                        const vixFileName = vixDs.fileName || '';
                        const isVIX = vixFileName.toUpperCase().includes('VIX');

                        if (isVIX) {
                            const vixData = calculateMeterData(vixDs.rows, cols);
                            vixSlot = {
                                slot: 2,
                                isVIX: true,
                                data: {
                                    ...vixData,
                                    momentum: -vixData.momentum,
                                    longTerm: -vixData.longTerm,
                                    direction: vixData.momentum > 10 ? 'BEARISH' : vixData.momentum < -10 ? 'BULLISH' : 'NEUTRAL'
                                }
                            };
                        }
                    }

                    // Retornar √çNDICE √öNICO + VIX opcional
                    const indexSlot = {
                        slot: 'INDEX',
                        slotCount: validSlots,
                        data: {
                            momentum: avgMomentum,
                            longTerm: avgLongTerm,
                            volatility: avgVolatility,
                            direction: indexDirection,
                            callValue: totalCallValue,
                            putValue: totalPutValue
                        }
                    };

                    return vixSlot ? [indexSlot, vixSlot] : [indexSlot];
                }
            }, [dataSource, allDataSources, currentMetric, isCorrelation, config.slotId, updateTick]);

            // A√±adir MA a meterData - SE EJECUTA CADA VEZ que meterData cambia
            const meterDataWithMA = useMemo(() => {
                const windowSeconds = config.parameters?.powerMeterMAWindow || 300;
                const now = Date.now();

                return meterData.map(slotData => {
                    // Calcular MA para este slot
                    let history = volatilityHistoryRef.current.get(slotData.slot) || [];

                    // A√±adir nuevo valor
                    history.push({ timestamp: now, value: slotData.data.volatility });

                    // Filtrar valores dentro de la ventana
                    const cutoff = now - (windowSeconds * 1000);
                    history = history.filter(e => e.timestamp >= cutoff);

                    // Guardar historial actualizado
                    volatilityHistoryRef.current.set(slotData.slot, history);

                    // Calcular promedio
                    const ma = history.length > 0
                        ? history.reduce((acc, e) => acc + e.value, 0) / history.length
                        : null;

                    return {
                        ...slotData,
                        data: {
                            ...slotData.data,
                            volatilityMA: ma
                        }
                    };
                });
            }, [meterData, config.parameters?.powerMeterMAWindow, updateTick]);

            // ===== DETECCI√ìN DE SE√ëAL DE ENTRADA (BULLISH Y BEARISH) =====
            const signalState = useMemo(() => {
                const threshold = config.parameters?.alertThreshold || alertThreshold;

                let bullish = false;
                let bearish = false;

                meterDataWithMA.forEach(slot => {
                    const { momentum, longTerm, volatility, volatilityMA } = slot.data;
                    const volAboveMA = volatilityMA !== null ? volatility > volatilityMA : true;

                    // BULLISH: Momentum > threshold AND Long Term > threshold AND Vol > MA
                    if (volAboveMA && momentum > threshold && longTerm > threshold) {
                        bullish = true;
                    }
                    // BEARISH: Momentum < -threshold AND Long Term < -threshold AND Vol > MA
                    if (volAboveMA && momentum < -threshold && longTerm < -threshold) {
                        bearish = true;
                    }
                });

                return { bullish, bearish, active: bullish || bearish };
            }, [meterDataWithMA, config.parameters?.alertThreshold, alertThreshold]);

            // Compatibilidad con c√≥digo existente
            const entrySignalDetected = signalState.active;

            // Efecto para disparar alerta
            useEffect(() => {
                if (!alertEnabled || !signalState.active) {
                    setIsAlertTriggered(false);
                    return;
                }

                const now = Date.now();
                const cooldownMs = (config.parameters?.alertCooldown || alertCooldown) * 1000;

                // Verificar cooldown
                if (now - lastAlertTimeRef.current < cooldownMs) {
                    // Mantener alerta visual pero sin sonido
                    setIsAlertTriggered(true);
                    return;
                }

                // Disparar alerta
                setIsAlertTriggered(true);
                lastAlertTimeRef.current = now;
                playAlertSound(config.parameters?.alertSound || alertSound);

            }, [entrySignalDetected, alertEnabled, alertCooldown, alertSound, config.parameters?.alertCooldown, config.parameters?.alertSound, playAlertSound]);

            // Colores
            const getMeterColor = (value) => {
                if (value > 50) return '#2d7acc';
                if (value > 20) return '#3d8ad9';
                if (value > 0) return '#4d9ae6';
                if (value > -20) return '#cc5555';
                if (value > -50) return '#b94444';
                return '#a63333';
            };

            const formatNum = services.signalCalculator.formatNumber;

            // Obtener threshold actual para alertas
            const currentAlertThreshold = config.parameters?.alertThreshold || alertThreshold;

            // Renderizar una barra de Power Meter con indicador de condici√≥n
            const renderMeterBar = (label, value, color, showAlertIndicator = false) => {
                const position = 50 + (value / 2);
                // Detectar si cumple condici√≥n BULLISH (>threshold) o BEARISH (<-threshold)
                const meetsBullish = alertEnabled && value > currentAlertThreshold;
                const meetsBearish = alertEnabled && value < -currentAlertThreshold;
                const meetsCondition = meetsBullish || meetsBearish;
                const conditionColor = meetsBullish ? '#22c55e' : meetsBearish ? '#ef4444' : color;

                return React.createElement('div', { className: "mb-2" },
                    React.createElement('div', { className: "flex items-center justify-between mb-0.5" },
                        React.createElement('span', { className: "text-[9px] font-bold text-neutral-400 uppercase tracking-wider" }, label),
                        React.createElement('div', { className: "flex items-center gap-1" },
                            React.createElement('span', {
                                className: `text-xs font-mono font-bold`,
                                style: {
                                    color: conditionColor,
                                    textShadow: meetsCondition ? `0 0 8px ${conditionColor}, 0 0 12px ${conditionColor}` : 'none'
                                }
                            }, value.toFixed(0) + '%')
                        )
                    ),
                    React.createElement('div', {
                        className: "relative h-5 rounded-full overflow-hidden",
                        style: meetsCondition ? {
                            boxShadow: `0 0 10px ${conditionColor}60, inset 0 0 8px ${conditionColor}30`
                        } : {}
                    },
                        React.createElement('div', {
                            className: "absolute inset-0",
                            style: { background: 'linear-gradient(90deg, #3d1515 0%, #4a1a1a 25%, #1a1a1a 45%, #1a1a1a 55%, #1a3d4d 75%, #15303d 100%)' }
                        }),
                        React.createElement('div', { className: "absolute inset-0 flex items-center justify-between px-2" },
                            React.createElement('span', { className: "text-[7px] font-bold text-white/50" }, "PUT"),
                            React.createElement('span', { className: "text-[7px] font-bold text-white/50" }, "CALL")
                        ),
                        // L√≠neas de umbral de alerta BULLISH y BEARISH (si alertas habilitadas)
                        alertEnabled && React.createElement('div', {
                            className: "absolute top-0 h-full w-0.5",
                            style: {
                                left: `${50 + (currentAlertThreshold / 2)}%`,
                                background: 'rgba(34, 197, 94, 0.4)',
                                boxShadow: '0 0 3px rgba(34, 197, 94, 0.3)'
                            },
                            title: `Umbral BULLISH: +${currentAlertThreshold}%`
                        }),
                        alertEnabled && React.createElement('div', {
                            className: "absolute top-0 h-full w-0.5",
                            style: {
                                left: `${50 - (currentAlertThreshold / 2)}%`,
                                background: 'rgba(239, 68, 68, 0.4)',
                                boxShadow: '0 0 3px rgba(239, 68, 68, 0.3)'
                            },
                            title: `Umbral BEARISH: -${currentAlertThreshold}%`
                        }),
                        React.createElement('div', {
                            className: "absolute top-0 h-full w-1.5 transition-all duration-300",
                            style: {
                                left: `${position}%`,
                                transform: 'translateX(-50%)',
                                background: meetsCondition ? conditionColor : '#fff',
                                boxShadow: meetsCondition
                                    ? `0 0 10px ${conditionColor}, 0 0 20px ${conditionColor}, 0 0 35px ${conditionColor}`
                                    : `0 0 8px #fff, 0 0 15px ${color}, 0 0 25px ${color}`
                            }
                        }),
                        React.createElement('div', {
                            className: "absolute top-1 bottom-1 rounded-full transition-all duration-300",
                            style: {
                                left: value >= 0 ? '50%' : `${position}%`,
                                width: `${Math.abs(value) / 2}%`,
                                background: meetsBullish
                                    ? 'linear-gradient(90deg, rgba(34,197,94,0.6), rgba(74,222,128,1))'
                                    : meetsBearish
                                        ? 'linear-gradient(90deg, rgba(239,68,68,1), rgba(239,68,68,0.6))'
                                        : value >= 0
                                            ? 'linear-gradient(90deg, rgba(74,158,255,0.6), rgba(100,180,255,1))'
                                            : 'linear-gradient(90deg, rgba(255,100,100,1), rgba(255,68,68,0.6))',
                                boxShadow: meetsCondition
                                    ? `0 0 20px ${conditionColor}90, 0 0 40px ${conditionColor}50`
                                    : value >= 0
                                        ? '0 0 15px rgba(74,158,255,0.9), 0 0 30px rgba(74,158,255,0.5)'
                                        : '0 0 15px rgba(255,68,68,0.9), 0 0 30px rgba(255,68,68,0.5)'
                            }
                        })
                    )
                );
            };

            // Renderizar barra de volatilidad (0% a 100%, sin direcci√≥n PUT/CALL)
            const renderVolatilityBar = (label, value, color, ma = null, pmConfig = {}) => {
                // Obtener config de Power Meter (viene de globalConfig o defaults)
                const mode = pmConfig.powerMeterMode || 'expanded'; // DEFAULT: expanded para ver MA
                const lowThreshold = pmConfig.powerMeterLowThreshold || 40;
                const mediumThreshold = pmConfig.powerMeterMediumThreshold || 70;
                const highThreshold = pmConfig.powerMeterHighThreshold || 100;
                const maWindow = pmConfig.powerMeterMAWindow || 300;

                // Si est√° hidden, no renderizar nada
                if (mode === 'hidden') return null;

                const clampedValue = Math.max(0, Math.min(100, value));
                const clampedMA = ma !== null ? Math.max(0, Math.min(100, ma)) : null;

                // Color din√°mico basado en thresholds
                const volColor = clampedValue >= mediumThreshold ? '#ef4444' :
                    clampedValue >= lowThreshold ? '#f59e0b' : '#22c55e';

                // Determinar nivel de actividad basado en MA
                const activityLevel = clampedMA !== null
                    ? clampedMA >= mediumThreshold ? 'AGGRESSIVE'
                        : clampedMA >= lowThreshold ? 'MEDIUM'
                            : 'PASSIVE'
                    : null;

                const activityColor = activityLevel === 'AGGRESSIVE' ? '#ef4444'
                    : activityLevel === 'MEDIUM' ? '#f59e0b'
                        : '#22c55e';

                // Calcular cambio porcentual vs MA
                const changeVsMA = clampedMA !== null && clampedMA !== 0
                    ? ((clampedValue - clampedMA) / clampedMA) * 100
                    : 0;

                const changeColor = changeVsMA > 0 ? '#ef4444' : changeVsMA < 0 ? '#22c55e' : '#999';
                const changeSymbol = changeVsMA > 0 ? '‚Üë' : changeVsMA < 0 ? '‚Üì' : '‚Üí';

                // Modo minimal: solo barra de color
                if (mode === 'minimal') {
                    return React.createElement('div', { className: "h-2 rounded-full mb-1", style: { backgroundColor: volColor, opacity: 0.8 } });
                }

                // Modos compact y expanded
                return React.createElement('div', { className: "mb-2" },
                    // Header con valores
                    React.createElement('div', { className: "flex items-center justify-between mb-1" },
                        React.createElement('span', { className: "text-[9px] font-bold text-neutral-400 uppercase tracking-wider" }, label),
                        React.createElement('div', { className: "flex items-center gap-2" },
                            // Valor actual
                            React.createElement('span', {
                                className: "text-xs font-mono font-bold",
                                style: { color: volColor }
                            }, clampedValue.toFixed(0) + '%'),
                            // MA SIEMPRE VISIBLE
                            clampedMA !== null && React.createElement('span', {
                                className: "text-[9px] font-mono font-semibold px-1.5 py-0.5 rounded-md border",
                                style: {
                                    color: activityColor,
                                    borderColor: activityColor + '60',
                                    backgroundColor: activityColor + '20'
                                },
                                title: `Promedio ${maWindow}s`
                            }, `AVG:${clampedMA.toFixed(0)}%`),
                            // Cambio vs MA
                            clampedMA !== null && Math.abs(changeVsMA) > 1 && React.createElement('span', {
                                className: "text-[8px] font-bold px-1 py-0.5 rounded",
                                style: {
                                    color: changeColor,
                                    backgroundColor: changeColor + '20'
                                },
                                title: `Cambio vs promedio ${maWindow}s`
                            }, `${changeSymbol}${Math.abs(changeVsMA).toFixed(0)}%`)
                        )
                    ),
                    React.createElement('div', { className: `relative ${mode === 'expanded' ? 'h-6' : 'h-5'} rounded-full overflow-hidden` },
                        // Fondo con gradiente de bajo a alto
                        React.createElement('div', {
                            className: "absolute inset-0",
                            style: { background: 'linear-gradient(90deg, #1a3d1a 0%, #2d4a2d 30%, #4a4a1a 50%, #4a3d1a 70%, #3d1515 100%)' }
                        }),
                        // Labels LOW y HIGH
                        React.createElement('div', { className: "absolute inset-0 flex items-center justify-between px-2" },
                            React.createElement('span', { className: "text-[7px] font-bold text-white/50" }, "LOW"),
                            React.createElement('span', { className: "text-[7px] font-bold text-white/50" }, "HIGH")
                        ),
                        // L√≠nea de MA (en gris semi-transparente detr√°s del valor actual)
                        clampedMA !== null && React.createElement('div', {
                            className: "absolute top-0 h-full w-1 transition-all duration-500",
                            style: {
                                left: `${clampedMA}%`,
                                transform: 'translateX(-50%)',
                                background: 'rgba(200, 200, 200, 0.5)',
                                boxShadow: '0 0 5px rgba(200, 200, 200, 0.6)',
                                zIndex: 1
                            }
                        }),
                        // Indicador de posici√≥n (l√≠nea blanca) - valor instant√°neo
                        React.createElement('div', {
                            className: "absolute top-0 h-full w-1.5 transition-all duration-300",
                            style: {
                                left: `${clampedValue}%`,
                                transform: 'translateX(-50%)',
                                background: '#fff',
                                boxShadow: `0 0 8px #fff, 0 0 15px ${volColor}, 0 0 25px ${volColor}`,
                                zIndex: 2
                            }
                        }),
                        // Barra de relleno desde la izquierda
                        React.createElement('div', {
                            className: "absolute top-1 bottom-1 left-0 rounded-full transition-all duration-300",
                            style: {
                                width: `${clampedValue}%`,
                                background: clampedValue >= mediumThreshold
                                    ? 'linear-gradient(90deg, rgba(34,197,94,0.6), rgba(245,158,11,0.8), rgba(239,68,68,1))'
                                    : clampedValue >= lowThreshold
                                        ? 'linear-gradient(90deg, rgba(34,197,94,0.6), rgba(245,158,11,1))'
                                        : 'linear-gradient(90deg, rgba(34,197,94,0.6), rgba(34,197,94,1))',
                                boxShadow: `0 0 15px ${volColor}, 0 0 30px ${volColor}80`,
                                zIndex: 0
                            }
                        })
                    )
                );
            };

            // Renderizar un slot completo
            const renderSlotMeters = (slotData, showSlotLabel = false) => {
                const { data, slot, slotCount, isVIX } = slotData;
                const momColor = getMeterColor(data.momentum);
                const ltColor = getMeterColor(data.longTerm);

                // Verificar si este slot cumple condiciones BULLISH o BEARISH
                const volAboveMA = data.volatilityMA !== null ? data.volatility > data.volatilityMA : true;
                const isBullishSlot = alertEnabled && volAboveMA && data.momentum > currentAlertThreshold && data.longTerm > currentAlertThreshold;
                const isBearishSlot = alertEnabled && volAboveMA && data.momentum < -currentAlertThreshold && data.longTerm < -currentAlertThreshold;
                const hasSignal = isBullishSlot || isBearishSlot;
                const signalColor = isBullishSlot ? '#22c55e' : isBearishSlot ? '#ef4444' : null;

                // Determinar el t√≠tulo del slot
                let slotTitle = '';
                if (isVIX) {
                    slotTitle = '‚ö° VOLATILITY INDEX (VIX INVERTED)';
                } else if (slot === 'INDEX') {
                    slotTitle = `üìä CORRELATION INDEX (${slotCount} Instruments)`;
                } else {
                    slotTitle = `SLOT ${slot}`;
                }

                return React.createElement('div', {
                    key: slot,
                    className: 'p-3 rounded-lg bg-neutral-900/70 border mb-2 transition-all duration-300',
                    style: hasSignal ? {
                        borderColor: signalColor,
                        boxShadow: `0 0 15px ${signalColor}40, inset 0 0 10px ${signalColor}15`
                    } : { borderColor: 'rgba(64, 64, 64, 0.5)' }
                },
                    // Header del slot
                    showSlotLabel && React.createElement('div', { className: "flex items-center justify-between mb-2" },
                        React.createElement('span', {
                            className: `text-[10px] font-bold ${isVIX ? 'text-amber-400' : slot === 'INDEX' ? 'text-cyan-400' : 'text-amber-400'}`
                        }, slotTitle),
                        React.createElement('span', {
                            className: `text-[9px] font-bold px-1.5 py-0.5 rounded ${data.direction === 'BULLISH' ? 'bg-blue-600/30 text-blue-300' :
                                data.direction === 'BEARISH' ? 'bg-red-600/30 text-red-300' :
                                    'bg-neutral-600/30 text-neutral-400'
                                }`
                        }, data.direction),
                        React.createElement('div', { className: "flex gap-2 text-[8px] font-mono" },
                            React.createElement('span', { className: "text-blue-400" }, 'C:' + formatNum(data.callValue)),
                            React.createElement('span', { className: "text-red-400" }, 'P:' + formatNum(data.putValue))
                        )
                    ),
                    renderMeterBar('MOMENTUM', data.momentum, momColor, true),
                    renderMeterBar('LONG TERM', data.longTerm, ltColor, true),
                    // Indicador de volatilidad vs MA
                    React.createElement('div', { className: "relative" },
                        renderVolatilityBar('VOLATILITY', data.volatility, '#f59e0b', data.volatilityMA, config.parameters || {})
                    )
                );
            };

            // Estilos din√°micos para alerta (BULLISH verde, BEARISH rojo)
            const alertColor = signalState.bullish ? '#22c55e' : signalState.bearish ? '#ef4444' : '#22c55e';
            const alertColorRgb = signalState.bullish ? '34, 197, 94' : signalState.bearish ? '239, 68, 68' : '34, 197, 94';

            const alertBorderStyle = isAlertTriggered ? {
                border: `2px solid ${alertColor}`,
                boxShadow: `0 0 20px rgba(${alertColorRgb}, 0.6), 0 0 40px rgba(${alertColorRgb}, 0.4), 0 0 60px rgba(${alertColorRgb}, 0.2), inset 0 0 30px rgba(${alertColorRgb}, 0.1)`,
                animation: 'alertPulse 1s ease-in-out infinite'
            } : {};

            const alertHeaderStyle = isAlertTriggered ? {
                background: `linear-gradient(90deg, rgba(${alertColorRgb}, 0.25), rgba(${alertColorRgb}, 0.05), rgba(${alertColorRgb}, 0.25))`,
                borderBottom: `2px solid ${alertColor}`
            } : {};

            return React.createElement('div', {
                className: 'flex flex-col bg-neutral-900/60 border border-neutral-800 rounded-lg overflow-hidden shadow-lg transition-all duration-300',
                style: alertBorderStyle
            },
                // Header
                React.createElement('div', {
                    className: 'flex flex-wrap items-center justify-between p-2 bg-neutral-800/50 border-b border-neutral-700 transition-all duration-300',
                    style: alertHeaderStyle
                },
                    React.createElement('div', { className: "flex items-center gap-2" },
                        React.createElement('h3', { className: "text-sm font-bold text-gray-200" },
                            isCorrelation ? 'Power Meter Pro Correlation' : `Power Meter Pro (S${config.slotId})`
                        ),
                        // Indicador de actualizaci√≥n en vivo
                        React.createElement('div', {
                            className: "w-2 h-2 rounded-full bg-green-500 animate-pulse",
                            title: `Actualizando cada ${refreshInterval / 1000}s`
                        }),
                        // Badge de se√±al - sin iconos, solo texto con brillo
                        isAlertTriggered && React.createElement('span', {
                            className: "text-[10px] font-bold px-2 py-1 rounded-full text-white",
                            style: {
                                backgroundColor: alertColor,
                                boxShadow: `0 0 10px ${alertColor}, 0 0 20px ${alertColor}80`
                            },
                            title: signalState.bullish
                                ? `BULLISH - Mom>${alertThreshold}% & LT>${alertThreshold}% & Vol>MA`
                                : `BEARISH - Mom<-${alertThreshold}% & LT<-${alertThreshold}% & Vol>MA`
                        }, signalState.bullish ? 'BULLISH' : 'BEARISH')
                    ),
                    React.createElement('div', { className: "flex flex-wrap items-center gap-1.5" },
                        // Toggle de Alerta ON/OFF
                        React.createElement('button', {
                            className: `p-1.5 rounded-md transition-all ${alertEnabled ? 'bg-green-600 hover:bg-green-500 text-white' : 'bg-neutral-700/50 hover:bg-neutral-600 text-gray-400'}`,
                            onClick: () => {
                                const newEnabled = !alertEnabled;
                                setAlertEnabled(newEnabled);
                                if (onUpdate) {
                                    onUpdate(config.id, { parameters: { ...config.parameters, alertEnabled: newEnabled } });
                                }
                            },
                            title: alertEnabled ? 'Alertas ON - Click para desactivar' : 'Alertas OFF - Click para activar'
                        }, React.createElement('svg', { className: "w-4 h-4", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24" },
                            React.createElement('path', { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M15 17h5l-1.405-1.405A2.032 2.032 0 0118 14.158V11a6.002 6.002 0 00-4-5.659V5a2 2 0 10-4 0v.341C7.67 6.165 6 8.388 6 11v3.159c0 .538-.214 1.055-.595 1.436L4 17h5m6 0v1a3 3 0 11-6 0v-1m6 0H9" })
                        )),

                        // Controles de alerta (solo si est√° habilitado)
                        alertEnabled && React.createElement(React.Fragment, null,
                            // Umbral (threshold)
                            React.createElement('div', { className: "flex items-center gap-1 bg-neutral-800/80 rounded px-1.5 py-1 border border-green-700" },
                                React.createElement('span', { className: "text-[8px] text-green-400" }, 'THR:'),
                                React.createElement('input', {
                                    type: 'number',
                                    value: config.parameters?.alertThreshold || alertThreshold,
                                    onChange: (e) => {
                                        const val = parseInt(e.target.value) || 10;
                                        setAlertThreshold(val);
                                        if (onUpdate) {
                                            onUpdate(config.id, { parameters: { ...config.parameters, alertThreshold: val } });
                                        }
                                    },
                                    min: 1,
                                    max: 50,
                                    className: "w-8 bg-transparent text-[10px] text-green-300 font-bold text-center focus:outline-none",
                                    title: "Umbral m√≠nimo para Momentum y Long Term (%)"
                                }),
                                React.createElement('span', { className: "text-[8px] text-green-400" }, '%')
                            ),
                            // Selector de sonido
                            React.createElement('select', {
                                value: config.parameters?.alertSound || alertSound,
                                onChange: (e) => {
                                    const newSound = e.target.value;
                                    setAlertSound(newSound);
                                    if (onUpdate) {
                                        onUpdate(config.id, { parameters: { ...config.parameters, alertSound: newSound } });
                                    }
                                    // Test del sonido
                                    playAlertSound(newSound);
                                },
                                className: "bg-neutral-800 border border-green-700 rounded px-1 py-1 text-[9px] text-green-300 font-bold focus:outline-none",
                                title: "Tipo de sonido (click para preview)"
                            },
                                SOUND_OPTIONS.map(opt =>
                                    React.createElement('option', { key: opt.value, value: opt.value }, opt.label)
                                )
                            ),
                            // Selector de cooldown
                            React.createElement('select', {
                                value: config.parameters?.alertCooldown || alertCooldown,
                                onChange: (e) => {
                                    const val = parseInt(e.target.value);
                                    setAlertCooldown(val);
                                    if (onUpdate) {
                                        onUpdate(config.id, { parameters: { ...config.parameters, alertCooldown: val } });
                                    }
                                },
                                className: "bg-neutral-800 border border-green-700 rounded px-1 py-1 text-[9px] text-green-300 font-bold focus:outline-none",
                                title: "Tiempo de espera entre alertas"
                            },
                                COOLDOWN_OPTIONS.map(opt =>
                                    React.createElement('option', { key: opt.value, value: opt.value }, opt.label)
                                )
                            )
                        ),

                        // Separador
                        React.createElement('div', { className: "h-4 w-px bg-neutral-600 mx-1" }),

                        // Selector de m√©trica como dropdown
                        React.createElement('select', {
                            value: selectedMetric,
                            onChange: (e) => {
                                const newMetric = e.target.value;
                                setSelectedMetric(newMetric);
                                // Guardar en config.parameters para persistencia
                                if (onUpdate) {
                                    onUpdate(config.id, {
                                        parameters: { ...config.parameters, selectedMetric: newMetric }
                                    });
                                }
                            },
                            className: "bg-neutral-800 border border-neutral-600 rounded px-2 py-1 text-[10px] text-amber-300 font-bold focus:outline-none focus:ring-1 focus:ring-amber-500"
                        },
                            METRICS.map(m =>
                                React.createElement('option', { key: m.key, value: m.key }, m.label)
                            )
                        ),

                        // Selector de ventana MA
                        React.createElement('select', {
                            value: config.parameters?.powerMeterMAWindow || 300,
                            onChange: (e) => {
                                const newWindow = parseInt(e.target.value);
                                if (onUpdate) {
                                    onUpdate(config.id, {
                                        parameters: { ...config.parameters, powerMeterMAWindow: newWindow, _updateTimestamp: Date.now() }
                                    });
                                }
                            },
                            className: "bg-neutral-800 border border-indigo-600 rounded px-2 py-1 text-[10px] text-indigo-300 font-bold focus:outline-none focus:ring-1 focus:ring-indigo-500",
                            title: "Ventana Promedio"
                        },
                            [
                                { value: 30, label: '30s' },
                                { value: 60, label: '1m' },
                                { value: 300, label: '5m' },
                                { value: 600, label: '10m' }
                            ].map(opt =>
                                React.createElement('option', { key: opt.value, value: opt.value }, opt.label)
                            )
                        ),

                        // Selector de velocidad de actualizaci√≥n
                        React.createElement('select', {
                            value: refreshInterval,
                            onChange: (e) => {
                                const newInterval = parseInt(e.target.value);
                                setRefreshInterval(newInterval);
                                // Guardar en config.parameters para persistencia
                                if (onUpdate) {
                                    onUpdate(config.id, {
                                        parameters: { ...config.parameters, refreshInterval: newInterval }
                                    });
                                }
                            },
                            className: "bg-neutral-800 border border-neutral-600 rounded px-2 py-1 text-[10px] text-cyan-300 font-bold focus:outline-none focus:ring-1 focus:ring-cyan-500",
                            title: "Velocidad de actualizaci√≥n"
                        },
                            REFRESH_OPTIONS.map(opt =>
                                React.createElement('option', { key: opt.value, value: opt.value }, opt.label)
                            )
                        ),
                        // Delete button
                        React.createElement('button', {
                            className: "p-1.5 rounded-md bg-neutral-700/50 hover:bg-red-500/50 text-gray-300",
                            onClick: () => onDelete(config.id),
                            title: "Delete Chart"
                        }, React.createElement(TrashIcon))
                    )
                ),
                // Content
                React.createElement('div', { className: "p-3" },
                    isCorrelation
                        ? React.createElement('div', { className: "grid grid-cols-1 gap-2" },
                            meterDataWithMA.map(slot => renderSlotMeters(slot, true))
                        )
                        : meterDataWithMA.map(slot => renderSlotMeters(slot, false))
                )
            );
        };

        // ===== ML PATTERN RECOGNITION CHART COMPONENT =====
        // Panel profesional de an√°lisis de patrones con Machine Learning
        components.MLPatternChart = ({ config, dataSource, allDataSources, onDelete, onUpdate, gridLayout }) => {
            const { useState, useMemo, useEffect, useCallback, useRef } = React;
            const { TrashIcon } = components.icons;
            const { MLPatternEngine, formatNumber } = services.signalCalculator;

            const [isAnalyzing, setIsAnalyzing] = useState(false);
            const [analysisResult, setAnalysisResult] = useState(null);
            const [activeTab, setActiveTab] = useState('causality'); // causality por defecto
            const [autoRefresh, setAutoRefresh] = useState(config.parameters?.autoRefresh ?? true);
            const [refreshInterval] = useState(config.parameters?.refreshInterval || 5000);
            const lastAnalysisRef = useRef(0);
            const [sessionHistory, setSessionHistory] = useState(null);
            const [isLoadingHistory, setIsLoadingHistory] = useState(false);

            // Los datos ya est√°n disponibles en dataSource/allDataSources
            // El sistema ya lee y mantiene el CSV en memoria
            const loadSessionHistory = useCallback(() => {
                console.log('Using live data from dataSource (CSV already loaded by system)');
                setIsLoadingHistory(false);
            }, []);

            // Obtener datos - el sistema ya mantiene el historial completo del CSV
            const combinedRows = useMemo(() => {
                let selectedData = null;

                if (config.type === 'ml-pattern-correlation') {
                    // Buscar el slot con m√°s datos
                    for (let slotId = 3; slotId <= 6; slotId++) {
                        const ds = allDataSources?.get(String(slotId));
                        if (ds?.rows?.length > 0) {
                            if (!selectedData || ds.rows.length > selectedData.rows.length) {
                                selectedData = ds;
                            }
                        }
                    }
                } else {
                    selectedData = dataSource;
                }

                if (selectedData?.rows?.length > 0) {
                    console.log(`ML Pattern: Using ${selectedData.rows.length} rows for analysis`);
                }

                return selectedData;
            }, [dataSource, allDataSources, config.type]);

            // Ejecutar an√°lisis - ULTRA-R√ÅPIDO desde 2 filas
            const runAnalysis = useCallback(() => {
                if (!combinedRows?.rows || combinedRows.rows.length < 2) return;

                setIsAnalyzing(true);

                setTimeout(() => {
                    try {
                        // Convertir de array de arrays a array de objetos
                        const headers = combinedRows.headers || [];
                        const rowsAsObjects = combinedRows.rows.map(row => {
                            const obj = {};
                            headers.forEach((header, idx) => {
                                obj[header] = row[idx];
                            });
                            return obj;
                        });

                        console.log('[MLPatternChart] Starting analysis:', {
                            totalRows: rowsAsObjects.length,
                            headers: headers,
                            firstRow: rowsAsObjects[0]
                        });

                        const result = MLPatternEngine.analyzePatterns(
                            rowsAsObjects,
                            'price',
                            'timestamp'
                        );

                        console.log('[MLPatternChart] Analysis result:', result);

                        if (result && !result.error) {
                            result.report = MLPatternEngine.generateCorrelationReport(result);

                            // Calcular "fingerprint" del estado actual - qu√© m√©tricas coinciden con patrones hist√≥ricos
                            result.fingerprint = calculateFingerprint(result);
                        }

                        setAnalysisResult(result);
                        lastAnalysisRef.current = Date.now();
                    } catch (e) {
                        console.error('ML Analysis error:', e);
                        setAnalysisResult({ error: e.message });
                    }
                    setIsAnalyzing(false);
                }, 100);
            }, [combinedRows]);

            // Calcular fingerprint de coincidencias
            const calculateFingerprint = (analysis) => {
                if (!analysis?.currentState?.snapshot || !analysis?.correlations) return null;

                const currentMetrics = analysis.currentState.snapshot.metrics;
                const fingerprint = { matches: [], strongSignals: [], overallBias: 0, confidence: 0 };
                let bullishScore = 0, bearishScore = 0, totalWeight = 0;

                // Para cada m√©trica, verificar coincidencias con patrones hist√≥ricos
                MLPatternEngine.METRICS_CONFIG.forEach(metricConfig => {
                    const current = currentMetrics[metricConfig.key];
                    if (!current) return;

                    const metricMatch = {
                        key: metricConfig.key,
                        label: metricConfig.label,
                        currentNet: current.net,
                        currentMomentum: current.momentum,
                        historicalMatches: [],
                        bias: 'NEUTRAL',
                        strength: 0
                    };

                    // Buscar en qu√© eventos hist√≥ricos esta m√©trica mostr√≥ valores similares
                    Object.entries(analysis.correlations).forEach(([eventType, eventData]) => {
                        const metricCorr = eventData.metrics[metricConfig.key];
                        if (!metricCorr) return;

                        // Determinar si el valor actual coincide con el patr√≥n hist√≥rico
                        const currentIsPositive = current.net > 0;
                        const historicalBullish = metricCorr.bullishBias > 0.5;

                        // Coincidencia si el signo actual es consistente con el bias hist√≥rico
                        const matches = (currentIsPositive && historicalBullish) || (!currentIsPositive && !historicalBullish);
                        const consistencyScore = metricCorr.consistency;

                        if (consistencyScore > 0.55) {
                            metricMatch.historicalMatches.push({
                                event: eventType,
                                consistency: consistencyScore,
                                matches,
                                isBullishEvent: eventType.includes('low') || eventType.includes('up'),
                                significance: metricCorr.significance
                            });

                            // Acumular score
                            const weight = consistencyScore * (metricCorr.significance === 'HIGH' ? 1.5 : metricCorr.significance === 'MEDIUM' ? 1 : 0.5);
                            if (matches) {
                                const isBullishEvent = eventType.includes('low') || eventType.includes('up');
                                if (isBullishEvent) bullishScore += weight;
                                else bearishScore += weight;
                            }
                            totalWeight += weight;
                        }
                    });

                    // Determinar bias de esta m√©trica
                    const bullishMatches = metricMatch.historicalMatches.filter(m => m.matches && m.isBullishEvent).length;
                    const bearishMatches = metricMatch.historicalMatches.filter(m => m.matches && !m.isBullishEvent).length;

                    if (bullishMatches > bearishMatches && bullishMatches > 0) {
                        metricMatch.bias = 'BULLISH';
                        metricMatch.strength = bullishMatches / (bullishMatches + bearishMatches + 1);
                    } else if (bearishMatches > bullishMatches && bearishMatches > 0) {
                        metricMatch.bias = 'BEARISH';
                        metricMatch.strength = bearishMatches / (bullishMatches + bearishMatches + 1);
                    }

                    if (metricMatch.historicalMatches.length > 0) {
                        fingerprint.matches.push(metricMatch);
                        if (metricMatch.strength > 0.5) {
                            fingerprint.strongSignals.push(metricMatch);
                        }
                    }
                });

                // Calcular bias general
                if (totalWeight > 0) {
                    fingerprint.overallBias = (bullishScore - bearishScore) / totalWeight;
                    fingerprint.confidence = Math.min(1, (bullishScore + bearishScore) / (totalWeight * 0.7));
                }

                // Ordenar por fuerza de se√±al
                fingerprint.matches.sort((a, b) => b.strength - a.strength);
                fingerprint.strongSignals.sort((a, b) => b.strength - a.strength);

                return fingerprint;
            };

            // Auto-refresh - FORZAR EJECUCI√ìN AUNQUE EL TAB EST√â INACTIVO
            useEffect(() => {
                if (!autoRefresh) return;

                // Usar setTimeout recursivo en lugar de setInterval para evitar throttling del navegador
                let timeoutId;
                const scheduleNext = () => {
                    timeoutId = setTimeout(() => {
                        if (Date.now() - lastAnalysisRef.current >= refreshInterval) {
                            runAnalysis();
                        }
                        scheduleNext(); // Programar siguiente ejecuci√≥n inmediatamente
                    }, refreshInterval);
                };

                scheduleNext();
                return () => clearTimeout(timeoutId);
            }, [autoRefresh, refreshInterval, runAnalysis]);

            // Forzar an√°lisis cuando el tab vuelve a estar visible (recuperar estado)
            useEffect(() => {
                const handleVisibilityChange = () => {
                    if (!document.hidden && autoRefresh) {
                        // Tab ahora visible - forzar an√°lisis si han pasado >10s desde el √∫ltimo
                        if (Date.now() - lastAnalysisRef.current >= 10000 && combinedRows?.rows?.length >= 2) {
                            console.log('[Visibility] Tab activo de nuevo - ejecutando an√°lisis inmediato');
                            runAnalysis();
                        }
                    }
                };

                document.addEventListener('visibilitychange', handleVisibilityChange);
                return () => document.removeEventListener('visibilitychange', handleVisibilityChange);
            }, [autoRefresh, combinedRows, runAnalysis]);

            // An√°lisis inicial - ULTRA-R√ÅPIDO
            useEffect(() => {
                if (!analysisResult && combinedRows?.rows?.length >= 2) {
                    runAnalysis();
                }
            }, [combinedRows, analysisResult, runAnalysis]);

            // Tab: CAUSALIDAD - Qu√© provoca REVERSIONES, IMPULSOS y BREAKOUTS
            const renderCausalityTab = () => {
                if (!analysisResult?.causality) {
                    return React.createElement('div', { className: "text-center text-neutral-500 py-4 text-xs" },
                        'Analyzing event causes...'
                    );
                }

                const causality = analysisResult.causality;
                const eventTypes = Object.keys(causality).sort((a, b) =>
                    causality[b].totalOccurrences - causality[a].totalOccurrences
                );

                if (eventTypes.length === 0) {
                    return React.createElement('div', { className: "text-center text-neutral-500 py-4 text-xs" },
                        'No se detectaron REVERSIONES, IMPULSOS o BREAKOUTS a√∫n. Necesita m√°s datos.'
                    );
                }

                // Agrupar por categor√≠a
                const categories = {
                    reversals: eventTypes.filter(et => et.includes('REVERSAL')),
                    impulses: eventTypes.filter(et => et.includes('IMPULSE')),
                    breakouts: eventTypes.filter(et => et.includes('BREAKOUT'))
                };

                const categoryConfig = {
                    reversals: { label: 'üîÑ REVERSIONES', color: '#8b5cf6', desc: 'Cambios de tendencia' },
                    impulses: { label: '‚ö° IMPULSOS', color: '#22c55e', desc: 'Movimientos r√°pidos' },
                    breakouts: { label: 'üöÄ BREAKOUTS', color: '#06b6d4', desc: 'Rupturas de consolidaci√≥n' }
                };

                return React.createElement('div', { className: "space-y-4" },
                    // Header explicativo
                    React.createElement('div', {
                        className: "bg-blue-500/10 border border-blue-500/30 rounded-lg p-3 text-[10px] text-blue-200"
                    },
                        React.createElement('div', { className: "font-bold mb-2 text-blue-100" }, 'üìä C√ìMO LEER LA TABLA DE CORRELACI√ìN'),
                        React.createElement('div', { className: "space-y-1.5 text-neutral-300" },
                            React.createElement('div', { className: "flex gap-2" },
                                React.createElement('div', { className: "font-bold text-blue-300" }, '1Ô∏è‚É£'),
                                React.createElement('div', {}, 'Cada secci√≥n muestra qu√© m√©tricas estaban ACTIVAS justo ANTES de que ocurriera el evento')
                            ),
                            React.createElement('div', { className: "flex gap-2" },
                                React.createElement('div', { className: "font-bold text-blue-300" }, '2Ô∏è‚É£'),
                                React.createElement('div', {}, 'Buscamos m√©tricas con momentum >10 (subiendo) o <-10 (bajando) en la fila anterior')
                            ),
                            React.createElement('div', { className: "flex gap-2" },
                                React.createElement('div', { className: "font-bold text-blue-300" }, '3Ô∏è‚É£'),
                                React.createElement('div', {},
                                    'El porcentaje indica FRECUENCIA: ',
                                    React.createElement('span', { className: "text-green-400" }, '70% = en 7 de 10 eventos'),
                                    ', ',
                                    React.createElement('span', { className: "text-yellow-400" }, '40% = en 4 de 10')
                                )
                            ),
                            React.createElement('div', { className: "flex gap-2" },
                                React.createElement('div', { className: "font-bold text-blue-300" }, '4Ô∏è‚É£'),
                                React.createElement('div', {},
                                    'Color de barra: ',
                                    React.createElement('span', { className: "text-blue-400" }, 'AZUL = m√©trica subiendo'),
                                    ' | ',
                                    React.createElement('span', { className: "text-orange-400" }, 'NARANJA = m√©trica bajando')
                                )
                            ),
                            React.createElement('div', { className: "flex gap-2" },
                                React.createElement('div', { className: "font-bold text-blue-300" }, 'üí°'),
                                React.createElement('div', {},
                                    React.createElement('strong', {}, 'Ejemplo: '),
                                    '"IV Skew SUBIENDO en 65%" = En 65% de los IMPULSE UP, el IV Skew estaba subiendo justo antes'
                                )
                            ),
                            React.createElement('div', { className: "flex gap-2 pt-1 border-t border-blue-500/20" },
                                React.createElement('div', { className: "font-bold text-yellow-400" }, '‚ö†Ô∏è'),
                                React.createElement('div', {},
                                    React.createElement('strong', {}, 'Solo muestra correlaciones >25%'),
                                    ' - m√©tricas que aparecen frecuentemente antes del evento'
                                )
                            )
                        )
                    ),

                    Object.keys(categories).map(cat => {
                        const events = categories[cat];
                        const config = categoryConfig[cat];

                        if (events.length === 0) return null;

                        return React.createElement('div', { key: cat, className: "space-y-2" },
                            // Header de categor√≠a
                            React.createElement('div', {
                                className: "flex items-center gap-2 pb-1 border-b",
                                style: { borderColor: config.color + '50' }
                            },
                                React.createElement('span', {
                                    className: "text-xs font-bold",
                                    style: { color: config.color }
                                }, config.label),
                                React.createElement('span', {
                                    className: "text-[9px] text-neutral-500"
                                }, config.desc)
                            ),

                            // Eventos de esta categor√≠a
                            events.map(eventType => {
                                const data = causality[eventType];
                                if (!data.triggers || data.triggers.length === 0) return null;

                                const eventLabel = eventType.replace(/_/g, ' ');
                                const isBullish = eventType.includes('UP') || eventType.includes('BULLISH');
                                const eventColor = isBullish ? '#22c55e' : '#ef4444';

                                return React.createElement('div', {
                                    key: eventType,
                                    className: "bg-neutral-800/50 rounded-lg p-2 border",
                                    style: { borderColor: eventColor + '40' }
                                },
                                    // Header del evento
                                    React.createElement('div', { className: "flex items-center justify-between mb-2" },
                                        React.createElement('div', { className: "flex items-center gap-2" },
                                            React.createElement('div', {
                                                className: "w-2 h-2 rounded-full",
                                                style: { backgroundColor: eventColor }
                                            }),
                                            React.createElement('span', {
                                                className: "text-[10px] font-bold text-neutral-200"
                                            }, eventLabel)
                                        ),
                                        React.createElement('span', {
                                            className: "text-[9px] px-2 py-0.5 rounded bg-neutral-700/50 text-neutral-400 font-mono"
                                        }, `${data.totalOccurrences}x`)
                                    ),

                                    // Lista de triggers (bajado a >25% para ver m√°s correlaciones)
                                    React.createElement('div', { className: "space-y-1.5" },
                                        data.triggers.filter(t => Math.max(t.increasingIn, t.decreasingIn) > 25).slice(0, 5).map((trigger, i) => {
                                            const maxPercentage = Math.max(trigger.increasingIn, trigger.decreasingIn);
                                            const isIncrease = trigger.increasingIn > trigger.decreasingIn;
                                            const barColor = isIncrease ? '#3b82f6' : '#f59e0b';

                                            return React.createElement('div', {
                                                key: trigger.key,
                                                className: "bg-neutral-900/50 rounded p-1.5"
                                            },
                                                React.createElement('div', { className: "flex items-center justify-between mb-1" },
                                                    React.createElement('span', {
                                                        className: "text-[9px] font-medium text-neutral-300"
                                                    }, trigger.metric),
                                                    React.createElement('span', {
                                                        className: "text-[10px] font-bold font-mono",
                                                        style: { color: barColor }
                                                    }, `${maxPercentage}%`)
                                                ),
                                                React.createElement('div', { className: "h-1.5 bg-neutral-800 rounded-full overflow-hidden mb-1" },
                                                    React.createElement('div', {
                                                        className: "h-full transition-all duration-300",
                                                        style: { width: `${maxPercentage}%`, backgroundColor: barColor }
                                                    })
                                                ),
                                                React.createElement('div', { className: "text-[8px] text-neutral-400", title: `Correlaci√≥n: Esta m√©trica mostr√≥ momentum ${isIncrease ? 'positivo >10' : 'negativo <-10'} en ${Math.max(trigger.increasingIn, trigger.decreasingIn)}% de ${eventLabel} detectados` },
                                                    isIncrease
                                                        ? `${trigger.metric} SUBIENDO (momentum >10) en ${trigger.increasingIn}% de casos`
                                                        : `${trigger.metric} BAJANDO (momentum <-10) en ${trigger.decreasingIn}% de casos`
                                                )
                                            );
                                        })
                                    ),

                                    // Sin triggers suficientes
                                    data.triggers.filter(t => Math.max(t.increasingIn, t.decreasingIn) > 25).length === 0 &&
                                    React.createElement('div', { className: "text-[9px] text-neutral-500 text-center py-2", title: "Se buscan m√©tricas con momentum >10 o <-10 presentes en >25% de los casos" },
                                        'Necesita m√°s ocurrencias para identificar causas (min 25% correlaci√≥n)'
                                    )
                                );
                            })
                        );
                    })
                );
            };

            // Tab: Coincidencias de m√©tricas
            const renderCoincidencesTab = () => {
                const mode = analysisResult?.summary?.mode || 'early';
                const dataQuality = analysisResult?.summary?.dataQuality || 'minimal';
                const dataPoints = combinedRows?.rows?.length || 0;

                if (!analysisResult?.fingerprint?.matches?.length) {
                    return React.createElement('div', { className: "text-center py-4" },
                        React.createElement('div', {
                            className: "text-xs mb-2",
                            style: { color: mode === 'early' ? '#f59e0b' : '#666' }
                        }, mode === 'early' ? '‚ö° EARLY MODE' : 'Analizando coincidencias...'),
                        React.createElement('div', { className: "text-[9px] text-neutral-600" },
                            `${dataPoints} rows ‚Ä¢ Waiting for price movements`
                        )
                    );
                }

                const fp = analysisResult.fingerprint;

                return React.createElement('div', { className: "space-y-2" },
                    // Header con modo y calidad
                    React.createElement('div', { className: "flex items-center justify-between px-2 py-1 bg-neutral-800/40 rounded mb-2" },
                        React.createElement('div', { className: "flex items-center gap-2" },
                            React.createElement('span', {
                                className: `text-[8px] px-1.5 py-0.5 rounded font-medium ${dataQuality === 'excellent' ? 'bg-green-500/20 text-green-400' :
                                    dataQuality === 'good' ? 'bg-blue-500/20 text-blue-400' :
                                        dataQuality === 'building' ? 'bg-amber-500/20 text-amber-400' :
                                            'bg-orange-500/20 text-orange-400'
                                    }`
                            }, mode.toUpperCase()),
                            React.createElement('span', { className: "text-[8px] text-neutral-500" }, `${dataPoints} rows`)
                        ),
                        React.createElement('span', { className: "text-[10px] font-mono font-bold text-purple-400" },
                            `${fp.strongSignals.length}/${fp.matches.length}`
                        )
                    ),

                    // Lista de m√©tricas con coincidencias
                    React.createElement('div', { className: "space-y-1 max-h-[280px] overflow-y-auto pr-1" },
                        fp.matches.map((match, idx) => {
                            const biasColor = match.bias === 'BULLISH' ? '#22c55e' : match.bias === 'BEARISH' ? '#ef4444' : '#666';
                            const isStrong = match.strength > 0.5;

                            return React.createElement('div', {
                                key: idx,
                                className: `p-2 rounded border transition-all ${isStrong ? 'bg-neutral-800/60 border-neutral-600' : 'bg-neutral-800/30 border-neutral-700/50'}`
                            },
                                // Header de m√©trica
                                React.createElement('div', { className: "flex items-center justify-between mb-1" },
                                    React.createElement('div', { className: "flex items-center gap-2" },
                                        React.createElement('span', {
                                            className: "w-2 h-2 rounded-full",
                                            style: { backgroundColor: biasColor }
                                        }),
                                        React.createElement('span', { className: "text-[10px] font-semibold text-neutral-200" }, match.label)
                                    ),
                                    React.createElement('div', { className: "flex items-center gap-2" },
                                        React.createElement('span', {
                                            className: "text-[8px] px-1.5 py-0.5 rounded font-medium",
                                            style: {
                                                color: biasColor,
                                                backgroundColor: biasColor + '20'
                                            }
                                        }, match.bias),
                                        React.createElement('span', {
                                            className: "text-[8px] font-mono",
                                            style: { color: match.strength > 0.5 ? '#a855f7' : '#666' }
                                        }, `${(match.strength * 100).toFixed(0)}%`)
                                    )
                                ),

                                // Valores actuales
                                React.createElement('div', { className: "flex items-center gap-3 text-[8px] mb-1" },
                                    React.createElement('span', { className: "text-neutral-500" }, 'Net:'),
                                    React.createElement('span', {
                                        className: "font-mono",
                                        style: { color: match.currentNet > 0 ? '#22c55e' : '#ef4444' }
                                    }, formatNumber(match.currentNet)),
                                    React.createElement('span', { className: "text-neutral-500 ml-2" }, 'Mom:'),
                                    React.createElement('span', {
                                        className: "font-mono",
                                        style: { color: match.currentMomentum > 0 ? '#22c55e' : '#ef4444' }
                                    }, match.currentMomentum.toFixed(1) + '%')
                                ),

                                // Coincidencias hist√≥ricas
                                match.historicalMatches.length > 0 && React.createElement('div', { className: "flex flex-wrap gap-1 mt-1" },
                                    match.historicalMatches.slice(0, 4).map((hm, hi) => {
                                        const eventColor = hm.isBullishEvent ? '#22c55e' : '#ef4444';
                                        const eventLabel = hm.event.replace('_', ' ').replace('local ', '').replace('impulse ', 'imp ').replace('breakout ', 'brk ');
                                        return React.createElement('span', {
                                            key: hi,
                                            className: "text-[7px] px-1 py-0.5 rounded",
                                            style: {
                                                backgroundColor: hm.matches ? eventColor + '20' : 'rgba(100,100,100,0.2)',
                                                color: hm.matches ? eventColor : '#666',
                                                border: `1px solid ${hm.matches ? eventColor + '40' : 'transparent'}`
                                            },
                                            title: `${hm.event}: ${(hm.consistency * 100).toFixed(0)}% consistency`
                                        }, eventLabel.toUpperCase());
                                    })
                                )
                            );
                        })
                    )
                );
            };

            // Tab: Fingerprint visual
            const renderFingerprintTab = () => {
                if (!analysisResult?.fingerprint) return null;

                const fp = analysisResult.fingerprint;
                const metrics = MLPatternEngine.METRICS_CONFIG;

                return React.createElement('div', { className: "space-y-3" },
                    // Matriz visual de coincidencias
                    React.createElement('div', { className: "p-2 bg-neutral-800/30 rounded" },
                        React.createElement('div', { className: "text-[9px] text-neutral-400 mb-2 font-medium" }, 'METRIC FINGERPRINT'),
                        React.createElement('div', { className: "grid gap-1", style: { gridTemplateColumns: 'repeat(4, 1fr)' } },
                            metrics.map((m, idx) => {
                                const match = fp.matches.find(fm => fm.key === m.key);
                                const strength = match?.strength || 0;
                                const bias = match?.bias || 'NEUTRAL';
                                const bgColor = bias === 'BULLISH' ? `rgba(34,197,94,${0.2 + strength * 0.6})`
                                    : bias === 'BEARISH' ? `rgba(239,68,68,${0.2 + strength * 0.6})`
                                        : 'rgba(100,100,100,0.2)';
                                const borderColor = strength > 0.5 ? (bias === 'BULLISH' ? '#22c55e' : '#ef4444') : 'transparent';

                                return React.createElement('div', {
                                    key: idx,
                                    className: "p-1.5 rounded text-center transition-all",
                                    style: { backgroundColor: bgColor, border: `1px solid ${borderColor}` },
                                    title: `${m.label}: ${(strength * 100).toFixed(0)}% ${bias}`
                                },
                                    React.createElement('div', { className: "text-[7px] text-neutral-300 truncate" }, m.label),
                                    React.createElement('div', {
                                        className: "text-[9px] font-bold font-mono",
                                        style: { color: bias === 'BULLISH' ? '#22c55e' : bias === 'BEARISH' ? '#ef4444' : '#666' }
                                    }, strength > 0 ? `${(strength * 100).toFixed(0)}` : '-')
                                );
                            })
                        )
                    ),

                    // Se√±ales fuertes destacadas
                    fp.strongSignals.length > 0 && React.createElement('div', { className: "p-2 bg-neutral-800/30 rounded" },
                        React.createElement('div', { className: "text-[9px] text-neutral-400 mb-2 font-medium" }, 'STRONG SIGNALS'),
                        React.createElement('div', { className: "space-y-1" },
                            fp.strongSignals.slice(0, 5).map((sig, idx) => {
                                const color = sig.bias === 'BULLISH' ? '#22c55e' : '#ef4444';
                                return React.createElement('div', {
                                    key: idx,
                                    className: "flex items-center justify-between py-1 px-2 rounded",
                                    style: { backgroundColor: color + '15' }
                                },
                                    React.createElement('span', { className: "text-[10px] text-neutral-200" }, sig.label),
                                    React.createElement('div', { className: "flex items-center gap-2" },
                                        React.createElement('div', {
                                            className: "w-16 h-1.5 bg-neutral-700 rounded-full overflow-hidden"
                                        },
                                            React.createElement('div', {
                                                className: "h-full rounded-full",
                                                style: { width: `${sig.strength * 100}%`, backgroundColor: color }
                                            })
                                        ),
                                        React.createElement('span', {
                                            className: "text-[9px] font-mono font-bold",
                                            style: { color }
                                        }, sig.bias.charAt(0))
                                    )
                                );
                            })
                        )
                    ),

                    // Estad√≠sticas de eventos detectados - SOLO REVERSIONES, IMPULSOS, BREAKOUTS
                    analysisResult.summary && React.createElement('div', { className: "grid grid-cols-3 gap-1" },
                        [
                            { label: 'Rev ‚Üë', value: analysisResult.summary.reversalsBullish, color: '#8b5cf6' },
                            { label: 'Rev ‚Üì', value: analysisResult.summary.reversalsBearish, color: '#f59e0b' },
                            { label: 'Imp ‚Üë', value: analysisResult.summary.impulsesUp, color: '#22c55e' },
                            { label: 'Imp ‚Üì', value: analysisResult.summary.impulsesDown, color: '#ef4444' },
                            { label: 'Brk ‚Üë', value: analysisResult.summary.breakoutsUp, color: '#06b6d4' },
                            { label: 'Brk ‚Üì', value: analysisResult.summary.breakoutsDown, color: '#dc2626' }
                        ].map((stat, idx) =>
                            React.createElement('div', {
                                key: idx,
                                className: "p-1.5 bg-neutral-800/40 rounded text-center"
                            },
                                React.createElement('div', { className: "text-[8px] text-neutral-500" }, stat.label),
                                React.createElement('div', {
                                    className: "text-sm font-bold font-mono",
                                    style: { color: stat.color }
                                }, stat.value || 0)
                            )
                        )
                    )
                );
            };

            // Tab: Predicci√≥n
            const renderPredictionTab = () => {
                if (!analysisResult?.fingerprint || !analysisResult?.currentState?.prediction) return null;

                const fp = analysisResult.fingerprint;
                const pred = analysisResult.currentState.prediction;
                const trend = analysisResult.currentState.trend;

                // Calcular se√±al combinada
                const biasScore = fp.overallBias;
                const combinedSignal = biasScore > 0.2 ? 'BULLISH' : biasScore < -0.2 ? 'BEARISH' : 'NEUTRAL';
                const combinedColor = combinedSignal === 'BULLISH' ? '#22c55e' : combinedSignal === 'BEARISH' ? '#ef4444' : '#666';
                const confidence = fp.confidence;

                return React.createElement('div', { className: "space-y-3" },
                    // Se√±al principal
                    React.createElement('div', {
                        className: "p-3 rounded-lg border text-center",
                        style: {
                            backgroundColor: combinedColor + '10',
                            borderColor: combinedColor + '40'
                        }
                    },
                        React.createElement('div', { className: "text-[9px] text-neutral-400 mb-1" }, 'ML SIGNAL'),
                        React.createElement('div', {
                            className: "text-2xl font-bold mb-1",
                            style: { color: combinedColor }
                        }, combinedSignal),
                        React.createElement('div', { className: "flex items-center justify-center gap-4 text-[10px]" },
                            React.createElement('span', { className: "text-neutral-400" },
                                `Confidence: ${(confidence * 100).toFixed(0)}%`
                            ),
                            React.createElement('span', { className: "text-neutral-400" },
                                `Bias: ${(biasScore * 100).toFixed(0)}%`
                            )
                        ),
                        // Barra de confianza
                        React.createElement('div', { className: "mt-2 h-2 bg-neutral-800 rounded-full overflow-hidden mx-auto max-w-[200px]" },
                            React.createElement('div', {
                                className: "h-full rounded-full transition-all",
                                style: {
                                    width: `${confidence * 100}%`,
                                    backgroundColor: combinedColor
                                }
                            })
                        )
                    ),

                    // An√°lisis de similitud
                    pred.basedOn > 0 && React.createElement('div', { className: "p-2 bg-neutral-800/30 rounded" },
                        React.createElement('div', { className: "flex items-center justify-between mb-2" },
                            React.createElement('span', { className: "text-[9px] text-neutral-400" }, 'PATTERN SIMILARITY'),
                            React.createElement('span', { className: "text-[9px] text-purple-400" },
                                `${pred.basedOn} matches`
                            )
                        ),
                        React.createElement('div', { className: "text-[10px] text-neutral-300" },
                            `Based on ${pred.basedOn} similar historical patterns, the model suggests a ${pred.signal.toLowerCase()} bias with ${(pred.confidence * 100).toFixed(0)}% agreement.`
                        )
                    ),

                    // Tendencia actual
                    trend && React.createElement('div', { className: "p-2 bg-neutral-800/30 rounded" },
                        React.createElement('div', { className: "text-[9px] text-neutral-400 mb-1" }, 'CURRENT TREND'),
                        React.createElement('div', { className: "flex items-center justify-between" },
                            React.createElement('span', {
                                className: "text-[11px] font-bold",
                                style: {
                                    color: trend.type === 'trend_up' ? '#22c55e' :
                                        trend.type === 'trend_down' ? '#ef4444' : '#888'
                                }
                            }, trend.type.replace('_', ' ').toUpperCase()),
                            React.createElement('span', { className: "text-[9px] text-neutral-500" },
                                `R¬≤: ${(trend.r2 * 100).toFixed(0)}%`
                            )
                        ),
                        React.createElement('div', { className: "flex items-center gap-2 mt-1" },
                            React.createElement('span', { className: "text-[8px] text-neutral-500" }, 'Slope:'),
                            React.createElement('span', {
                                className: "text-[9px] font-mono",
                                style: { color: trend.slope > 0 ? '#22c55e' : '#ef4444' }
                            }, `${trend.slope > 0 ? '+' : ''}${trend.slope.toFixed(4)}%`)
                        )
                    ),

                    // M√©tricas clave que respaldan la se√±al
                    fp.strongSignals.length > 0 && React.createElement('div', { className: "p-2 bg-neutral-800/30 rounded" },
                        React.createElement('div', { className: "text-[9px] text-neutral-400 mb-1" }, 'SUPPORTING METRICS'),
                        React.createElement('div', { className: "flex flex-wrap gap-1" },
                            fp.strongSignals.filter(s => s.bias === combinedSignal).slice(0, 4).map((s, idx) =>
                                React.createElement('span', {
                                    key: idx,
                                    className: "text-[8px] px-1.5 py-0.5 rounded",
                                    style: {
                                        backgroundColor: combinedColor + '20',
                                        color: combinedColor
                                    }
                                }, s.label)
                            )
                        )
                    )
                );
            };

            // Tab: Eventos de precio detectados
            const renderEventsTab = () => {
                if (!analysisResult?.events) return null;

                const { localExtremes, impulses, breakouts } = analysisResult.events;
                const allEvents = [
                    ...localExtremes.map(e => ({ ...e, category: 'extreme' })),
                    ...impulses.map(e => ({ ...e, category: 'impulse' })),
                    ...breakouts.map(e => ({ ...e, category: 'breakout' }))
                ].sort((a, b) => b.index - a.index).slice(0, 20); // √öltimos 20 eventos

                const eventStyles = {
                    'local_high': { label: 'HIGH', color: '#ef4444', bg: 'rgba(239,68,68,0.1)' },
                    'local_low': { label: 'LOW', color: '#22c55e', bg: 'rgba(34,197,94,0.1)' },
                    'impulse_up': { label: 'IMP UP', color: '#3b82f6', bg: 'rgba(59,130,246,0.1)' },
                    'impulse_down': { label: 'IMP DN', color: '#f97316', bg: 'rgba(249,115,22,0.1)' },
                    'breakout_up': { label: 'BRK UP', color: '#06b6d4', bg: 'rgba(6,182,212,0.1)' },
                    'breakout_down': { label: 'BRK DN', color: '#ec4899', bg: 'rgba(236,72,153,0.1)' }
                };

                return React.createElement('div', { className: "space-y-2" },
                    // Header con resumen
                    React.createElement('div', { className: "flex items-center justify-between px-1 py-1 bg-neutral-800/40 rounded" },
                        React.createElement('span', { className: "text-[9px] text-neutral-400" }, 'PRICE EVENTS DETECTED'),
                        React.createElement('span', { className: "text-[10px] font-mono text-purple-400" },
                            `${localExtremes.length + impulses.length + breakouts.length} total`
                        )
                    ),

                    // Stats r√°pidas
                    React.createElement('div', { className: "grid grid-cols-3 gap-1" },
                        React.createElement('div', { className: "p-1.5 bg-neutral-800/30 rounded text-center" },
                            React.createElement('div', { className: "text-[8px] text-neutral-500" }, 'Extremes'),
                            React.createElement('div', { className: "text-xs font-bold text-amber-400" }, localExtremes.length)
                        ),
                        React.createElement('div', { className: "p-1.5 bg-neutral-800/30 rounded text-center" },
                            React.createElement('div', { className: "text-[8px] text-neutral-500" }, 'Impulses'),
                            React.createElement('div', { className: "text-xs font-bold text-blue-400" }, impulses.length)
                        ),
                        React.createElement('div', { className: "p-1.5 bg-neutral-800/30 rounded text-center" },
                            React.createElement('div', { className: "text-[8px] text-neutral-500" }, 'Breakouts'),
                            React.createElement('div', { className: "text-xs font-bold text-cyan-400" }, breakouts.length)
                        )
                    ),

                    // Lista de eventos recientes
                    React.createElement('div', { className: "text-[9px] text-neutral-400 mt-2" }, 'Recent Events (newest first):'),
                    React.createElement('div', { className: "space-y-1 max-h-[220px] overflow-y-auto pr-1" },
                        allEvents.length === 0
                            ? React.createElement('div', { className: "text-center text-neutral-500 py-2 text-[10px]" }, 'No events detected yet')
                            : allEvents.map((event, idx) => {
                                const style = eventStyles[event.type] || { label: event.type, color: '#888', bg: 'rgba(100,100,100,0.1)' };

                                return React.createElement('div', {
                                    key: idx,
                                    className: "flex items-center gap-2 p-1.5 rounded border border-neutral-700/50",
                                    style: { backgroundColor: style.bg }
                                },
                                    // Tipo de evento
                                    React.createElement('span', {
                                        className: "text-[8px] font-bold px-1.5 py-0.5 rounded min-w-[45px] text-center",
                                        style: { color: style.color, backgroundColor: style.color + '20' }
                                    }, style.label),

                                    // Precio
                                    React.createElement('div', { className: "flex-1" },
                                        React.createElement('div', { className: "flex items-center gap-2" },
                                            React.createElement('span', { className: "text-[8px] text-neutral-500" }, 'Price:'),
                                            React.createElement('span', {
                                                className: "text-[10px] font-mono font-bold",
                                                style: { color: style.color }
                                            }, event.price?.toFixed(2) || '-')
                                        ),
                                        // Info adicional seg√∫n tipo
                                        event.magnitude && React.createElement('div', { className: "text-[7px] text-neutral-500" },
                                            `Move: ${event.magnitude > 0 ? '+' : ''}${event.magnitude.toFixed(2)}% in ${event.bars} bars`
                                        ),
                                        event.zScore && React.createElement('div', { className: "text-[7px] text-neutral-500" },
                                            `Z-Score: ${event.zScore.toFixed(2)}`
                                        )
                                    ),

                                    // Index (posici√≥n en datos)
                                    React.createElement('span', { className: "text-[7px] text-neutral-600" },
                                        `#${event.index}`
                                    )
                                );
                            })
                    ),

                    // Nota explicativa
                    React.createElement('div', { className: "text-[8px] text-neutral-600 mt-2 px-1" },
                        'Events are detected using price data: Local highs/lows (5-bar lookback), Impulses (>2.5œÉ moves), Breakouts (range breaks).'
                    )
                );
            };

            // Tabs
            const tabs = [
                { key: 'causality', label: 'What Causes Events' },
                { key: 'coincidences', label: 'Coincidences' },
                { key: 'events', label: 'Events' },
                { key: 'fingerprint', label: 'Fingerprint' },
                { key: 'prediction', label: 'Prediction' }
            ];

            return React.createElement('div', {
                className: "flex flex-col bg-neutral-900/60 border border-neutral-800 rounded-lg overflow-hidden shadow-lg"
            },
                // Header - sin icono
                React.createElement('div', { className: "flex items-center justify-between p-2 bg-gradient-to-r from-purple-900/30 via-neutral-800/50 to-neutral-800/50 border-b border-neutral-700" },
                    React.createElement('div', { className: "flex items-center gap-2" },
                        React.createElement('h3', { className: "text-sm font-bold text-gray-200" },
                            config.type === 'ml-pattern-correlation' ? 'ML Pattern Analysis' : `ML Pattern (S${config.slotId})`
                        ),
                        isAnalyzing && React.createElement('div', {
                            className: "w-2 h-2 rounded-full bg-purple-500 animate-pulse"
                        }),
                        // Indicador de datos disponibles
                        combinedRows?.rows?.length > 0 && React.createElement('span', {
                            className: "text-[8px] px-1.5 py-0.5 rounded bg-green-500/20 text-green-400 font-medium"
                        }, `${combinedRows.rows.length} rows`)
                    ),
                    React.createElement('div', { className: "flex items-center gap-1" },
                        // Bot√≥n recargar historial
                        React.createElement('button', {
                            className: "p-1 rounded bg-neutral-700/50 hover:bg-blue-600/50 text-gray-300 disabled:opacity-50",
                            onClick: loadSessionHistory,
                            disabled: isLoadingHistory,
                            title: "Reload Session History"
                        }, React.createElement('svg', { className: `w-3 h-3 ${isLoadingHistory ? 'animate-spin' : ''}`, fill: "none", stroke: "currentColor", viewBox: "0 0 24 24" },
                            React.createElement('path', { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M8 7H5a2 2 0 00-2 2v9a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-3m-1 4l-3 3m0 0l-3-3m3 3V4" })
                        )),
                        // Auto-refresh toggle
                        React.createElement('button', {
                            className: `p-1 rounded transition-all ${autoRefresh ? 'bg-purple-600 text-white' : 'bg-neutral-700/50 text-gray-400'}`,
                            onClick: () => {
                                setAutoRefresh(!autoRefresh);
                                if (onUpdate) onUpdate(config.id, { parameters: { ...config.parameters, autoRefresh: !autoRefresh } });
                            },
                            title: autoRefresh ? 'Auto ON' : 'Auto OFF'
                        }, React.createElement('svg', { className: "w-3 h-3", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24" },
                            React.createElement('path', { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" })
                        )),
                        // Manual refresh
                        React.createElement('button', {
                            className: "p-1 rounded bg-neutral-700/50 hover:bg-purple-600/50 text-gray-300",
                            onClick: runAnalysis,
                            disabled: isAnalyzing
                        }, React.createElement('svg', { className: `w-3 h-3 ${isAnalyzing ? 'animate-spin' : ''}`, fill: "none", stroke: "currentColor", viewBox: "0 0 24 24" },
                            React.createElement('path', { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z" })
                        )),
                        // Delete
                        React.createElement('button', {
                            className: "p-1 rounded bg-neutral-700/50 hover:bg-red-500/50 text-gray-300",
                            onClick: () => onDelete(config.id)
                        }, React.createElement(TrashIcon))
                    )
                ),

                // Tabs
                React.createElement('div', { className: "flex border-b border-neutral-700" },
                    tabs.map(tab =>
                        React.createElement('button', {
                            key: tab.key,
                            className: `flex-1 px-2 py-1.5 text-[9px] font-medium transition-all ${activeTab === tab.key
                                ? 'text-purple-400 border-b-2 border-purple-500 bg-purple-500/10'
                                : 'text-neutral-400 hover:text-neutral-200'}`,
                            onClick: () => setActiveTab(tab.key)
                        }, tab.label)
                    )
                ),

                // Content
                React.createElement('div', { className: "p-2 overflow-y-auto", style: { maxHeight: gridLayout === '4x4' ? '320px' : '420px' } },
                    analysisResult?.error
                        ? React.createElement('div', { className: "text-center py-6" },
                            React.createElement('div', {
                                className: "w-12 h-12 mx-auto mb-3 rounded-full bg-gradient-to-br from-amber-500/20 to-orange-500/20 flex items-center justify-center animate-pulse"
                            },
                                React.createElement('div', { className: "text-2xl" }, 'üì°')
                            ),
                            React.createElement('div', { className: "text-sm font-medium text-neutral-300 mb-1" },
                                'Waiting for Session Data'
                            ),
                            React.createElement('div', { className: "text-[10px] text-neutral-500 mb-3" },
                                `${analysisResult.current || 0} rows received - need ${analysisResult.minRequired || 2} minimum`
                            ),
                            React.createElement('div', { className: "text-[9px] text-amber-400 font-medium" },
                                '‚ö° Analysis starts IMMEDIATELY with first price movements'
                            )
                        )
                        : !analysisResult
                            ? React.createElement('div', { className: "text-center text-neutral-500 py-4" },
                                React.createElement('div', { className: "animate-pulse text-xs" }, 'Analyzing...')
                            )
                            : activeTab === 'causality' ? renderCausalityTab()
                                : activeTab === 'coincidences' ? renderCoincidencesTab()
                                    : activeTab === 'events' ? renderEventsTab()
                                        : activeTab === 'fingerprint' ? renderFingerprintTab()
                                            : renderPredictionTab()
                )
            );
        };

        // ===== ANALYSIS CENTER COMPONENT =====
        // Centro de An√°lisis Causal Inteligente - Reemplaza pesta√±a Custom
        // === ANALYSIS CENTER - Centro de An√°lisis Causal ===
        components.AnalysisCenter = ({ dataSources, globalAiEnabled, onAiEnabledChange }) => {
            const { useState, useEffect, useMemo, useCallback, useRef } = React;
            const { MLPatternEngine } = services.signalCalculator;

            // Estados
            const [selectedSlot, setSelectedSlot] = useState('1');
            const [analysisResult, setAnalysisResult] = useState(null);
            const [isAnalyzing, setIsAnalyzing] = useState(false);
            const [autoRefresh, setAutoRefresh] = useState(true);
            const [debugInfo, setDebugInfo] = useState('');
            const [aiNarrations, setAiNarrations] = useState([]); // NUEVO: Narraciones de IA
            const [showNarrator, setShowNarrator] = useState(true); // Toggle para mostrar/ocultar narrador
            const [absorptionMetricFilter, setAbsorptionMetricFilter] = useState('all'); // Filtro de m√©tricas para absorci√≥n
            // Usar estado global del header (no local)
            const aiEnabled = globalAiEnabled !== undefined ? globalAiEnabled : false;
            const setAiEnabled = onAiEnabledChange || (() => { });
            const [aiStatus, setAiStatus] = useState('disconnected'); // NUEVO: Estado de conexi√≥n con backend
            const [showApiKeyModal, setShowApiKeyModal] = useState(false); // NUEVO: Modal para configurar API key
            const [apiKeyInput, setApiKeyInput] = useState(''); // NUEVO: Input temporal de API key
            const [lastCausalHash, setLastCausalHash] = useState(''); // NUEVO: Hash del √∫ltimo an√°lisis para evitar duplicados
            const lastAnalysisRef = useRef(0);
            const lastPriceRef = useRef(null); // NUEVO: Para detectar cambios

            // NUEVO: Cargar API key guardada al iniciar
            useEffect(() => {
                const savedApiKey = localStorage.getItem('groq_api_key');
                if (savedApiKey) {
                    setApiKeyInput(savedApiKey);
                }
            }, []);

            // NUEVO: Guardar API key
            const saveApiKey = () => {
                if (apiKeyInput.trim()) {
                    localStorage.setItem('groq_api_key', apiKeyInput.trim());
                    setShowApiKeyModal(false);
                    checkAiHealth(); // Reintentar conexi√≥n
                    alert('‚úÖ API Key guardada correctamente');
                } else {
                    alert('‚ö†Ô∏è Por favor ingresa una API key v√°lida');
                }
            };

            // NUEVO: Borrar API key
            const clearApiKey = () => {
                if (confirm('¬øSeguro que quieres borrar la API key?')) {
                    localStorage.removeItem('groq_api_key');
                    setApiKeyInput('');
                    setAiStatus('disconnected');
                    setAiEnabled(false);
                    alert('üóëÔ∏è API Key borrada');
                }
            };

            // NUEVO: Verificar si el servidor de IA est√° disponible
            useEffect(() => {
                const checkAiServer = async () => {
                    try {
                        const response = await fetch('http://localhost:5000/health');
                        if (response.ok) {
                            setAiStatus('connected');
                        } else {
                            setAiStatus('error');
                        }
                    } catch (error) {
                        setAiStatus('disconnected');
                    }
                };

                checkAiServer();
                const interval = setInterval(checkAiServer, 30000); // Verificar cada 30s
                return () => clearInterval(interval);
            }, []);

            // NUEVO: Funci√≥n para enviar an√°lisis a la IA
            // NUEVO: Formatear texto de IA con colores seg√∫n importancia
            const formatAiText = (text) => {
                if (!text) return '';

                return text
                    // N√∫meros con % (correlaciones, porcentajes) -> AMARILLO
                    .replace(/(\d+%)/g, '<span style="color: #fbbf24; font-weight: 600;">$1</span>')
                    // Palabras clave alcistas -> VERDE
                    .replace(/\b(ALZA|ALCISTA|COMPRA|BULLISH|CALLS?|SUBE|SUBIENDO|DOMINAN|PRESI√ìN COMPRADORA)\b/gi,
                        '<span style="color: #22c55e; font-weight: 600;">$&</span>')
                    // Palabras clave bajistas -> ROJO
                    .replace(/\b(CA√çDA|BAJISTA|VENTA|BEARISH|PUTS?|BAJA|BAJANDO|VENDEN|PRESI√ìN VENDEDORA)\b/gi,
                        '<span style="color: #ef4444; font-weight: 600;">$&</span>')
                    // Alertas y advertencias -> ROJO INTENSO
                    .replace(/\b(ALERTA|DIVERGENCIA|RIESGO|CUIDADO|VIGILAR|ATENCI√ìN|IMPORTANTE)\b/gi,
                        '<span style="color: #dc2626; font-weight: 700; text-transform: uppercase;">$&</span>')
                    // M√©tricas importantes (Delta, OI, Volume, etc) -> CYAN
                    .replace(/\b(DELTA|GAMMA|VEGA|THETA|OI|VOLUME|VOLUMEN|FLOW|PREMIUM|PCR|SKEW|IV)\b/gi,
                        '<span style="color: #06b6d4; font-weight: 600;">$&</span>')
                    // N√∫meros grandes (precios, valores) -> BLANCO BRILLANTE
                    .replace(/\$\d+[\d,.]*/g, '<span style="color: #f3f4f6; font-weight: 500;">$&</span>');
            };

            // NUEVO: Generar hash del an√°lisis causal para detectar cambios reales
            const generateCausalHash = (causality, eventTypes) => {
                // Crear una firma √∫nica basada en: tipos de eventos, ocurrencias y triggers principales
                const signature = eventTypes.map(et => {
                    const data = causality[et];
                    const topTriggers = data.triggers?.slice(0, 3).map(t =>
                        `${t.metric}:${Math.round(Math.max(t.increasingIn || 0, t.decreasingIn || 0))}`
                    ).join(',') || '';
                    return `${et}:${data.totalOccurrences}:${topTriggers}`;
                }).join('|');

                // Simple hash (no necesita ser criptogr√°fico)
                let hash = 0;
                for (let i = 0; i < signature.length; i++) {
                    const char = signature.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash;
                }
                return hash.toString();
            };

            // NUEVO: Solicitar an√°lisis causal a la IA
            const requestAiCausalAnalysis = async (causalData, precioActual) => {
                if (!aiEnabled || aiStatus !== 'connected') return;

                // Obtener API key del localStorage
                const apiKey = localStorage.getItem('groq_api_key');
                if (!apiKey) {
                    console.warn('No hay API key configurada');
                    setShowApiKeyModal(true);
                    setAiEnabled(false);
                    return;
                }

                try {
                    console.log('[AI] Enviando an√°lisis causal a IA...');

                    const response = await fetch('http://localhost:5000/analyze-causal', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-API-Key': apiKey
                        },
                        body: JSON.stringify({
                            precio_actual: precioActual,
                            causal_data: causalData,
                            timestamp: new Date().toLocaleTimeString()
                        })
                    });

                    const result = await response.json();

                    if (result.success) {
                        console.log('[AI] An√°lisis causal recibido');

                        const narrationData = {
                            timestamp: result.timestamp,
                            priceFrom: precioActual,
                            priceTo: precioActual,
                            priceChange: 0,
                            explanation: result.explanation,
                            type: 'causal',
                            eventsAnalyzed: causalData.totalEvents
                        };

                        setAiNarrations(prev => [narrationData, ...prev.slice(0, 9)]);

                        // Guardar globalmente para Telegram (prioridad a an√°lisis m√°s reciente)
                        window.lastAiNarration = {
                            text: result.explanation,
                            timestamp: result.timestamp,
                            sentiment: 'Causal Analysis',
                            score: causalData.totalEvents
                        };
                    } else {
                        console.error('[AI] Error en respuesta:', result.error);
                    }
                } catch (error) {
                    console.error('[AI] Error al solicitar an√°lisis:', error);
                }
            };

            // LEGACY: An√°lisis de precio simple (ya no se usa)
            const requestAiAnalysis = async (precioAnterior, precioActual, metricas) => {
                if (!aiEnabled || aiStatus !== 'connected') return;

                const cambioPct = ((precioActual - precioAnterior) / precioAnterior) * 100;

                // Solo analizar cambios significativos (>0.05%)
                if (Math.abs(cambioPct) < 0.05) return;

                // Obtener API key del localStorage
                const apiKey = localStorage.getItem('groq_api_key');
                if (!apiKey) {
                    console.warn('No hay API key configurada');
                    setShowApiKeyModal(true);
                    setAiEnabled(false);
                    return;
                }

                try {
                    const response = await fetch('http://localhost:5000/analyze', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-API-Key': apiKey  // Enviar API key en header
                        },
                        body: JSON.stringify({
                            precio_anterior: precioAnterior,
                            precio_actual: precioActual,
                            cambio_pct: cambioPct,
                            metricas: metricas,
                            timestamp: new Date().toLocaleTimeString()
                        })
                    });

                    const result = await response.json();

                    if (result.success) {
                        const narrationData = {
                            timestamp: result.timestamp,
                            priceChange: cambioPct,
                            explanation: result.explanation,
                            priceFrom: precioAnterior,
                            priceTo: precioActual
                        };

                        setAiNarrations(prev => [narrationData, ...prev.slice(0, 9)]);

                        // Guardar globalmente para Telegram
                        window.lastAiNarration = {
                            text: result.explanation,
                            timestamp: result.timestamp,
                            sentiment: cambioPct > 0 ? 'BULLISH' : cambioPct < 0 ? 'BEARISH' : 'NEUTRAL',
                            score: Math.abs(cambioPct)
                        };
                    }
                } catch (error) {
                    console.error('[AI Narrator] Error:', error);
                    setAiStatus('error');
                }
            };

            // Obtener TODOS los slots (1-6)
            const availableSlots = useMemo(() => {
                const slots = [];
                for (let i = 1; i <= 6; i++) {
                    const ds = dataSources?.get(String(i));
                    const hasData = ds?.rows?.length > 0;
                    slots.push({
                        id: String(i),
                        symbol: ds?.symbol || `Slot ${i}`,
                        displayName: ds?.symbol || `Slot ${i}`,
                        rowCount: ds?.rows?.length || 0,
                        hasData: hasData
                    });
                }
                return slots;
            }, [dataSources]);

            // Auto-seleccionar primer slot con datos
            useEffect(() => {
                const firstWithData = availableSlots.find(s => s.hasData);
                if (firstWithData && !dataSources?.get(selectedSlot)?.rows?.length) {
                    setSelectedSlot(firstWithData.id);
                }
            }, [availableSlots]);

            // Obtener datos del slot seleccionado
            const slotData = useMemo(() => {
                const ds = dataSources?.get(selectedSlot);
                console.log(`[AnalysisCenter] Slot ${selectedSlot} data:`, ds);

                if (!ds) {
                    setDebugInfo(`Slot ${selectedSlot}: No dataSource found`);
                    return null;
                }

                if (!ds.rows?.length) {
                    setDebugInfo(`Slot ${selectedSlot}: No rows (${ds.rows?.length || 0})`);
                    return null;
                }

                if (!ds.headers?.length) {
                    setDebugInfo(`Slot ${selectedSlot}: No headers`);
                    return null;
                }

                // Convertir de array de arrays a array de objetos
                const headers = ds.headers;
                const rows = ds.rows.map(row => {
                    if (Array.isArray(row)) {
                        const obj = {};
                        headers.forEach((header, idx) => {
                            obj[header] = row[idx];
                        });
                        return obj;
                    }
                    return row; // Ya es objeto
                });

                setDebugInfo(`Slot ${selectedSlot}: ${rows.length} rows, ${headers.length} headers`);
                console.log('[AnalysisCenter] Converted data:', { headers, firstRow: rows[0], rowCount: rows.length });

                return { headers, rows, symbol: ds.symbol };
            }, [dataSources, selectedSlot]);

            // Ejecutar an√°lisis
            const runAnalysis = useCallback(() => {
                if (!slotData?.rows?.length) {
                    console.log('[AnalysisCenter] Cannot analyze: no data');
                    return;
                }

                if (slotData.rows.length < 2) {
                    console.log('[AnalysisCenter] Cannot analyze: need at least 2 rows');
                    return;
                }

                setIsAnalyzing(true);
                console.log(`[AnalysisCenter] Starting analysis with ${slotData.rows.length} rows`);

                setTimeout(() => {
                    try {
                        const result = MLPatternEngine.analyzePatterns(
                            slotData.rows,
                            'Underlying_Price',
                            'timestamp'
                        );

                        console.log('[AnalysisCenter] Raw analysis result:', result);

                        if (result && !result.error) {
                            result.report = MLPatternEngine.generateCorrelationReport(result);

                            // NUEVO: Cuando hay an√°lisis causal completo, generar resumen IA (CON RESTRICCIONES ESTRICTAS)
                            if (aiEnabled && aiStatus === 'connected' && result.causality) {
                                const causality = result.causality;
                                const eventTypes = Object.keys(causality).filter(et => causality[et].totalOccurrences > 0);

                                // RESTRICCI√ìN 1: M√≠nimo 5 eventos totales (antes era 3)
                                const totalEvents = eventTypes.reduce((sum, et) => sum + causality[et].totalOccurrences, 0);

                                // RESTRICCI√ìN 2: Al menos 3 tipos de eventos diferentes
                                if (totalEvents >= 5 && eventTypes.length >= 3) {

                                    // RESTRICCI√ìN 3: Crear hash del contenido causal para detectar cambios reales
                                    const causalHash = generateCausalHash(causality, eventTypes);

                                    // RESTRICCI√ìN 4: Solo analizar si el hash cambi√≥ (contenido diferente)
                                    if (causalHash !== lastCausalHash) {
                                        console.log('[AI] Cambio significativo detectado en an√°lisis causal');
                                        console.log('[AI] Eventos totales:', totalEvents, '| Tipos:', eventTypes.length);

                                        setLastCausalHash(causalHash);

                                        // Preparar datos para la IA
                                        const causalData = {
                                            totalEvents,
                                            eventTypes: eventTypes.length,
                                            causes: {}
                                        };

                                        // Extraer triggers principales de cada tipo de evento
                                        eventTypes.forEach(eventType => {
                                            const data = causality[eventType];
                                            if (data.triggers && data.triggers.length > 0) {
                                                causalData.causes[eventType] = {
                                                    occurrences: data.totalOccurrences,
                                                    triggers: data.triggers.slice(0, 5).map(t => ({
                                                        metric: t.metric,
                                                        correlation: Math.max(t.increasingIn || 0, t.decreasingIn || 0),
                                                        direction: (t.increasingIn || 0) > (t.decreasingIn || 0) ? 'SUBIENDO' : 'BAJANDO',
                                                        pattern: t.dominantPattern
                                                    })),
                                                    precededBy: data.precededBy?.filter(p => p.percentage > 50).slice(0, 2).map(p => ({
                                                        event: p.eventLabel,
                                                        percentage: p.percentage
                                                    }))
                                                };
                                            }
                                        });

                                        // Obtener precio actual del mercado
                                        const precioActual = result.rawData?.rows?.length > 0
                                            ? parseFloat(result.rawData.rows[result.rawData.rows.length - 1].Underlying_Price || 0)
                                            : 0;

                                        requestAiCausalAnalysis(causalData, precioActual);
                                    } else {
                                        console.log('[AI] Sin cambios significativos en an√°lisis causal, omitiendo an√°lisis');
                                    }
                                } else {
                                    console.log('[AI] Insuficientes eventos para an√°lisis:', totalEvents, 'eventos,', eventTypes.length, 'tipos (necesita ‚â•5 eventos y ‚â•3 tipos)');
                                }
                            }
                        }

                        setAnalysisResult(result);
                        lastAnalysisRef.current = Date.now();
                    } catch (e) {
                        console.error('[AnalysisCenter] Analysis error:', e);
                        setAnalysisResult({ error: e.message });
                    }
                    setIsAnalyzing(false);
                }, 50);
            }, [slotData]);

            // Exportar a PDF profesional
            const exportToPDF = useCallback(() => {
                if (!analysisResult || !slotData) return;

                try {
                    const content = [];
                    content.push('<html><head><meta charset="utf-8"><style>');
                    content.push('@page { margin: 12mm; size: A4; }');
                    content.push('* { margin: 0; padding: 0; box-sizing: border-box; }');
                    content.push('body { font-family: "Segoe UI", Arial, sans-serif; font-size: 8.5pt; line-height: 1.3; color: #e5e7eb; background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%); }');

                    // Header oscuro con gradiente
                    content.push('.header { background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%); padding: 15px; margin-bottom: 15px; border-radius: 0; border-bottom: 2px solid #334155; }');
                    content.push('.logo { font-size: 20pt; font-weight: 700; letter-spacing: 1px; margin-bottom: 5px; }');
                    content.push('.header-subtitle { font-size: 14pt; font-weight: 600; margin-bottom: 8px; }');
                    content.push('.header-info { font-size: 8pt; opacity: 0.9; }');

                    // Layout profesional en columnas
                    content.push('.two-col { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin: 12px 0; }');
                    content.push('.three-col { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin: 10px 0; }');
                    content.push('.four-col { display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; margin: 10px 0; }');

                    // Secciones - tema oscuro
                    content.push('h2 { font-size: 12pt; color: #60a5fa; margin: 15px 0 8px 0; padding-bottom: 4px; border-bottom: 2px solid #374151; font-weight: 700; text-transform: uppercase; letter-spacing: 1px; }');
                    content.push('h3 { font-size: 10pt; color: #94a3b8; margin: 12px 0 6px 0; font-weight: 600; }');

                    // Cards con tema oscuro
                    content.push('.stat-card { background: linear-gradient(135deg, #1e293b 0%, #334155 100%); border: 1px solid #475569; border-radius: 6px; padding: 10px; text-align: center; box-shadow: 0 2px 4px rgba(0,0,0,0.3); }');
                    content.push('.stat-label { font-size: 7pt; color: #94a3b8; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 3px; }');
                    content.push('.stat-value { font-size: 16pt; font-weight: 700; color: #f1f5f9; }');
                    content.push('.stat-bar { height: 4px; background: #334155; border-radius: 2px; margin-top: 5px; overflow: hidden; }');
                    content.push('.stat-bar-fill { height: 100%; background: linear-gradient(90deg, #6366f1, #a855f7); transition: width 0.3s; }');

                    // Event cards - tema oscuro
                    content.push('.event-box { background: #1e293b; border: 1px solid #334155; border-radius: 6px; padding: 9px; margin: 6px 0; page-break-inside: avoid; box-shadow: 0 1px 3px rgba(0,0,0,0.3); }');
                    content.push('.event-box.bullish { border-left: 3px solid #22c55e; background: linear-gradient(135deg, #1e293b 0%, #064e3b 100%); }');
                    content.push('.event-box.bearish { border-left: 3px solid #ef4444; background: linear-gradient(135deg, #1e293b 0%, #7f1d1d 100%); }');
                    content.push('.event-box.reversal { border-left: 3px solid #a855f7; background: linear-gradient(135deg, #1e293b 0%, #581c87 100%); }');
                    content.push('.event-header { font-size: 8.5pt; font-weight: 600; color: #f1f5f9; margin-bottom: 4px; }');
                    content.push('.event-meta { font-size: 7.5pt; color: #cbd5e1; margin-bottom: 6px; line-height: 1.3; }');

                    // Triggers y m√©tricas - tema oscuro
                    content.push('.trigger-item { background: #0f172a; border: 1px solid #334155; padding: 5px; margin: 3px 0; border-radius: 4px; font-size: 7.5pt; }');
                    content.push('.trigger-label { color: #cbd5e1; font-weight: 500; }');
                    content.push('.trigger-value { color: #60a5fa; font-weight: 700; float: right; font-size: 8pt; }');
                    content.push('.progress-bar { height: 3px; background: #334155; border-radius: 2px; margin-top: 3px; overflow: hidden; }');
                    content.push('.progress-fill { height: 100%; background: linear-gradient(90deg, #3b82f6, #8b5cf6); border-radius: 2px; }');

                    // AI section - tema oscuro
                    content.push('.ai-box { background: linear-gradient(135deg, #172554 0%, #1e3a8a 100%); border: 1px solid #3b82f6; border-radius: 6px; padding: 9px; margin: 8px 0; box-shadow: 0 2px 4px rgba(59,130,246,0.2); }');
                    content.push('.ai-title { font-size: 7.5pt; font-weight: 600; color: #60a5fa; margin-bottom: 5px; text-transform: uppercase; letter-spacing: 0.5px; }');
                    content.push('.ai-text { font-size: 7.5pt; color: #bfdbfe; line-height: 1.4; }');
                    content.push('.ai-timestamp { font-size: 6.5pt; color: #94a3b8; margin-top: 5px; text-align: right; }');

                    // Colores de texto
                    content.push('.text-bullish { color: #22c55e; font-weight: 600; }');
                    content.push('.text-bearish { color: #ef4444; font-weight: 600; }');
                    content.push('.text-percentage { color: #f59e0b; font-weight: 600; }');
                    content.push('.text-metric { color: #06b6d4; font-weight: 600; }');

                    content.push('</style></head><body>');

                    // Header profesional igual al de la p√°gina
                    content.push('<div class="header">');
                    content.push('<div style="display: flex; align-items: center; justify-content: space-between;">');
                    // Logo como en el HeaderBar
                    content.push('<div style="display: flex; align-items: baseline; gap: 4px;">');
                    content.push('<span style="font-size: 24pt; font-weight: bold; color: #f5f5f5; letter-spacing: 1px;">ReloadingTape</span>');
                    content.push('<span style="font-size: 14pt; color: #0ea5e9; font-weight: 500; font-style: italic;">Evolution</span>');
                    content.push('</div>');
                    // Telegram link
                    content.push('<div style="text-align: right;">');
                    content.push('<div style="font-size: 9pt; color: #94a3b8; margin-bottom: 3px;">üì± Telegram Channel</div>');
                    content.push('<div style="font-size: 8pt; color: #60a5fa; font-family: monospace;">@ReloadingTapeBot</div>');
                    content.push('</div>');
                    content.push('</div>');
                    // Subt√≠tulo y info
                    content.push(`<div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #334155;">`);
                    content.push(`<div style="font-size: 12pt; font-weight: 600; color: #e5e7eb; margin-bottom: 4px;">Analysis Report - ${slotData.symbol || 'Slot ' + selectedSlot}</div>`);
                    content.push(`<div style="font-size: 8pt; color: #94a3b8;">${new Date().toLocaleString()} | ${slotData.rows.length} data points analyzed</div>`);
                    content.push('</div>');
                    content.push('</div>');

                    // Resumen ejecutivo en 4 columnas
                    const summary = analysisResult.summary;
                    content.push('<h2>EXECUTIVE SUMMARY</h2>');
                    content.push('<div class="four-col">');
                    content.push(`<div class="stat-card"><div class="stat-label">Total Events</div><div class="stat-value">${summary.totalEvents}</div></div>`);
                    content.push(`<div class="stat-card"><div class="stat-label">Impulses Up</div><div class="stat-value" style="color: #22c55e;">${summary.impulsesUp || 0}</div><div class="stat-bar"><div class="stat-bar-fill" style="width: ${((summary.impulsesUp || 0) / summary.totalEvents * 100)}%"></div></div></div>`);
                    content.push(`<div class="stat-card"><div class="stat-label">Impulses Down</div><div class="stat-value" style="color: #ef4444;">${summary.impulsesDown || 0}</div><div class="stat-bar"><div class="stat-bar-fill" style="width: ${((summary.impulsesDown || 0) / summary.totalEvents * 100)}%"></div></div></div>`);
                    content.push(`<div class="stat-card"><div class="stat-label">Reversals Up</div><div class="stat-value" style="color: #8b5cf6;">${summary.reversalsBullish || 0}</div><div class="stat-bar"><div class="stat-bar-fill" style="width: ${((summary.reversalsBullish || 0) / summary.totalEvents * 100)}%"></div></div></div>`);
                    content.push(`<div class="stat-card"><div class="stat-label">Reversals Down</div><div class="stat-value" style="color: #f59e0b;">${summary.reversalsBearish || 0}</div><div class="stat-bar"><div class="stat-bar-fill" style="width: ${((summary.reversalsBearish || 0) / summary.totalEvents * 100)}%"></div></div></div>`);
                    content.push(`<div class="stat-card"><div class="stat-label">Breakouts Up</div><div class="stat-value" style="color: #06b6d4;">${summary.breakoutsUp || 0}</div><div class="stat-bar"><div class="stat-bar-fill" style="width: ${((summary.breakoutsUp || 0) / summary.totalEvents * 100)}%"></div></div></div>`);
                    content.push(`<div class="stat-card"><div class="stat-label">Breakouts Down</div><div class="stat-value" style="color: #dc2626;">${summary.breakoutsDown || 0}</div><div class="stat-bar"><div class="stat-bar-fill" style="width: ${((summary.breakoutsDown || 0) / summary.totalEvents * 100)}%"></div></div></div>`);
                    const bullishTotal = (summary.impulsesUp || 0) + (summary.breakoutsUp || 0) + (summary.reversalsBullish || 0);
                    const bearishTotal = (summary.impulsesDown || 0) + (summary.breakoutsDown || 0) + (summary.reversalsBearish || 0);
                    content.push(`<div class="stat-card"><div class="stat-label">Market Bias</div><div class="stat-value" style="color: ${bullishTotal > bearishTotal ? '#22c55e' : '#ef4444'};">${bullishTotal > bearishTotal ? 'BULLISH' : 'BEARISH'}</div></div>`);
                    content.push('</div>');

                    // AI ANALYSIS en 2 columnas
                    if (aiNarrations && aiNarrations.length > 0) {
                        content.push('<h2>AI ANALYSIS</h2>');
                        content.push('<div class="two-col">');
                        aiNarrations.slice(0, 6).forEach((narration, idx) => {
                            content.push('<div class="ai-box">');
                            content.push(`<div class="ai-title">Analysis #${idx + 1}</div>`);

                            let aiText = (narration.explanation || 'No analysis available')
                                .replace(/(\d+%)/g, '<span class="text-percentage">$1</span>')
                                .replace(/\b(ALZA|ALCISTA|COMPRA|BULLISH|CALLS?|SUBE)\b/gi, '<span class="text-bullish">$&</span>')
                                .replace(/\b(CA√çDA|BAJISTA|VENTA|BEARISH|PUTS?|BAJA)\b/gi, '<span class="text-bearish">$&</span>')
                                .replace(/\b(DELTA|GAMMA|OI|VOLUME|FLOW|PREMIUM)\b/gi, '<span class="text-metric">$&</span>');

                            content.push(`<div class="ai-text">${aiText}</div>`);
                            content.push(`<div class="ai-timestamp">${new Date(narration.timestamp).toLocaleTimeString()}</div>`);
                            content.push('</div>');
                        });
                        content.push('</div>');
                    }

                    // IMPULSOS Y REVERSIONES en 2 columnas
                    if (analysisResult.expertAnalysis && analysisResult.expertAnalysis.patterns) {
                        content.push('<h2>EVENTS ANALYSIS</h2>');
                        const { patterns } = analysisResult.expertAnalysis;

                        // Contador de eventos totales
                        const totalEvents = (
                            (patterns.impulseUpPatterns?.length || 0) +
                            (patterns.impulseDownPatterns?.length || 0) +
                            (patterns.reversalBullishPatterns?.length || 0) +
                            (patterns.reversalBearishPatterns?.length || 0) +
                            (patterns.breakoutUpPatterns?.length || 0) +
                            (patterns.breakoutDownPatterns?.length || 0)
                        );

                        if (totalEvents === 0) {
                            content.push('<div style="text-align: center; padding: 40px; color: #94a3b8; font-size: 10pt;">');
                            content.push('<div style="font-size: 14pt; margin-bottom: 10px; color: #60a5fa;">\u26A0\uFE0F No Events Detected Yet</div>');
                            content.push('<div>Waiting for market movements to detect IMPULSES, REVERSALS, and BREAKOUTS</div>');
                            content.push('<div style="margin-top: 10px; font-size: 8pt;">Need more data points with price action</div>');
                            content.push('</div>');
                        }

                        // Impulsos alcistas
                        if (patterns.impulseUpPatterns && patterns.impulseUpPatterns.length > 0) {
                            content.push('<h3>Bullish Impulses</h3>');
                            content.push('<div class="two-col">');
                            patterns.impulseUpPatterns.slice(0, 10).forEach(pattern => {
                                content.push(`<div class="event-box bullish">`);
                                content.push(`<div class="event-header">Row #${pattern.index} | $${pattern.price?.toFixed(2)}</div>`);
                                content.push(`<div class="event-meta">${pattern.expertAnalysis}</div>`);

                                if (Object.keys(pattern.immediateTrigger || {}).length > 0) {
                                    Object.values(pattern.immediateTrigger).slice(0, 2).forEach(t => {
                                        content.push(`<div class="trigger-item"><span class="trigger-label">${t.label}</span><span class="trigger-value">${t.changePercent}%</span><div class="progress-bar"><div class="progress-fill" style="width: ${Math.abs(parseFloat(t.changePercent))}%"></div></div></div>`);
                                    });
                                }
                                content.push('</div>');
                            });
                            content.push('</div>');
                        }

                        // Impulsos bajistas
                        if (patterns.impulseDownPatterns && patterns.impulseDownPatterns.length > 0) {
                            content.push('<h3>Bearish Impulses</h3>');
                            content.push('<div class="two-col">');
                            patterns.impulseDownPatterns.slice(0, 10).forEach(pattern => {
                                content.push(`<div class="event-box bearish">`);
                                content.push(`<div class="event-header">Row #${pattern.index} | $${pattern.price?.toFixed(2)}</div>`);
                                content.push(`<div class="event-meta">${pattern.expertAnalysis}</div>`);

                                if (Object.keys(pattern.immediateTrigger || {}).length > 0) {
                                    content.push('<div style="margin-top: 8px;"><strong style="font-size: 8pt; color: #94a3b8;">Triggers:</strong></div>');
                                    Object.values(pattern.immediateTrigger).slice(0, 3).forEach(t => {
                                        const percent = Math.abs(parseFloat(t.changePercent) || 0);
                                        content.push(`<div class="trigger-item">`);
                                        content.push(`<span class="trigger-label">${t.label}</span>`);
                                        content.push(`<span class="trigger-value">${percent.toFixed(1)}%</span>`);
                                        content.push(`<div class="progress-bar"><div class="progress-fill" style="width: ${Math.min(percent * 5, 100)}%; background: #ef4444;"></div></div>`);
                                        content.push(`</div>`);
                                    });
                                }
                                content.push(`</div>`);
                            });
                            content.push('</div>');
                        }

                        // Reversiones alcistas
                        if (patterns.reversalBullishPatterns && patterns.reversalBullishPatterns.length > 0) {
                            content.push('<h3>Bullish Reversals</h3>');
                            content.push('<div class="two-col">');
                            patterns.reversalBullishPatterns.slice(0, 10).forEach(pattern => {
                                content.push(`<div class="event-box reversal">`);
                                content.push(`<div class="event-header">Row #${pattern.index} | $${pattern.price?.toFixed(2)}</div>`);
                                content.push(`<div class="event-meta">${pattern.expertAnalysis}</div>`);

                                if (Object.keys(pattern.exhaustionSignals || {}).length > 0) {
                                    content.push('<div style="margin-top: 8px;"><strong style="font-size: 8pt; color: #64748b;">Exhaustion Signals:</strong></div>');
                                    Object.values(pattern.exhaustionSignals).slice(0, 3).forEach(s => {
                                        content.push(`<div class="trigger-item">`);
                                        content.push(`<span class="trigger-label">${s.label}</span>`);
                                        content.push(`<span class="trigger-value">${s.prevMomentum}% ‚Üí ${s.currMomentum}%</span>`);
                                        content.push(`</div>`);
                                    });
                                }
                                content.push(`</div>`);
                            });
                            content.push('</div>');
                        }

                        // Reversiones bajistas
                        if (patterns.reversalBearishPatterns && patterns.reversalBearishPatterns.length > 0) {
                            content.push('<h3>Bearish Reversals</h3>');
                            content.push('<div class="two-col">');
                            patterns.reversalBearishPatterns.slice(0, 10).forEach(pattern => {
                                content.push(`<div class="event-box reversal">`);
                                content.push(`<div class="event-header">Row #${pattern.index} | $${pattern.price?.toFixed(2)}</div>`);
                                content.push(`<div class="event-meta">${pattern.expertAnalysis}</div>`);

                                if (Object.keys(pattern.exhaustionSignals || {}).length > 0) {
                                    content.push('<div style="margin-top: 8px;"><strong style="font-size: 8pt; color: #64748b;">Exhaustion Signals:</strong></div>');
                                    Object.values(pattern.exhaustionSignals).slice(0, 3).forEach(s => {
                                        content.push(`<div class="trigger-item">`);
                                        content.push(`<span class="trigger-label">${s.label}</span>`);
                                        content.push(`<span class="trigger-value">${s.prevMomentum}% ‚Üí ${s.currMomentum}%</span>`);
                                        content.push(`</div>`);
                                    });
                                }
                                content.push(`</div>`);
                            });
                            content.push('</div>');
                        }

                        // Breakouts alcistas
                        if (patterns.breakoutUpPatterns && patterns.breakoutUpPatterns.length > 0) {
                            content.push('<h3>Bullish Breakouts</h3>');
                            content.push('<div class="two-col">');
                            patterns.breakoutUpPatterns.slice(0, 10).forEach(pattern => {
                                content.push(`<div class="event-box bullish">`);
                                content.push(`<div class="event-header">Row #${pattern.index} | $${pattern.price?.toFixed(2)}</div>`);
                                content.push(`<div class="event-meta">${pattern.expertAnalysis}</div>`);

                                if (Object.keys(pattern.consolidationMetrics || {}).length > 0) {
                                    content.push('<div style="margin-top: 8px;"><strong style="font-size: 8pt; color: #64748b;">Consolidation:</strong></div>');
                                    Object.values(pattern.consolidationMetrics).slice(0, 3).forEach(m => {
                                        content.push(`<div class="trigger-item">`);
                                        content.push(`<span class="trigger-label">${m.label}</span>`);
                                        content.push(`<span class="trigger-value">${m.volatilityDrop || m.value}</span>`);
                                        content.push(`</div>`);
                                    });
                                }
                                content.push(`</div>`);
                            });
                            content.push('</div>');
                        }

                        // Breakouts bajistas
                        if (patterns.breakoutDownPatterns && patterns.breakoutDownPatterns.length > 0) {
                            content.push('<h3>Bearish Breakouts</h3>');
                            content.push('<div class="two-col">');
                            patterns.breakoutDownPatterns.slice(0, 10).forEach(pattern => {
                                content.push(`<div class="event-box bearish">`);
                                content.push(`<div class="event-header">Row #${pattern.index} | $${pattern.price?.toFixed(2)}</div>`);
                                content.push(`<div class="event-meta">${pattern.expertAnalysis}</div>`);

                                if (Object.keys(pattern.consolidationMetrics || {}).length > 0) {
                                    content.push('<div style="margin-top: 8px;"><strong style="font-size: 8pt; color: #64748b;">Consolidation:</strong></div>');
                                    Object.values(pattern.consolidationMetrics).slice(0, 3).forEach(m => {
                                        content.push(`<div class="trigger-item">`);
                                        content.push(`<span class="trigger-label">${m.label}</span>`);
                                        content.push(`<span class="trigger-value">${m.volatilityDrop || m.value}</span>`);
                                        content.push(`</div>`);
                                    });
                                }
                                content.push(`</div>`);
                            });
                            content.push('</div>');
                        }
                    }

                    // An√°lisis Causal
                    if (analysisResult.causality) {
                        content.push('<h2>CAUSAL ANALYSIS</h2>');
                        content.push('<div class="two-col">');

                        Object.keys(analysisResult.causality).forEach(eventType => {
                            const data = analysisResult.causality[eventType];

                            // Determinar clase CSS seg√∫n tipo de evento
                            let boxClass = 'event-box';
                            if (eventType.includes('UP') || eventType.includes('BULLISH')) boxClass += ' bullish';
                            else if (eventType.includes('DOWN') || eventType.includes('BEARISH')) boxClass += ' bearish';
                            else if (eventType.includes('REVERSAL')) boxClass += ' reversal';

                            content.push(`<div class="${boxClass}">`);
                            content.push(`<div class="event-header">${eventType.replace(/_/g, ' ')} (${data.totalOccurrences}x)</div>`);

                            // Triggers
                            if (data.triggers && data.triggers.length > 0) {
                                content.push('<div style="margin-top: 8px;"><strong style="font-size: 8pt; color: #64748b;">Metric Triggers:</strong></div>');
                                data.triggers.slice(0, 3).forEach(trigger => {
                                    const maxPct = Math.max(trigger.increasingIn || 0, trigger.decreasingIn || 0);
                                    const direction = (trigger.increasingIn || 0) > (trigger.decreasingIn || 0) ? '‚Üë' : '‚Üì';
                                    content.push(`<div class="trigger-item">`);
                                    content.push(`<span class="trigger-label">${trigger.metric} ${direction}</span>`);
                                    content.push(`<span class="trigger-value">${maxPct.toFixed(0)}%</span>`);
                                    content.push(`<div class="progress-bar"><div class="progress-fill" style="width: ${maxPct}%;"></div></div>`);
                                    content.push(`</div>`);
                                });
                            }

                            // Eventos precedentes
                            if (data.precededBy && data.precededBy.length > 0) {
                                content.push('<div style="margin-top: 8px;"><strong style="font-size: 8pt; color: #64748b;">Preceded by:</strong></div>');
                                data.precededBy.slice(0, 2).forEach(prec => {
                                    content.push(`<div class="trigger-item">`);
                                    content.push(`<span class="trigger-label">${prec.eventLabel}</span>`);
                                    content.push(`<span class="trigger-value">${prec.percentage}%</span>`);
                                    content.push(`<div class="progress-bar"><div class="progress-fill" style="width: ${prec.percentage}%;"></div></div>`);
                                    content.push(`</div>`);
                                });
                            }

                            content.push('</div>');
                        });

                        content.push('</div>');
                    }

                    content.push('</body></html>');

                    // Crear blob y descargar
                    const blob = new Blob([content.join('\n')], { type: 'text/html' });
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = `AnalysisCenter_${slotData.symbol || 'Slot' + selectedSlot}_${new Date().toISOString().slice(0, 10)}.html`;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    URL.revokeObjectURL(url);

                    console.log('[AnalysisCenter] Report exported');
                } catch (e) {
                    console.error('[AnalysisCenter] Export error:', e);
                    alert('Error al exportar: ' + e.message);
                }
            }, [analysisResult, slotData, selectedSlot]);

            // Auto-an√°lisis cuando cambia el slot o llegan datos nuevos
            useEffect(() => {
                if (slotData?.rows?.length >= 2) {
                    runAnalysis();
                }
            }, [selectedSlot, slotData?.rows?.length]);

            // Auto-refresh cada 10 segundos - FORZAR EJECUCI√ìN AUNQUE EL TAB EST√â INACTIVO
            useEffect(() => {
                if (!autoRefresh) return;

                // Usar setTimeout recursivo en lugar de setInterval para evitar throttling del navegador
                let timeoutId;
                const scheduleNext = () => {
                    timeoutId = setTimeout(() => {
                        if (Date.now() - lastAnalysisRef.current >= 10000 && slotData?.rows?.length >= 2) {
                            runAnalysis();
                        }
                        scheduleNext(); // Programar siguiente ejecuci√≥n inmediatamente
                    }, 10000);
                };

                scheduleNext();
                return () => clearTimeout(timeoutId);
            }, [autoRefresh, slotData, runAnalysis]);

            // Forzar an√°lisis cuando el tab vuelve a estar visible (recuperar estado)
            useEffect(() => {
                const handleVisibilityChange = () => {
                    if (!document.hidden && autoRefresh) {
                        // Tab ahora visible - forzar an√°lisis si han pasado >10s desde el √∫ltimo
                        if (Date.now() - lastAnalysisRef.current >= 10000 && slotData?.rows?.length >= 2) {
                            console.log('[Visibility] Tab activo de nuevo - ejecutando an√°lisis causal inmediato');
                            runAnalysis();
                        }
                    }
                };

                document.addEventListener('visibilitychange', handleVisibilityChange);
                return () => document.removeEventListener('visibilitychange', handleVisibilityChange);
            }, [autoRefresh, slotData, runAnalysis]);

            // Renderizar secci√≥n de causalidad
            const renderCausalitySection = () => {
                if (!analysisResult?.causality) {
                    return React.createElement('div', { className: "text-center text-neutral-500 py-4 text-sm" },
                        'Esperando eventos de precio para an√°lisis causal...'
                    );
                }

                const causality = analysisResult.causality;
                const eventTypes = Object.keys(causality).filter(et => causality[et].totalOccurrences > 0);

                if (eventTypes.length === 0) {
                    return React.createElement('div', { className: "text-center text-neutral-500 py-4 text-sm" },
                        'No se han detectado eventos de precio a√∫n. Necesita m√°s movimientos.'
                    );
                }

                // Filtrar UNUSUAL: solo mostrar EL M√ÅS FUERTE (top 1)
                const filteredEventTypes = eventTypes.filter(et => {
                    if (!et.includes('UNUSUAL')) return true;
                    const unusualEvents = eventTypes.filter(e => e.includes('UNUSUAL'));
                    if (unusualEvents.length === 0) return false;
                    const strongest = unusualEvents
                        .map(e => ({ type: e, strength: causality[e].triggers[0]?.correlation || 0 }))
                        .sort((a, b) => b.strength - a.strength)[0];
                    return et === strongest.type;
                });

                return React.createElement('div', { className: "grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-3" },
                    filteredEventTypes.map(eventType => {
                        const data = causality[eventType];
                        if (!data.triggers || data.triggers.length === 0) return null;

                        const eventLabel = eventType.replace(/_/g, ' ');
                        const isBullish = eventType.includes('UP') || eventType.includes('LOW') || eventType.includes('BULLISH');
                        const isReversal = eventType.includes('REVERSAL');
                        const isUnusual = eventType.includes('UNUSUAL');

                        let eventColor = '#737373';
                        if (isBullish) eventColor = '#22c55e';
                        else if (eventType.includes('DOWN') || eventType.includes('BEARISH')) eventColor = '#ef4444';
                        if (isUnusual) eventColor = '#f59e0b'; // Naranja para eventos inusuales
                        if (isReversal) eventColor = '#8b5cf6'; // P√∫rpura para reversiones

                        return React.createElement('div', {
                            key: eventType,
                            className: "bg-neutral-800/50 rounded-lg p-3 border border-neutral-700/30"
                        },
                            // Header del evento
                            React.createElement('div', { className: "flex items-center justify-between mb-3 pb-2 border-b border-neutral-700/30" },
                                React.createElement('div', { className: "flex items-center gap-2" },
                                    React.createElement('div', {
                                        className: "w-2 h-2 rounded-full",
                                        style: { backgroundColor: eventColor }
                                    }),
                                    React.createElement('span', {
                                        className: "text-xs font-semibold uppercase tracking-wide",
                                        style: { color: eventColor }
                                    }, eventLabel)
                                ),
                                React.createElement('span', {
                                    className: "text-[10px] px-2 py-0.5 rounded bg-neutral-700/50 text-neutral-400 font-mono"
                                }, `${data.totalOccurrences}x`)
                            ),

                            // Lista de triggers causales
                            React.createElement('div', { className: "space-y-2" },
                                data.triggers.slice(0, 8).map((trigger, i) => {
                                    const maxPct = Math.max(trigger.increasingIn || 0, trigger.decreasingIn || 0);
                                    const isIncrease = (trigger.increasingIn || 0) > (trigger.decreasingIn || 0);
                                    const direction = isIncrease ? 'SUBIENDO' : 'BAJANDO';
                                    const barColor = isIncrease ? '#3b82f6' : '#f97316';

                                    // Identificar si es CALL, PUT o ratio
                                    let sideLabel = '';
                                    let sideColor = '#737373';
                                    if (trigger.metric.includes('CALLS')) {
                                        sideLabel = 'C';
                                        sideColor = '#22c55e';
                                    } else if (trigger.metric.includes('PUTS')) {
                                        sideLabel = 'P';
                                        sideColor = '#ef4444';
                                    } else if (trigger.metric.includes('PCR')) {
                                        sideLabel = 'R';
                                        sideColor = '#8b5cf6';
                                    }

                                    return React.createElement('div', {
                                        key: trigger.key || i,
                                        className: "bg-neutral-900/40 rounded p-2"
                                    },
                                        React.createElement('div', { className: "flex items-center justify-between mb-1" },
                                            React.createElement('div', { className: "flex items-center gap-1.5" },
                                                sideLabel && React.createElement('span', {
                                                    className: "text-[7px] font-bold px-1.5 py-0.5 rounded",
                                                    style: { backgroundColor: sideColor + '20', color: sideColor, border: `1px solid ${sideColor}50` }
                                                }, sideLabel),
                                                React.createElement('span', { className: "text-[10px] text-neutral-300 font-medium" },
                                                    trigger.metric
                                                )
                                            ),
                                            React.createElement('span', {
                                                className: "text-xs font-bold font-mono",
                                                style: { color: barColor }
                                            }, `${maxPct}%`)
                                        ),
                                        React.createElement('div', { className: "h-1.5 bg-neutral-800 rounded-full overflow-hidden mb-1" },
                                            React.createElement('div', {
                                                className: "h-full rounded-full",
                                                style: { width: `${maxPct}%`, backgroundColor: barColor }
                                            })
                                        ),
                                        React.createElement('div', { className: "text-[9px] text-neutral-500" },
                                            `${maxPct}% de eventos ${eventLabel} ten√≠an ${trigger.metric} ${direction}`
                                        ),
                                        // NUEVO: Mostrar cambio t√≠pico si existe
                                        trigger.typicalChange && React.createElement('div', {
                                            className: "text-[9px] text-blue-400 mt-1 font-mono"
                                        },
                                            `Ejemplo: ${trigger.typicalChange.direction} de ${trigger.typicalChange.from} a ${trigger.typicalChange.to}`
                                        )
                                    );
                                })
                            ),

                            // Conclusi√≥n y eventos precedentes
                            React.createElement('div', {
                                className: "mt-2 pt-2 border-t border-neutral-700/30 space-y-2"
                            },
                                // Trigger principal
                                data.triggers.length > 0 && React.createElement('div', { className: "text-[10px] text-neutral-400" },
                                    'Trigger principal: ',
                                    React.createElement('span', { className: "text-neutral-200 font-medium" },
                                        `${data.triggers[0].metric} ${data.triggers[0].dominantPattern?.toLowerCase() || ''}`
                                    )
                                ),
                                // NUEVO: Eventos precedentes (SOLO >50%)
                                data.precededBy && data.precededBy.filter(p => p.percentage > 50).length > 0 && React.createElement('div', {
                                    className: "bg-yellow-900/20 rounded p-2 mt-2"
                                },
                                    React.createElement('div', { className: "text-[9px] font-bold text-yellow-400 mb-1" },
                                        'Precedido por:'
                                    ),
                                    data.precededBy.filter(p => p.percentage > 50).slice(0, 3).map((prec, idx) =>
                                        React.createElement('div', {
                                            key: idx,
                                            className: "text-[9px] text-yellow-300 mb-1"
                                        },
                                            `‚Ä¢ ${prec.percentage}% de las veces: ${prec.eventLabel}`,
                                            React.createElement('div', { className: "text-yellow-500/70 ml-2 italic text-[8px]" },
                                                prec.hypothesis
                                            )
                                        )
                                    )
                                )
                            )
                        );
                    })
                );
            };

            // Renderizar secci√≥n de matriz de correlaciones
            const renderMatrixSection = () => {
                if (!analysisResult?.correlations) {
                    return React.createElement('div', { className: "text-center text-neutral-500 py-4 text-sm" },
                        'Sin datos de correlaci√≥n...'
                    );
                }

                const correlations = analysisResult.correlations;
                const eventTypes = Object.keys(correlations);
                const metrics = MLPatternEngine.METRICS_CONFIG || [];

                if (eventTypes.length === 0 || metrics.length === 0) {
                    return React.createElement('div', { className: "text-center text-neutral-500 py-4 text-sm" },
                        'No hay correlaciones calculadas a√∫n'
                    );
                }

                return React.createElement('div', { className: "overflow-x-auto" },
                    React.createElement('table', { className: "w-full text-[10px] border-collapse" },
                        React.createElement('thead', null,
                            React.createElement('tr', { className: "bg-neutral-800/50" },
                                React.createElement('th', { className: "text-left py-2 px-2 text-neutral-400 font-medium border-b border-neutral-700/50" }, 'M√©trica'),
                                ...eventTypes.map(et =>
                                    React.createElement('th', {
                                        key: et,
                                        className: "text-center py-2 px-1 text-neutral-400 font-medium border-b border-neutral-700/50",
                                        style: { minWidth: '60px' }
                                    }, et.replace(/_/g, ' ').replace('LOCAL ', '').replace('IMPULSE ', 'IMP ').replace('BREAKOUT ', 'BRK '))
                                )
                            )
                        ),
                        React.createElement('tbody', null,
                            metrics.map((metric, idx) =>
                                React.createElement('tr', {
                                    key: metric.key,
                                    className: idx % 2 === 0 ? 'bg-neutral-900/30' : ''
                                },
                                    React.createElement('td', { className: "py-1.5 px-2 text-neutral-300 font-medium border-b border-neutral-800/30" },
                                        metric.label
                                    ),
                                    ...eventTypes.map(et => {
                                        const data = correlations[et]?.metrics?.[metric.key];
                                        if (!data) {
                                            return React.createElement('td', { key: et, className: "text-center py-1.5 px-1 text-neutral-600 border-b border-neutral-800/30" }, '-');
                                        }
                                        const consistency = Math.round((data.consistency || 0) * 100);
                                        const isBullish = (data.bullishBias || 0) > 0.5;
                                        const color = data.significance === 'HIGH'
                                            ? (isBullish ? '#22c55e' : '#ef4444')
                                            : data.significance === 'MEDIUM'
                                                ? '#eab308'
                                                : '#525252';

                                        return React.createElement('td', {
                                            key: et,
                                            className: "text-center py-1.5 px-1 border-b border-neutral-800/30"
                                        },
                                            React.createElement('span', {
                                                className: "inline-block px-1.5 py-0.5 rounded text-[9px] font-mono font-bold",
                                                style: { backgroundColor: color + '25', color: color }
                                            }, `${consistency}%`)
                                        );
                                    })
                                )
                            )
                        )
                    )
                );
            };

            // Renderizar secci√≥n de eventos - TODOS LOS IMPULSOS
            const renderEventsSection = () => {
                if (!analysisResult?.events) {
                    return React.createElement('div', { className: "text-center text-neutral-500 py-4 text-sm" },
                        'Sin impulsos detectados...'
                    );
                }

                const { impulses = [] } = analysisResult.events;
                const causality = analysisResult?.causality;

                console.log('[Events] Total impulsos detectados:', impulses.length);
                console.log('[Events] Impulsos:', impulses.map(i => ({ type: i.type, mag: i.magnitude?.toFixed(2) })));

                // Mostrar TODOS los impulsos (sin filtro)
                const strongImpulses = impulses
                    .sort((a, b) => (b.index || 0) - (a.index || 0))
                    .slice(0, 30); // Mostrar hasta 30

                console.log('[Events] Impulsos mostrados:', strongImpulses.length);

                if (strongImpulses.length === 0) {
                    return React.createElement('div', { className: "text-center text-neutral-500 py-4 text-sm" },
                        'No se detectaron impulsos en este archivo'
                    );
                }

                // Obtener snapshots ya calculados
                const snapshots = analysisResult?.snapshots || [];
                const rows = analysisResult?.rawData?.rows || [];

                console.log('[Events] Snapshots disponibles:', snapshots.length);
                console.log('[Events] Rows disponibles:', rows.length);

                // Funci√≥n para extraer m√©tricas del momento del impulso
                const getMetricsAtMoment = (event) => {
                    const index = event.index;

                    // Primero buscar en snapshots calculados
                    const snapshot = snapshots.find(s => s.index === index);
                    if (snapshot) {
                        const metrics = [];

                        // Extraer del snapshot
                        if (snapshot.net_delta !== undefined) metrics.push({ label: 'Net Delta', value: snapshot.net_delta.toFixed(2) });
                        if (snapshot.delta_premium !== undefined) metrics.push({ label: 'Delta Premium', value: snapshot.delta_premium.toFixed(2) });
                        if (snapshot.money_flow !== undefined) metrics.push({ label: 'Money Flow', value: snapshot.money_flow.toFixed(2) });
                        if (snapshot.money_flow_evolution !== undefined) metrics.push({ label: 'MF Evolution', value: snapshot.money_flow_evolution.toFixed(2) });
                        if (snapshot.premium_flow !== undefined) metrics.push({ label: 'Premium Flow', value: snapshot.premium_flow.toFixed(2) });
                        if (snapshot.hedge_pressure !== undefined) metrics.push({ label: 'Hedge Pressure', value: snapshot.hedge_pressure.toFixed(2) });
                        if (snapshot.delta_velocity !== undefined) metrics.push({ label: 'Delta Velocity', value: snapshot.delta_velocity.toFixed(2) });
                        if (snapshot.delta_acceleration !== undefined) metrics.push({ label: 'Delta Accel', value: snapshot.delta_acceleration.toFixed(2) });

                        return metrics.slice(0, 5);
                    }

                    // Fallback: buscar en rows
                    if (index >= 0 && index < rows.length) {
                        const row = rows[index];
                        const metrics = [];

                        const metricKeys = [
                            { key: 'net_delta', label: 'Net Delta' },
                            { key: 'delta_premium', label: 'Delta Premium' },
                            { key: 'money_flow', label: 'Money Flow' },
                            { key: 'money_flow_evolution', label: 'MF Evolution' },
                            { key: 'premium_flow', label: 'Premium Flow' },
                            { key: 'hedge_pressure', label: 'Hedge Pressure' },
                            { key: 'delta_velocity', label: 'Delta Velocity' },
                            { key: 'delta_acceleration', label: 'Delta Accel' }
                        ];

                        for (const { key, label } of metricKeys) {
                            const value = row[key];
                            if (value !== undefined && value !== null && !isNaN(value)) {
                                metrics.push({
                                    label,
                                    value: typeof value === 'number' ? value.toFixed(2) : value
                                });
                            }
                        }

                        return metrics.slice(0, 5);
                    }

                    return [];
                };

                return React.createElement('div', { className: "space-y-2 max-h-96 overflow-y-auto" },
                    strongImpulses.map((event, i) => {
                        const isUp = event.type?.includes('UP');
                        const color = isUp ? '#22c55e' : '#ef4444';
                        const metrics = getMetricsAtMoment(event);

                        console.log(`[Events] Impulso #${i} (index ${event.index}): ${metrics.length} m√©tricas encontradas`);

                        return React.createElement('div', {
                            key: i,
                            className: "bg-neutral-800/40 rounded-lg p-3 border-l-4",
                            style: { borderLeftColor: color }
                        },
                            // Header del impulso
                            React.createElement('div', { className: "flex items-center justify-between mb-2" },
                                React.createElement('div', { className: "flex items-center gap-2" },
                                    React.createElement('span', {
                                        className: "text-[10px] font-bold uppercase",
                                        style: { color }
                                    }, isUp ? 'IMPULSO ALCISTA' : 'IMPULSO BAJISTA'),
                                    event.price && React.createElement('span', { className: "text-[9px] text-neutral-500 font-mono" },
                                        `$${parseFloat(event.price).toFixed(2)}`
                                    )
                                ),
                                React.createElement('div', { className: "flex items-center gap-2" },
                                    React.createElement('span', {
                                        className: "text-[11px] font-bold font-mono",
                                        style: { color }
                                    }, `${event.magnitude > 0 ? '+' : ''}${event.magnitude.toFixed(2)}%`),
                                    event.strength && React.createElement('span', { className: "text-[9px] text-neutral-400" },
                                        `[${event.strength.toFixed(1)}]`
                                    )
                                )
                            ),

                            // M√©tricas en ese momento
                            metrics.length > 0 && React.createElement('div', { className: "mt-2 pt-2 border-t border-neutral-700/50" },
                                React.createElement('div', { className: "text-[9px] text-neutral-400 mb-1.5" }, 'M√©tricas en ese momento:'),
                                React.createElement('div', { className: "space-y-1" },
                                    metrics.map((metric, mi) =>
                                        React.createElement('div', {
                                            key: mi,
                                            className: "flex items-center justify-between bg-neutral-900/50 rounded px-2 py-1"
                                        },
                                            React.createElement('span', { className: "text-[10px] text-neutral-200" }, metric.label),
                                            React.createElement('span', {
                                                className: "text-[10px] font-mono font-bold text-neutral-300"
                                            }, metric.value)
                                        )
                                    )
                                )
                            ),

                            // Sin m√©tricas disponibles
                            metrics.length === 0 && React.createElement('div', { className: "text-[9px] text-neutral-500 italic" },
                                'No hay m√©tricas disponibles en este punto'
                            )
                        );
                    })
                );
            };

            // === RENDERIZAR SECCI√ìN DE IMPULSOS Y REVERSIONES (AN√ÅLISIS CONSOLIDADO) ===
            const renderImpulsesAndReversalsSection = () => {
                const expertAnalysis = analysisResult?.expertAnalysis;

                if (!expertAnalysis) {
                    return React.createElement('div', { className: "text-center text-neutral-500 py-4 text-xs" },
                        'Analizando movimientos...'
                    );
                }

                const { patterns } = expertAnalysis;
                const allPatterns = [
                    ...patterns.impulseUpPatterns.map(p => ({ ...p, type: 'IMPULSE_UP', color: '#22c55e', label: 'Impulso Alcista' })),
                    ...patterns.impulseDownPatterns.map(p => ({ ...p, type: 'IMPULSE_DOWN', color: '#ef4444', label: 'Impulso Bajista' })),
                    ...patterns.reversalBullishPatterns.map(p => ({ ...p, type: 'REVERSAL_BULLISH', color: '#8b5cf6', label: 'Reversi√≥n Alcista' })),
                    ...patterns.reversalBearishPatterns.map(p => ({ ...p, type: 'REVERSAL_BEARISH', color: '#dc2626', label: 'Reversi√≥n Bajista' }))
                ].filter(p => p.hasData).sort((a, b) => b.index - a.index); // Solo con datos, m√°s recientes primero

                if (allPatterns.length === 0) {
                    return React.createElement('div', { className: "text-center text-neutral-500 py-4 text-xs" },
                        'No se han detectado impulsos o reversiones con datos suficientes'
                    );
                }

                return React.createElement('div', { className: "space-y-3 max-h-[500px] overflow-y-auto pr-2" },
                    allPatterns.slice(0, 15).map((pattern, i) => {
                        const isImpulse = pattern.type.includes('IMPULSE');

                        return React.createElement('div', {
                            key: i,
                            className: "rounded-lg p-3 border-l-4",
                            style: {
                                backgroundColor: 'rgba(30,30,30,0.5)',
                                borderLeftColor: pattern.color
                            }
                        },
                            // Header simplificado
                            React.createElement('div', { className: "flex items-center justify-between mb-2" },
                                React.createElement('span', {
                                    className: "text-[11px] font-bold",
                                    style: { color: pattern.color }
                                }, pattern.label),
                                React.createElement('span', { className: "text-[9px] text-neutral-500 font-mono" },
                                    `#${pattern.index} | $${pattern.price?.toFixed(2) || '?'}`
                                )
                            ),

                            // Conclusi√≥n principal
                            React.createElement('div', { className: "p-2 bg-neutral-900/50 rounded text-[10px] text-neutral-300 leading-relaxed mb-2" },
                                pattern.expertAnalysis
                            ),

                            // Detalles principales (solo lo m√°s relevante)
                            React.createElement('div', { className: "grid grid-cols-2 gap-2 text-[9px]" },

                                // Triggers principales
                                Object.keys(pattern.immediateTrigger || pattern.reversalTriggers || {}).length > 0 && React.createElement('div', {
                                    className: "bg-neutral-900/30 rounded p-2"
                                },
                                    React.createElement('div', { className: "text-neutral-500 font-bold mb-1" }, 'CAUSA PRINCIPAL'),
                                    React.createElement('div', { className: "space-y-1" },
                                        Object.values(pattern.immediateTrigger || pattern.reversalTriggers || {}).slice(0, 2).map((trigger, idx) =>
                                            React.createElement('div', { key: idx, className: "text-neutral-300" },
                                                React.createElement('div', { className: "font-medium" }, trigger.label),
                                                React.createElement('div', { className: "text-neutral-400 font-mono text-[8px]" },
                                                    `${trigger.from} ‚Üí ${trigger.to}`
                                                )
                                            )
                                        )
                                    )
                                ),

                                // Contexto (acumulaci√≥n o agotamiento) - solo si es relevante
                                (Object.keys(pattern.preAccumulation || {}).length >= 2 || Object.keys(pattern.exhaustionSignals || {}).length > 0) &&
                                React.createElement('div', {
                                    className: "bg-neutral-900/30 rounded p-2"
                                },
                                    React.createElement('div', { className: "text-neutral-500 font-bold mb-1" },
                                        isImpulse ? 'PREPARACI√ìN' : 'AGOTAMIENTO'
                                    ),
                                    React.createElement('div', { className: "text-neutral-400" },
                                        isImpulse
                                            ? `${Object.keys(pattern.preAccumulation || {}).length} indicadores en tendencia`
                                            : `${Object.keys(pattern.exhaustionSignals || {}).length} se√±ales detectadas`
                                    )
                                )
                            )
                        );
                    })
                );
            };

            // === ELIMINADO: renderDailyAnalysisSection ===
            // Ya no se usa

            // Renderizar secci√≥n de eventos - SOLO IMPULSOS FUERTES
            const renderEventsSection_OLD = () => {
                const causality = analysisResult?.causality;
                const expertAnalysis = analysisResult?.expertAnalysis;

                if (!causality) {
                    return React.createElement('div', { className: "text-center text-neutral-500 py-4 text-xs" },
                        'Analizando m√©tricas en tiempo real...'
                    );
                }

                // Analizar solo IMPULSOS y REVERSIONES
                const impulsesUp = causality['IMPULSE_UP'];
                const impulsesDown = causality['IMPULSE_DOWN'];
                const reversalsBullish = causality['REVERSAL_BULLISH'];
                const reversalsBearish = causality['REVERSAL_BEARISH'];

                // CONSOLIDAR RESUMEN ACTUAL
                const currentSummary = {
                    alcista: { metrics: {}, total: 0 },
                    bajista: { metrics: {}, total: 0 },
                    reversiones: { metrics: {}, total: 0 }
                };

                // Procesar impulsos alcistas
                if (impulsesUp?.triggers) {
                    impulsesUp.triggers.filter(t => Math.max(t.increasingIn, t.decreasingIn) > 50).forEach(t => {
                        const key = t.key;
                        if (!currentSummary.alcista.metrics[key]) {
                            currentSummary.alcista.metrics[key] = {
                                label: t.metric,
                                percentage: Math.max(t.increasingIn, t.decreasingIn),
                                direction: t.increasingIn > t.decreasingIn ? 'subiendo' : 'bajando'
                            };
                        }
                    });
                    currentSummary.alcista.total = impulsesUp.totalOccurrences;
                }

                // Procesar impulsos bajistas
                if (impulsesDown?.triggers) {
                    impulsesDown.triggers.filter(t => Math.max(t.increasingIn, t.decreasingIn) > 50).forEach(t => {
                        const key = t.key;
                        if (!currentSummary.bajista.metrics[key]) {
                            currentSummary.bajista.metrics[key] = {
                                label: t.metric,
                                percentage: Math.max(t.increasingIn, t.decreasingIn),
                                direction: t.increasingIn > t.decreasingIn ? 'subiendo' : 'bajando'
                            };
                        }
                    });
                    currentSummary.bajista.total = impulsesDown.totalOccurrences;
                }

                // Procesar reversiones
                [reversalsBullish, reversalsBearish].forEach(rev => {
                    if (!rev?.triggers) return;
                    rev.triggers.filter(t => Math.max(t.increasingIn, t.decreasingIn) > 50).forEach(t => {
                        const key = t.key;
                        if (!currentSummary.reversiones.metrics[key]) {
                            currentSummary.reversiones.metrics[key] = {
                                label: t.metric,
                                percentage: Math.max(t.increasingIn, t.decreasingIn),
                                direction: t.increasingIn > t.decreasingIn ? 'subiendo' : 'bajando'
                            };
                        }
                    });
                    if (rev.totalOccurrences) currentSummary.reversiones.total += rev.totalOccurrences;
                });

                // HISTORIAL: Extraer √∫ltimos 10 movimientos con sus m√©tricas causantes
                const history = [];
                if (expertAnalysis?.patterns) {
                    const allPatterns = [
                        ...expertAnalysis.patterns.impulseUpPatterns.map(p => ({ ...p, type: 'Alcista', color: '#22c55e' })),
                        ...expertAnalysis.patterns.impulseDownPatterns.map(p => ({ ...p, type: 'Bajista', color: '#ef4444' })),
                        ...expertAnalysis.patterns.reversalBullishPatterns.map(p => ({ ...p, type: 'Rev. Alcista', color: '#8b5cf6' })),
                        ...expertAnalysis.patterns.reversalBearishPatterns.map(p => ({ ...p, type: 'Rev. Bajista', color: '#dc2626' }))
                    ].sort((a, b) => b.index - a.index);

                    allPatterns.slice(0, 10).forEach(pattern => {
                        const triggers = pattern.immediateTrigger || pattern.reversalTriggers || {};
                        const mainMetrics = Object.values(triggers).slice(0, 2).map(t => t.label);

                        if (mainMetrics.length > 0) {
                            history.push({
                                index: pattern.index,
                                type: pattern.type,
                                color: pattern.color,
                                price: pattern.price,
                                metrics: mainMetrics
                            });
                        }
                    });
                }

                const hasData = currentSummary.alcista.total > 0 || currentSummary.bajista.total > 0 || currentSummary.reversiones.total > 0;

                if (!hasData) {
                    return React.createElement('div', { className: "text-center text-neutral-500 py-4 text-xs" },
                        'Esperando movimientos en tiempo real...'
                    );
                }

                return React.createElement('div', { className: "space-y-3" },

                    // RESUMEN EN TIEMPO REAL
                    React.createElement('div', { className: "bg-neutral-900/70 rounded-lg p-3 border border-blue-500/30" },
                        React.createElement('div', { className: "flex items-center gap-2 mb-3" },
                            React.createElement('div', { className: "w-2 h-2 bg-blue-500 rounded-full animate-pulse" }),
                            React.createElement('h3', { className: "text-[10px] font-bold text-blue-400 uppercase" },
                                'Resumen en Tiempo Real'
                            )
                        ),
                        React.createElement('div', { className: "grid grid-cols-3 gap-2" },
                            // Alcista
                            React.createElement('div', { className: "bg-green-900/20 rounded p-2 text-center border border-green-500/30" },
                                React.createElement('div', { className: "text-[9px] text-green-400 mb-1" }, 'ALCISTA'),
                                React.createElement('div', { className: "text-lg font-bold text-green-400" }, currentSummary.alcista.total),
                                React.createElement('div', { className: "text-[8px] text-neutral-400 mt-1" },
                                    `${Object.keys(currentSummary.alcista.metrics).length} m√©tricas`
                                )
                            ),
                            // Bajista
                            React.createElement('div', { className: "bg-red-900/20 rounded p-2 text-center border border-red-500/30" },
                                React.createElement('div', { className: "text-[9px] text-red-400 mb-1" }, 'BAJISTA'),
                                React.createElement('div', { className: "text-lg font-bold text-red-400" }, currentSummary.bajista.total),
                                React.createElement('div', { className: "text-[8px] text-neutral-400 mt-1" },
                                    `${Object.keys(currentSummary.bajista.metrics).length} m√©tricas`
                                )
                            ),
                            // Reversiones
                            React.createElement('div', { className: "bg-purple-900/20 rounded p-2 text-center border border-purple-500/30" },
                                React.createElement('div', { className: "text-[9px] text-purple-400 mb-1" }, 'REVERSIONES'),
                                React.createElement('div', { className: "text-lg font-bold text-purple-400" }, currentSummary.reversiones.total),
                                React.createElement('div', { className: "text-[8px] text-neutral-400 mt-1" },
                                    `${Object.keys(currentSummary.reversiones.metrics).length} m√©tricas`
                                )
                            )
                        )
                    ),

                    // M√âTRICAS ACTUALES (Alcista)
                    currentSummary.alcista.total > 0 && React.createElement('div', {
                        className: "bg-green-900/20 rounded-lg p-3 border-l-4 border-green-500"
                    },
                        React.createElement('h3', { className: "text-[10px] font-bold text-green-400 uppercase mb-2" },
                            'M√©tricas Generando Direcci√≥n Alcista'
                        ),
                        React.createElement('div', { className: "space-y-1.5" },
                            Object.values(currentSummary.alcista.metrics)
                                .sort((a, b) => b.percentage - a.percentage)
                                .map((m, i) =>
                                    React.createElement('div', {
                                        key: i,
                                        className: "bg-neutral-900/50 rounded px-2 py-1.5 flex items-center justify-between"
                                    },
                                        React.createElement('div', null,
                                            React.createElement('span', { className: "text-[10px] font-semibold text-neutral-200" }, m.label),
                                            React.createElement('span', { className: "text-[8px] text-neutral-400 ml-2" }, m.direction)
                                        ),
                                        React.createElement('span', { className: "text-[11px] font-bold text-green-400 font-mono" }, `${m.percentage}%`)
                                    )
                                )
                        )
                    ),

                    // M√âTRICAS ACTUALES (Bajista)
                    currentSummary.bajista.total > 0 && React.createElement('div', {
                        className: "bg-red-900/20 rounded-lg p-3 border-l-4 border-red-500"
                    },
                        React.createElement('h3', { className: "text-[10px] font-bold text-red-400 uppercase mb-2" },
                            'M√©tricas Generando Direcci√≥n Bajista'
                        ),
                        React.createElement('div', { className: "space-y-1.5" },
                            Object.values(currentSummary.bajista.metrics)
                                .sort((a, b) => b.percentage - a.percentage)
                                .map((m, i) =>
                                    React.createElement('div', {
                                        key: i,
                                        className: "bg-neutral-900/50 rounded px-2 py-1.5 flex items-center justify-between"
                                    },
                                        React.createElement('div', null,
                                            React.createElement('span', { className: "text-[10px] font-semibold text-neutral-200" }, m.label),
                                            React.createElement('span', { className: "text-[8px] text-neutral-400 ml-2" }, m.direction)
                                        ),
                                        React.createElement('span', { className: "text-[11px] font-bold text-red-400 font-mono" }, `${m.percentage}%`)
                                    )
                                )
                        )
                    ),

                    // M√âTRICAS ACTUALES (Reversiones)
                    currentSummary.reversiones.total > 0 && React.createElement('div', {
                        className: "bg-purple-900/20 rounded-lg p-3 border-l-4 border-purple-500"
                    },
                        React.createElement('h3', { className: "text-[10px] font-bold text-purple-400 uppercase mb-2" },
                            'M√©tricas Generando Reversiones'
                        ),
                        React.createElement('div', { className: "space-y-1.5" },
                            Object.values(currentSummary.reversiones.metrics)
                                .sort((a, b) => b.percentage - a.percentage)
                                .map((m, i) =>
                                    React.createElement('div', {
                                        key: i,
                                        className: "bg-neutral-900/50 rounded px-2 py-1.5 flex items-center justify-between"
                                    },
                                        React.createElement('div', null,
                                            React.createElement('span', { className: "text-[10px] font-semibold text-neutral-200" }, m.label),
                                            React.createElement('span', { className: "text-[8px] text-neutral-400 ml-2" }, m.direction)
                                        ),
                                        React.createElement('span', { className: "text-[11px] font-bold text-purple-400 font-mono" }, `${m.percentage}%`)
                                    )
                                )
                        )
                    ),

                    // HISTORIAL DE MOVIMIENTOS
                    history.length > 0 && React.createElement('div', {
                        className: "bg-neutral-900/50 rounded-lg p-3 border border-neutral-700/50"
                    },
                        React.createElement('h3', { className: "text-[10px] font-bold text-neutral-300 uppercase mb-2" },
                            'Historial - √öltimos 10 Movimientos'
                        ),
                        React.createElement('div', { className: "space-y-1.5 max-h-[300px] overflow-y-auto" },
                            history.map((item, i) =>
                                React.createElement('div', {
                                    key: i,
                                    className: "bg-neutral-800/50 rounded p-2 border-l-2",
                                    style: { borderLeftColor: item.color }
                                },
                                    React.createElement('div', { className: "flex items-center justify-between mb-1" },
                                        React.createElement('div', { className: "flex items-center gap-2" },
                                            React.createElement('span', {
                                                className: "text-[9px] font-bold",
                                                style: { color: item.color }
                                            }, item.type),
                                            React.createElement('span', { className: "text-[8px] text-neutral-500 font-mono" },
                                                `#${item.index}`
                                            )
                                        ),
                                        React.createElement('span', { className: "text-[8px] text-neutral-400 font-mono" },
                                            `$${item.price?.toFixed(2) || '?'}`
                                        )
                                    ),
                                    React.createElement('div', { className: "text-[8px] text-neutral-400" },
                                        'Causado por: ',
                                        React.createElement('span', { className: "text-neutral-300 font-medium" },
                                            item.metrics.join(', ')
                                        )
                                    )
                                )
                            )
                        )
                    )
                );
            };



            // === RENDER PRINCIPAL ===
            return React.createElement('div', { className: "h-full flex flex-col bg-neutral-900/95 overflow-y-auto" },
                // === HEADER ===
                React.createElement('div', { className: "sticky top-0 z-10 bg-neutral-900/98 border-b border-neutral-800 p-3" },
                    React.createElement('div', { className: "flex items-center justify-between flex-wrap gap-2" },
                        // T√≠tulo y selector
                        React.createElement('div', { className: "flex items-center gap-3" },
                            React.createElement('h1', { className: "text-base font-bold text-white" }, 'ANALYSIS CENTER'),
                            React.createElement('div', { className: "h-4 w-px bg-neutral-700" }),
                            React.createElement('select', {
                                className: "bg-neutral-800 border border-neutral-700 rounded px-2 py-1 text-xs text-neutral-200 focus:outline-none focus:border-purple-500",
                                value: selectedSlot,
                                onChange: (e) => setSelectedSlot(e.target.value)
                            },
                                availableSlots.map(slot =>
                                    React.createElement('option', {
                                        key: slot.id,
                                        value: slot.id,
                                        disabled: !slot.hasData
                                    },
                                        `${slot.displayName} ${slot.hasData ? `(${slot.rowCount})` : '(vac√≠o)'}`
                                    )
                                )
                            )
                        ),
                        // Controles
                        React.createElement('div', { className: "flex items-center gap-2" },
                            // Debug info
                            React.createElement('span', { className: "text-[10px] text-neutral-500 font-mono" }, debugInfo),
                            // Status
                            slotData && React.createElement('span', {
                                className: "text-[10px] px-2 py-0.5 rounded bg-green-500/20 text-green-400"
                            }, `${slotData.rows.length} rows`),
                            isAnalyzing && React.createElement('span', {
                                className: "text-[10px] px-2 py-0.5 rounded bg-yellow-500/20 text-yellow-400"
                            }, 'Analyzing...'),

                            // Auto toggle
                            React.createElement('button', {
                                className: `px-2 py-1 rounded text-[10px] font-medium ${autoRefresh ? 'bg-purple-600 text-white' : 'bg-neutral-700 text-neutral-400'}`,
                                onClick: () => setAutoRefresh(!autoRefresh)
                            }, autoRefresh ? 'AUTO ON' : 'AUTO OFF'),
                            // Refresh
                            React.createElement('button', {
                                className: "px-2 py-1 rounded bg-neutral-700 hover:bg-neutral-600 text-neutral-200 text-[10px] font-medium",
                                onClick: runAnalysis,
                                disabled: isAnalyzing || !slotData
                            }, 'REFRESH')
                        )
                    )
                ),

                // === CONTENIDO - TODAS LAS SECCIONES ===
                React.createElement('div', { className: "flex-grow p-3 space-y-4" },

                    // Sin datos
                    !slotData && React.createElement('div', { className: "flex items-center justify-center h-64" },
                        React.createElement('div', { className: "text-center" },
                            React.createElement('div', { className: "text-4xl text-neutral-700 mb-3" }, '[ ]'),
                            React.createElement('h2', { className: "text-sm font-semibold text-neutral-400 mb-1" }, 'Sin datos disponibles'),
                            React.createElement('p', { className: "text-xs text-neutral-500" }, 'Seleccione un slot con datos cargados'),
                            React.createElement('div', { className: "mt-3 text-[10px] text-neutral-600" },
                                `Slots disponibles: ${availableSlots.filter(s => s.hasData).map(s => s.id).join(', ') || 'ninguno'}`
                            )
                        )
                    ),

                    // Con datos - mostrar todas las secciones
                    slotData && React.createElement(React.Fragment, null,

                        // === SECCI√ìN 1: AN√ÅLISIS CAUSAL ===
                        React.createElement('section', { className: "bg-neutral-800/30 rounded-lg p-3 border border-neutral-700/30" },
                            React.createElement('h2', { className: "text-xs font-bold text-neutral-300 uppercase tracking-wider mb-3 flex items-center gap-2" },
                                React.createElement('span', { className: "w-1 h-3 bg-blue-500 rounded" }),
                                'Qu√© Provoca los Movimientos'
                            ),
                            renderCausalitySection()
                        ),

                        // === SECCI√ìN 2: MATRIZ DE CORRELACIONES ===
                        React.createElement('section', { className: "bg-neutral-800/30 rounded-lg p-3 border border-neutral-700/30" },
                            React.createElement('h2', { className: "text-xs font-bold text-neutral-300 uppercase tracking-wider mb-3 flex items-center gap-2" },
                                React.createElement('span', { className: "w-1 h-3 bg-green-500 rounded" }),
                                'Matriz de Correlaciones'
                            ),
                            renderMatrixSection()
                        )
                    )
                ),

                // === MODAL DE CONFIGURACI√ìN API KEY ===
                showApiKeyModal && React.createElement('div', {
                    className: "fixed inset-0 bg-black/70 flex items-center justify-center z-50",
                    onClick: () => setShowApiKeyModal(false)
                },
                    React.createElement('div', {
                        className: "bg-neutral-800 rounded-xl p-6 max-w-md w-full mx-4 shadow-2xl border border-neutral-700",
                        onClick: (e) => e.stopPropagation()
                    },
                        // Header
                        React.createElement('div', { className: "flex justify-between items-center mb-4" },
                            React.createElement('h3', { className: "text-lg font-bold text-white" }, 'Configurar API Key de Groq'),
                            React.createElement('button', {
                                className: "text-neutral-400 hover:text-white text-2xl leading-none",
                                onClick: () => setShowApiKeyModal(false)
                            }, '√ó')
                        ),
                        // Instrucciones
                        React.createElement('div', { className: "mb-4 text-xs text-neutral-300 space-y-1" },
                            React.createElement('p', null, '1. Ve a ',
                                React.createElement('a', {
                                    href: 'https://console.groq.com',
                                    target: '_blank',
                                    className: "text-blue-400 underline"
                                }, 'console.groq.com')
                            ),
                            React.createElement('p', null, '2. Crea una cuenta gratis (sin tarjeta)'),
                            React.createElement('p', null, '3. Ve a "API Keys" y crea una nueva'),
                            React.createElement('p', null, '4. Copia y pega tu key aqu√≠:')
                        ),
                        // Input
                        React.createElement('input', {
                            type: 'password',
                            value: apiKeyInput,
                            onChange: (e) => setApiKeyInput(e.target.value),
                            placeholder: 'gsk_...',
                            className: "w-full px-3 py-2 bg-neutral-900 border border-neutral-600 rounded text-white text-sm font-mono mb-4 focus:outline-none focus:border-blue-500"
                        }),
                        // Status
                        localStorage.getItem('groq_api_key') && React.createElement('div', {
                            className: "mb-4 px-3 py-2 bg-green-500/10 border border-green-500/50 rounded text-green-400 text-xs"
                        }, '[OK] API Key guardada y activa'),
                        // Botones
                        React.createElement('div', { className: "flex gap-2" },
                            React.createElement('button', {
                                onClick: saveApiKey,
                                className: "flex-1 px-4 py-2 bg-green-600 hover:bg-green-500 text-white rounded font-semibold text-sm"
                            }, 'GUARDAR'),
                            localStorage.getItem('groq_api_key') && React.createElement('button', {
                                onClick: clearApiKey,
                                className: "px-4 py-2 bg-red-600 hover:bg-red-500 text-white rounded font-semibold text-sm"
                            }, 'BORRAR')
                        ),
                        // Nota de seguridad
                        React.createElement('p', { className: "mt-4 text-[10px] text-neutral-500" },
                            '[SEGURO] Tu API key se guarda localmente en tu navegador y solo se env√≠a directamente a Groq.'
                        )
                    )
                )
            );
        };

        // --- START: components/ChartGrid.tsx ---
        components.ChartGrid = ({ gridLayout, chartConfigs, dataSources, volumeProfileData, onDeleteChart, onUpdateChartConfig, onDominanceSignalUpdate, onSpikeSignalUpdate, onEvolutionSignalUpdate, onKeltnerSignalUpdate }) => {
            // Grid classes basadas en layout: 1x1, 2x2, 4x4
            const gridClass = chartConfigs.length <= 1 ? 'grid-cols-1'
                : gridLayout === '1x1' ? 'grid-cols-1'
                    : gridLayout === '4x4' ? 'grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4'
                        : 'grid-cols-1 lg:grid-cols-2'; // default 2x2

            return React.createElement('div', { className: `grid gap-2 sm:gap-2.5 transition-all duration-300 ${gridClass}` },
                chartConfigs.map(config => {
                    // ML Pattern Analysis - usar componente especial
                    if (config.category === 'ml-pattern') {
                        const dataSource = dataSources.get(config.slotId);
                        const isMLCorrelation = config.type === 'ml-pattern-correlation';

                        // Para single, necesita dataSource; para correlation, usa allDataSources
                        if (!isMLCorrelation && !dataSource) return null;

                        return React.createElement(components.MLPatternChart, {
                            key: config.id,
                            config: config,
                            dataSource: dataSource,
                            allDataSources: dataSources,
                            onDelete: onDeleteChart,
                            onUpdate: onUpdateChartConfig,
                            gridLayout: gridLayout
                        });
                    }

                    // Power Meter Pro - usar componente especial
                    if (config.category === 'power-meter-pro') {
                        const dataSource = dataSources.get(config.slotId);
                        const isPowerMeterCorrelation = config.type === 'power-meter-pro-correlation';

                        // Para single, necesita dataSource; para correlation, usa allDataSources
                        if (!isPowerMeterCorrelation && !dataSource) return null;

                        return React.createElement(components.PowerMeterProChart, {
                            key: config.id,
                            config: config,
                            dataSource: dataSource,
                            allDataSources: dataSources,
                            onDelete: onDeleteChart,
                            onUpdate: onUpdateChartConfig,
                            gridLayout: gridLayout
                        });
                    }

                    // Correlation charts don't need dataSource from selected slot
                    // They use data from correlation slots (3-6) via allDataSources
                    const isCorrelationChart = config.category === 'otm-correlation' || config.category === 'correlation-keltner' || config.category === 'correlation-evolution' || config.category === 'correlation-dominance' || config.category === 'correlation-zscore' || config.category === 'correlation-tow' || config.category === 'correlation-intensity' || config.category === 'correlation-towind' || config.category === 'correlation-pulse-rsi';
                    const dataSource = dataSources.get(config.slotId);

                    // Skip if no dataSource AND it's not a Correlation chart
                    if (!dataSource && !isCorrelationChart) return null;

                    // For Correlation charts, use a dummy dataSource if needed
                    const effectiveDataSource = dataSource || { rows: [], headers: [], timestampHeader: 'timestamp' };
                    const volumeProfile = volumeProfileData?.get(config.slotId);

                    return React.createElement(components.ChartWrapper, {
                        key: config.id, config: config, dataSource: effectiveDataSource, volumeProfile: volumeProfile,
                        onDelete: onDeleteChart, onUpdate: onUpdateChartConfig,
                        onDominanceSignalUpdate: onDominanceSignalUpdate, onSpikeSignalUpdate: onSpikeSignalUpdate, onEvolutionSignalUpdate: onEvolutionSignalUpdate, onKeltnerSignalUpdate: onKeltnerSignalUpdate,
                        allDataSources: dataSources,
                        gridLayout: gridLayout
                    });
                })
            );
        };
        // --- END: components/ChartGrid.tsx ---

        // --- START: components/TradingSignalsPanel.tsx ---
        // Mini Chart Component for Signal Cards
        components.MiniSignalChart = ({ data, indicatorKey, dataSource, callColor, putColor, signalType }) => {
            const { useRef, useEffect, useMemo } = React;
            const chartRef = useRef(null);
            const chartInstance = useRef(null);

            const chartData = useMemo(() => {
                if (!dataSource?.rows?.length) return null;
                const config = constants.SIGNAL_INDICATORS[indicatorKey];
                if (!config) return null;

                const rows = dataSource.rows.slice(-30); // Last 30 data points
                const timestamps = rows.map(r => r[dataSource.timestampHeader]);
                const callValues = rows.map(r => Math.abs(r[config.call] || 0));
                const putValues = rows.map(r => Math.abs(r[config.put] || 0));
                const ratioValues = rows.map(r => r[config.ratio] || 0);

                return { timestamps, callValues, putValues, ratioValues };
            }, [dataSource, indicatorKey]);

            useEffect(() => {
                if (!chartRef.current || !chartData) return;

                if (!chartInstance.current) {
                    chartInstance.current = echarts.init(chartRef.current, null, { renderer: 'canvas' });
                }

                const option = {
                    animation: false,
                    backgroundColor: 'transparent',
                    grid: { left: 5, right: 5, top: 5, bottom: 5 },
                    xAxis: { type: 'category', show: false, data: chartData.timestamps.map((_, i) => i) },
                    yAxis: { type: 'value', show: false, scale: true },
                    series: signalType === 'ratio' || signalType === 'dominance' ? [
                        {
                            type: 'line',
                            data: chartData.ratioValues,
                            smooth: true,
                            symbol: 'none',
                            lineStyle: { width: 1.5, color: '#ffffff' },
                            areaStyle: {
                                color: {
                                    type: 'linear',
                                    x: 0, y: 0, x2: 0, y2: 1,
                                    colorStops: [
                                        { offset: 0, color: 'rgba(255,255,255,0.3)' },
                                        { offset: 1, color: 'rgba(255,255,255,0)' }
                                    ]
                                }
                            }
                        }
                    ] : [
                        {
                            type: 'bar',
                            data: chartData.callValues,
                            barWidth: '35%',
                            itemStyle: { color: callColor || '#4a9eff', opacity: 0.7 },
                            barGap: '10%'
                        },
                        {
                            type: 'bar',
                            data: chartData.putValues.map(v => -v),
                            barWidth: '35%',
                            itemStyle: { color: putColor || '#ff4444', opacity: 0.7 }
                        }
                    ]
                };

                chartInstance.current.setOption(option, true);

                return () => {
                    if (chartInstance.current) {
                        chartInstance.current.dispose();
                        chartInstance.current = null;
                    }
                };
            }, [chartData, callColor, putColor, signalType]);

            if (!chartData) return null;

            return React.createElement('div', {
                ref: chartRef,
                style: { width: '100%', height: '40px', marginTop: '4px' }
            });
        };

        // ===== MOMENTUM POWER METER COMPONENT =====
        components.MomentumPowerMeter = ({ dataSource, tradingSignal, globalConfig, onValueChange }) => {
            const { useState, useMemo, useEffect } = React;
            const [momentumType, setMomentumType] = useState('gex'); // cash, delta, gex, vanna

            const momentumData = useMemo(() => {
                const defaultData = {
                    momentum: 0, velocity: 0, acceleration: 0, direction: 'NEUTRAL',
                    strength: 0, callValue: 0, putValue: 0, netValue: 0, ratio: 1
                };

                try {
                    if (!dataSource?.rows?.length || dataSource.rows.length < 10) {
                        return defaultData;
                    }

                    const rows = dataSource.rows;
                    const n = rows.length;
                    const lookback = Math.min(20, n - 1);

                    // Columnas seg√∫n tipo de momentum
                    const colMap = {
                        cash: { call: 'Call_OTM_Impact', put: 'Put_OTM_Impact' },
                        delta: { call: 'Call_Delta_Flow', put: 'Put_Delta_Flow' },
                        gex: { call: 'Call_GEX', put: 'Put_GEX' },
                        vanna: { call: 'Call_Vanna_Flow', put: 'Put_Vanna_Flow' }
                    };

                    const cols = colMap[momentumType] || colMap.cash;

                    // Verificar que las columnas existen
                    if (!rows[0] || rows[0][cols.call] === undefined) {
                        return defaultData;
                    }

                    // Calcular valores para los √∫ltimos N per√≠odos
                    const values = [];
                    for (let i = Math.max(0, n - lookback); i < n; i++) {
                        const callVal = Math.abs(parseFloat(rows[i][cols.call]) || 0);
                        const putVal = Math.abs(parseFloat(rows[i][cols.put]) || 0);
                        const net = callVal - putVal;
                        values.push({ call: callVal, put: putVal, net, total: callVal + putVal });
                    }

                    if (values.length < 3) {
                        return defaultData;
                    }

                    // Calcular momentum (cambio porcentual del net flow)
                    const current = values[values.length - 1];
                    const prev = values[values.length - 2];
                    const older = values[values.length - 3];

                    // Momentum = diferencia actual vs promedio hist√≥rico
                    const avgNet = values.slice(0, -1).reduce((s, v) => s + v.net, 0) / (values.length - 1);
                    const momentum = avgNet !== 0 ? ((current.net - avgNet) / Math.abs(avgNet)) * 100 :
                        current.net > 0 ? 100 : current.net < 0 ? -100 : 0;

                    // Velocity = tasa de cambio del net
                    const velocity = prev.total > 0 ? ((current.net - prev.net) / Math.max(1, current.total)) * 100 : 0;

                    // Acceleration = cambio de la velocidad
                    const prevVelocity = older.total > 0 ? ((prev.net - older.net) / Math.max(1, prev.total)) * 100 : 0;
                    const acceleration = velocity - prevVelocity;

                    // Direcci√≥n y fuerza
                    const direction = momentum > 10 ? 'BULLISH' : momentum < -10 ? 'BEARISH' : 'NEUTRAL';
                    const strength = Math.min(100, Math.abs(momentum));

                    // Calcular ratio para display
                    const ratio = current.put > 0 ? current.call / current.put : current.call > 0 ? 999 : 1;

                    return {
                        momentum: Math.max(-100, Math.min(100, isNaN(momentum) ? 0 : momentum)),
                        velocity: Math.max(-100, Math.min(100, isNaN(velocity) ? 0 : velocity * 10)),
                        acceleration: isNaN(acceleration) ? 0 : acceleration,
                        direction,
                        strength: isNaN(strength) ? 0 : strength,
                        callValue: current.call || 0,
                        putValue: current.put || 0,
                        netValue: current.net || 0,
                        ratio: isNaN(ratio) ? 1 : ratio
                    };
                } catch (e) {
                    console.warn('MomentumPowerMeter error:', e);
                    return defaultData;
                }
            }, [dataSource, momentumType]);

            // Reportar valor al padre
            useEffect(() => {
                if (onValueChange) {
                    onValueChange('momentum', momentumData.momentum);
                }
            }, [momentumData.momentum, onValueChange]);

            const formatNum = services.signalCalculator.formatNumber;

            // Colores del medidor (tonos m√°s oscuros)
            const getMeterColor = (value) => {
                if (value > 50) return '#2d7acc';
                if (value > 20) return '#3d8ad9';
                if (value > 0) return '#4d9ae6';
                if (value > -20) return '#cc5555';
                if (value > -50) return '#b94444';
                return '#a63333';
            };

            const meterColor = getMeterColor(momentumData.momentum);
            const meterPosition = 50 + (momentumData.momentum / 2);

            return React.createElement('div', {
                className: "p-2 rounded-lg bg-neutral-900/70 border border-neutral-700/50"
            },
                // Header con selector de tipo
                React.createElement('div', { className: "flex items-center justify-between mb-1" },
                    React.createElement('span', { className: "text-[9px] font-bold text-neutral-400 uppercase tracking-wider" },
                        "MOMENTUM"
                    ),
                    React.createElement('div', { className: "flex gap-0.5" },
                        ['cash', 'delta', 'gex', 'vanna'].map(type =>
                            React.createElement('button', {
                                key: type,
                                onClick: () => setMomentumType(type),
                                className: `px-1.5 py-0.5 text-[7px] rounded uppercase font-bold transition-all ${momentumType === type
                                    ? 'bg-blue-600/50 text-blue-200'
                                    : 'bg-neutral-700/30 text-neutral-500 hover:bg-neutral-700/50'
                                    }`
                            }, type)
                        )
                    ),
                    // Datos inline
                    React.createElement('div', { className: "flex items-center gap-2" },
                        React.createElement('span', {
                            className: "text-xs font-mono font-bold",
                            style: { color: meterColor }
                        }, momentumData.momentum.toFixed(0) + '%'),
                        React.createElement('span', {
                            className: `text-[9px] font-bold px-1 rounded ${momentumData.direction === 'BULLISH' ? 'bg-blue-600/30 text-blue-300' :
                                momentumData.direction === 'BEARISH' ? 'bg-red-600/30 text-red-300' :
                                    'bg-neutral-600/30 text-neutral-400'
                                }`
                        }, momentumData.direction.slice(0, 4)),
                        React.createElement('span', { className: "text-[8px] text-blue-400 font-mono" }, 'C:' + formatNum(momentumData.callValue)),
                        React.createElement('span', { className: "text-[8px] text-red-400 font-mono" }, 'P:' + formatNum(momentumData.putValue))
                    )
                ),

                // Power Meter Bar
                React.createElement('div', { className: "relative h-5 rounded-full overflow-hidden" },
                    React.createElement('div', {
                        className: "absolute inset-0",
                        style: {
                            background: 'linear-gradient(90deg, #3d1515 0%, #4a1a1a 25%, #1a1a1a 45%, #1a1a1a 55%, #1a3d4d 75%, #15303d 100%)'
                        }
                    }),
                    React.createElement('div', { className: "absolute inset-0 flex items-center justify-between px-2" },
                        React.createElement('span', { className: "text-[7px] font-bold text-white/50" }, "PUT"),
                        React.createElement('span', { className: "text-[7px] font-bold text-white/50" }, "CALL")
                    ),
                    React.createElement('div', {
                        className: "absolute top-0 h-full w-1.5 transition-all duration-300",
                        style: {
                            left: `${meterPosition}%`,
                            transform: 'translateX(-50%)',
                            background: '#fff',
                            boxShadow: `0 0 8px #fff, 0 0 15px ${meterColor}, 0 0 25px ${meterColor}, 0 0 35px ${meterColor}80`
                        }
                    }),
                    React.createElement('div', {
                        className: "absolute top-1 bottom-1 rounded-full transition-all duration-300",
                        style: {
                            left: momentumData.momentum >= 0 ? '50%' : `${meterPosition}%`,
                            width: `${Math.abs(momentumData.momentum) / 2}%`,
                            background: momentumData.momentum >= 0
                                ? 'linear-gradient(90deg, rgba(74,158,255,0.6), rgba(100,180,255,1))'
                                : 'linear-gradient(90deg, rgba(255,100,100,1), rgba(255,68,68,0.6))',
                            boxShadow: momentumData.momentum >= 0
                                ? '0 0 15px rgba(74,158,255,0.9), 0 0 30px rgba(74,158,255,0.7), 0 0 45px rgba(74,158,255,0.5), 0 0 60px rgba(74,158,255,0.3)'
                                : '0 0 15px rgba(255,68,68,0.9), 0 0 30px rgba(255,68,68,0.7), 0 0 45px rgba(255,68,68,0.5), 0 0 60px rgba(255,68,68,0.3)'
                        }
                    })
                )
            );
        };

        // ===== LONG TERM POWER METER COMPONENT =====
        components.LongTermPowerMeter = ({ dataSource, globalConfig, onValueChange }) => {
            const { useState, useMemo, useEffect } = React;
            const [metricType, setMetricType] = useState('gex');

            const longTermData = useMemo(() => {
                const defaultData = {
                    momentum: 0, trend: 'NEUTRAL', strength: 0,
                    callValue: 0, putValue: 0, smaDirection: 0
                };

                try {
                    if (!dataSource?.rows?.length || dataSource.rows.length < 50) {
                        return defaultData;
                    }

                    const rows = dataSource.rows;
                    const n = rows.length;
                    const longLookback = Math.min(50, n - 1); // Largo plazo: 50 per√≠odos (m√°s sensible)

                    const colMap = {
                        cash: { call: 'Call_OTM_Impact', put: 'Put_OTM_Impact' },
                        delta: { call: 'Call_Delta_Flow', put: 'Put_Delta_Flow' },
                        gex: { call: 'Call_GEX', put: 'Put_GEX' },
                        vanna: { call: 'Call_Vanna_Flow', put: 'Put_Vanna_Flow' }
                    };

                    const cols = colMap[metricType] || colMap.gex;

                    if (!rows[0] || rows[0][cols.call] === undefined) {
                        return defaultData;
                    }

                    // Calcular SMA de largo plazo
                    const values = [];
                    for (let i = Math.max(0, n - longLookback); i < n; i++) {
                        const callVal = Math.abs(parseFloat(rows[i][cols.call]) || 0);
                        const putVal = Math.abs(parseFloat(rows[i][cols.put]) || 0);
                        values.push({ call: callVal, put: putVal, net: callVal - putVal });
                    }

                    if (values.length < 10) return defaultData;

                    // SMA de net flow (per√≠odos m√°s cortos para m√°s sensibilidad)
                    const sma30 = values.slice(-30).reduce((s, v) => s + v.net, 0) / Math.min(30, values.length);
                    const sma10 = values.slice(-10).reduce((s, v) => s + v.net, 0) / Math.min(10, values.length);
                    const current = values[values.length - 1];

                    // Momentum largo plazo = posici√≥n actual vs SMA30 (multiplicador m√°s alto)
                    const avgTotal = values.reduce((s, v) => s + v.call + v.put, 0) / values.length;
                    const momentum = avgTotal > 0 ? ((current.net - sma30) / avgTotal) * 200 : 0; // x2 sensibilidad

                    // Tendencia basada en SMA crossover (umbrales m√°s bajos)
                    const smaDirection = sma10 - sma30;
                    const trend = smaDirection > avgTotal * 0.02 ? 'BULLISH' :
                        smaDirection < -avgTotal * 0.02 ? 'BEARISH' : 'NEUTRAL';
                    const strength = Math.min(100, Math.abs(momentum) * 1.5); // x1.5 sensibilidad

                    return {
                        momentum: Math.max(-100, Math.min(100, isNaN(momentum) ? 0 : momentum)),
                        trend,
                        strength: isNaN(strength) ? 0 : strength,
                        callValue: current.call || 0,
                        putValue: current.put || 0,
                        smaDirection: smaDirection > 0 ? 1 : smaDirection < 0 ? -1 : 0
                    };
                } catch (e) {
                    console.warn('LongTermPowerMeter error:', e);
                    return defaultData;
                }
            }, [dataSource, metricType]);

            // Reportar valor al padre
            useEffect(() => {
                if (onValueChange) {
                    onValueChange('longTerm', longTermData.momentum);
                }
            }, [longTermData.momentum, onValueChange]);

            const formatNum = services.signalCalculator.formatNumber;

            const getMeterColor = (value) => {
                if (value > 50) return '#22cc88';
                if (value > 20) return '#44bb77';
                if (value > 0) return '#66aa66';
                if (value > -20) return '#aa6666';
                if (value > -50) return '#bb4444';
                return '#cc2222';
            };

            const meterColor = getMeterColor(longTermData.momentum);
            const meterPosition = 50 + (longTermData.momentum / 2);

            return React.createElement('div', {
                className: "p-2 rounded-lg bg-neutral-900/70 border border-green-700/30"
            },
                // Header con selector de tipo
                React.createElement('div', { className: "flex items-center justify-between mb-1" },
                    React.createElement('span', { className: "text-[9px] font-bold text-green-400 uppercase tracking-wider" },
                        "LONG TERM"
                    ),
                    React.createElement('div', { className: "flex gap-0.5" },
                        ['cash', 'delta', 'gex', 'vanna'].map(type =>
                            React.createElement('button', {
                                key: type,
                                onClick: () => setMetricType(type),
                                className: `px-1.5 py-0.5 text-[7px] rounded uppercase font-bold transition-all ${metricType === type
                                    ? 'bg-green-600/50 text-green-200'
                                    : 'bg-neutral-700/30 text-neutral-500 hover:bg-neutral-700/50'
                                    }`
                            }, type)
                        )
                    ),
                    // Datos inline
                    React.createElement('div', { className: "flex items-center gap-2" },
                        React.createElement('span', {
                            className: "text-xs font-mono font-bold",
                            style: { color: meterColor }
                        }, longTermData.momentum.toFixed(0) + '%'),
                        React.createElement('span', {
                            className: `text-[9px] font-bold px-1 rounded ${longTermData.trend === 'BULLISH' ? 'bg-green-600/30 text-green-300' :
                                longTermData.trend === 'BEARISH' ? 'bg-red-600/30 text-red-300' :
                                    'bg-neutral-600/30 text-neutral-400'
                                }`
                        }, longTermData.trend.slice(0, 4)),
                        React.createElement('span', { className: "text-[8px] text-green-400 font-mono" }, 'C:' + formatNum(longTermData.callValue)),
                        React.createElement('span', { className: "text-[8px] text-red-400 font-mono" }, 'P:' + formatNum(longTermData.putValue))
                    )
                ),

                // Power Meter Bar (verde oscuro)
                React.createElement('div', { className: "relative h-5 rounded-full overflow-hidden" },
                    React.createElement('div', {
                        className: "absolute inset-0",
                        style: {
                            background: 'linear-gradient(90deg, #3d1515 0%, #4a1a1a 25%, #1a1a1a 45%, #1a1a1a 55%, #1a3d2d 75%, #15302d 100%)'
                        }
                    }),
                    React.createElement('div', { className: "absolute inset-0 flex items-center justify-between px-2" },
                        React.createElement('span', { className: "text-[7px] font-bold text-white/50" }, "SELL"),
                        React.createElement('span', { className: "text-[7px] font-bold text-white/50" }, "BUY")
                    ),
                    React.createElement('div', {
                        className: "absolute top-0 h-full w-1.5 transition-all duration-300",
                        style: {
                            left: `${meterPosition}%`,
                            transform: 'translateX(-50%)',
                            background: '#fff',
                            boxShadow: `0 0 8px #fff, 0 0 15px ${meterColor}, 0 0 25px ${meterColor}, 0 0 35px ${meterColor}80`
                        }
                    }),
                    React.createElement('div', {
                        className: "absolute top-1 bottom-1 rounded-full transition-all duration-300",
                        style: {
                            left: longTermData.momentum >= 0 ? '50%' : `${meterPosition}%`,
                            width: `${Math.abs(longTermData.momentum) / 2}%`,
                            background: longTermData.momentum >= 0
                                ? 'linear-gradient(90deg, rgba(34,204,136,0.6), rgba(100,230,170,1))'
                                : 'linear-gradient(90deg, rgba(255,100,100,1), rgba(204,34,34,0.6))',
                            boxShadow: longTermData.momentum >= 0
                                ? '0 0 15px rgba(34,204,136,0.9), 0 0 30px rgba(34,204,136,0.7), 0 0 45px rgba(34,204,136,0.5), 0 0 60px rgba(34,204,136,0.3)'
                                : '0 0 15px rgba(204,34,34,0.9), 0 0 30px rgba(204,34,34,0.7), 0 0 45px rgba(204,34,34,0.5), 0 0 60px rgba(204,34,34,0.3)'
                        }
                    })
                )
            );
        };

        // ===== CORRELATION POWER METER COMPONENT =====
        components.CorrelationPowerMeter = ({ allSlotData, globalConfig, onValueChange }) => {
            const { useState, useMemo, useEffect } = React;
            const [metricType, setMetricType] = useState('gex');

            const correlationData = useMemo(() => {
                const defaultData = {
                    correlation: 0, avgCorr: 0, direction: 'NEUTRAL',
                    strength: 0, slots: [], consensus: 0
                };

                const colMap = {
                    cash: { call: 'Call_OTM_Impact', put: 'Put_OTM_Impact' },
                    delta: { call: 'Call_Delta_Flow', put: 'Put_Delta_Flow' },
                    gex: { call: 'Call_GEX', put: 'Put_GEX' },
                    vanna: { call: 'Call_Vanna_Flow', put: 'Put_Vanna_Flow' }
                };

                const cols = colMap[metricType] || colMap.delta;

                try {
                    // Obtener datos de slots 3-6 (correlaciones)
                    const corrSlots = [3, 4, 5, 6].map(slotId => {
                        const slotKey = `slot${slotId}`;
                        const data = allSlotData?.[slotKey];
                        if (!data?.rows?.length || data.rows.length < 5) return null;

                        const rows = data.rows;
                        const n = rows.length;
                        const lookback = Math.min(20, n - 1);

                        // Calcular valores para los √∫ltimos N per√≠odos (igual que Momentum)
                        const values = [];
                        for (let i = Math.max(0, n - lookback); i < n; i++) {
                            const callVal = Math.abs(parseFloat(rows[i]?.[cols.call]) || 0);
                            const putVal = Math.abs(parseFloat(rows[i]?.[cols.put]) || 0);
                            values.push({ call: callVal, put: putVal, net: callVal - putVal, total: callVal + putVal });
                        }

                        if (values.length < 3) return null;

                        const current = values[values.length - 1];
                        const prev = values[values.length - 2];

                        // Calcular momentum igual que MomentumPowerMeter
                        const avgNet = values.slice(0, -1).reduce((s, v) => s + v.net, 0) / (values.length - 1);
                        let ratio = avgNet !== 0 ? ((current.net - avgNet) / Math.abs(avgNet)) * 100 :
                            current.net > 0 ? 100 : current.net < 0 ? -100 : 0;

                        // Calcular momentum (cambio reciente)
                        const momentum = prev.total > 0 ? ((current.net - prev.net) / Math.max(1, current.total)) * 100 : 0;

                        return {
                            slotId,
                            ratio: Math.max(-100, Math.min(100, isNaN(ratio) ? 0 : ratio)),
                            momentum: Math.max(-100, Math.min(100, isNaN(momentum) ? 0 : momentum * 10)),
                            direction: ratio > 10 ? 'BULL' : ratio < -10 ? 'BEAR' : 'NEUT',
                            callFlow: current.call,
                            putFlow: current.put
                        };
                    }).filter(Boolean);

                    if (corrSlots.length === 0) return defaultData;

                    // Calcular correlaci√≥n promedio
                    const avgRatio = corrSlots.reduce((s, slot) => s + slot.ratio, 0) / corrSlots.length;
                    const avgMomentum = corrSlots.reduce((s, slot) => s + slot.momentum, 0) / corrSlots.length;

                    // Calcular consenso (cu√°ntos slots apuntan en la misma direcci√≥n)
                    const bullCount = corrSlots.filter(s => s.direction === 'BULL').length;
                    const bearCount = corrSlots.filter(s => s.direction === 'BEAR').length;
                    const consensus = Math.max(bullCount, bearCount) / corrSlots.length * 100;

                    const direction = avgRatio > 15 ? 'BULLISH' : avgRatio < -15 ? 'BEARISH' : 'NEUTRAL';
                    const strength = Math.min(100, Math.abs(avgRatio));

                    return {
                        correlation: avgRatio,
                        avgCorr: avgMomentum,
                        direction,
                        strength,
                        slots: corrSlots,
                        consensus,
                        bullCount,
                        bearCount
                    };
                } catch (e) {
                    console.warn('CorrelationPowerMeter error:', e);
                    return defaultData;
                }
            }, [allSlotData, metricType]);

            // Reportar valor al padre
            useEffect(() => {
                if (onValueChange) {
                    onValueChange('correlation', correlationData.correlation);
                }
            }, [correlationData.correlation, onValueChange]);

            const formatNum = services.signalCalculator.formatNumber;

            // Colores del medidor de correlaci√≥n (tonos m√°s oscuros)
            const getMeterColor = (value) => {
                if (value > 50) return '#00aa88';
                if (value > 20) return '#22997a';
                if (value > 0) return '#44886c';
                if (value > -20) return '#aa5588';
                if (value > -50) return '#994477';
                return '#883366';
            };

            const meterColor = getMeterColor(correlationData.correlation);
            const meterPosition = 50 + (correlationData.correlation / 2);

            return React.createElement('div', {
                className: "p-2 rounded-lg bg-neutral-900/70 border border-purple-700/30"
            },
                // Header con selector de m√©trica
                React.createElement('div', { className: "flex items-center justify-between mb-1" },
                    React.createElement('span', { className: "text-[9px] font-bold text-purple-400 uppercase tracking-wider" },
                        "CORRELATION"
                    ),
                    // Selector de m√©tricas
                    React.createElement('div', { className: "flex gap-0.5" },
                        ['cash', 'delta', 'gex', 'vanna'].map(type =>
                            React.createElement('button', {
                                key: type,
                                onClick: () => setMetricType(type),
                                className: `px-1.5 py-0.5 text-[7px] rounded uppercase font-bold transition-all ${metricType === type
                                    ? 'bg-purple-600/50 text-purple-200'
                                    : 'bg-neutral-700/30 text-neutral-500 hover:bg-neutral-700/50'
                                    }`
                            }, type)
                        )
                    ),
                    // Slots mini inline
                    React.createElement('div', { className: "flex gap-0.5" },
                        correlationData.slots?.map((slot, i) =>
                            React.createElement('span', {
                                key: i,
                                className: `px-1 py-0.5 text-[7px] rounded font-bold ${slot.direction === 'BULL' ? 'bg-cyan-600/30 text-cyan-300' :
                                    slot.direction === 'BEAR' ? 'bg-pink-600/30 text-pink-300' :
                                        'bg-neutral-600/30 text-neutral-400'
                                    }`
                            }, `S${slot.slotId}`)
                        ) || [3, 4, 5, 6].map(i =>
                            React.createElement('span', {
                                key: i,
                                className: "px-1 py-0.5 text-[7px] rounded bg-neutral-700/30 text-neutral-500"
                            }, `S${i}`)
                        )
                    ),
                    // Datos inline
                    React.createElement('div', { className: "flex items-center gap-2" },
                        React.createElement('span', {
                            className: "text-xs font-mono font-bold",
                            style: { color: meterColor }
                        }, correlationData.correlation?.toFixed(0) + '%'),
                        React.createElement('span', {
                            className: `text-[9px] font-bold px-1 rounded ${correlationData.direction === 'BULLISH' ? 'bg-cyan-600/30 text-cyan-300' :
                                correlationData.direction === 'BEARISH' ? 'bg-pink-600/30 text-pink-300' :
                                    'bg-neutral-600/30 text-neutral-400'
                                }`
                        }, correlationData.direction?.slice(0, 4) || 'NEUT'),
                        React.createElement('span', { className: "text-[8px] text-cyan-400 font-mono" },
                            (correlationData.bullCount || 0) + 'B'),
                        React.createElement('span', { className: "text-[8px] text-pink-400 font-mono" },
                            (correlationData.bearCount || 0) + 'S')
                    )
                ),

                // Power Meter Bar
                React.createElement('div', { className: "relative h-5 rounded-full overflow-hidden" },
                    React.createElement('div', {
                        className: "absolute inset-0",
                        style: {
                            background: 'linear-gradient(90deg, #2d1525 0%, #3a1a30 25%, #1a1a1a 45%, #1a1a1a 55%, #1a3a35 75%, #153530 100%)'
                        }
                    }),
                    React.createElement('div', { className: "absolute inset-0 flex items-center justify-between px-2" },
                        React.createElement('span', { className: "text-[7px] font-bold text-white/50" }, "SELL"),
                        React.createElement('span', { className: "text-[7px] font-bold text-white/50" }, "BUY")
                    ),
                    React.createElement('div', {
                        className: "absolute top-0 h-full w-1.5 transition-all duration-300",
                        style: {
                            left: `${meterPosition}%`,
                            transform: 'translateX(-50%)',
                            background: '#fff',
                            boxShadow: `0 0 8px #fff, 0 0 15px ${meterColor}, 0 0 25px ${meterColor}, 0 0 35px ${meterColor}80`
                        }
                    }),
                    React.createElement('div', {
                        className: "absolute top-1 bottom-1 rounded-full transition-all duration-300",
                        style: {
                            left: correlationData.correlation >= 0 ? '50%' : `${meterPosition}%`,
                            width: `${Math.abs(correlationData.correlation) / 2}%`,
                            background: correlationData.correlation >= 0
                                ? 'linear-gradient(90deg, rgba(0,255,204,0.6), rgba(100,255,230,1))'
                                : 'linear-gradient(90deg, rgba(255,100,170,1), rgba(255,68,136,0.6))',
                            boxShadow: correlationData.correlation >= 0
                                ? '0 0 15px rgba(0,255,204,0.9), 0 0 30px rgba(0,255,204,0.7), 0 0 45px rgba(0,255,204,0.5), 0 0 60px rgba(0,255,204,0.3)'
                                : '0 0 15px rgba(255,68,136,0.9), 0 0 30px rgba(255,68,136,0.7), 0 0 45px rgba(255,68,136,0.5), 0 0 60px rgba(255,68,136,0.3)'
                        }
                    })
                )
            );
        };

        // Main Signal Chart Component for the big signal box
        components.MainSignalChart = ({ dataSource, selectedIndicators, signalType, signalColors, callColor = '#4a9eff', putColor = '#ff4444' }) => {
            const { useRef, useEffect, useMemo } = React;
            const chartRef = useRef(null);
            const chartInstance = useRef(null);

            const chartData = useMemo(() => {
                if (!dataSource?.rows?.length || selectedIndicators.length === 0) return null;

                const rows = dataSource.rows.slice(-50); // Last 50 data points
                const timestamps = rows.map((_, i) => i);

                // Aggregate data from all selected indicators
                const aggregatedRatios = rows.map((row, i) => {
                    let sum = 0;
                    let count = 0;
                    selectedIndicators.forEach(indKey => {
                        const config = constants.SIGNAL_INDICATORS[indKey];
                        if (config && row[config.ratio] !== undefined) {
                            sum += row[config.ratio] || 0;
                            count++;
                        }
                    });
                    return count > 0 ? sum / count : 1;
                });

                // Calculate bullish/bearish momentum
                const bullishMomentum = rows.map((row, i) => {
                    let sum = 0;
                    selectedIndicators.forEach(indKey => {
                        const config = constants.SIGNAL_INDICATORS[indKey];
                        if (config) {
                            sum += Math.abs(row[config.call] || 0);
                        }
                    });
                    return sum / selectedIndicators.length;
                });

                const bearishMomentum = rows.map((row, i) => {
                    let sum = 0;
                    selectedIndicators.forEach(indKey => {
                        const config = constants.SIGNAL_INDICATORS[indKey];
                        if (config) {
                            sum += Math.abs(row[config.put] || 0);
                        }
                    });
                    return sum / selectedIndicators.length;
                });

                return { timestamps, aggregatedRatios, bullishMomentum, bearishMomentum };
            }, [dataSource, selectedIndicators]);

            useEffect(() => {
                if (!chartRef.current || !chartData) return;

                if (!chartInstance.current) {
                    chartInstance.current = echarts.init(chartRef.current, null, { renderer: 'canvas' });
                }

                const option = {
                    animation: false,
                    backgroundColor: 'transparent',
                    grid: { left: 0, right: 0, top: 0, bottom: 0 },
                    xAxis: { type: 'category', show: false, data: chartData.timestamps },
                    yAxis: { type: 'value', show: false, scale: true },
                    series: [
                        {
                            type: 'line',
                            data: chartData.aggregatedRatios,
                            smooth: true,
                            symbol: 'none',
                            lineStyle: { width: 2, color: signalColors.border },
                            areaStyle: {
                                color: {
                                    type: 'linear',
                                    x: 0, y: 0, x2: 0, y2: 1,
                                    colorStops: [
                                        { offset: 0, color: signalColors.glow },
                                        { offset: 1, color: 'transparent' }
                                    ]
                                }
                            }
                        },
                        {
                            type: 'bar',
                            data: chartData.bullishMomentum,
                            barWidth: '40%',
                            itemStyle: { color: callColor + '33' }, // 20% opacity
                            barGap: '-100%'
                        },
                        {
                            type: 'bar',
                            data: chartData.bearishMomentum.map(v => -v),
                            barWidth: '40%',
                            itemStyle: { color: putColor + '33' } // 20% opacity
                        }
                    ]
                };

                chartInstance.current.setOption(option, true);

                return () => {
                    if (chartInstance.current) {
                        chartInstance.current.dispose();
                        chartInstance.current = null;
                    }
                };
            }, [chartData, signalColors, callColor, putColor]);

            if (!chartData) return null;

            return React.createElement('div', {
                ref: chartRef,
                className: "absolute inset-0 opacity-40",
                style: { width: '100%', height: '100%' }
            });
        };

        components.TradingSignalsPanel = ({ dataSources, onClose, globalConfig, volumeProfileData, globalMarketSentiment }) => {
            const { useState, useMemo, useEffect, useCallback, useRef } = React;

            // Estados principales
            const [selectedSlot, setSelectedSlot] = useState('1');
            const [isExpanded, setIsExpanded] = useState(true);
            const [isConfigOpen, setIsConfigOpen] = useState(false);
            const [isSendingTelegram, setIsSendingTelegram] = useState(false);
            const [telegramStatus, setTelegramStatus] = useState(null);
            const [autoSendEnabled, setAutoSendEnabled] = useState(false);
            const [autoSendInterval, setAutoSendInterval] = useState(60); // seconds
            const panelRef = useRef(null);

            // Sistema de sonido
            const [soundEnabled, setSoundEnabled] = useState(true);
            const prevSignalRef = useRef('FLAT');
            const audioContextRef = useRef(null);

            // Tipo de se√±al (movido antes de MT5 porque se usa en sendSignalToMT5)
            const [signalType, setSignalType] = useState('dominance');

            // Combinar globalConfig directamente - PRESET ES LA LEY
            const signalParams = useMemo(() => {
                const gc = globalConfig || {};
                const preset = GLOBAL_PRESETS[gc.presetKey] || GLOBAL_PRESETS.balanced;

                // Usar valores del globalConfig (que viene del preset)
                const smaPeriod = gc.smaPeriod || preset.sma;
                const ratio = gc.bullishThreshold || preset.ratio;
                const lookback = gc.lookback || preset.lookback;
                const velocityPeriod = gc.velocityPeriod || preset.velocityPeriod;
                const towSignalSma = gc.towSignalSmaPeriod || preset.towSignalSmaPeriod;
                const towLookback = gc.towLookback || preset.towLookback;

                return {
                    evolution: { smaPeriod: smaPeriod },
                    intensity: { smaPeriod: smaPeriod },
                    towindicator: { smaPeriod: towSignalSma, lookback: towLookback },
                    dominance: {
                        ratio: ratio,
                        lookback: lookback,
                        smaPeriod: towSignalSma,
                        velocityPeriod: velocityPeriod,
                        dominanceFilterRatio: gc.dominanceFilterRatio || preset.dominanceFilterRatio
                    },
                    towforce: {
                        smaPeriod: towSignalSma,
                        lookback: towLookback,
                        velocityPeriod: velocityPeriod
                    },
                    keltner: {
                        emaPeriod: gc.keltnerEmaPeriod || preset.keltnerEmaPeriod,
                        atrMultiplier: gc.keltnerAtrMult || preset.keltnerAtrMult,
                        slopeThreshold: gc.keltnerSlopeThreshold || preset.keltnerSlopeThreshold
                    },
                    rsi: {
                        period: gc.rsiPeriod || 14,
                        overbought: gc.rsiOverbought || 60,
                        oversold: gc.rsiOversold || 40
                    },
                    correlation: {
                        threshold: gc.corrThreshold || 2,
                        smaPeriod: gc.corrSmaPeriod || 5
                    },
                    // Par√°metros adicionales para spikes
                    spikes: {
                        spikeThreshold: gc.spikeThreshold || preset.spikeThreshold,
                        intensityThreshold: gc.intensityThreshold || preset.intensityThreshold
                    }
                };
            }, [globalConfig]);

            // Funci√≥n para actualizar par√°metros (legacy - ahora el preset controla todo)
            const setSignalParams = useCallback((updater) => {
                // Los presets ahora controlan todo, pero mantenemos esta funci√≥n por compatibilidad
                console.log('Signal params update requested - Preset controls all parameters now');
            }, []);

            // ===== MT5 BRIDGE CONNECTION =====
            const [mt5Connected, setMt5Connected] = useState(false);
            const [mt5Enabled, setMt5Enabled] = useState(false);
            const [mt5Status, setMt5Status] = useState(null);
            const [mt5Symbol, setMt5Symbol] = useState('XAUUSD');
            const [mt5Volume, setMt5Volume] = useState(0.01);
            const [mt5AutoTrade, setMt5AutoTrade] = useState(false);
            const [mt5Positions, setMt5Positions] = useState([]);
            const wsRef = useRef(null);
            const reconnectTimeoutRef = useRef(null);

            // Conectar a MT5 Bridge
            const connectMT5 = useCallback(() => {
                if (wsRef.current?.readyState === WebSocket.OPEN) return;

                try {
                    wsRef.current = new WebSocket('ws://localhost:8765');

                    wsRef.current.onopen = () => {
                        console.log('MT5 Bridge conectado');
                        setMt5Connected(true);
                        wsRef.current.send(JSON.stringify({ action: 'status' }));
                    };

                    wsRef.current.onclose = () => {
                        console.log('MT5 Bridge desconectado');
                        setMt5Connected(false);
                        setMt5Status(null);
                        if (mt5Enabled) {
                            reconnectTimeoutRef.current = setTimeout(connectMT5, 5000);
                        }
                    };

                    wsRef.current.onerror = (error) => {
                        console.error('MT5 Bridge error:', error);
                    };

                    wsRef.current.onmessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            if (data.type === 'status') {
                                setMt5Status(data);
                            } else if (data.type === 'trade_result') {
                                wsRef.current.send(JSON.stringify({ action: 'positions' }));
                            } else if (data.type === 'positions') {
                                setMt5Positions(data.data || []);
                            }
                        } catch (e) {
                            console.error('Error parsing MT5 message:', e);
                        }
                    };
                } catch (e) {
                    console.error('Error connecting to MT5 Bridge:', e);
                }
            }, [mt5Enabled]);

            // Desconectar de MT5 Bridge
            const disconnectMT5 = useCallback(() => {
                if (reconnectTimeoutRef.current) clearTimeout(reconnectTimeoutRef.current);
                if (wsRef.current) { wsRef.current.close(); wsRef.current = null; }
                setMt5Connected(false);
                setMt5Status(null);
            }, []);

            // Toggle MT5 connection
            useEffect(() => {
                if (mt5Enabled) { connectMT5(); } else { disconnectMT5(); }
                return () => disconnectMT5();
            }, [mt5Enabled, connectMT5, disconnectMT5]);

            // Enviar se√±al a MT5
            const sendSignalToMT5 = useCallback((direction) => {
                if (!wsRef.current || wsRef.current.readyState !== WebSocket.OPEN) return;
                const signal = { action: 'signal', signal: { direction: direction, symbol: mt5Symbol, volume: mt5Volume, comment: `RT_${signalType}` } };
                wsRef.current.send(JSON.stringify(signal));
            }, [mt5Symbol, mt5Volume, signalType]);

            // Cerrar posici√≥n MT5
            const closeMT5Position = useCallback((ticket = null) => {
                if (!wsRef.current || wsRef.current.readyState !== WebSocket.OPEN) return;
                wsRef.current.send(JSON.stringify(ticket ? { action: 'close', ticket: ticket } : { action: 'close_all' }));
            }, []);

            // Funci√≥n para reproducir beep moteado (intermitente) - FUERTE
            const playSignalSound = useCallback((signalType) => {
                if (!soundEnabled) return;

                try {
                    if (!audioContextRef.current) {
                        audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)();
                    }
                    const ctx = audioContextRef.current;

                    // Frecuencia seg√∫n tipo de se√±al
                    const baseFreq = signalType === 'BULLISH' ? 880 : 440; // A5 para bullish, A4 para bearish
                    const beepCount = 4; // 4 beeps para m√°s atenci√≥n
                    const beepDuration = 0.15; // 150ms cada beep
                    const beepGap = 0.1; // 100ms entre beeps

                    for (let i = 0; i < beepCount; i++) {
                        const startTime = ctx.currentTime + (i * (beepDuration + beepGap));

                        const oscillator = ctx.createOscillator();
                        const gainNode = ctx.createGain();

                        oscillator.connect(gainNode);
                        gainNode.connect(ctx.destination);

                        oscillator.type = 'square'; // Sonido m√°s fuerte y distintivo
                        oscillator.frequency.setValueAtTime(baseFreq, startTime);

                        // Volumen FUERTE con fade r√°pido
                        gainNode.gain.setValueAtTime(0, startTime);
                        gainNode.gain.linearRampToValueAtTime(0.7, startTime + 0.01);
                        gainNode.gain.setValueAtTime(0.7, startTime + beepDuration - 0.02);
                        gainNode.gain.linearRampToValueAtTime(0, startTime + beepDuration);

                        oscillator.start(startTime);
                        oscillator.stop(startTime + beepDuration);
                    }
                } catch (e) {
                    console.log('Audio not available');
                }
            }, [soundEnabled]);

            // === POWER METERS ALIGNMENT SPECIAL SOUND ===
            const playAlignmentSound = useCallback((alignType) => {
                if (!soundEnabled) return;

                try {
                    if (!audioContextRef.current) {
                        audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)();
                    }
                    const ctx = audioContextRef.current;

                    // Sonido tipo "alarm" - arpeggio ascendente/descendente
                    const isBullish = alignType === 'BULLISH';
                    const notes = isBullish
                        ? [523, 659, 784, 1047] // C5, E5, G5, C6 - Acorde mayor ascendente
                        : [392, 330, 262, 196]; // G4, E4, C4, G3 - Acorde descendente

                    const noteDuration = 0.12;
                    const noteGap = 0.05;

                    notes.forEach((freq, i) => {
                        const startTime = ctx.currentTime + (i * (noteDuration + noteGap));

                        const osc = ctx.createOscillator();
                        const gain = ctx.createGain();

                        osc.connect(gain);
                        gain.connect(ctx.destination);

                        osc.type = 'sine'; // Sonido m√°s suave y distintivo del normal
                        osc.frequency.setValueAtTime(freq, startTime);

                        gain.gain.setValueAtTime(0, startTime);
                        gain.gain.linearRampToValueAtTime(0.5, startTime + 0.02);
                        gain.gain.setValueAtTime(0.4, startTime + noteDuration - 0.03);
                        gain.gain.linearRampToValueAtTime(0, startTime + noteDuration);

                        osc.start(startTime);
                        osc.stop(startTime + noteDuration);
                    });

                    // Segundo pase para reforzar
                    setTimeout(() => {
                        notes.forEach((freq, i) => {
                            const startTime = ctx.currentTime + (i * (noteDuration + noteGap));

                            const osc = ctx.createOscillator();
                            const gain = ctx.createGain();

                            osc.connect(gain);
                            gain.connect(ctx.destination);

                            osc.type = 'triangle';
                            osc.frequency.setValueAtTime(freq * 2, startTime); // Una octava m√°s arriba

                            gain.gain.setValueAtTime(0, startTime);
                            gain.gain.linearRampToValueAtTime(0.3, startTime + 0.02);
                            gain.gain.linearRampToValueAtTime(0, startTime + noteDuration);

                            osc.start(startTime);
                            osc.stop(startTime + noteDuration);
                        });
                    }, 400);

                } catch (e) {
                    console.log('Audio not available');
                }
            }, [soundEnabled]);

            // NUEVA ESTRUCTURA: Signal Slots (cada slot = m√©trica + algoritmo)
            // Cargar desde localStorage si existe
            const [signalSlots, setSignalSlots] = useState(() => {
                try {
                    const saved = localStorage.getItem('rt_signalSlots');
                    if (saved) {
                        const parsed = JSON.parse(saved);
                        if (Array.isArray(parsed) && parsed.length > 0) {
                            return parsed;
                        }
                    }
                } catch (e) { }
                return [
                    { id: 1, metric: 'money-flow', algorithm: 'dominance', enabled: true },
                    { id: 2, metric: 'delta-flow', algorithm: 'dominance', enabled: true },
                    { id: 3, metric: 'gex', algorithm: 'rsi', enabled: true },
                    { id: 4, metric: 'smart-money', algorithm: 'correlation', enabled: true }
                ];
            });

            // Guardar signalSlots en localStorage cuando cambie
            useEffect(() => {
                try {
                    localStorage.setItem('rt_signalSlots', JSON.stringify(signalSlots));
                } catch (e) { }
            }, [signalSlots]);

            // Slot actualmente siendo editado
            const [editingSlotId, setEditingSlotId] = useState(null);

            // LEGACY: Mantener selectedIndicators para compatibilidad con c√≥digo existente
            const selectedIndicators = useMemo(() => {
                return signalSlots.filter(s => s.enabled).map(s => `intensity-${s.metric}`);
            }, [signalSlots]);

            // Confirmaci√≥n m√≠nima
            const [minConfirmation, setMinConfirmation] = useState(3);

            // Configuraciones por indicador (thresholds, sma, colors)
            const [indicatorSettings, setIndicatorSettings] = useState({});

            // Estado para modal de configuraci√≥n de indicador individual
            const [editingIndicator, setEditingIndicator] = useState(null);

            // Historial de se√±ales
            const [signalHistory, setSignalHistory] = useState([]);

            // === POWER METERS ALIGNMENT SYSTEM ===
            const [powerMeterValues, setPowerMeterValues] = useState({ momentum: 0, longTerm: 0, correlation: 0 });
            const [metersAligned, setMetersAligned] = useState(null); // null, 'BULLISH', 'BEARISH'
            const [alignmentHistory, setAlignmentHistory] = useState([]); // Historial de alineaciones para burbujas
            const [alignmentThreshold, setAlignmentThreshold] = useState(10); // Umbral de alineaci√≥n (10%, 20%, etc)
            const prevAlignedRef = useRef(null);

            // Gr√°fico de precios con historial
            const [showPriceChart, setShowPriceChart] = useState(false);
            const priceChartRef = useRef(null);
            const priceChartInstance = useRef(null);

            // Backtest del panel de se√±ales
            const [showBacktest, setShowBacktest] = useState(false);
            const [backtestResults, setBacktestResults] = useState(null);

            // Volume Profile data - viene de los props (cargado en el slot)
            const profileData = volumeProfileData?.get(selectedSlot);

            // Obtener slots disponibles
            const availableSlots = useMemo(() => Array.from(dataSources.keys()), [dataSources]);

            // Auto-seleccionar slot
            useEffect(() => {
                if (!dataSources.has(selectedSlot) && availableSlots.length > 0) {
                    setSelectedSlot(availableSlots[0]);
                }
            }, [availableSlots, selectedSlot, dataSources]);

            const dataSource = dataSources.get(selectedSlot);

            // Calcular un hash de actualizaci√≥n basado en los datos m√°s recientes de cada slot
            const dataUpdateHash = useMemo(() => {
                let hash = '';
                [1, 2, 3, 4, 5, 6].forEach(slotId => {
                    const data = dataSources.get(String(slotId));
                    const len = data?.rows?.length || 0;
                    // Incluir √∫ltimo timestamp o √≠ndice para detectar actualizaciones
                    const lastTs = len > 0 ? (data.rows[len - 1]?.timestamp || data.rows[len - 1]?.Timestamp || len) : 0;
                    hash += `${slotId}:${len}:${lastTs},`;
                });
                return hash;
            }, [dataSources]);

            // Crear objeto con datos de todos los slots para CorrelationPowerMeter
            const allSlotData = useMemo(() => {
                const result = {};
                [1, 2, 3, 4, 5, 6].forEach(slotId => {
                    const data = dataSources.get(String(slotId));
                    if (data) {
                        result[`slot${slotId}`] = data;
                    }
                });
                return result;
            }, [dataSources, dataUpdateHash]);

            // Calcular se√±al combinada usando la nueva estructura de slots
            const tradingSignal = useMemo(() => {
                if (!dataSource?.rows?.length) {
                    return { signal: 'FLAT', bullishCount: 0, bearishCount: 0, flatCount: 0, details: [], total: 0, confidence: 0, avgStrength: 0 };
                }
                // Usar la nueva funci√≥n con slots (m√©trica + algoritmo por slot)
                return services.signalCalculator.calculateCombinedSignalFromSlots(
                    dataSource.rows,
                    signalSlots,
                    signalParams,
                    minConfirmation
                );
            }, [dataSource, signalSlots, signalParams, minConfirmation]);

            // Actualizar historial cuando cambia la se√±al
            useEffect(() => {
                if (tradingSignal.signal !== 'FLAT') {
                    setSignalHistory(prev => {
                        const newEntry = {
                            time: new Date().toLocaleTimeString(),
                            signal: tradingSignal.signal,
                            confidence: tradingSignal.confidence,
                            bullish: tradingSignal.bullishCount,
                            bearish: tradingSignal.bearishCount
                        };
                        return [newEntry, ...prev.slice(0, 9)];
                    });
                }
            }, [tradingSignal.signal, tradingSignal.confidence]);

            // Reproducir sonido cuando cambia la se√±al
            useEffect(() => {
                const currentSignal = tradingSignal.signal;
                if (currentSignal !== 'FLAT' && currentSignal !== prevSignalRef.current) {
                    playSignalSound(currentSignal);
                    // Auto-trade MT5
                    if (mt5AutoTrade && mt5Connected) {
                        sendSignalToMT5(currentSignal === 'BULLISH' ? 'BUY' : 'SELL');
                    }
                }
                prevSignalRef.current = currentSignal;
            }, [tradingSignal.signal, playSignalSound, mt5AutoTrade, mt5Connected, sendSignalToMT5]);

            // Detectar alineaci√≥n de los 3 Power Meters
            useEffect(() => {
                const { momentum, longTerm, correlation } = powerMeterValues;
                const threshold = alignmentThreshold; // Usar umbral din√°mico

                let aligned = null;
                if (momentum > threshold && longTerm > threshold && correlation > threshold) {
                    aligned = 'BULLISH';
                } else if (momentum < -threshold && longTerm < -threshold && correlation < -threshold) {
                    aligned = 'BEARISH';
                }

                setMetersAligned(aligned);

                // Reproducir sonido y guardar en historial si cambia la alineaci√≥n
                if (aligned && aligned !== prevAlignedRef.current) {
                    playAlignmentSound(aligned);

                    // Obtener precio actual del dataSource
                    const currentPrice = dataSource?.rows?.length > 0
                        ? parseFloat(dataSource.rows[dataSource.rows.length - 1]?.Underlying_Price) || 0
                        : 0;

                    // Calcular intensidad (promedio de los 3 valores absolutos)
                    const intensity = (Math.abs(momentum) + Math.abs(longTerm) + Math.abs(correlation)) / 3;

                    // Guardar en historial de alineaciones
                    setAlignmentHistory(prev => {
                        const newEntry = {
                            timestamp: new Date(),
                            time: new Date().toLocaleTimeString(),
                            type: aligned,
                            price: currentPrice,
                            intensity: Math.min(100, intensity),
                            threshold: threshold, // Guardar el umbral usado
                            momentum,
                            longTerm,
                            correlation
                        };
                        return [newEntry, ...prev.slice(0, 49)]; // M√°ximo 50 alineaciones
                    });
                }
                prevAlignedRef.current = aligned;
            }, [powerMeterValues, playAlignmentSound, dataSource, alignmentThreshold]);

            // Calcular historial completo de se√±ales para gr√°fico de precios
            // Calcular historial de se√±ales - USA TODOS LOS INDICADORES SELECCIONADOS
            const signalHistoryData = useMemo(() => {
                if ((!showPriceChart && !showBacktest) || !dataSource || !dataSource.rows || dataSource.rows.length < 50) return [];

                const rows = dataSource.rows;
                const timestampHeader = dataSource.timestampHeader || 'timestamp';
                const priceHeader = 'Underlying_Price';
                const n = rows.length;
                const smaPeriod = signalParams[signalType]?.smaPeriod || 14;

                // SUPER SIMPLE: solo 200 puntos m√°ximo
                const step = Math.max(1, Math.floor(n / 200));
                const history = [];

                // Obtener configuraciones de TODOS los indicadores seleccionados
                const indicatorConfigs = selectedIndicators
                    .map(key => ({ key, config: constants.SIGNAL_INDICATORS[key] }))
                    .filter(item => item.config);

                if (indicatorConfigs.length === 0) return [];

                for (var i = smaPeriod; i < n; i += step) {
                    let bullishCount = 0;
                    let bearishCount = 0;

                    // Evaluar CADA indicador seleccionado
                    for (const { config } of indicatorConfigs) {
                        const callCol = config.call;
                        const putCol = config.put;

                        // Calcular imbalance actual para este indicador
                        const c = Math.abs(rows[i][callCol] || 0);
                        const p = Math.abs(rows[i][putCol] || 0);
                        const total = c + p;
                        const currentImb = total > 0 ? ((c - p) / total) * 100 : 0;

                        // SMA simple (solo √∫ltimos smaPeriod)
                        var smaSum = 0;
                        for (var k = 0; k < smaPeriod && (i - k) >= 0; k++) {
                            const cc = Math.abs(rows[i - k][callCol] || 0);
                            const pp = Math.abs(rows[i - k][putCol] || 0);
                            const tt = cc + pp;
                            smaSum += tt > 0 ? ((cc - pp) / tt) * 100 : 0;
                        }
                        const smaImb = smaSum / smaPeriod;

                        // Se√±al de este indicador
                        if (currentImb > smaImb && currentImb > 0) bullishCount++;
                        else if (currentImb < smaImb && currentImb < 0) bearishCount++;
                    }

                    // Se√±al combinada basada en confirmaci√≥n m√≠nima
                    var signal = 'FLAT';
                    const minConf = Math.min(minConfirmation, indicatorConfigs.length);
                    if (bullishCount >= minConf && bullishCount > bearishCount) signal = 'BULLISH';
                    else if (bearishCount >= minConf && bearishCount > bullishCount) signal = 'BEARISH';

                    history.push({
                        timestamp: rows[i][timestampHeader],
                        price: rows[i][priceHeader] || 0,
                        signal: signal,
                        index: i,
                        bullishCount: bullishCount,
                        bearishCount: bearishCount
                    });
                }

                return history;
            }, [showPriceChart, showBacktest, dataSource, selectedIndicators, signalType, signalParams, minConfirmation]);

            // Calcular backtest autom√°ticamente cuando hay datos
            const backtestData = useMemo(() => {
                if (signalHistoryData.length < 10) return null;

                let position = null;
                let entryPrice = 0;
                let entryIdx = 0;
                const trades = [];

                for (var i = 0; i < signalHistoryData.length; i++) {
                    const d = signalHistoryData[i];
                    const prevSignal = i > 0 ? signalHistoryData[i - 1].signal : 'FLAT';

                    // Detectar cambios de se√±al
                    if (d.signal !== prevSignal) {
                        if (d.signal === 'BULLISH' && position !== 'long') {
                            // Cerrar short si existe
                            if (position === 'short') {
                                trades.push({ type: 'SHORT', entry: entryPrice, exit: d.price, pnl: entryPrice - d.price, bars: i - entryIdx });
                            }
                            // Abrir long
                            position = 'long';
                            entryPrice = d.price;
                            entryIdx = i;
                        } else if (d.signal === 'BEARISH' && position !== 'short') {
                            // Cerrar long si existe
                            if (position === 'long') {
                                trades.push({ type: 'LONG', entry: entryPrice, exit: d.price, pnl: d.price - entryPrice, bars: i - entryIdx });
                            }
                            // Abrir short
                            position = 'short';
                            entryPrice = d.price;
                            entryIdx = i;
                        } else if (d.signal === 'FLAT' && position) {
                            // Cerrar posici√≥n
                            if (position === 'long') {
                                trades.push({ type: 'LONG', entry: entryPrice, exit: d.price, pnl: d.price - entryPrice, bars: i - entryIdx });
                            } else if (position === 'short') {
                                trades.push({ type: 'SHORT', entry: entryPrice, exit: d.price, pnl: entryPrice - d.price, bars: i - entryIdx });
                            }
                            position = null;
                        }
                    }
                }

                // Cerrar posici√≥n abierta al final
                if (position && signalHistoryData.length > 0) {
                    const lastPrice = signalHistoryData[signalHistoryData.length - 1].price;
                    if (position === 'long') {
                        trades.push({ type: 'LONG', entry: entryPrice, exit: lastPrice, pnl: lastPrice - entryPrice, bars: signalHistoryData.length - entryIdx, open: true });
                    } else {
                        trades.push({ type: 'SHORT', entry: entryPrice, exit: lastPrice, pnl: entryPrice - lastPrice, bars: signalHistoryData.length - entryIdx, open: true });
                    }
                }

                if (trades.length === 0) return null;

                const totalPnl = trades.reduce((sum, t) => sum + t.pnl, 0);
                const winners = trades.filter(t => t.pnl > 0);
                const losers = trades.filter(t => t.pnl <= 0);
                const winRate = (winners.length / trades.length) * 100;
                const avgWin = winners.length > 0 ? winners.reduce((s, t) => s + t.pnl, 0) / winners.length : 0;
                const avgLoss = losers.length > 0 ? Math.abs(losers.reduce((s, t) => s + t.pnl, 0) / losers.length) : 0;
                const profitFactor = avgLoss > 0 ? (avgWin * winners.length) / (avgLoss * losers.length) : avgWin > 0 ? 999 : 0;

                // Max Drawdown
                let peak = 0, maxDD = 0, cumPnl = 0;
                for (const t of trades) {
                    cumPnl += t.pnl;
                    peak = Math.max(peak, cumPnl);
                    maxDD = Math.max(maxDD, peak - cumPnl);
                }

                return {
                    trades: trades.length,
                    winners: winners.length,
                    losers: losers.length,
                    winRate: winRate,
                    totalPnl: totalPnl,
                    avgWin: avgWin,
                    avgLoss: avgLoss,
                    profitFactor: profitFactor,
                    maxDrawdown: maxDD,
                    lastTrades: trades.slice(-5)
                };
            }, [signalHistoryData]);

            // Renderizar gr√°fico de precios (precio + SMA14 + se√±ales + perfil integrado)
            useEffect(() => {
                if (!showPriceChart || !priceChartRef.current || !dataSource?.rows?.length) {
                    if (priceChartInstance.current) {
                        priceChartInstance.current.dispose();
                        priceChartInstance.current = null;
                    }
                    return;
                }

                if (!priceChartInstance.current) {
                    priceChartInstance.current = echarts.init(priceChartRef.current, null, { renderer: 'canvas' });
                }

                // Usar signalHistoryData como base (ya tiene precio, timestamp, se√±al)
                // Si no hay se√±ales, mostrar solo el precio
                const hasSignals = signalHistoryData.length > 0;
                const hasProfile = profileData && profileData.size > 0;

                // Colores de call/put desde globalConfig
                const callColor = globalConfig?.callColor || '#4a9eff';
                const putColor = globalConfig?.putColor || '#ff4444';

                let priceData, timestamps, sma14;
                let minPrice, maxPrice;

                if (hasSignals) {
                    // Usar datos de signalHistoryData (muestreados y con se√±ales)
                    priceData = signalHistoryData.map(d => d.price);
                    timestamps = signalHistoryData.map((d, idx) => {
                        if (d.timestamp instanceof Date) return d.timestamp.toLocaleTimeString();
                        if (typeof d.timestamp === 'string') return d.timestamp.slice(-8);
                        return idx.toString();
                    });

                    // Calcular SMA(14) sobre los datos muestreados
                    sma14 = [];
                    for (let i = 0; i < priceData.length; i++) {
                        if (i < 13) {
                            sma14.push(null);
                        } else {
                            let sum = 0;
                            for (let j = 0; j < 14; j++) {
                                sum += priceData[i - j];
                            }
                            sma14.push(sum / 14);
                        }
                    }
                } else {
                    // Sin se√±ales - mostrar todos los datos
                    const rows = dataSource.rows;
                    const timestampHeader = dataSource.timestampHeader || 'timestamp';
                    const priceHeader = 'Underlying_Price';

                    // Muestrear para rendimiento (m√°x 300 puntos)
                    const step = Math.max(1, Math.floor(rows.length / 300));
                    priceData = [];
                    timestamps = [];

                    for (let i = 0; i < rows.length; i += step) {
                        priceData.push(rows[i][priceHeader] || 0);
                        const ts = rows[i][timestampHeader];
                        if (ts instanceof Date) timestamps.push(ts.toLocaleTimeString());
                        else if (typeof ts === 'string') timestamps.push(ts.slice(-8));
                        else timestamps.push(i.toString());
                    }

                    // Calcular SMA(14)
                    sma14 = [];
                    for (let i = 0; i < priceData.length; i++) {
                        if (i < 13) {
                            sma14.push(null);
                        } else {
                            let sum = 0;
                            for (let j = 0; j < 14; j++) {
                                sum += priceData[i - j];
                            }
                            sma14.push(sum / 14);
                        }
                    }
                }

                // Calcular min/max precios
                minPrice = Math.min(...priceData.filter(p => p > 0));
                maxPrice = Math.max(...priceData.filter(p => p > 0));

                // Zonas de fondo para se√±ales (en lugar de tri√°ngulos)
                const signalAreas = [];

                if (hasSignals) {
                    let currentSignal = 'FLAT';
                    let signalStartIdx = 0;

                    for (let i = 0; i < signalHistoryData.length; i++) {
                        const d = signalHistoryData[i];

                        // Detectar cambio de se√±al
                        if (d.signal !== currentSignal) {
                            // Cerrar zona anterior si era BULLISH o BEARISH
                            if (currentSignal === 'BULLISH' || currentSignal === 'BEARISH') {
                                signalAreas.push([
                                    {
                                        xAxis: signalStartIdx, itemStyle: {
                                            color: currentSignal === 'BULLISH'
                                                ? 'rgba(74, 158, 255, 0.15)'
                                                : 'rgba(255, 68, 68, 0.15)'
                                        }
                                    },
                                    { xAxis: i }
                                ]);
                            }
                            // Iniciar nueva zona
                            currentSignal = d.signal;
                            signalStartIdx = i;
                        }
                    }

                    // Cerrar √∫ltima zona si qued√≥ abierta
                    if ((currentSignal === 'BULLISH' || currentSignal === 'BEARISH') && signalHistoryData.length > 0) {
                        signalAreas.push([
                            {
                                xAxis: signalStartIdx, itemStyle: {
                                    color: currentSignal === 'BULLISH'
                                        ? 'rgba(74, 158, 255, 0.15)'
                                        : 'rgba(255, 68, 68, 0.15)'
                                }
                            },
                            { xAxis: signalHistoryData.length - 1 }
                        ]);
                    }
                }

                // Preparar datos de perfil si existen - usando renderizado custom como price-profile
                let profileSeriesData = [];
                let maxVol = 1;
                let binSize = 1;
                const binCount = 50;

                if (hasProfile) {
                    const priceRange = maxPrice - minPrice || 1;
                    binSize = priceRange / binCount;

                    let callProfile = new Array(binCount).fill(0);
                    let putProfile = new Array(binCount).fill(0);
                    const priceBins = Array.from({ length: binCount }, (_, i) => minPrice + (i * binSize));

                    profileData.forEach((strikeData) => {
                        strikeData.forEach(row => {
                            const strike = row.strike;
                            if (strike >= minPrice && strike <= maxPrice) {
                                const binIndex = Math.min(binCount - 1, Math.floor((strike - minPrice) / binSize));
                                if (binIndex >= 0 && binIndex < binCount) {
                                    callProfile[binIndex] += row.callCash;
                                    putProfile[binIndex] += row.putCash;
                                }
                            }
                        });
                    });

                    const maxCallVol = Math.max(...callProfile.filter(v => !isNaN(v)));
                    const maxPutVol = Math.max(...putProfile.filter(v => !isNaN(v)));
                    maxVol = Math.max(maxCallVol, maxPutVol, 1);

                    // Formato para renderItem custom: [price, callVol, putVol, timestamp_index, isTopCall, isTopPut]
                    let allProfileData = priceBins.map((price, i) => [price, callProfile[i], putProfile[i], 0]);

                    // Identificar los 4 niveles m√°s fuertes para mostrar etiquetas (top 2 calls + top 2 puts)
                    const sortedByCalls = [...allProfileData].filter(d => d[1] > 0).sort((a, b) => b[1] - a[1]);
                    const sortedByPuts = [...allProfileData].filter(d => d[2] > 0).sort((a, b) => b[2] - a[2]);
                    const topCallPrices = new Set(sortedByCalls.slice(0, 2).map(d => d[0]));
                    const topPutPrices = new Set(sortedByPuts.slice(0, 2).map(d => d[0]));

                    // Todos los strikes pero marcando cu√°les son top para etiquetas
                    profileSeriesData = allProfileData.map(d => [
                        d[0],  // price
                        d[1],  // callVol
                        d[2],  // putVol
                        d[3],  // timestamp_index
                        topCallPrices.has(d[0]) ? 1 : 0,  // isTopCall
                        topPutPrices.has(d[0]) ? 1 : 0    // isTopPut
                    ]).filter(d => d[1] > 0 || d[2] > 0);
                }

                // Funci√≥n de renderizado custom para barras horizontales por strike
                const renderVolumeProfile = (params, api) => {
                    const price = api.value(0);
                    const callVol = api.value(1);
                    const putVol = api.value(2);
                    const isTopCall = api.value(4) === 1;
                    const isTopPut = api.value(5) === 1;

                    if (price == null || callVol == null || putVol == null) return;

                    const panelWidth = api.getWidth();
                    const maxWidth = panelWidth * 0.35; // 35% del ancho para las barras

                    const callWidth = maxVol > 0 ? (callVol / maxVol) * maxWidth : 0;
                    const putWidth = maxVol > 0 ? (putVol / maxVol) * maxWidth : 0;

                    const centerCoord = api.coord([0, price + binSize / 2]);
                    if (!centerCoord) return;

                    const binHeightInPixels = Math.abs(api.size([0, binSize])[1]);
                    const barHeight = Math.max(2, binHeightInPixels * 0.4);
                    const gap = binHeightInPixels * 0.05;

                    const startX = params.coordSys.x;
                    const putY = centerCoord[1] + gap / 2;
                    const callY = centerCoord[1] - gap / 2 - barHeight;

                    const children = [];

                    // Funci√≥n para abreviar n√∫meros
                    const abbreviateNumber = (num) => {
                        if (num >= 1000000) return (num / 1000000).toFixed(1) + 'M';
                        if (num >= 1000) return (num / 1000).toFixed(1) + 'K';
                        return num.toFixed(0);
                    };

                    // Barra de Calls (arriba, color azul)
                    if (callWidth > 0.5) {
                        children.push({
                            type: 'rect',
                            shape: { x: startX, y: callY, width: callWidth, height: barHeight },
                            style: { fill: callColor, opacity: 0.7 }
                        });
                        // Texto con cantidad - solo en los top 2 calls
                        if (isTopCall && callVol > 0) {
                            children.push({
                                type: 'text',
                                style: {
                                    text: abbreviateNumber(callVol),
                                    x: startX + 2,
                                    y: callY - 2,
                                    fill: callColor,
                                    fontSize: 7,
                                    fontWeight: 'bold',
                                    textAlign: 'left',
                                    textVerticalAlign: 'bottom',
                                    opacity: 0.9
                                }
                            });
                        }
                    }

                    // Barra de Puts (abajo, color rojo)
                    if (putWidth > 0.5) {
                        children.push({
                            type: 'rect',
                            shape: { x: startX, y: putY, width: putWidth, height: barHeight },
                            style: { fill: putColor, opacity: 0.7 }
                        });
                        // Texto con cantidad - solo en los top 2 puts
                        if (isTopPut && putVol > 0) {
                            children.push({
                                type: 'text',
                                style: {
                                    text: abbreviateNumber(putVol),
                                    x: startX + 2,
                                    y: putY + barHeight + 2,
                                    fill: putColor,
                                    fontSize: 7,
                                    fontWeight: 'bold',
                                    textAlign: 'left',
                                    textVerticalAlign: 'top',
                                    opacity: 0.9
                                }
                            });
                        }
                    }

                    return { type: 'group', children: children };
                };

                // Grid √∫nico - el perfil se renderiza sobre el gr√°fico de precios
                const grids = [
                    { left: 50, right: 18, top: 45, bottom: 45 }
                ];

                const xAxes = [
                    {
                        type: 'category',
                        data: timestamps,
                        axisLine: { lineStyle: { color: '#333' } },
                        axisLabel: { color: '#666', fontSize: 9, rotate: 45, interval: Math.floor(timestamps.length / 12) },
                        splitLine: { show: false }
                    }
                ];

                const yAxes = [
                    {
                        type: 'value',
                        scale: true,
                        axisLine: { lineStyle: { color: '#333' } },
                        axisLabel: { color: '#666', fontSize: 10, formatter: (v) => v.toFixed(2) },
                        splitLine: { lineStyle: { color: '#222' } }
                    }
                ];

                // Series base
                const series = [
                    {
                        name: 'Precio',
                        type: 'line',
                        data: priceData,
                        smooth: false,
                        symbol: 'none',
                        lineStyle: { color: '#ffffff', width: 1 },
                        markArea: {
                            silent: true,
                            data: signalAreas
                        },
                        z: 10
                    },
                    {
                        name: 'SMA(14)',
                        type: 'line',
                        data: sma14,
                        smooth: true,
                        symbol: 'none',
                        lineStyle: { color: 'rgba(128, 128, 128, 0.4)', width: 1 },
                        z: 9
                    }
                ];

                // Agregar serie de perfil custom si hay datos
                if (hasProfile && profileSeriesData.length > 0) {
                    series.push({
                        name: 'Volume Profile',
                        type: 'custom',
                        renderItem: renderVolumeProfile,
                        data: profileSeriesData,
                        encode: { x: 3, y: 0 },
                        tooltip: { show: false },
                        z: 2
                    });
                }

                // === BURBUJAS DE BIG ALIGNMENT ===
                // Filtrar alineaciones que cumplan con el umbral actual
                const filteredAlignments = alignmentHistory.filter(align => {
                    // Verificar que los 3 valores superen el umbral actual
                    const threshold = alignmentThreshold;
                    if (align.type === 'BULLISH') {
                        return align.momentum > threshold && align.longTerm > threshold && align.correlation > threshold;
                    } else {
                        return align.momentum < -threshold && align.longTerm < -threshold && align.correlation < -threshold;
                    }
                });

                // Mapear alineaciones filtradas a posiciones en el gr√°fico
                if (filteredAlignments.length > 0 && timestamps.length > 0) {
                    const alignmentBubbles = filteredAlignments.map(align => {
                        // Buscar el timestamp m√°s cercano en el gr√°fico
                        const alignTime = align.timestamp instanceof Date
                            ? align.timestamp.toLocaleTimeString()
                            : align.time;

                        // Buscar √≠ndice m√°s cercano por tiempo o por precio
                        let closestIdx = timestamps.length - 1;
                        let minDiff = Infinity;

                        timestamps.forEach((ts, idx) => {
                            // Comparar por string de tiempo
                            if (ts === alignTime || ts.includes(alignTime.slice(-5))) {
                                closestIdx = idx;
                                minDiff = 0;
                            }
                        });

                        // Si no encontr√≥ por tiempo, usar el precio m√°s cercano
                        if (minDiff > 0 && align.price > 0) {
                            priceData.forEach((price, idx) => {
                                const diff = Math.abs(price - align.price);
                                if (diff < minDiff) {
                                    minDiff = diff;
                                    closestIdx = idx;
                                }
                            });
                        }

                        // Tama√±o de burbuja basado en intensidad (10-40 pixels)
                        const bubbleSize = 10 + (align.intensity / 100) * 30;

                        return {
                            value: [closestIdx, priceData[closestIdx] || align.price],
                            itemStyle: {
                                color: align.type === 'BULLISH'
                                    ? 'rgba(34, 197, 94, 0.35)'
                                    : 'rgba(239, 68, 68, 0.35)',
                                borderColor: align.type === 'BULLISH'
                                    ? 'rgba(34, 197, 94, 0.7)'
                                    : 'rgba(239, 68, 68, 0.7)',
                                borderWidth: 2,
                                shadowColor: align.type === 'BULLISH'
                                    ? 'rgba(34, 197, 94, 0.5)'
                                    : 'rgba(239, 68, 68, 0.5)',
                                shadowBlur: 10
                            },
                            symbolSize: bubbleSize,
                            alignData: align // Guardar datos para tooltip
                        };
                    });

                    series.push({
                        name: 'Big Alignment',
                        type: 'scatter',
                        data: alignmentBubbles,
                        symbol: 'circle',
                        z: 15,
                        tooltip: {
                            formatter: (params) => {
                                const align = params.data.alignData;
                                if (!align) return '';
                                return `<div style="padding:4px">
                                    <b style="color:${align.type === 'BULLISH' ? '#22c55e' : '#ef4444'}">
                                        ‚ö° ${align.type} ALIGNMENT
                                    </b><br/>
                                    <span style="color:#888">Time: ${align.time}</span><br/>
                                    <span style="color:#aaa">Intensity: ${align.intensity.toFixed(0)}%</span><br/>
                                    <span style="font-size:10px;color:#666">
                                        M:${align.momentum.toFixed(0)} | L:${align.longTerm.toFixed(0)} | C:${align.correlation.toFixed(0)}
                                    </span>
                                </div>`;
                            }
                        }
                    });
                }

                const legendData = hasProfile ? ['Precio', 'SMA(14)', 'Calls', 'Puts'] : ['Precio', 'SMA(14)'];

                const option = {
                    animation: false,
                    backgroundColor: 'transparent',
                    title: {
                        text: hasProfile ? 'Precio + Perfil por Strikes' : 'Precio + SMA(14)',
                        subtext: hasSignals ?
                            'Zonas: ' + signalAreas.length + (hasProfile ? ' | ' + profileData.size + ' snapshots (Vol cargado en Slot ' + selectedSlot + ')' : ' | Carga chain.csv con bot√≥n Vol del Slot para ver perfiles') :
                            priceData.length + ' puntos' + (hasProfile ? ' | ' + profileData.size + ' snapshots' : ' | Sin perfil'),
                        left: 10,
                        top: 5,
                        textStyle: { color: '#e5e5e5', fontSize: 14 },
                        subtextStyle: { color: hasProfile ? '#888' : '#666', fontSize: 11 }
                    },
                    legend: {
                        data: legendData,
                        top: 5,
                        right: 20,
                        textStyle: { color: '#888', fontSize: 10 }
                    },
                    grid: grids,
                    tooltip: {
                        trigger: 'axis',
                        backgroundColor: 'rgba(23,23,23,0.95)',
                        borderColor: '#333',
                        textStyle: { color: '#fff', fontSize: 11 },
                        axisPointer: { type: 'cross' }
                    },
                    xAxis: xAxes,
                    yAxis: yAxes,
                    dataZoom: [
                        {
                            type: 'inside',
                            xAxisIndex: [0],
                            start: 0,
                            end: 100,
                            zoomOnMouseWheel: true,
                            moveOnMouseMove: true
                        },
                        {
                            type: 'inside',
                            yAxisIndex: [0],
                            start: 0,
                            end: 100,
                            zoomOnMouseWheel: 'shift',
                            moveOnMouseMove: true
                        }
                    ],
                    series: series
                };

                priceChartInstance.current.setOption(option, true);

            }, [showPriceChart, dataSource, signalHistoryData, globalConfig, profileData, selectedSlot, volumeProfileData, alignmentHistory, alignmentThreshold]);

            // Resize handler para el gr√°fico de precios
            useEffect(() => {
                if (!showPriceChart || !priceChartInstance.current) return;

                const handleResize = () => {
                    if (priceChartInstance.current) {
                        priceChartInstance.current.resize();
                    }
                };

                // Doble clic para zoom in/out con escala autom√°tica
                const handleDoubleClick = (params) => {
                    if (!priceChartInstance.current) return;
                    const chart = priceChartInstance.current;
                    const option = chart.getOption();
                    const currentZoom = option.dataZoom?.[0];

                    if (currentZoom) {
                        const currentRange = currentZoom.end - currentZoom.start;

                        if (currentRange < 100) {
                            // Si esta con zoom, resetear a 100%
                            chart.dispatchAction({ type: 'dataZoom', start: 0, end: 100 });
                        } else {
                            // Si esta al 100%, hacer zoom al 30% centrado
                            chart.dispatchAction({ type: 'dataZoom', start: 35, end: 65 });
                        }
                    }
                };

                priceChartInstance.current.on('dblclick', handleDoubleClick);

                // Listener de window resize
                window.addEventListener('resize', handleResize);

                // ResizeObserver para el contenedor
                let resizeObserver = null;
                if (priceChartRef.current && window.ResizeObserver) {
                    resizeObserver = new ResizeObserver(handleResize);
                    resizeObserver.observe(priceChartRef.current);
                }

                return () => {
                    window.removeEventListener('resize', handleResize);
                    if (resizeObserver) {
                        resizeObserver.disconnect();
                    }
                    if (priceChartInstance.current) {
                        priceChartInstance.current.off('dblclick');
                    }
                };
            }, [showPriceChart]);

            // Funciones para el gr√°fico de precios
            const handlePriceChartResetZoom = useCallback(() => {
                if (priceChartInstance.current) {
                    priceChartInstance.current.dispatchAction({
                        type: 'dataZoom',
                        start: 0,
                        end: 100
                    });
                }
            }, []);

            const handlePriceChartDownload = useCallback(() => {
                if (priceChartInstance.current) {
                    const dataUrl = priceChartInstance.current.getDataURL({
                        type: 'png',
                        pixelRatio: 2,
                        backgroundColor: '#171717'
                    });
                    const link = document.createElement('a');
                    link.download = `price_chart_${new Date().toISOString().slice(0, 19).replace(/[:-]/g, '')}.png`;
                    link.href = dataUrl;
                    link.click();
                }
            }, []);

            const handlePriceChartTelegram = useCallback(() => {
                if (priceChartInstance.current && window.services?.telegram?.sendImageToTelegram) {
                    const dataUrl = priceChartInstance.current.getDataURL({
                        type: 'png',
                        pixelRatio: 2,
                        backgroundColor: '#171717'
                    });
                    const caption = `Price & Profile Chart\n${new Date().toLocaleTimeString()}`;
                    window.services.telegram.sendImageToTelegram(dataUrl, caption);
                }
            }, []);

            // Toggle indicador
            const handleIndicatorToggle = useCallback((key) => {
                setSelectedIndicators(prev => {
                    if (prev.includes(key)) {
                        return prev.filter(i => i !== key);
                    } else if (prev.length < 4) {
                        return [...prev, key];
                    }
                    return prev;
                });
            }, []);

            // Actualizar configuraci√≥n de indicador
            const handleIndicatorSettingChange = useCallback((indicatorKey, settingType, value) => {
                setIndicatorSettings(prev => {
                    const current = prev[indicatorKey] || {};
                    if (settingType === 'bullish' || settingType === 'bearish') {
                        return {
                            ...prev,
                            [indicatorKey]: {
                                ...current,
                                thresholds: {
                                    ...(current.thresholds || {}),
                                    [settingType]: parseFloat(value) || 0
                                }
                            }
                        };
                    } else if (settingType === 'sma') {
                        return {
                            ...prev,
                            [indicatorKey]: {
                                ...current,
                                sma: parseInt(value) || 1
                            }
                        };
                    } else if (settingType === 'callColor' || settingType === 'putColor') {
                        return {
                            ...prev,
                            [indicatorKey]: {
                                ...current,
                                colors: {
                                    ...(current.colors || {}),
                                    [settingType === 'callColor' ? 'call' : 'put']: value
                                }
                            }
                        };
                    }
                    return prev;
                });
            }, []);

            // Compatibilidad con el viejo handleThresholdChange
            const handleThresholdChange = useCallback((indicatorKey, type, value) => {
                handleIndicatorSettingChange(indicatorKey, type, value);
            }, [handleIndicatorSettingChange]);

            // Refs para controlar el env√≠o autom√°tico
            const lastSentTimeRef = useRef(0);
            const lastSentSignalRef = useRef(null);
            const isSendingRef = useRef(false);
            const autoSendIntervalRef = useRef(null);

            // Telegram Send Handler - captures actual panel
            const handleSendToTelegram = useCallback(async (isAutoSend = false) => {
                // Prevenir env√≠os simult√°neos
                if (isSendingRef.current || !panelRef.current) {
                    console.log('Skip: already sending or no panel');
                    return;
                }

                const now = Date.now();
                const timeSinceLastSend = now - lastSentTimeRef.current;
                const minInterval = 10000; // M√≠nimo 10 segundos entre env√≠os

                // Si es auto-send, aplicar filtros
                if (isAutoSend) {
                    // No enviar si pas√≥ muy poco tiempo
                    if (timeSinceLastSend < minInterval) {
                        console.log('Skip: too soon', timeSinceLastSend);
                        return;
                    }

                    // No enviar si la se√±al es FLAT y ya enviamos FLAT
                    if (tradingSignal.signal === 'FLAT' && lastSentSignalRef.current === 'FLAT') {
                        console.log('Skip: still FLAT');
                        return;
                    }

                    // No enviar si la se√±al no ha cambiado (para el mismo tipo)
                    if (tradingSignal.signal === lastSentSignalRef.current && tradingSignal.confidence === lastSentTimeRef.current) {
                        console.log('Skip: same signal');
                        return;
                    }
                }

                isSendingRef.current = true;
                setIsSendingTelegram(true);
                setTelegramStatus('Capturando...');

                try {
                    console.log('Starting Telegram send...');
                    console.log('Panel ref:', panelRef.current);

                    // Load html2canvas if needed
                    await services.telegram.loadHtml2Canvas();
                    console.log('html2canvas loaded');

                    // Capture the panel as image
                    const imageBlob = await services.telegram.captureElementAsImage(panelRef.current);
                    console.log('Image blob:', imageBlob);

                    if (!imageBlob) {
                        throw new Error('No se pudo capturar la imagen');
                    }

                    setTelegramStatus('Enviando...');

                    // Calculate extra stats
                    const extraStats = {};
                    if (dataSource?.rows?.length > 0) {
                        const lastRow = dataSource.rows[dataSource.rows.length - 1];
                        let totalCall = 0, totalPut = 0;
                        selectedIndicators.forEach(indKey => {
                            const config = constants.SIGNAL_INDICATORS[indKey];
                            if (config) {
                                totalCall += Math.abs(lastRow[config.call] || 0);
                                totalPut += Math.abs(lastRow[config.put] || 0);
                            }
                        });
                        extraStats.totalVolume = totalCall + totalPut;
                        extraStats.netFlow = totalCall - totalPut;
                    }

                    // Generate caption with stats
                    const caption = services.telegram.generateCaption(tradingSignal, selectedSlot, extraStats);
                    console.log('Caption generated');

                    // Send to all Telegram groups
                    const results = await services.telegram.sendImageToTelegram(imageBlob, caption);
                    console.log('Telegram results:', results);

                    const successCount = results.filter(r => r.success).length;
                    const totalCount = results.length;

                    if (successCount > 0) {
                        // Actualizar refs solo si el env√≠o fue exitoso
                        lastSentTimeRef.current = Date.now();
                        lastSentSignalRef.current = tradingSignal.signal;
                        setTelegramStatus(`OK ${successCount}/${totalCount}`);
                        console.log('Sent successfully:', successCount, '/', totalCount);
                    } else {
                        setTelegramStatus('Error');
                        console.log('All sends failed');
                        results.forEach(r => console.log('   Result:', r));
                    }

                    // Clear status after 3 seconds
                    setTimeout(() => setTelegramStatus(null), 3000);
                } catch (error) {
                    console.error('Telegram send error:', error);
                    setTelegramStatus('Error: ' + (error.message || 'Unknown'));
                    setTimeout(() => setTelegramStatus(null), 5000);
                } finally {
                    isSendingRef.current = false;
                    setIsSendingTelegram(false);
                }
            }, [tradingSignal, selectedSlot, dataSource, selectedIndicators]);

            // Auto-send interval effect - solo maneja el timer
            useEffect(() => {
                // Limpiar intervalo anterior
                if (autoSendIntervalRef.current) {
                    clearInterval(autoSendIntervalRef.current);
                    autoSendIntervalRef.current = null;
                }

                if (autoSendEnabled && autoSendInterval > 0) {
                    console.log('Auto-send enabled, interval:', autoSendInterval);

                    // Configurar nuevo intervalo
                    autoSendIntervalRef.current = setInterval(() => {
                        console.log('Auto-send tick');
                        handleSendToTelegram(true);
                    }, autoSendInterval * 1000);
                }

                return () => {
                    if (autoSendIntervalRef.current) {
                        clearInterval(autoSendIntervalRef.current);
                        autoSendIntervalRef.current = null;
                    }
                };
            }, [autoSendEnabled, autoSendInterval]); // NO incluir handleSendToTelegram aqu√≠

            // Efecto para enviar cuando cambia la se√±al (solo si auto est√° habilitado)
            useEffect(() => {
                if (!autoSendEnabled) return;

                // Solo enviar si la se√±al cambi√≥ a algo diferente de FLAT
                if (tradingSignal.signal !== 'FLAT' && tradingSignal.signal !== lastSentSignalRef.current) {
                    console.log('Signal changed to:', tradingSignal.signal);
                    // Peque√±o delay para evitar m√∫ltiples disparos
                    const timer = setTimeout(() => {
                        handleSendToTelegram(true);
                    }, 500);
                    return () => clearTimeout(timer);
                }
            }, [tradingSignal.signal, autoSendEnabled]); // NO incluir handleSendToTelegram aqu√≠

            // Colores seg√∫n se√±al
            const getSignalColor = (signal) => ({
                BULLISH: { bg: 'rgba(74, 158, 255, 0.15)', border: '#4a9eff', text: '#6bb3ff', glow: 'rgba(74, 158, 255, 0.4)' },
                BEARISH: { bg: 'rgba(255, 68, 68, 0.15)', border: '#ff4444', text: '#ff6b6b', glow: 'rgba(255, 68, 68, 0.4)' },
                FLAT: { bg: 'rgba(107, 114, 128, 0.15)', border: '#6b7280', text: '#9ca3af', glow: 'transparent' }
            }[signal] || { bg: 'rgba(107, 114, 128, 0.15)', border: '#6b7280', text: '#9ca3af', glow: 'transparent' });

            const signalColors = getSignalColor(tradingSignal.signal);

            // Lista de indicadores disponibles
            const indicatorList = Object.entries(constants.SIGNAL_INDICATORS).map(([key, config]) => ({
                key,
                label: config.label,
                category: config.category,
                type: config.type,
                defaultThreshold: config.defaultThreshold
            }));

            // Agrupar por categor√≠a
            const indicatorsByCategory = indicatorList.reduce((acc, ind) => {
                if (!acc[ind.category]) acc[ind.category] = [];
                acc[ind.category].push(ind);
                return acc;
            }, {});

            const signalEmoji = tradingSignal.signal === 'BULLISH' ? '‚ñ≤' : tradingSignal.signal === 'BEARISH' ? '‚ñº' : '‚óè';

            return React.createElement('div', {
                ref: panelRef,
                className: "mb-2 rounded-lg overflow-hidden shadow-lg",
                style: {
                    background: 'linear-gradient(180deg, rgba(23,23,23,0.98) 0%, rgba(15,15,15,0.99) 100%)',
                    border: `1px solid ${signalColors.border}40`,
                    boxShadow: tradingSignal.signal !== 'FLAT' ? `0 0 20px ${signalColors.glow}` : 'none'
                }
            },
                // ===== HEADER =====
                React.createElement('div', {
                    className: "flex items-center justify-between px-3 py-2 cursor-pointer",
                    style: {
                        background: `linear-gradient(90deg, ${signalColors.bg} 0%, transparent 100%)`,
                        borderBottom: '1px solid rgba(255,255,255,0.05)'
                    },
                    onClick: () => setIsExpanded(!isExpanded)
                },
                    // Lado izquierdo - compacto
                    React.createElement('div', { className: "flex items-center gap-2" },
                        React.createElement('h3', {
                            className: "text-xs font-bold tracking-wide",
                            style: { color: signalColors.text }
                        }, "SIGNALS"),
                        // Preset activo
                        React.createElement('span', {
                            className: "px-1.5 py-0.5 rounded text-[8px] font-semibold uppercase",
                            style: {
                                backgroundColor: globalConfig?.presetKey === 'aggressive' ? 'rgba(239, 68, 68, 0.2)' :
                                    globalConfig?.presetKey === 'conservative' ? 'rgba(34, 197, 94, 0.2)' :
                                        'rgba(59, 130, 246, 0.2)',
                                color: globalConfig?.presetKey === 'aggressive' ? '#ef4444' :
                                    globalConfig?.presetKey === 'conservative' ? '#22c55e' :
                                        '#3b82f6'
                            }
                        }, globalConfig?.presetKey || 'bal'),
                        // Contador compacto
                        React.createElement('div', { className: "flex items-center gap-1 text-[9px] font-mono" },
                            React.createElement('span', { className: "text-blue-400" }, tradingSignal.bullishCount),
                            React.createElement('span', { className: "text-neutral-500" }, '/'),
                            React.createElement('span', { className: "text-red-400" }, tradingSignal.bearishCount),
                            React.createElement('span', { className: "text-neutral-500" }, '/'),
                            React.createElement('span', { className: "text-neutral-400" }, tradingSignal.flatCount)
                        ),
                        // Indicador de Sentimiento Global de Sectores
                        globalMarketSentiment && React.createElement('div', {
                            className: "flex items-center gap-1 px-1.5 py-0.5 rounded text-[8px] font-semibold",
                            style: {
                                backgroundColor: `${globalMarketSentiment.color}20`,
                                border: `1px solid ${globalMarketSentiment.color}50`,
                                color: globalMarketSentiment.color
                            },
                            title: `Sentimiento Global: ${globalMarketSentiment.label} (${globalMarketSentiment.score >= 0 ? '+' : ''}${globalMarketSentiment.score.toFixed(1)}%)\nSectores: ${globalMarketSentiment.sectors?.length || 0}`
                        },
                            React.createElement('span', { className: "text-[7px] opacity-70" }, "MKT"),
                            React.createElement('span', {
                                style: {
                                    fontSize: '9px',
                                    textShadow: `0 0 6px ${globalMarketSentiment.color}`
                                }
                            }, globalMarketSentiment.score >= 2 ? '‚ñ≤' : globalMarketSentiment.score <= -2 ? '‚ñº' : '‚óè'),
                            React.createElement('span', null, globalMarketSentiment.label?.substring(0, 4).toUpperCase() || '-')
                        )
                    ),
                    // Lado derecho - compacto
                    React.createElement('div', { className: "flex items-center gap-2" },
                        // Selector de Slot
                        React.createElement('select', {
                            value: selectedSlot,
                            onChange: (e) => { e.stopPropagation(); setSelectedSlot(e.target.value); },
                            onClick: (e) => e.stopPropagation(),
                            className: "bg-neutral-800/80 border border-neutral-600 rounded px-2 py-1 text-[10px] text-gray-200 focus:outline-none"
                        },
                            availableSlots.length === 0
                                ? React.createElement('option', { value: '1' }, 'No Data')
                                : availableSlots.map(slot => React.createElement('option', { key: slot, value: slot }, `S${slot}`))
                        ),
                        // Se√±al principal compacta
                        React.createElement('div', {
                            className: "flex items-center gap-1 px-2 py-1 rounded font-bold",
                            style: {
                                background: signalColors.bg,
                                border: `1px solid ${signalColors.border}`,
                                color: signalColors.text,
                                boxShadow: tradingSignal.signal !== 'FLAT' ? `0 0 10px ${signalColors.glow}` : 'none'
                            }
                        },
                            React.createElement('span', { className: "text-sm font-bold" }, signalEmoji),
                            React.createElement('span', { className: "text-[10px] tracking-wide" }, tradingSignal.signal),
                            tradingSignal.confidence > 0 && React.createElement('span', {
                                className: "text-[9px] opacity-70"
                            }, `${tradingSignal.confidence}%`)
                        ),
                        // Bot√≥n config
                        React.createElement('button', {
                            onClick: (e) => { e.stopPropagation(); setIsConfigOpen(!isConfigOpen); },
                            className: `px-1.5 py-1 rounded transition-all text-[9px] ${isConfigOpen ? 'bg-sky-600 text-white' : 'bg-neutral-700/50 text-neutral-400 hover:bg-neutral-600'}`
                        }, "‚öô"),
                        // Bot√≥n gr√°fico de historial (con indicador de perfil)
                        React.createElement('button', {
                            onClick: (e) => { e.stopPropagation(); setShowPriceChart(!showPriceChart); },
                            className: `px-1.5 py-1 rounded transition-all text-[9px] ${showPriceChart ? (profileData ? 'bg-emerald-600 text-white' : 'bg-sky-600 text-white') : (profileData ? 'bg-emerald-900/50 text-emerald-400 border border-emerald-700' : 'bg-neutral-700/50 text-neutral-400 hover:bg-neutral-600')}`,
                            title: profileData ? 'Historial + Perfil por Strikes (Vol cargado)' : 'Historial de Precios (Sin perfil - carga chain.csv con Vol)'
                        }, profileData ? "H+" : "H"),
                        // Bot√≥n backtest
                        React.createElement('button', {
                            onClick: (e) => { e.stopPropagation(); setShowBacktest(!showBacktest); },
                            className: `px-1.5 py-1 rounded transition-all text-[9px] ${showBacktest ? 'bg-purple-600 text-white' : 'bg-neutral-700/50 text-neutral-400 hover:bg-neutral-600'}`,
                            title: 'Backtest Results'
                        }, "B"),
                        // Bot√≥n sonido
                        React.createElement('button', {
                            onClick: (e) => { e.stopPropagation(); setSoundEnabled(!soundEnabled); },
                            className: `px-1.5 py-1 rounded transition-all text-[9px] ${soundEnabled ? 'bg-amber-600 text-white' : 'bg-neutral-700/50 text-neutral-400 hover:bg-neutral-600'}`,
                            title: soundEnabled ? 'Sonido activado' : 'Sonido desactivado'
                        }, soundEnabled ? "‚ô™" : "‚ô™"),
                        // Bot√≥n MT5
                        React.createElement('button', {
                            onClick: (e) => { e.stopPropagation(); setMt5Enabled(!mt5Enabled); },
                            className: `px-1.5 py-1 rounded transition-all text-[9px] font-bold ${mt5Enabled ? (mt5Connected ? 'bg-blue-600 text-white' : 'bg-yellow-600 text-white animate-pulse') : 'bg-neutral-700/50 text-neutral-400 hover:bg-neutral-600'}`,
                            title: mt5Connected ? 'MT5 Conectado' : (mt5Enabled ? 'Conectando...' : 'Conectar MT5')
                        }, "M5"),
                        // Indicador expandir
                        React.createElement('span', {
                            className: "text-neutral-500 text-sm transition-transform duration-200",
                            style: { transform: isExpanded ? 'rotate(0deg)' : 'rotate(-90deg)' }
                        }, "‚ñº")
                    )
                ),

                // ===== BODY =====
                isExpanded && React.createElement('div', { className: "p-3" },

                    // ----- Panel de Configuraci√≥n (colapsable) -----
                    isConfigOpen && React.createElement('div', {
                        className: "mb-4 p-4 rounded-xl bg-neutral-800/30 border border-neutral-700/50 space-y-4"
                    },
                        // Titulo
                        React.createElement('div', { className: "flex items-center justify-between border-b border-neutral-700/50 pb-3" },
                            React.createElement('h4', { className: "text-sm font-bold text-sky-400 uppercase tracking-wider" }, "Configuracion de Senales"),
                            React.createElement('span', { className: "text-[10px] text-neutral-500" }, "Selecciona el tipo de senal")
                        ),

                        // Fila 1 y 2: Par√°metros de Algoritmos usados en Slots
                        (() => {
                            // Obtener algoritmos √∫nicos de los slots habilitados
                            const usedAlgorithms = [...new Set(signalSlots.filter(s => s.enabled).map(s => s.algorithm))];

                            return React.createElement('div', { className: "p-3 rounded-lg bg-neutral-900/50 border border-neutral-700/50" },
                                React.createElement('label', { className: "block text-xs font-semibold text-neutral-400 mb-3 uppercase tracking-wider" },
                                    'Par√°metros de Algoritmos (' + usedAlgorithms.length + ' en uso)'
                                ),
                                React.createElement('div', { className: "space-y-3" },
                                    usedAlgorithms.includes('evolution') && React.createElement('div', { className: "flex items-center gap-4 p-2 bg-cyan-900/20 rounded border border-cyan-800/30" },
                                        React.createElement('span', { className: "text-[10px] font-bold text-cyan-400 w-20" }, "Evolution"),
                                        React.createElement('div', null,
                                            React.createElement('span', { className: "text-[9px] text-neutral-500 block" }, "SMA"),
                                            React.createElement('input', {
                                                type: 'number', min: 2, max: 50,
                                                value: signalParams.evolution?.smaPeriod || 14,
                                                onChange: function (e) { setSignalParams(function (prev) { return Object.assign({}, prev, { evolution: { smaPeriod: parseInt(e.target.value) || 14 } }); }); },
                                                className: "w-16 px-1.5 py-1 text-xs bg-neutral-800 border border-neutral-600 rounded text-center text-gray-200"
                                            })
                                        )
                                    ),
                                    usedAlgorithms.includes('intensity') && React.createElement('div', { className: "flex items-center gap-4 p-2 bg-sky-900/20 rounded border border-sky-800/30" },
                                        React.createElement('span', { className: "text-[10px] font-bold text-sky-400 w-20" }, "Intensity"),
                                        React.createElement('div', null,
                                            React.createElement('span', { className: "text-[9px] text-neutral-500 block" }, "SMA"),
                                            React.createElement('input', {
                                                type: 'number', min: 2, max: 50,
                                                value: signalParams.intensity?.smaPeriod || 14,
                                                onChange: function (e) { setSignalParams(function (prev) { return Object.assign({}, prev, { intensity: { smaPeriod: parseInt(e.target.value) || 14 } }); }); },
                                                className: "w-16 px-1.5 py-1 text-xs bg-neutral-800 border border-neutral-600 rounded text-center text-gray-200"
                                            })
                                        )
                                    ),
                                    usedAlgorithms.includes('towindicator') && React.createElement('div', { className: "flex items-center gap-4 p-2 bg-orange-900/20 rounded border border-orange-800/30" },
                                        React.createElement('span', { className: "text-[10px] font-bold text-orange-400 w-20" }, "TOW Ind"),
                                        React.createElement('div', null,
                                            React.createElement('span', { className: "text-[9px] text-neutral-500 block" }, "SMA"),
                                            React.createElement('input', {
                                                type: 'number', min: 2, max: 30,
                                                value: signalParams.towindicator?.smaPeriod || 8,
                                                onChange: function (e) { setSignalParams(function (prev) { return Object.assign({}, prev, { towindicator: { smaPeriod: parseInt(e.target.value) || 8 } }); }); },
                                                className: "w-16 px-1.5 py-1 text-xs bg-neutral-800 border border-neutral-600 rounded text-center text-gray-200"
                                            })
                                        )
                                    ),
                                    usedAlgorithms.includes('dominance') && React.createElement('div', { className: "flex items-center gap-4 p-2 bg-emerald-900/20 rounded border border-emerald-800/30" },
                                        React.createElement('span', { className: "text-[10px] font-bold text-emerald-400 w-20" }, "Dominance"),
                                        React.createElement('div', null,
                                            React.createElement('span', { className: "text-[9px] text-neutral-500 block" }, "Ratio"),
                                            React.createElement('input', {
                                                type: 'number', step: 0.1, min: 1, max: 5,
                                                value: signalParams.dominance?.ratio || 2,
                                                onChange: function (e) { setSignalParams(function (prev) { return Object.assign({}, prev, { dominance: Object.assign({}, prev.dominance || {}, { ratio: parseFloat(e.target.value) || 2 }) }); }); },
                                                className: "w-16 px-1.5 py-1 text-xs bg-neutral-800 border border-neutral-600 rounded text-center text-gray-200"
                                            })
                                        ),
                                        React.createElement('div', null,
                                            React.createElement('span', { className: "text-[9px] text-neutral-500 block" }, "Lookback"),
                                            React.createElement('input', {
                                                type: 'number', min: 5, max: 100,
                                                value: signalParams.dominance?.lookback || 30,
                                                onChange: function (e) { setSignalParams(function (prev) { return Object.assign({}, prev, { dominance: Object.assign({}, prev.dominance || {}, { lookback: parseInt(e.target.value) || 30 }) }); }); },
                                                className: "w-16 px-1.5 py-1 text-xs bg-neutral-800 border border-neutral-600 rounded text-center text-gray-200"
                                            })
                                        ),
                                        React.createElement('div', null,
                                            React.createElement('span', { className: "text-[9px] text-neutral-500 block" }, "SMA"),
                                            React.createElement('input', {
                                                type: 'number', min: 2, max: 30,
                                                value: signalParams.dominance?.smaPeriod || 8,
                                                onChange: function (e) { setSignalParams(function (prev) { return Object.assign({}, prev, { dominance: Object.assign({}, prev.dominance || {}, { smaPeriod: parseInt(e.target.value) || 8 }) }); }); },
                                                className: "w-16 px-1.5 py-1 text-xs bg-neutral-800 border border-neutral-600 rounded text-center text-gray-200"
                                            })
                                        )
                                    ),
                                    usedAlgorithms.includes('towforce') && React.createElement('div', { className: "flex items-center gap-4 p-2 bg-purple-900/20 rounded border border-purple-800/30" },
                                        React.createElement('span', { className: "text-[10px] font-bold text-purple-400 w-20" }, "TOW Force"),
                                        React.createElement('div', null,
                                            React.createElement('span', { className: "text-[9px] text-neutral-500 block" }, "SMA"),
                                            React.createElement('input', {
                                                type: 'number', min: 2, max: 30,
                                                value: signalParams.towforce?.smaPeriod || 8,
                                                onChange: function (e) { setSignalParams(function (prev) { return Object.assign({}, prev, { towforce: { smaPeriod: parseInt(e.target.value) || 8 } }); }); },
                                                className: "w-16 px-1.5 py-1 text-xs bg-neutral-800 border border-neutral-600 rounded text-center text-gray-200"
                                            })
                                        )
                                    ),
                                    usedAlgorithms.includes('keltner') && React.createElement('div', { className: "flex items-center gap-4 p-2 bg-teal-900/20 rounded border border-teal-800/30" },
                                        React.createElement('span', { className: "text-[10px] font-bold text-teal-400 w-20" }, "Keltner"),
                                        React.createElement('div', null,
                                            React.createElement('span', { className: "text-[9px] text-neutral-500 block" }, "EMA"),
                                            React.createElement('input', {
                                                type: 'number', min: 5, max: 50,
                                                value: signalParams.keltner?.emaPeriod || 20,
                                                onChange: function (e) { setSignalParams(function (prev) { return Object.assign({}, prev, { keltner: Object.assign({}, prev.keltner || {}, { emaPeriod: parseInt(e.target.value) || 20 }) }); }); },
                                                className: "w-16 px-1.5 py-1 text-xs bg-neutral-800 border border-neutral-600 rounded text-center text-gray-200"
                                            })
                                        ),
                                        React.createElement('div', null,
                                            React.createElement('span', { className: "text-[9px] text-neutral-500 block" }, "ATR√ó"),
                                            React.createElement('input', {
                                                type: 'number', step: 0.5, min: 1, max: 5,
                                                value: signalParams.keltner?.atrMultiplier || 3.0,
                                                onChange: function (e) { setSignalParams(function (prev) { return Object.assign({}, prev, { keltner: Object.assign({}, prev.keltner || {}, { atrMultiplier: parseFloat(e.target.value) || 3.0 }) }); }); },
                                                className: "w-16 px-1.5 py-1 text-xs bg-neutral-800 border border-neutral-600 rounded text-center text-gray-200"
                                            })
                                        )
                                    ),
                                    usedAlgorithms.includes('rsi') && React.createElement('div', { className: "flex items-center gap-4 p-2 bg-pink-900/20 rounded border border-pink-800/30" },
                                        React.createElement('span', { className: "text-[10px] font-bold text-pink-400 w-20" }, "RSI"),
                                        React.createElement('div', null,
                                            React.createElement('span', { className: "text-[9px] text-neutral-500 block" }, "Period"),
                                            React.createElement('input', {
                                                type: 'number', min: 5, max: 50,
                                                value: signalParams.rsi?.period || 14,
                                                onChange: function (e) { setSignalParams(function (prev) { return Object.assign({}, prev, { rsi: Object.assign({}, prev.rsi || {}, { period: parseInt(e.target.value) || 14 }) }); }); },
                                                className: "w-16 px-1.5 py-1 text-xs bg-neutral-800 border border-neutral-600 rounded text-center text-gray-200"
                                            })
                                        ),
                                        React.createElement('div', null,
                                            React.createElement('span', { className: "text-[9px] text-neutral-500 block" }, "OB"),
                                            React.createElement('input', {
                                                type: 'number', min: 50, max: 90,
                                                value: signalParams.rsi?.overbought || 60,
                                                onChange: function (e) { setSignalParams(function (prev) { return Object.assign({}, prev, { rsi: Object.assign({}, prev.rsi || {}, { overbought: parseInt(e.target.value) || 60 }) }); }); },
                                                className: "w-16 px-1.5 py-1 text-xs bg-neutral-800 border border-neutral-600 rounded text-center text-gray-200"
                                            })
                                        ),
                                        React.createElement('div', null,
                                            React.createElement('span', { className: "text-[9px] text-neutral-500 block" }, "OS"),
                                            React.createElement('input', {
                                                type: 'number', min: 10, max: 50,
                                                value: signalParams.rsi?.oversold || 40,
                                                onChange: function (e) { setSignalParams(function (prev) { return Object.assign({}, prev, { rsi: Object.assign({}, prev.rsi || {}, { oversold: parseInt(e.target.value) || 40 }) }); }); },
                                                className: "w-16 px-1.5 py-1 text-xs bg-neutral-800 border border-neutral-600 rounded text-center text-gray-200"
                                            })
                                        )
                                    ),
                                    usedAlgorithms.includes('correlation') && React.createElement('div', { className: "flex items-center gap-4 p-2 bg-amber-900/20 rounded border border-amber-800/30" },
                                        React.createElement('span', { className: "text-[10px] font-bold text-amber-400 w-20" }, "Correlation"),
                                        React.createElement('div', null,
                                            React.createElement('span', { className: "text-[9px] text-neutral-500 block" }, "Z Thr"),
                                            React.createElement('input', {
                                                type: 'number', step: 0.5, min: 1, max: 4,
                                                value: signalParams.correlation?.threshold || 2,
                                                onChange: function (e) { setSignalParams(function (prev) { return Object.assign({}, prev, { correlation: Object.assign({}, prev.correlation || {}, { threshold: parseFloat(e.target.value) || 2 }) }); }); },
                                                className: "w-16 px-1.5 py-1 text-xs bg-neutral-800 border border-neutral-600 rounded text-center text-gray-200"
                                            })
                                        ),
                                        React.createElement('div', null,
                                            React.createElement('span', { className: "text-[9px] text-neutral-500 block" }, "SMA"),
                                            React.createElement('input', {
                                                type: 'number', min: 2, max: 20,
                                                value: signalParams.correlation?.smaPeriod || 5,
                                                onChange: function (e) { setSignalParams(function (prev) { return Object.assign({}, prev, { correlation: Object.assign({}, prev.correlation || {}, { smaPeriod: parseInt(e.target.value) || 5 }) }); }); },
                                                className: "w-16 px-1.5 py-1 text-xs bg-neutral-800 border border-neutral-600 rounded text-center text-gray-200"
                                            })
                                        )
                                    ),
                                    usedAlgorithms.length === 0 && React.createElement('div', { className: "text-xs text-neutral-500 text-center py-2" },
                                        "Habilita al menos un slot para ver par√°metros"
                                    )
                                )
                            );
                        })(),

                        // Fila 3: NUEVO - Signal Slots (M√©trica + Algoritmo por slot)
                        React.createElement('div', { className: "space-y-3" },
                            React.createElement('label', { className: "block text-xs font-semibold text-neutral-400 mb-2 uppercase tracking-wider" },
                                'Signal Slots - M√©trica + Algoritmo (' + signalSlots.filter(s => s.enabled).length + '/4)'
                            ),
                            // Grid de 4 Slots
                            React.createElement('div', { className: "grid grid-cols-2 lg:grid-cols-4 gap-2" },
                                signalSlots.map(function (slot) {
                                    const metric = constants.SIGNAL_METRICS[slot.metric];
                                    const algorithm = constants.SIGNAL_ALGORITHMS[slot.algorithm];

                                    return React.createElement('div', {
                                        key: slot.id,
                                        className: `p-2 rounded-lg border transition-all ${slot.enabled
                                            ? 'bg-neutral-800/60 border-neutral-600'
                                            : 'bg-neutral-900/40 border-neutral-800 opacity-50'}`,
                                    },
                                        // Header con toggle
                                        React.createElement('div', { className: "flex items-center justify-between mb-2" },
                                            React.createElement('span', { className: "text-[10px] font-bold text-neutral-300" }, `Slot ${slot.id}`),
                                            React.createElement('button', {
                                                onClick: function () {
                                                    setSignalSlots(function (prev) {
                                                        return prev.map(function (s) {
                                                            return s.id === slot.id ? Object.assign({}, s, { enabled: !s.enabled }) : s;
                                                        });
                                                    });
                                                },
                                                className: `w-8 h-4 rounded-full transition-all ${slot.enabled ? 'bg-sky-500' : 'bg-neutral-700'}`,
                                                style: { position: 'relative' }
                                            },
                                                React.createElement('div', {
                                                    className: "w-3 h-3 rounded-full bg-white absolute top-0.5 transition-all",
                                                    style: { left: slot.enabled ? '16px' : '2px' }
                                                })
                                            )
                                        ),
                                        // Selector de M√©trica
                                        React.createElement('div', { className: "mb-1.5" },
                                            React.createElement('span', { className: "text-[8px] text-neutral-500 uppercase" }, "M√©trica"),
                                            React.createElement('select', {
                                                value: slot.metric,
                                                onChange: function (e) {
                                                    setSignalSlots(function (prev) {
                                                        return prev.map(function (s) {
                                                            return s.id === slot.id ? Object.assign({}, s, { metric: e.target.value }) : s;
                                                        });
                                                    });
                                                },
                                                disabled: !slot.enabled,
                                                className: "w-full px-1.5 py-1 text-[9px] bg-neutral-900 border border-neutral-700 rounded text-gray-200 focus:outline-none focus:border-sky-500"
                                            },
                                                Object.entries(constants.SIGNAL_METRICS).map(function ([key, m]) {
                                                    return React.createElement('option', { key: key, value: key }, m.shortLabel + ' - ' + m.label);
                                                })
                                            )
                                        ),
                                        // Selector de Algoritmo
                                        React.createElement('div', null,
                                            React.createElement('span', { className: "text-[8px] text-neutral-500 uppercase" }, "Algoritmo"),
                                            React.createElement('select', {
                                                value: slot.algorithm,
                                                onChange: function (e) {
                                                    setSignalSlots(function (prev) {
                                                        return prev.map(function (s) {
                                                            return s.id === slot.id ? Object.assign({}, s, { algorithm: e.target.value }) : s;
                                                        });
                                                    });
                                                },
                                                disabled: !slot.enabled,
                                                className: "w-full px-1.5 py-1 text-[9px] bg-neutral-900 border border-neutral-700 rounded text-gray-200 focus:outline-none focus:border-sky-500"
                                            },
                                                Object.entries(constants.SIGNAL_ALGORITHMS).map(function ([key, a]) {
                                                    return React.createElement('option', {
                                                        key: key,
                                                        value: key,
                                                        style: { color: a.color }
                                                    }, a.shortLabel + ' - ' + a.label);
                                                })
                                            )
                                        ),
                                        // Preview del color del algoritmo
                                        algorithm && React.createElement('div', {
                                            className: "mt-1.5 h-1 rounded-full",
                                            style: { backgroundColor: algorithm.color }
                                        })
                                    );
                                })
                            ),
                            // Confirmaci√≥n M√≠nima
                            React.createElement('div', { className: "flex items-center gap-3 mt-3" },
                                React.createElement('span', { className: "text-[10px] text-neutral-500" }, "Confirmaci√≥n:"),
                                [1, 2, 3, 4].map(function (num) {
                                    const enabledCount = signalSlots.filter(s => s.enabled).length;
                                    const isDisabled = num > enabledCount;
                                    return React.createElement('button', {
                                        key: num,
                                        onClick: function () { if (!isDisabled) setMinConfirmation(num); },
                                        className: 'w-8 h-8 rounded text-xs font-bold transition-all ' + (minConfirmation === num
                                            ? 'bg-sky-600 text-white'
                                            : isDisabled
                                                ? 'bg-neutral-800 text-neutral-600 cursor-not-allowed'
                                                : 'bg-neutral-700/50 text-neutral-400 hover:bg-neutral-600')
                                    }, num);
                                }),
                                React.createElement('span', { className: "text-[9px] text-neutral-500 ml-2" },
                                    `(${minConfirmation} de ${signalSlots.filter(s => s.enabled).length} slots activos)`
                                )
                            )
                        ),

                        // ----- MT5 Bridge Config -----
                        mt5Enabled && React.createElement('div', { className: "pt-4 border-t border-neutral-700/50" },
                            React.createElement('h5', { className: "text-xs font-bold text-blue-400 mb-3 uppercase tracking-wider" }, "MT5 BRIDGE"),

                            React.createElement('div', { className: "flex items-center gap-2 mb-3" },
                                React.createElement('div', { className: `w-2 h-2 rounded-full ${mt5Connected ? 'bg-blue-500 animate-pulse' : 'bg-red-500'}` }),
                                React.createElement('span', { className: "text-xs text-neutral-400" },
                                    mt5Connected
                                        ? `Conectado | Bal: ${mt5Status?.account?.balance?.toFixed(2) || '0'} ${mt5Status?.account?.currency || ''}`
                                        : 'Desconectado - Ejecutar MT5_Bridge.py'
                                )
                            ),

                            React.createElement('div', { className: "grid grid-cols-2 gap-3 mb-3" },
                                React.createElement('div', null,
                                    React.createElement('label', { className: "text-[10px] text-neutral-500 block mb-1" }, "Simbolo"),
                                    React.createElement('input', {
                                        type: 'text',
                                        value: mt5Symbol,
                                        onChange: (e) => setMt5Symbol(e.target.value.toUpperCase()),
                                        className: "w-full px-2 py-1.5 text-xs bg-neutral-800 border border-neutral-600 rounded text-gray-200"
                                    })
                                ),
                                React.createElement('div', null,
                                    React.createElement('label', { className: "text-[10px] text-neutral-500 block mb-1" }, "Volumen"),
                                    React.createElement('input', {
                                        type: 'number',
                                        step: '0.01',
                                        min: '0.01',
                                        value: mt5Volume,
                                        onChange: (e) => setMt5Volume(parseFloat(e.target.value) || 0.01),
                                        className: "w-full px-2 py-1.5 text-xs bg-neutral-800 border border-neutral-600 rounded text-gray-200"
                                    })
                                )
                            ),

                            React.createElement('div', { className: "flex items-center justify-between mb-3" },
                                React.createElement('span', { className: "text-xs text-neutral-400" }, "Auto-Trade"),
                                React.createElement('button', {
                                    onClick: () => setMt5AutoTrade(!mt5AutoTrade),
                                    className: `px-3 py-1 rounded text-xs font-bold transition-all ${mt5AutoTrade ? 'bg-blue-600 text-white' : 'bg-neutral-700 text-neutral-400'}`
                                }, mt5AutoTrade ? "ON" : "OFF")
                            ),

                            React.createElement('div', { className: "flex gap-2 mb-3" },
                                React.createElement('button', {
                                    onClick: () => sendSignalToMT5('BUY'),
                                    disabled: !mt5Connected,
                                    className: "flex-1 py-2 rounded text-xs font-bold bg-blue-600 hover:bg-blue-500 text-white disabled:opacity-50 disabled:cursor-not-allowed transition-all"
                                }, "BUY"),
                                React.createElement('button', {
                                    onClick: () => sendSignalToMT5('SELL'),
                                    disabled: !mt5Connected,
                                    className: "flex-1 py-2 rounded text-xs font-bold bg-red-600 hover:bg-red-500 text-white disabled:opacity-50 disabled:cursor-not-allowed transition-all"
                                }, "SELL"),
                                React.createElement('button', {
                                    onClick: () => closeMT5Position(),
                                    disabled: !mt5Connected,
                                    className: "flex-1 py-2 rounded text-xs font-bold bg-neutral-600 hover:bg-neutral-500 text-white disabled:opacity-50 disabled:cursor-not-allowed transition-all"
                                }, "CLOSE")
                            ),

                            mt5Positions.length > 0 && React.createElement('div', null,
                                React.createElement('span', { className: "text-[10px] text-neutral-500 block mb-1" }, `Posiciones (${mt5Positions.length})`),
                                React.createElement('div', { className: "max-h-20 overflow-y-auto space-y-1" },
                                    mt5Positions.map((pos, idx) =>
                                        React.createElement('div', {
                                            key: idx,
                                            className: "flex items-center justify-between text-[10px] bg-neutral-800/50 px-2 py-1 rounded"
                                        },
                                            React.createElement('span', { className: pos.type === 'BUY' ? 'text-blue-400' : 'text-red-400' },
                                                `${pos.type} ${pos.volume} ${pos.symbol}`
                                            ),
                                            React.createElement('span', { className: pos.profit >= 0 ? 'text-blue-400' : 'text-red-400' },
                                                `${pos.profit >= 0 ? '+' : ''}${pos.profit.toFixed(2)}`
                                            ),
                                            React.createElement('button', {
                                                onClick: () => closeMT5Position(pos.ticket),
                                                className: "text-neutral-500 hover:text-red-400"
                                            }, "X")
                                        )
                                    )
                                )
                            )
                        )
                    ),

                    // ----- Panel de Backtest Results -----
                    showBacktest && backtestData && React.createElement('div', {
                        className: "mb-4 p-4 rounded-xl bg-gradient-to-r from-purple-900/30 to-indigo-900/30 border border-purple-500/30"
                    },
                        React.createElement('div', { className: "flex justify-between items-center mb-3" },
                            React.createElement('h4', { className: "text-sm font-bold text-purple-300" }, "BACKTEST RESULTS"),
                            React.createElement('span', { className: `text-sm font-bold ${backtestData.totalPnl >= 0 ? 'text-blue-400' : 'text-red-400'}` },
                                (backtestData.totalPnl >= 0 ? '+' : '') + backtestData.totalPnl.toFixed(2) + ' pts'
                            )
                        ),
                        React.createElement('div', { className: "grid grid-cols-4 gap-3 text-center" },
                            React.createElement('div', { className: "bg-neutral-800/50 rounded-lg p-2" },
                                React.createElement('div', { className: "text-lg font-bold text-white" }, backtestData.trades),
                                React.createElement('div', { className: "text-[10px] text-neutral-400" }, "TRADES")
                            ),
                            React.createElement('div', { className: "bg-neutral-800/50 rounded-lg p-2" },
                                React.createElement('div', { className: `text-lg font-bold ${backtestData.winRate >= 50 ? 'text-blue-400' : 'text-red-400'}` }, backtestData.winRate.toFixed(1) + '%'),
                                React.createElement('div', { className: "text-[10px] text-neutral-400" }, "WIN RATE")
                            ),
                            React.createElement('div', { className: "bg-neutral-800/50 rounded-lg p-2" },
                                React.createElement('div', { className: `text-lg font-bold ${backtestData.profitFactor >= 1 ? 'text-blue-400' : 'text-red-400'}` }, backtestData.profitFactor.toFixed(2)),
                                React.createElement('div', { className: "text-[10px] text-neutral-400" }, "PROFIT F.")
                            ),
                            React.createElement('div', { className: "bg-neutral-800/50 rounded-lg p-2" },
                                React.createElement('div', { className: "text-lg font-bold text-red-400" }, backtestData.maxDrawdown.toFixed(2)),
                                React.createElement('div', { className: "text-[10px] text-neutral-400" }, "MAX DD")
                            )
                        ),
                        React.createElement('div', { className: "mt-3 grid grid-cols-2 gap-2 text-xs" },
                            React.createElement('div', { className: "flex justify-between bg-blue-900/20 rounded px-2 py-1" },
                                React.createElement('span', { className: "text-blue-400" }, "Winners: " + backtestData.winners),
                                React.createElement('span', { className: "text-blue-300" }, "Avg: +" + backtestData.avgWin.toFixed(2))
                            ),
                            React.createElement('div', { className: "flex justify-between bg-red-900/20 rounded px-2 py-1" },
                                React.createElement('span', { className: "text-red-400" }, "Losers: " + backtestData.losers),
                                React.createElement('span', { className: "text-red-300" }, "Avg: -" + backtestData.avgLoss.toFixed(2))
                            )
                        )
                    ),
                    showBacktest && !backtestData && React.createElement('div', {
                        className: "mb-4 p-4 rounded-xl bg-neutral-800/30 border border-neutral-700/50 text-center text-neutral-500"
                    }, "Activa HIST primero para calcular backtest"),

                    // ----- Gr√°fico de Precios con Historial de Se√±ales -----
                    showPriceChart && React.createElement('div', {
                        className: "mb-4 rounded-xl bg-neutral-800/30 border border-neutral-700/50 overflow-hidden"
                    },
                        // Header con t√≠tulo y botones (igual que los dem√°s gr√°ficos)
                        React.createElement('div', {
                            className: "flex justify-between items-center p-2 bg-neutral-800/50 border-b border-neutral-700"
                        },
                            React.createElement('h3', {
                                className: "text-xs font-semibold text-gray-200"
                            }, "Price & Volume Profile"),
                            React.createElement('div', { className: "flex items-center gap-1" },
                                // Reset Zoom
                                React.createElement('button', {
                                    className: "p-1.5 rounded-md bg-neutral-700/50 hover:bg-neutral-600/70 text-gray-300 transition-colors",
                                    onClick: handlePriceChartResetZoom,
                                    title: "Reset Zoom"
                                }, React.createElement('svg', { width: 14, height: 14, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: 2 },
                                    React.createElement('path', { d: "M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8" }),
                                    React.createElement('path', { d: "M3 3v5h5" })
                                )),
                                // Telegram
                                React.createElement('button', {
                                    className: "p-1.5 rounded-md bg-blue-600/50 hover:bg-blue-500/70 text-blue-200 transition-colors",
                                    onClick: handlePriceChartTelegram,
                                    title: "Send to Telegram"
                                }, "TG"),
                                // Download
                                React.createElement('button', {
                                    className: "p-1.5 rounded-md bg-neutral-700/50 hover:bg-neutral-600/70 text-gray-300 transition-colors",
                                    onClick: handlePriceChartDownload,
                                    title: "Download Chart"
                                }, React.createElement('svg', { width: 14, height: 14, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: 2 },
                                    React.createElement('path', { d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" }),
                                    React.createElement('polyline', { points: "7 10 12 15 17 10" }),
                                    React.createElement('line', { x1: 12, y1: 15, x2: 12, y2: 3 })
                                ))
                            )
                        ),
                        // Contenedor del gr√°fico
                        React.createElement('div', {
                            className: "p-3"
                        },
                            React.createElement('div', {
                                ref: priceChartRef,
                                style: { width: '100%', height: '500px' }
                            }),
                            signalHistoryData.length === 0 && React.createElement('div', {
                                className: "flex items-center justify-center h-[500px] text-neutral-500"
                            }, "Cargando historial de se√±ales...")
                        )
                    ),

                    // ----- Grid de Signal Slots con M√©trica + Algoritmo -----
                    React.createElement('div', { className: "grid grid-cols-2 md:grid-cols-4 gap-3 mb-4" },
                        tradingSignal.details.map(detail => {
                            const metricConfig = constants.SIGNAL_METRICS[detail.metric];
                            const algorithmConfig = constants.SIGNAL_ALGORITHMS[detail.algorithm];
                            const currentSettings = indicatorSettings[detail.key] || {};
                            const currentThreshold = currentSettings.thresholds || {};
                            const smaPeriod = currentSettings.sma ?? globalConfig.sma ?? 10;
                            const callColor = detail.colors?.call ?? currentSettings.colors?.call ?? globalConfig.callColor ?? '#4a9eff';
                            const putColor = detail.colors?.put ?? currentSettings.colors?.put ?? globalConfig.putColor ?? '#ff4444';
                            const detailColors = getSignalColor(detail.signal);

                            return React.createElement('div', {
                                key: detail.key,
                                className: "relative p-3 rounded-xl transition-all overflow-hidden group",
                                style: {
                                    background: `linear-gradient(135deg, ${detailColors.bg} 0%, rgba(23,23,23,0.9) 100%)`,
                                    border: `1px solid ${detailColors.border}50`,
                                    boxShadow: detail.signal !== 'FLAT' ? `0 0 20px ${detailColors.glow}` : 'none'
                                }
                            },
                                // Barra de fuerza (background)
                                React.createElement('div', {
                                    className: "absolute bottom-0 left-0 h-1 transition-all duration-500",
                                    style: {
                                        width: `${detail.strength}%`,
                                        background: `linear-gradient(90deg, ${detailColors.border} 0%, ${detailColors.text} 100%)`
                                    }
                                }),

                                // Header con Slot ID + M√©trica
                                React.createElement('div', { className: "flex items-center justify-between mb-1" },
                                    React.createElement('div', { className: "flex items-center gap-2" },
                                        React.createElement('span', { className: "text-[8px] text-neutral-600 font-bold" }, `#${detail.slotId}`),
                                        React.createElement('span', {
                                            className: "text-[10px] font-bold uppercase tracking-wider",
                                            style: { color: detailColors.text }
                                        }, detail.label || metricConfig?.shortLabel || detail.metric),
                                        React.createElement('span', {
                                            className: "w-2 h-2 rounded-full",
                                            style: {
                                                backgroundColor: detail.signal === 'BULLISH' ? '#4a9eff' : detail.signal === 'BEARISH' ? '#ff4444' : '#6b7280',
                                                boxShadow: detail.signal !== 'FLAT' ? `0 0 6px ${detail.signal === 'BULLISH' ? '#4a9eff' : '#ff4444'}` : 'none'
                                            }
                                        })
                                    )
                                ),

                                // Algoritmo usado (con color caracter√≠stico)
                                React.createElement('div', { className: "flex items-center gap-1.5 mb-2" },
                                    React.createElement('div', {
                                        className: "w-1.5 h-1.5 rounded-full",
                                        style: { backgroundColor: detail.algorithmColor || algorithmConfig?.color || '#6b7280' }
                                    }),
                                    React.createElement('span', {
                                        className: "text-[8px] font-medium",
                                        style: { color: detail.algorithmColor || algorithmConfig?.color || '#9ca3af' }
                                    }, detail.algorithmLabel || algorithmConfig?.shortLabel || detail.algorithm)
                                ),

                                // Valor principal
                                React.createElement('div', {
                                    className: "text-2xl font-mono font-bold mb-1",
                                    style: { color: detailColors.text }
                                },
                                    typeof detail.value === 'number' ? detail.value.toFixed(3) : '-'
                                ),

                                // Fuerza y estad√≠sticas adicionales
                                React.createElement('div', { className: "flex flex-wrap items-center gap-x-3 gap-y-1 text-[9px] text-neutral-500" },
                                    React.createElement('span', null, `${detail.strength}%`),
                                    React.createElement('span', {
                                        style: { color: (detail.callValue - detail.putValue) >= 0 ? '#4a9eff' : '#ff4444' }
                                    }, `Net: ${services.signalCalculator.formatNumber(detail.callValue - detail.putValue)}`),
                                    detail.netForce !== undefined && detail.netForce !== 0 &&
                                    React.createElement('span', null, `NF: ${services.signalCalculator.formatNumber(detail.netForce)}`)
                                ),

                                // Call/Put Values con colores personalizados
                                React.createElement('div', { className: "flex gap-3 mt-1 text-[9px]" },
                                    React.createElement('span', { style: { color: callColor } },
                                        `C: ${services.signalCalculator.formatNumber(detail.callValue)}`
                                    ),
                                    React.createElement('span', { style: { color: putColor } },
                                        `P: ${services.signalCalculator.formatNumber(detail.putValue)}`
                                    ),
                                    detail.putValue > 0 && React.createElement('span', { className: "text-neutral-400" },
                                        `R: ${(detail.callValue / detail.putValue).toFixed(2)}`
                                    )
                                ),

                                // Mini Chart
                                React.createElement(components.MiniSignalChart, {
                                    indicatorKey: detail.metric,
                                    dataSource: dataSource,
                                    callColor: callColor,
                                    putColor: putColor,
                                    signalType: detail.algorithm
                                })
                            );
                        })
                    ),

                    // ----- POWER METERS CONTAINER (3 en columna, largos) -----
                    React.createElement('div', {
                        className: "flex flex-col gap-1.5 mb-3 p-2 rounded-lg transition-all duration-500",
                        style: {
                            background: metersAligned
                                ? `linear-gradient(135deg, ${metersAligned === 'BULLISH' ? 'rgba(34,197,94,0.15)' : 'rgba(239,68,68,0.15)'} 0%, rgba(23,23,23,0.5) 100%)`
                                : 'transparent',
                            border: metersAligned
                                ? `1px solid ${metersAligned === 'BULLISH' ? 'rgba(34,197,94,0.4)' : 'rgba(239,68,68,0.4)'}`
                                : '1px solid transparent',
                            boxShadow: metersAligned
                                ? `0 0 15px ${metersAligned === 'BULLISH' ? 'rgba(34,197,94,0.2)' : 'rgba(239,68,68,0.2)'}, inset 0 0 20px ${metersAligned === 'BULLISH' ? 'rgba(34,197,94,0.05)' : 'rgba(239,68,68,0.05)'}`
                                : 'none'
                        }
                    },
                        // Header con selector de umbral
                        React.createElement('div', { className: "flex items-center justify-between mb-1" },
                            React.createElement('span', { className: "text-[9px] text-neutral-500 uppercase tracking-wider font-semibold" },
                                "Power Meters"
                            ),
                            // Valores actuales (debug visual)
                            React.createElement('div', { className: "flex items-center gap-1 text-[7px] font-mono" },
                                React.createElement('span', {
                                    className: powerMeterValues.momentum > alignmentThreshold ? "text-cyan-400" :
                                        powerMeterValues.momentum < -alignmentThreshold ? "text-pink-400" : "text-neutral-600"
                                }, `M:${powerMeterValues.momentum.toFixed(0)}`),
                                React.createElement('span', {
                                    className: powerMeterValues.longTerm > alignmentThreshold ? "text-cyan-400" :
                                        powerMeterValues.longTerm < -alignmentThreshold ? "text-pink-400" : "text-neutral-600"
                                }, `L:${powerMeterValues.longTerm.toFixed(0)}`),
                                React.createElement('span', {
                                    className: powerMeterValues.correlation > alignmentThreshold ? "text-cyan-400" :
                                        powerMeterValues.correlation < -alignmentThreshold ? "text-pink-400" : "text-neutral-600"
                                }, `C:${powerMeterValues.correlation.toFixed(0)}`)
                            ),
                            // Selector de umbral para Big Alignment
                            React.createElement('div', { className: "flex items-center gap-1" },
                                React.createElement('span', { className: "text-[8px] text-neutral-600" }, "Big:"),
                                [10, 20, 30, 50].map(threshold =>
                                    React.createElement('button', {
                                        key: threshold,
                                        onClick: () => setAlignmentThreshold(threshold),
                                        className: `px-1.5 py-0.5 text-[8px] rounded font-bold transition-all ${alignmentThreshold === threshold
                                            ? 'bg-amber-600/50 text-amber-200'
                                            : 'bg-neutral-700/30 text-neutral-500 hover:bg-neutral-700/50'
                                            }`
                                    }, `${threshold}%`)
                                ),
                                // Contador de alineaciones filtradas por umbral actual
                                React.createElement('span', {
                                    className: `ml-2 px-1.5 py-0.5 text-[8px] rounded ${metersAligned === 'BULLISH' ? 'bg-cyan-600/30 text-cyan-300' :
                                        metersAligned === 'BEARISH' ? 'bg-pink-600/30 text-pink-300' :
                                            'bg-neutral-800 text-neutral-500'
                                        }`,
                                    title: "Estado de alineaci√≥n actual"
                                }, metersAligned ? `‚ö°${metersAligned}` : '‚óã')
                            )
                        ),
                        // 1. MOMENTUM POWER METER (corto plazo)
                        React.createElement(components.MomentumPowerMeter, {
                            dataSource: dataSource,
                            tradingSignal: tradingSignal,
                            globalConfig: globalConfig,
                            onValueChange: (type, value) => setPowerMeterValues(prev => ({ ...prev, [type]: value }))
                        }),
                        // 2. LONG TERM POWER METER (largo plazo)
                        React.createElement(components.LongTermPowerMeter, {
                            dataSource: dataSource,
                            globalConfig: globalConfig,
                            onValueChange: (type, value) => setPowerMeterValues(prev => ({ ...prev, [type]: value }))
                        }),
                        // 3. CORRELATION POWER METER
                        React.createElement(components.CorrelationPowerMeter, {
                            allSlotData: allSlotData,
                            globalConfig: globalConfig,
                            onValueChange: (type, value) => setPowerMeterValues(prev => ({ ...prev, [type]: value }))
                        })
                    ),

                    // ----- Main Signal Chart (fondo con gr√°fico) -----
                    React.createElement('div', {
                        className: "relative rounded-xl overflow-hidden mb-4",
                        style: {
                            background: metersAligned
                                ? `linear-gradient(135deg, ${metersAligned === 'BULLISH' ? 'rgba(34,197,94,0.25)' : 'rgba(239,68,68,0.25)'} 0%, rgba(15,15,15,0.95) 100%)`
                                : 'linear-gradient(135deg, rgba(50,50,50,0.3) 0%, rgba(15,15,15,0.95) 100%)',
                            border: metersAligned
                                ? `2px solid ${metersAligned === 'BULLISH' ? 'rgba(34,197,94,0.6)' : 'rgba(239,68,68,0.6)'}`
                                : `2px solid ${signalColors.border}40`,
                            boxShadow: metersAligned
                                ? `0 0 20px ${metersAligned === 'BULLISH' ? 'rgba(34,197,94,0.4)' : 'rgba(239,68,68,0.4)'}, inset 0 0 30px ${metersAligned === 'BULLISH' ? 'rgba(34,197,94,0.1)' : 'rgba(239,68,68,0.1)'}`
                                : 'none',
                            transition: 'all 0.5s ease'
                        }
                    },
                        // Indicador de alineaci√≥n
                        metersAligned && React.createElement('div', {
                            className: "absolute top-2 right-2 z-10 px-2 py-1 rounded text-[10px] font-bold uppercase tracking-wider animate-pulse",
                            style: {
                                background: metersAligned === 'BULLISH' ? 'rgba(34,197,94,0.3)' : 'rgba(239,68,68,0.3)',
                                color: metersAligned === 'BULLISH' ? '#22c55e' : '#ef4444',
                                border: `1px solid ${metersAligned === 'BULLISH' ? 'rgba(34,197,94,0.5)' : 'rgba(239,68,68,0.5)'}`
                            }
                        }, `‚ö° ${metersAligned} ALIGNED ‚ö°`),
                        React.createElement(components.MainSignalChart, {
                            dataSource: dataSource,
                            selectedIndicators: selectedIndicators,
                            signalType: signalType,
                            signalColors: signalColors,
                            callColor: globalConfig.callColor,
                            putColor: globalConfig.putColor
                        })
                    ),

                    // ----- Historial de Se√±ales (mini) -----
                    signalHistory.length > 0 && React.createElement('div', { className: "mt-4" },
                        React.createElement('div', { className: "flex items-center justify-between mb-2" },
                            React.createElement('span', { className: "text-[10px] font-semibold text-neutral-500 uppercase tracking-wider" }, "Historial Reciente"),
                            React.createElement('button', {
                                onClick: () => setSignalHistory([]),
                                className: "text-[9px] text-neutral-600 hover:text-neutral-400"
                            }, "Limpiar")
                        ),
                        React.createElement('div', { className: "flex gap-1.5 overflow-x-auto pb-1" },
                            signalHistory.map((entry, idx) => {
                                const histColors = getSignalColor(entry.signal);
                                return React.createElement('div', {
                                    key: idx,
                                    className: "flex-shrink-0 px-2 py-1 rounded-lg text-[9px] font-mono",
                                    style: {
                                        background: histColors.bg,
                                        border: `1px solid ${histColors.border}50`,
                                        color: histColors.text
                                    }
                                },
                                    React.createElement('div', null, entry.time),
                                    React.createElement('div', { className: "font-bold" }, `${entry.signal.charAt(0)} ${entry.confidence}%`)
                                );
                            })
                        )
                    )
                )
            );
        };
        // --- END: components/TradingSignalsPanel.tsx ---

        // --- START: components/MarketIntelligencePanel.tsx ---
        // Sistema de Inteligencia de Mercado con detecci√≥n de Compresiones, Pivots e Impulsos
        components.MarketIntelligencePanel = ({ dataSources, globalConfig, aiApiKey, aiNarratorEnabled, volumeProfileData, nasdaq100Sentiment }) => {
            const { useState, useEffect, useMemo, useCallback, useRef } = React;

            const [selectedSlot, setSelectedSlot] = useState('1');
            const [isAnalyzing, setIsAnalyzing] = useState(false);
            const [aiInsight, setAiInsight] = useState(null);
            const [analysisHistory, setAnalysisHistory] = useState([]);
            const [autoAnalyze, setAutoAnalyze] = useState(false);
            const [analysisInterval, setAnalysisInterval] = useState(30);
            const [isZoomed, setIsZoomed] = useState(false);
            const [showReport, setShowReport] = useState(false);
            const [showIntelligenceChart, setShowIntelligenceChart] = useState(true);

            // Sensibilidad de detectores (1=bajo, 2=medio, 3=alto)
            const [pivotSensitivity, setPivotSensitivity] = useState(2);
            const [compressionSensitivity, setCompressionSensitivity] = useState(2);
            const [impulseSensitivity, setImpulseSensitivity] = useState(2);
            const [volatilitySensitivity, setVolatilitySensitivity] = useState(2);
            const [confluenceSensitivity, setConfluenceSensitivity] = useState(2);
            const [tickOpportunitySensitivity, setTickOpportunitySensitivity] = useState(2);
            const [sweepSensitivity, setSweepSensitivity] = useState(2);
            const [absorptionSensitivity, setAbsorptionSensitivity] = useState(2);

            // Filtro de m√©tricas para pivots (null = todas, array = solo las seleccionadas)
            const [pivotMetricFilter, setPivotMetricFilter] = useState(null);
            const [showPivotMetricSelector, setShowPivotMetricSelector] = useState(false);

            // Filtro de m√©tricas para volatility
            const [volatilityMetricFilter, setVolatilityMetricFilter] = useState(null);
            const [showVolatilityMetricSelector, setShowVolatilityMetricSelector] = useState(false);

            // NUEVO: Filtro de m√©tricas para absorci√≥n (igual que pivots: null = todas, array = solo las seleccionadas)
            const [absorptionMetricFilter, setAbsorptionMetricFilter] = useState(null);
            const [showAbsorptionMetricSelector, setShowAbsorptionMetricSelector] = useState(false);

            // NUEVO: Filtro de m√©tricas para Tick Opportunity (an√°lisis causal)
            const [tickMetricFilter, setTickMetricFilter] = useState(null);
            const [showTickMetricSelector, setShowTickMetricSelector] = useState(false);
            const [tickAlgorithm, setTickAlgorithm] = useState('dominance'); // 'dominance', 'intensity', 'tow'
            const [tickLookback, setTickLookback] = useState(30);
            const [tickRatioThreshold, setTickRatioThreshold] = useState(2);
            const [tickAvgPeriod, setTickAvgPeriod] = useState(10);

            // Sound controls
            const [soundEnabled, setSoundEnabled] = useState(true);
            const [compressionSoundEnabled, setCompressionSoundEnabled] = useState(true);
            const [impulseSoundEnabled, setImpulseSoundEnabled] = useState(true);
            const [volatilitySoundEnabled, setVolatilitySoundEnabled] = useState(true);

            // ===== ALERTAS DE PANELES INTELLIGENCE =====
            const [panelAlerts, setPanelAlerts] = useState(() => {
                try {
                    const saved = localStorage.getItem('reloadingtape_panel_alerts');
                    return saved ? JSON.parse(saved) : {
                        confluence: { enabled: false, threshold: 70, triggered: false, lastTrigger: 0 },
                        tickOpportunity: { enabled: false, threshold: 60, triggered: false, lastTrigger: 0 },
                        sweep: { enabled: false, threshold: 50, triggered: false, lastTrigger: 0 }
                    };
                } catch (e) {
                    return {
                        confluence: { enabled: false, threshold: 70, triggered: false, lastTrigger: 0 },
                        tickOpportunity: { enabled: false, threshold: 60, triggered: false, lastTrigger: 0 },
                        sweep: { enabled: false, threshold: 50, triggered: false, lastTrigger: 0 }
                    };
                }
            });

            // Guardar alertas en localStorage
            useEffect(() => {
                try {
                    localStorage.setItem('reloadingtape_panel_alerts', JSON.stringify(panelAlerts));
                } catch (e) { }
            }, [panelAlerts]);

            // Toggle alerta de panel
            const togglePanelAlert = useCallback((panel) => {
                setPanelAlerts(prev => ({
                    ...prev,
                    [panel]: { ...prev[panel], enabled: !prev[panel].enabled, triggered: false }
                }));
            }, []);

            // Actualizar threshold de alerta
            const setPanelAlertThreshold = useCallback((panel, threshold) => {
                setPanelAlerts(prev => ({
                    ...prev,
                    [panel]: { ...prev[panel], threshold }
                }));
            }, []);

            // Reproducir sonido de alerta de panel
            const playPanelAlertSound = useCallback((panel) => {
                if (!soundEnabled) return;
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    // Diferentes tonos seg√∫n el panel
                    const freq = panel === 'confluence' ? 880 : panel === 'tickOpportunity' ? 660 : 550;
                    oscillator.frequency.setValueAtTime(freq, audioContext.currentTime);
                    oscillator.type = 'sine';
                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.5);
                } catch (e) { }
            }, [soundEnabled]);

            // Flow Levels type: 'cash' or 'delta'
            const [flowLevelType, setFlowLevelType] = useState('cash');

            // ===== MODULOS VISIBLES (seleccionables) =====
            const [visibleModules, setVisibleModules] = useState(() => {
                const defaultModules = {
                    confluence: true,
                    tickOpportunity: true,
                    sweepAnalysis: true,
                    panelsGrid: true,
                    absorption: true,
                    pivots: true,
                    narrator: true
                };
                try {
                    const saved = localStorage.getItem('reloadingtape_visible_modules');
                    if (saved) {
                        const parsed = JSON.parse(saved);
                        // Merge with defaults to ensure new modules are visible
                        return { ...defaultModules, ...parsed };
                    }
                } catch (e) { }
                return defaultModules;
            });

            // Guardar preferencia de m√≥dulos
            useEffect(() => {
                try {
                    localStorage.setItem('reloadingtape_visible_modules', JSON.stringify(visibleModules));
                } catch (e) { }
            }, [visibleModules]);

            // Toggle de m√≥dulo individual
            const toggleModule = useCallback((module) => {
                setVisibleModules(prev => ({ ...prev, [module]: !prev[module] }));
            }, []);

            // Dropdown de selecci√≥n de m√≥dulos abierto/cerrado
            const [showModuleSelector, setShowModuleSelector] = useState(false);
            const moduleSelectorRef = useRef(null);

            // Cerrar selector al hacer click fuera
            useEffect(() => {
                const handleClickOutside = (e) => {
                    if (moduleSelectorRef.current && !moduleSelectorRef.current.contains(e.target)) {
                        setShowModuleSelector(false);
                    }
                };
                if (showModuleSelector) document.addEventListener('mousedown', handleClickOutside);
                return () => document.removeEventListener('mousedown', handleClickOutside);
            }, [showModuleSelector]);

            // SESSION HISTORY - Acumula todos los eventos de la sesi√≥n (PERSISTENTE EN LOCALSTORAGE)
            const [sessionHistory, setSessionHistory] = useState(() => {
                // Cargar historial guardado de localStorage
                try {
                    const saved = localStorage.getItem('reloadingtape_session_history');
                    if (saved) {
                        const parsed = JSON.parse(saved);
                        // Verificar si es del mismo d√≠a
                        const savedDate = new Date(parsed.sessionStart).toDateString();
                        const today = new Date().toDateString();
                        if (savedDate === today) {
                            console.log('[Session History] Historial restaurado:', {
                                pivots: parsed.pivots?.length || 0,
                                impulses: parsed.impulses?.length || 0,
                                volatility: parsed.volatilityEvents?.length || 0,
                                breakouts: parsed.compressionBreakouts?.length || 0
                            });
                            return parsed;
                        }
                    }
                } catch (e) {
                    console.error('[Session History] Error cargando historial:', e);
                }
                // Retornar estado inicial
                return {
                    pivots: [],
                    impulses: [],
                    volatilityEvents: [],
                    compressionBreakouts: [],
                    aiNarrations: [],     // NUEVO: Guardar narraciones de IA
                    sessionStart: new Date().toISOString()
                };
            });

            // Guardar historial en localStorage cuando cambie
            useEffect(() => {
                try {
                    localStorage.setItem('reloadingtape_session_history', JSON.stringify(sessionHistory));
                } catch (e) {
                    console.error('[Session History] Error guardando:', e);
                }
            }, [sessionHistory]);

            // Funci√≥n para limpiar historial
            const clearSessionHistory = useCallback(() => {
                if (confirm('¬øLimpiar todo el historial de la sesi√≥n?')) {
                    const emptyHistory = {
                        pivots: [],
                        impulses: [],
                        volatilityEvents: [],
                        compressionBreakouts: [],
                        aiNarrations: [],
                        sessionStart: new Date().toISOString()
                    };
                    setSessionHistory(emptyHistory);
                    localStorage.removeItem('reloadingtape_session_history');
                    alert('Historial limpiado');
                }
            }, []);

            // PDF Export state
            const [isExporting, setIsExporting] = useState(false);
            const reportContentRef = useRef(null);
            const pivotMetricSelectorRef = useRef(null);
            const volatilityMetricSelectorRef = useRef(null);
            const absorptionMetricSelectorRef = useRef(null);

            // Factores de absorci√≥n disponibles (para el filtro)
            const ABSORPTION_FACTORS = {
                'DELTA_DIV': { label: 'Delta Divergence', shortLabel: 'DELTA' },
                'VOL_ABS': { label: 'Volume Absorption', shortLabel: 'VOL' },
                'GEX_PIN': { label: 'GEX Pinning', shortLabel: 'GEX' },
                'SM_DIV': { label: 'Smart Money Div', shortLabel: 'SM' },
                'OPT_FLOW': { label: 'Option Flow', shortLabel: 'OPT' },
                'VANNA': { label: 'Vanna Flow', shortLabel: 'VAN' },
                'REVISIT': { label: 'Price Revisit', shortLabel: 'REV' }
            };

            // Cerrar selector de m√©tricas al hacer clic fuera
            useEffect(() => {
                const handleClickOutside = (e) => {
                    if (pivotMetricSelectorRef.current && !pivotMetricSelectorRef.current.contains(e.target)) {
                        setShowPivotMetricSelector(false);
                    }
                    if (volatilityMetricSelectorRef.current && !volatilityMetricSelectorRef.current.contains(e.target)) {
                        setShowVolatilityMetricSelector(false);
                    }
                    if (absorptionMetricSelectorRef.current && !absorptionMetricSelectorRef.current.contains(e.target)) {
                        setShowAbsorptionMetricSelector(false);
                    }
                };
                if (showPivotMetricSelector || showVolatilityMetricSelector || showAbsorptionMetricSelector) {
                    document.addEventListener('mousedown', handleClickOutside);
                }
                return () => document.removeEventListener('mousedown', handleClickOutside);
            }, [showPivotMetricSelector, showVolatilityMetricSelector, showAbsorptionMetricSelector]);

            const chartRef = useRef(null);
            const chartInstance = useRef(null);
            const lastAnalysisRef = useRef(0);
            const audioContextRef = useRef(null);

            // Previous states for sound triggers and history tracking
            const prevImpulseRef = useRef({ active: false, direction: null, strength: 0, recordedStrength: false });
            const prevVolatilityRef = useRef({ state: 'NORMAL', recorded: false });
            const prevCompressionRef = useRef({ detected: false, startTime: null, metrics: [] });

            const availableSlots = useMemo(() => Array.from(dataSources.keys()), [dataSources]);
            const dataSource = dataSources.get(selectedSlot);

            // Surge sensitivity (1=low, 2=medium, 3=high)
            const [surgeSensitivity, setSurgeSensitivity] = useState(2);

            // ===== MULTI-SLOT MONITOR =====
            // Monitorea slots 2-6 con precios, volatilidad y detecci√≥n de impulsos
            const multiSlotMonitor = useMemo(() => {
                const slots = [];
                const slotsToCheck = ['2', '3', '4', '5', '6'];

                // Multiplicador de sensibilidad: 1=alto umbral (menos alertas), 3=bajo umbral (m√°s alertas)
                const sensitivityMultiplier = { 1: 2.0, 2: 1.0, 3: 0.5 }[surgeSensitivity] || 1.0;

                slotsToCheck.forEach(slotId => {
                    const slotData = dataSources.get(slotId);

                    // Slot sin datos
                    if (!slotData?.rows?.length || slotData.rows.length < 5) {
                        slots.push({
                            slot: slotId,
                            symbol: slotId === '2' ? 'VIX' : `Slot ${slotId}`,
                            hasData: false,
                            price: 0,
                            change: 0,
                            volatility: 0,
                            impulse: 'NONE',
                            intensity: 0,
                            isVIX: slotId === '2'
                        });
                        return;
                    }

                    const rows = slotData.rows;
                    const n = rows.length;
                    const priceCol = 'Underlying_Price';

                    // Obtener precios
                    const currentPrice = parseFloat(rows[n - 1][priceCol]) || 0;
                    const price1Ago = parseFloat(rows[n - 2]?.[priceCol]) || currentPrice;
                    const price5Ago = parseFloat(rows[Math.max(0, n - 6)]?.[priceCol]) || currentPrice;
                    const price10Ago = parseFloat(rows[Math.max(0, n - 11)]?.[priceCol]) || currentPrice;
                    const price20Ago = parseFloat(rows[Math.max(0, n - 21)]?.[priceCol]) || currentPrice;

                    if (currentPrice <= 0) return;

                    // Calcular cambios %
                    const change1 = ((currentPrice - price1Ago) / price1Ago) * 100;
                    const change5 = ((currentPrice - price5Ago) / price5Ago) * 100;
                    const change10 = ((currentPrice - price10Ago) / price10Ago) * 100;

                    // Calcular volatilidad (desviaci√≥n est√°ndar de cambios recientes)
                    const recentPrices = [];
                    for (let i = Math.max(0, n - 20); i < n; i++) {
                        recentPrices.push(parseFloat(rows[i][priceCol]) || 0);
                    }
                    const changes = [];
                    for (let i = 1; i < recentPrices.length; i++) {
                        if (recentPrices[i - 1] > 0) {
                            changes.push(((recentPrices[i] - recentPrices[i - 1]) / recentPrices[i - 1]) * 100);
                        }
                    }
                    const avgChange = changes.length > 0 ? changes.reduce((a, b) => a + b, 0) / changes.length : 0;
                    const variance = changes.length > 0
                        ? changes.reduce((sum, c) => sum + Math.pow(c - avgChange, 2), 0) / changes.length
                        : 0;
                    const volatility = Math.sqrt(variance); // Desviaci√≥n est√°ndar

                    // Detectar s√≠mbolo
                    let symbolName = slotData.symbol || `Slot ${slotId}`;
                    if (slotId === '2') symbolName = 'VIX';

                    const isVIX = slotId === '2';

                    // Umbral din√°mico basado en volatilidad del instrumento
                    // Umbral = volatilidad * multiplicador de sensibilidad
                    const baseThreshold = Math.max(0.05, volatility * 1.5) * sensitivityMultiplier;

                    // Detectar impulso
                    const absChange5 = Math.abs(change5);
                    let impulse = 'NONE';
                    let intensity = 0;

                    if (absChange5 > baseThreshold) {
                        // Hay impulso
                        intensity = Math.min(100, (absChange5 / baseThreshold) * 50);

                        if (isVIX) {
                            // VIX invertido: sube = bearish, baja = bullish
                            impulse = change5 > 0 ? 'BEARISH' : 'BULLISH';
                        } else {
                            impulse = change5 > 0 ? 'BULLISH' : 'BEARISH';
                        }
                    }

                    slots.push({
                        slot: slotId,
                        symbol: symbolName,
                        hasData: true,
                        price: currentPrice,
                        change: change5,
                        change1,
                        change10,
                        volatility,
                        threshold: baseThreshold,
                        impulse,
                        intensity,
                        isVIX
                    });
                });

                return slots;
            }, [dataSources, surgeSensitivity]);

            // Auto-seleccionar slot
            useEffect(() => {
                if (!dataSources.has(selectedSlot) && availableSlots.length > 0) {
                    setSelectedSlot(availableSlots[0]);
                }
            }, [availableSlots, selectedSlot, dataSources]);

            // ===== SOUND FUNCTIONS =====
            // Impulse Sound - Arpeggio r√°pido direccional
            const playImpulseSound = useCallback((direction) => {
                if (!soundEnabled || !impulseSoundEnabled) return;
                try {
                    if (!audioContextRef.current) {
                        audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)();
                    }
                    const ctx = audioContextRef.current;
                    const isBullish = direction === 'BULLISH';
                    // Arpeggio r√°pido ascendente (bullish) o descendente (bearish)
                    const notes = isBullish
                        ? [523, 659, 784, 1047, 1319] // C5-E5-G5-C6-E6
                        : [523, 392, 330, 262, 196];  // C5-G4-E4-C4-G3
                    const noteDuration = 0.08;
                    const noteGap = 0.03;

                    notes.forEach((freq, i) => {
                        const startTime = ctx.currentTime + (i * (noteDuration + noteGap));
                        const osc = ctx.createOscillator();
                        const gain = ctx.createGain();
                        osc.connect(gain);
                        gain.connect(ctx.destination);
                        osc.type = 'triangle';
                        osc.frequency.setValueAtTime(freq, startTime);
                        gain.gain.setValueAtTime(0, startTime);
                        gain.gain.linearRampToValueAtTime(0.4, startTime + 0.01);
                        gain.gain.linearRampToValueAtTime(0, startTime + noteDuration);
                        osc.start(startTime);
                        osc.stop(startTime + noteDuration);
                    });
                } catch (e) { console.log('Audio not available'); }
            }, [soundEnabled, impulseSoundEnabled]);

            // Volatility Sound - Pulso de alerta expansi√≥n/compresi√≥n
            const playVolatilitySound = useCallback((state) => {
                if (!soundEnabled || !volatilitySoundEnabled) return;
                try {
                    if (!audioContextRef.current) {
                        audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)();
                    }
                    const ctx = audioContextRef.current;
                    const isExpansion = state === 'EXPANSION';
                    // Expansi√≥n: tono creciente urgente, Compresi√≥n: tono decreciente suave
                    const baseFreq = isExpansion ? 600 : 400;
                    const endFreq = isExpansion ? 1200 : 200;
                    const duration = 0.4;

                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    osc.type = isExpansion ? 'sawtooth' : 'sine';
                    osc.frequency.setValueAtTime(baseFreq, ctx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(endFreq, ctx.currentTime + duration);
                    gain.gain.setValueAtTime(0, ctx.currentTime);
                    gain.gain.linearRampToValueAtTime(isExpansion ? 0.35 : 0.25, ctx.currentTime + 0.02);
                    gain.gain.linearRampToValueAtTime(0, ctx.currentTime + duration);
                    osc.start(ctx.currentTime);
                    osc.stop(ctx.currentTime + duration);

                    // Segundo tono para √©nfasis
                    if (isExpansion) {
                        const osc2 = ctx.createOscillator();
                        const gain2 = ctx.createGain();
                        osc2.connect(gain2);
                        gain2.connect(ctx.destination);
                        osc2.type = 'square';
                        osc2.frequency.setValueAtTime(800, ctx.currentTime + 0.15);
                        gain2.gain.setValueAtTime(0, ctx.currentTime + 0.15);
                        gain2.gain.linearRampToValueAtTime(0.2, ctx.currentTime + 0.17);
                        gain2.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.35);
                        osc2.start(ctx.currentTime + 0.15);
                        osc2.stop(ctx.currentTime + 0.35);
                    }
                } catch (e) { console.log('Audio not available'); }
            }, [soundEnabled, volatilitySoundEnabled]);

            // Compression Sound - Tono sostenido de acumulaci√≥n
            const playCompressionSound = useCallback(() => {
                if (!soundEnabled || !compressionSoundEnabled) return;
                try {
                    if (!audioContextRef.current) {
                        audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)();
                    }
                    const ctx = audioContextRef.current;
                    // Tono "brewing" - como energ√≠a acumul√°ndose
                    const freqs = [330, 370, 415]; // E4-F#4-G#4 cluster
                    const duration = 0.5;

                    freqs.forEach((freq, i) => {
                        const osc = ctx.createOscillator();
                        const gain = ctx.createGain();
                        osc.connect(gain);
                        gain.connect(ctx.destination);
                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(freq, ctx.currentTime);
                        // Vibrato sutil
                        osc.frequency.setValueAtTime(freq, ctx.currentTime);
                        gain.gain.setValueAtTime(0, ctx.currentTime);
                        gain.gain.linearRampToValueAtTime(0.15, ctx.currentTime + 0.05);
                        gain.gain.setValueAtTime(0.15, ctx.currentTime + duration * 0.7);
                        gain.gain.linearRampToValueAtTime(0, ctx.currentTime + duration);
                        osc.start(ctx.currentTime + i * 0.02);
                        osc.stop(ctx.currentTime + duration);
                    });
                } catch (e) { console.log('Audio not available'); }
            }, [soundEnabled, compressionSoundEnabled]);

            // ===== METRIC STRENGTH CALCULATOR (RTH Optimized) =====
            const calculateMetricStrength = useCallback((rows, metricConfig, lookback = 15) => {
                // Reducido para RTH - funciona con menos datos
                const minRequired = Math.min(lookback, 5);
                if (!rows || rows.length < minRequired) return { strength: 0, direction: 'NEUTRAL', change: 0 };
                const effectiveLookback = Math.min(lookback, rows.length);

                const n = rows.length;
                const recent = rows.slice(-effectiveLookback);

                let totalCall = 0, totalPut = 0, prevCall = 0, prevPut = 0;
                const halfPoint = Math.floor(effectiveLookback / 2);

                recent.forEach((row, i) => {
                    const callVal = Math.abs(parseFloat(row[metricConfig.call]) || 0);
                    const putVal = Math.abs(parseFloat(row[metricConfig.put]) || 0);
                    totalCall += callVal;
                    totalPut += putVal;
                    if (i < halfPoint) {
                        prevCall += callVal;
                        prevPut += putVal;
                    }
                });

                const avgCall = totalCall / effectiveLookback;
                const avgPut = totalPut / effectiveLookback;
                const prevAvgCall = halfPoint > 0 ? prevCall / halfPoint : 0;
                const prevAvgPut = halfPoint > 0 ? prevPut / halfPoint : 0;

                const net = avgCall - avgPut;
                const prevNet = prevAvgCall - prevAvgPut;
                const total = avgCall + avgPut;

                const strength = total > 0 ? Math.abs(net / total) * 100 : 0;
                const change = prevNet !== 0 ? ((net - prevNet) / Math.abs(prevNet)) * 100 : (net > 0 ? 100 : -100);
                const direction = net > total * 0.1 ? 'BULLISH' : net < -total * 0.1 ? 'BEARISH' : 'NEUTRAL';

                return { strength: Math.min(100, strength), direction, change, net, avgCall, avgPut };
            }, []);

            // ===== COMPRESSION DETECTOR (RTH Optimized - Improved) =====
            const compressionAnalysis = useMemo(() => {
                // M√≠nimo 12 barras para funcionar
                if (!dataSource?.rows?.length || dataSource.rows.length < 12) {
                    return { detected: false, energy: 0, direction: 'NEUTRAL', topMetrics: [], duration: 0, volRatio: 0, atr: 0 };
                }

                const rows = dataSource.rows;
                const n = rows.length;
                const priceCol = 'Underlying_Price';

                // Extraer precios v√°lidos
                const allPrices = rows.map(r => parseFloat(r[priceCol]) || 0).filter(p => p > 0);
                if (allPrices.length < 10) {
                    return { detected: false, energy: 0, direction: 'NEUTRAL', topMetrics: [], duration: 0, volRatio: 0, atr: 0 };
                }

                // M√âTODO 1: Volatilidad (StdDev)
                const calcStdDev = (arr) => {
                    if (arr.length < 2) return 0;
                    const mean = arr.reduce((a, b) => a + b, 0) / arr.length;
                    const sqDiffs = arr.map(v => Math.pow(v - mean, 2));
                    return Math.sqrt(sqDiffs.reduce((a, b) => a + b, 0) / arr.length);
                };

                // M√âTODO 2: ATR simplificado (High-Low range)
                const calcATR = (priceArr, period) => {
                    if (priceArr.length < period) return 0;
                    let sum = 0;
                    for (let i = 1; i < priceArr.length; i++) {
                        sum += Math.abs(priceArr[i] - priceArr[i - 1]);
                    }
                    return sum / (priceArr.length - 1);
                };

                // M√âTODO 3: Range como % del precio
                const calcRange = (arr) => {
                    const max = Math.max(...arr);
                    const min = Math.min(...arr);
                    const mid = (max + min) / 2;
                    return mid > 0 ? ((max - min) / mid) * 100 : 0;
                };

                // Dividir datos en reciente vs hist√≥rico
                const recentSize = Math.max(5, Math.floor(n * 0.25));
                const historicalSize = Math.max(5, Math.floor(n * 0.5));

                const recentPrices = allPrices.slice(-recentSize);
                const historicalPrices = allPrices.slice(-(recentSize + historicalSize), -recentSize);

                if (historicalPrices.length < 3) {
                    // Si no hay suficiente historial, comparar con toda la data
                    const fullPrices = allPrices.slice(0, -recentSize);
                    if (fullPrices.length >= 3) {
                        historicalPrices.push(...fullPrices);
                    }
                }

                // Calcular m√©tricas de volatilidad
                const recentVol = calcStdDev(recentPrices);
                const historicalVol = calcStdDev(historicalPrices.length >= 3 ? historicalPrices : allPrices.slice(0, Math.floor(allPrices.length / 2)));

                const recentRange = calcRange(recentPrices);
                const historicalRange = calcRange(historicalPrices.length >= 3 ? historicalPrices : allPrices.slice(0, Math.floor(allPrices.length / 2)));

                const recentATR = calcATR(recentPrices, recentPrices.length);
                const historicalATR = calcATR(historicalPrices.length >= 3 ? historicalPrices : allPrices.slice(0, Math.floor(allPrices.length / 2)),
                    historicalPrices.length >= 3 ? historicalPrices.length : Math.floor(allPrices.length / 2));

                // Ratio de volatilidad combinada (promedio de los 3 m√©todos)
                const volRatio1 = historicalVol > 0 ? recentVol / historicalVol : 1;
                const volRatio2 = historicalRange > 0 ? recentRange / historicalRange : 1;
                const volRatio3 = historicalATR > 0 ? recentATR / historicalATR : 1;

                const avgVolRatio = (volRatio1 + volRatio2 + volRatio3) / 3;

                // Umbrales basados en sensibilidad (1=bajo, 2=medio, 3=alto)
                const compressionThresholds = { 1: 0.75, 2: 0.85, 3: 0.95 };
                const threshold = compressionThresholds[compressionSensitivity] || 0.85;

                // DETECCI√ìN: Compresi√≥n cuando volatilidad reciente < umbral
                const isCompressed = avgVolRatio < threshold;

                // Nivel de compresi√≥n (0-100)
                const compressionLevel = isCompressed ? Math.min(100, Math.max(0, (threshold - avgVolRatio) * (100 / (threshold - 0.40)))) : 0;

                // Calcular energ√≠a acumulada en m√©tricas
                const metrics = Object.entries(constants.SIGNAL_METRICS);
                const metricStrengths = [];

                metrics.forEach(([key, config]) => {
                    const strength = calculateMetricStrength(rows, config, Math.min(10, n - 2));
                    metricStrengths.push({
                        key,
                        label: config.shortLabel,
                        ...strength
                    });
                });

                metricStrengths.sort((a, b) => b.strength - a.strength);
                const topMetrics = metricStrengths.slice(0, 3);

                // Energ√≠a total = fuerza m√©tricas * nivel compresi√≥n
                const avgMetricStrength = metricStrengths.reduce((sum, m) => sum + m.strength, 0) / metrics.length;
                const totalEnergy = isCompressed ? Math.min(100, avgMetricStrength * (1 + compressionLevel / 100)) : avgMetricStrength * 0.5;

                // Direcci√≥n probable basada en m√©tricas bullish vs bearish (ponderado por fuerza)
                const bullishStrength = metricStrengths.filter(m => m.direction === 'BULLISH').reduce((s, m) => s + m.strength, 0);
                const bearishStrength = metricStrengths.filter(m => m.direction === 'BEARISH').reduce((s, m) => s + m.strength, 0);
                const totalStrength = bullishStrength + bearishStrength;

                let probableDirection = 'NEUTRAL';
                if (totalStrength > 0) {
                    const ratio = bullishStrength / totalStrength;
                    if (ratio > 0.60) probableDirection = 'BULLISH';
                    else if (ratio < 0.40) probableDirection = 'BEARISH';
                }

                // Duraci√≥n: contar barras consecutivas en compresi√≥n (simplificado)
                let duration = 0;
                if (isCompressed) {
                    for (let windowEnd = n; windowEnd >= Math.max(recentSize + 3, n - 30); windowEnd--) {
                        const winRecent = allPrices.slice(windowEnd - recentSize, windowEnd);
                        const winHist = allPrices.slice(Math.max(0, windowEnd - recentSize - historicalSize), windowEnd - recentSize);
                        if (winRecent.length < 3 || winHist.length < 3) break;

                        const winRecentVol = calcStdDev(winRecent);
                        const winHistVol = calcStdDev(winHist);
                        if (winHistVol > 0 && winRecentVol / winHistVol < 0.85) {
                            duration++;
                        } else {
                            break;
                        }
                    }
                }

                return {
                    detected: isCompressed,
                    energy: Math.round(totalEnergy),
                    volRatio: Math.round(avgVolRatio * 100),
                    compressionLevel: Math.round(compressionLevel),
                    direction: probableDirection,
                    topMetrics,
                    duration,
                    debug: { volRatio1: volRatio1.toFixed(3), volRatio2: volRatio2.toFixed(3), volRatio3: volRatio3.toFixed(3) }
                };
            }, [dataSource, calculateMetricStrength, compressionSensitivity]);

            // ===== PIVOT DETECTOR (RTH Optimized) =====
            const pivotAnalysis = useMemo(() => {
                // RTH: Reducido de 30 a 15 barras m√≠nimo
                if (!dataSource?.rows?.length || dataSource.rows.length < 15) {
                    return { pivots: [], lastPivot: null };
                }

                const rows = dataSource.rows;
                const n = rows.length;
                const priceCol = 'Underlying_Price';
                // Lookback basado en sensibilidad (1=bajo/m√°s barras, 2=medio, 3=alto/menos barras)
                const lookbackSettings = { 1: { min: 4, max: 6 }, 2: { min: 2, max: 4 }, 3: { min: 1, max: 3 } };
                const lbSetting = lookbackSettings[pivotSensitivity] || lookbackSettings[2];
                const lookback = Math.max(lbSetting.min, Math.min(lbSetting.max, Math.floor(n * 0.03)));

                const pivots = [];

                // Detectar pivots locales
                for (let i = lookback; i < n - lookback; i++) {
                    const currentPrice = parseFloat(rows[i][priceCol]) || 0;
                    if (currentPrice <= 0) continue;

                    let isHigh = true, isLow = true;

                    for (let j = 1; j <= lookback; j++) {
                        const leftPrice = parseFloat(rows[i - j][priceCol]) || 0;
                        const rightPrice = parseFloat(rows[i + j][priceCol]) || 0;

                        if (leftPrice >= currentPrice || rightPrice >= currentPrice) isHigh = false;
                        if (leftPrice <= currentPrice || rightPrice <= currentPrice) isLow = false;
                    }

                    if (isHigh || isLow) {
                        // Calcular m√©tricas dominantes en este punto
                        const windowRows = rows.slice(Math.max(0, i - 5), i + 1);
                        const metrics = Object.entries(constants.SIGNAL_METRICS);
                        const metricStrengths = [];

                        metrics.forEach(([key, config]) => {
                            const strength = calculateMetricStrength(windowRows, config, 5);
                            metricStrengths.push({
                                key,
                                label: config.shortLabel,
                                ...strength
                            });
                        });

                        metricStrengths.sort((a, b) => b.strength - a.strength);

                        // UMBRAL basado en sensibilidad (1=estricto, 2=medio, 3=permisivo)
                        const top3 = metricStrengths.slice(0, 3);
                        const avgStrength = top3.reduce((sum, m) => sum + m.strength, 0) / 3;
                        const totalStrength = metricStrengths.reduce((sum, m) => sum + m.strength, 0);

                        const pivotThresholds = { 1: { avg: 15, metric: 25 }, 2: { avg: 5, metric: 10 }, 3: { avg: 0, metric: 0 } };
                        const pThresh = pivotThresholds[pivotSensitivity] || pivotThresholds[2];
                        const hasAnyMetric = top3.some(m => m.strength >= pThresh.metric);
                        const meetsThreshold = avgStrength >= pThresh.avg || hasAnyMetric || pivotSensitivity === 3;

                        if (meetsThreshold) {
                            // Determinar sentimiento basado en m√©tricas dominantes
                            const bullishMetrics = top3.filter(m => m.direction === 'BULLISH');
                            const bearishMetrics = top3.filter(m => m.direction === 'BEARISH');
                            const bullishStrength = bullishMetrics.reduce((sum, m) => sum + m.strength, 0);
                            const bearishStrength = bearishMetrics.reduce((sum, m) => sum + m.strength, 0);

                            // Por defecto NEUTRAL (gris) - la MAYOR√çA ser√°n grises
                            let sentiment = 'NEUTRAL';

                            // Solo colorear si:
                            // 1. UNA direcci√≥n tiene 80%+ de la fuerza total
                            // 2. Y la m√©trica top tiene al menos 60% de strength
                            const totalDir = bullishStrength + bearishStrength;
                            const bullishRatio = totalDir > 0 ? bullishStrength / totalDir : 0;
                            const bearishRatio = totalDir > 0 ? bearishStrength / totalDir : 0;
                            const topMetricStrength = top3[0]?.strength || 0;

                            if (bullishRatio >= 0.80 && topMetricStrength >= 60) {
                                sentiment = 'BULLISH';
                            } else if (bearishRatio >= 0.80 && topMetricStrength >= 60) {
                                sentiment = 'BEARISH';
                            }

                            pivots.push({
                                index: i,
                                totalRows: n, // Guardar n para mapeo correcto en el gr√°fico
                                type: isHigh ? 'HIGH' : 'LOW',
                                price: currentPrice,
                                timestamp: rows[i][dataSource.timestampHeader] || i,
                                topMetrics: top3,
                                avgStrength: avgStrength,
                                totalStrength: totalStrength,
                                barsAgo: n - i - 1,
                                sentiment: sentiment, // BULLISH, BEARISH, o NEUTRAL
                                bullishStrength: bullishStrength,
                                bearishStrength: bearishStrength
                            });
                        }
                    }
                }

                // Filtrar pivots muy cercanos (m√≠nimo 3% de separaci√≥n entre cada uno)
                const minSeparation = Math.max(5, Math.floor(n * 0.03));
                const filteredPivots = [];
                for (const pivot of pivots) {
                    const lastPivot = filteredPivots[filteredPivots.length - 1];
                    if (!lastPivot || (pivot.index - lastPivot.index) >= minSeparation) {
                        filteredPivots.push(pivot);
                    } else if (pivot.avgStrength > lastPivot.avgStrength) {
                        // Si el nuevo pivot es m√°s fuerte, reemplazar el anterior
                        filteredPivots[filteredPivots.length - 1] = pivot;
                    }
                }

                // Solo √∫ltimos 10 pivots
                const recentPivots = filteredPivots.slice(-10);
                const lastPivot = recentPivots.length > 0 ? recentPivots[recentPivots.length - 1] : null;

                return { pivots: recentPivots, lastPivot };
            }, [dataSource, calculateMetricStrength, pivotSensitivity]);

            // ===== ABSORPTION PIVOT DETECTOR (Professional Grade) =====
            // Detecta zonas donde el mercado absorbe presi√≥n sin mover el precio significativamente
            // Esto indica manos fuertes (institucionales) acumulando/distribuyendo
            const absorptionAnalysis = useMemo(() => {
                if (!dataSource?.rows?.length || dataSource.rows.length < 20) {
                    return {
                        zones: [],
                        activeAbsorption: null,
                        totalAbsorptions: 0,
                        recentAbsorptions: 0,
                        absorptionStrength: 'MINOR',
                        dominantSide: 'NEUTRAL',
                        institutionalActivity: 0,
                        bullishCount: 0,
                        bearishCount: 0,
                        keyLevels: []
                    };
                }

                const rows = dataSource.rows;
                const n = rows.length;
                const priceCol = 'Underlying_Price';

                // M√©tricas para detectar absorci√≥n
                const getMetricValue = (row, col) => parseFloat(row[col]) || 0;

                // Calcular ATR (Average True Range) para normalizar movimientos
                const atrPeriod = Math.min(14, Math.floor(n * 0.1));
                let atrSum = 0;
                for (let i = Math.max(1, n - atrPeriod); i < n; i++) {
                    const high = getMetricValue(rows[i], priceCol);
                    const low = getMetricValue(rows[i - 1], priceCol);
                    atrSum += Math.abs(high - low);
                }
                const avgATR = atrSum / atrPeriod || 0.5;

                const absorptionZones = [];
                const lookbackWindow = 5; // Ventana para detectar absorci√≥n

                // Analizar cada punto buscando caracter√≠sticas de absorci√≥n
                for (let i = lookbackWindow; i < n - 1; i++) {
                    const currentPrice = getMetricValue(rows[i], priceCol);
                    const prevPrice = getMetricValue(rows[i - 1], priceCol);
                    const priceChange = Math.abs(currentPrice - prevPrice);

                    if (currentPrice <= 0) continue;

                    // === INDICADORES DE ABSORCI√ìN ===

                    // 1. DELTA DIVERGENCE: Alto delta pero poco movimiento de precio
                    const deltaFlow = getMetricValue(rows[i], 'Net_Delta_Flow');
                    const prevDelta = getMetricValue(rows[i - 1], 'Net_Delta_Flow');
                    const deltaChange = Math.abs(deltaFlow - prevDelta);
                    const deltaDivergence = deltaChange > 0 && priceChange < avgATR * 0.3;

                    // 2. VOLUME ABSORPTION: Alto volumen sin movimiento proporcional
                    const moneyFlow = Math.abs(getMetricValue(rows[i], 'Net_Money_Flow'));
                    const avgMoneyFlow = (() => {
                        let sum = 0;
                        for (let j = Math.max(0, i - 10); j < i; j++) {
                            sum += Math.abs(getMetricValue(rows[j], 'Net_Money_Flow'));
                        }
                        return sum / Math.min(10, i) || 1;
                    })();
                    const volumeRatio = moneyFlow / avgMoneyFlow;
                    const highVolumeNoMove = volumeRatio > 1.5 && priceChange < avgATR * 0.5;

                    // 3. OTM/ITM IMBALANCE: Flujo de opciones indica posicionamiento institucional
                    const otmImpact = getMetricValue(rows[i], 'Net_OTM_Impact');
                    const itmImpact = getMetricValue(rows[i], 'Net_ITM_Impact');
                    const optionImbalance = Math.abs(otmImpact - itmImpact);
                    const hasOptionActivity = optionImbalance > 20;

                    // 4. GEX PINNING: Gamma exposure sugiere precio "clavado"
                    const gex = getMetricValue(rows[i], 'Net_GEX');
                    const prevGex = getMetricValue(rows[i - 1], 'Net_GEX');
                    const gexStable = Math.abs(gex - prevGex) < Math.abs(gex) * 0.1;
                    const highGex = Math.abs(gex) > 50;
                    const gexPinning = gexStable && highGex;

                    // 5. SMART MONEY DIVERGENCE: Smart money vs precio
                    const smartMoney = getMetricValue(rows[i], 'Net_Smart_Money');
                    const smartMoneyDivergent = Math.abs(smartMoney) > 30 && priceChange < avgATR * 0.3;

                    // 6. VANNA FLOW: Vanna indica hedging institucional
                    const vannaFlow = getMetricValue(rows[i], 'Net_Vanna_Flow');
                    const highVanna = Math.abs(vannaFlow) > 40;

                    // 7. REPETITIVE PRICE ZONE: Precio vuelve al mismo nivel
                    let priceRevisits = 0;
                    const priceZone = currentPrice;
                    const zoneTolerance = avgATR * 0.2;
                    for (let j = Math.max(0, i - 15); j < i; j++) {
                        const histPrice = getMetricValue(rows[j], priceCol);
                        if (Math.abs(histPrice - priceZone) < zoneTolerance) {
                            priceRevisits++;
                        }
                    }
                    const isRevisitedZone = priceRevisits >= 3;

                    // === CALCULAR SCORE DE ABSORCI√ìN ===
                    // Umbrales basados en absorptionSensitivity (1=estricto, 2=medio, 3=sensible)
                    const absThresholds = {
                        1: { deltaMin: 50, volRatio: 4.0, gexMin: 300, smMin: 120, optMin: 120, vannaMin: 150, revisitMin: 8, minScore: 110, minCritical: 3, minTotal: 5, minIntensity: 80, barSep: 20, maxShow: 2 },
                        2: { deltaMin: 35, volRatio: 3.0, gexMin: 200, smMin: 80, optMin: 80, vannaMin: 100, revisitMin: 6, minScore: 90, minCritical: 3, minTotal: 4, minIntensity: 70, barSep: 15, maxShow: 3 },
                        3: { deltaMin: 20, volRatio: 2.0, gexMin: 100, smMin: 50, optMin: 50, vannaMin: 60, revisitMin: 4, minScore: 70, minCritical: 2, minTotal: 3, minIntensity: 55, barSep: 10, maxShow: 5 }
                    };
                    const aThresh = absThresholds[absorptionSensitivity] || absThresholds[2];

                    let absorptionScore = 0;
                    const absorptionFactors = [];
                    let criticalFactors = 0; // Factores de alta importancia

                    // Factores CR√çTICOS (umbrales basados en sensibilidad)
                    if (deltaDivergence && deltaChange > aThresh.deltaMin) {
                        absorptionScore += 30;
                        absorptionFactors.push('DELTA_DIV');
                        criticalFactors++;
                    }
                    if (highVolumeNoMove && volumeRatio > aThresh.volRatio) {
                        absorptionScore += 35;
                        absorptionFactors.push('VOL_ABS');
                        criticalFactors++;
                    }
                    if (gexPinning && Math.abs(gex) > aThresh.gexMin) {
                        absorptionScore += 30;
                        absorptionFactors.push('GEX_PIN');
                        criticalFactors++;
                    }
                    if (smartMoneyDivergent && Math.abs(smartMoney) > aThresh.smMin) {
                        absorptionScore += 30;
                        absorptionFactors.push('SM_DIV');
                        criticalFactors++;
                    }

                    // Factores SECUNDARIOS (basados en sensibilidad)
                    if (hasOptionActivity && optionImbalance > aThresh.optMin) {
                        absorptionScore += 15;
                        absorptionFactors.push('OPT_FLOW');
                    }
                    if (highVanna && Math.abs(vannaFlow) > aThresh.vannaMin) {
                        absorptionScore += 12;
                        absorptionFactors.push('VANNA');
                    }
                    if (isRevisitedZone && priceRevisits >= aThresh.revisitMin) {
                        absorptionScore += 15;
                        absorptionFactors.push('REVISIT');
                    }

                    // REQUISITOS basados en sensibilidad
                    const minAbsorptionScore = aThresh.minScore;
                    const minCriticalFactors = aThresh.minCritical;
                    const minTotalFactors = aThresh.minTotal;

                    // CONDICI√ìN ULTRA-ESTRICTA: Debe cumplir TODOS los requisitos
                    const isValidAbsorption = absorptionScore >= minAbsorptionScore &&
                        criticalFactors >= minCriticalFactors &&
                        absorptionFactors.length >= minTotalFactors;

                    if (isValidAbsorption) {
                        // Determinar direcci√≥n de la absorci√≥n
                        // Absorci√≥n BULLISH = comprando calls, delta positivo estancado (sellers being absorbed)
                        // Absorci√≥n BEARISH = comprando puts, delta negativo estancado (buyers being absorbed)
                        let absorptionType = 'NEUTRAL';

                        // Requiere delta MUY significativo para determinar direcci√≥n
                        if (deltaFlow > 40 && priceChange < avgATR * 0.2) {
                            // Delta positivo muy fuerte pero precio no sube = absorci√≥n institucional bullish
                            absorptionType = 'BULLISH';
                        } else if (deltaFlow < -40 && priceChange < avgATR * 0.2) {
                            // Delta negativo muy fuerte pero precio no baja = absorci√≥n institucional bearish
                            absorptionType = 'BEARISH';
                        } else if (Math.abs(otmImpact) > Math.abs(itmImpact) * 3.0) {
                            // OTM extremadamente mayor que ITM = posicionamiento especulativo claro
                            absorptionType = otmImpact > 0 ? 'BULLISH' : 'BEARISH';
                        }

                        // Solo registrar absorciones con direcci√≥n clara (no neutrales)
                        if (absorptionType === 'NEUTRAL') continue;

                        // Calcular intensidad de la absorci√≥n (ajustado para criterios ultra-estrictos)
                        const intensity = Math.min(100, Math.round(
                            (absorptionScore / 167) * 40 + // Score contribuye 40%
                            (volumeRatio / 4.0) * 25 + // Volume ratio contribuye 25%
                            (Math.abs(deltaFlow) / 100) * 20 + // Delta magnitude contribuye 20%
                            (criticalFactors / 4) * 15 // Factores cr√≠ticos contribuyen 15%
                        ));

                        // Solo absorciones de intensidad basada en sensibilidad
                        if (intensity < aThresh.minIntensity) continue;

                        // Clasificar tipo de absorci√≥n (solo MAJOR e INSTITUTIONAL)
                        let absorptionClass = 'MAJOR';
                        if (intensity >= 90) absorptionClass = 'INSTITUTIONAL';

                        absorptionZones.push({
                            index: i,
                            price: currentPrice,
                            priceLevel: currentPrice.toFixed(2),
                            timestamp: rows[i][dataSource.timestampHeader] || i,
                            barsAgo: n - i - 1,
                            score: absorptionScore,
                            intensity: intensity,
                            type: absorptionType, // BULLISH, BEARISH, NEUTRAL
                            class: absorptionClass, // INSTITUTIONAL, MAJOR, MODERATE, MINOR
                            factors: absorptionFactors,
                            metrics: {
                                deltaFlow: deltaFlow.toFixed(1),
                                moneyFlow: moneyFlow.toFixed(1),
                                volumeRatio: volumeRatio.toFixed(2),
                                gex: gex.toFixed(1),
                                otmImpact: otmImpact.toFixed(1),
                                smartMoney: smartMoney.toFixed(1),
                                priceChange: priceChange.toFixed(4),
                                priceRevisits: priceRevisits
                            },
                            // Se√±ales de trading
                            signals: {
                                potentialBreakout: volumeRatio > 2 && gexPinning,
                                accumulation: absorptionType === 'BULLISH' && intensity > 50,
                                distribution: absorptionType === 'BEARISH' && intensity > 50,
                                institutionalHedging: highVanna && highGex,
                                priceTrapped: isRevisitedZone && gexPinning
                            }
                        });
                    }
                }

                // Filtrar absorciones muy cercanas (basado en sensibilidad)
                const absThresholdsFilter = {
                    1: { barSep: 20, maxShow: 2 },
                    2: { barSep: 15, maxShow: 3 },
                    3: { barSep: 10, maxShow: 5 }
                };
                const aThreshFilter = absThresholdsFilter[absorptionSensitivity] || absThresholdsFilter[2];
                const minBarsSeparation = aThreshFilter.barSep;
                const filteredZones = [];
                for (const zone of absorptionZones) {
                    const lastZone = filteredZones[filteredZones.length - 1];
                    if (!lastZone || (zone.index - lastZone.index) >= minBarsSeparation) {
                        filteredZones.push(zone);
                    } else if (zone.intensity > lastZone.intensity) {
                        // Si hay una absorci√≥n m√°s fuerte en la misma zona, reemplazar
                        filteredZones[filteredZones.length - 1] = zone;
                    }
                }

                // Cantidad de absorciones basada en sensibilidad
                const recentAbsorptions = filteredZones.slice(-aThreshFilter.maxShow);

                // Absorci√≥n activa (√∫ltima si es reciente)
                const activeAbsorption = recentAbsorptions.length > 0 && recentAbsorptions[recentAbsorptions.length - 1].barsAgo <= 3
                    ? recentAbsorptions[recentAbsorptions.length - 1]
                    : null;

                // Calcular dominancia y actividad institucional
                const bullishAbsorptions = recentAbsorptions.filter(z => z.type === 'BULLISH');
                const bearishAbsorptions = recentAbsorptions.filter(z => z.type === 'BEARISH');
                const institutionalCount = recentAbsorptions.filter(z => z.class === 'INSTITUTIONAL').length;

                const dominantSide = bullishAbsorptions.length > bearishAbsorptions.length * 1.5 ? 'BULLISH'
                    : bearishAbsorptions.length > bullishAbsorptions.length * 1.5 ? 'BEARISH'
                        : 'BALANCED';

                const avgIntensity = recentAbsorptions.length > 0
                    ? recentAbsorptions.reduce((sum, z) => sum + z.intensity, 0) / recentAbsorptions.length
                    : 0;

                return {
                    zones: filteredZones,
                    activeAbsorption: activeAbsorption,
                    totalAbsorptions: filteredZones.length,
                    recentAbsorptions: recentAbsorptions.length,
                    absorptionStrength: avgIntensity >= 80 ? 'INSTITUTIONAL'
                        : avgIntensity >= 60 ? 'MAJOR'
                            : avgIntensity >= 40 ? 'MODERATE'
                                : 'MINOR',
                    dominantSide: dominantSide,
                    institutionalActivity: Math.round((institutionalCount / Math.max(1, recentAbsorptions.length)) * 100),
                    bullishCount: bullishAbsorptions.length,
                    bearishCount: bearishAbsorptions.length,
                    // Zonas de precio con mayor absorci√≥n (niveles clave)
                    keyLevels: (() => {
                        const priceLevels = {};
                        filteredZones.forEach(z => {
                            const level = z.priceLevel;
                            if (!priceLevels[level]) priceLevels[level] = {
                                count: 0,
                                totalIntensity: 0,
                                types: { BULLISH: 0, BEARISH: 0, NEUTRAL: 0 }
                            };
                            priceLevels[level].count++;
                            priceLevels[level].totalIntensity += z.intensity;
                            priceLevels[level].types[z.type || 'NEUTRAL']++;
                        });
                        return Object.entries(priceLevels)
                            .map(([price, data]) => {
                                // Determinar tipo dominante
                                const dominantType = data.types.BULLISH > data.types.BEARISH
                                    ? 'BULLISH'
                                    : data.types.BEARISH > data.types.BULLISH
                                        ? 'BEARISH'
                                        : 'NEUTRAL';
                                return {
                                    price: parseFloat(price),
                                    count: data.count,
                                    strength: Math.round(data.totalIntensity / data.count),
                                    type: dominantType
                                };
                            })
                            .sort((a, b) => b.strength - a.strength)
                            .slice(0, 5);
                    })()
                };
            }, [dataSource, absorptionSensitivity]);

            // ===== IMPULSE DETECTOR (Enhanced Multi-Factor) =====
            const impulseAnalysis = useMemo(() => {
                if (!dataSource?.rows?.length || dataSource.rows.length < 6) {
                    return { active: false, direction: 'NEUTRAL', strength: 0, topMetrics: [], exhaustion: 0, velocity: 0, acceleration: 0 };
                }

                const rows = dataSource.rows;
                const n = rows.length;
                const priceCol = 'Underlying_Price';

                // Extraer precios
                const prices = [];
                for (let i = Math.max(0, n - 10); i < n; i++) {
                    prices.push(parseFloat(rows[i][priceCol]) || 0);
                }

                if (prices.length < 4 || prices[0] <= 0) {
                    return { active: false, direction: 'NEUTRAL', strength: 0, topMetrics: [], exhaustion: 0, velocity: 0, acceleration: 0 };
                }

                const currentPrice = prices[prices.length - 1];
                const price1Ago = prices[prices.length - 2] || currentPrice;
                const price2Ago = prices[prices.length - 3] || price1Ago;
                const price3Ago = prices[prices.length - 4] || price2Ago;
                const priceStart = prices[0];

                // === FACTOR 1: Cambio de precio (momentum) ===
                const totalChange = ((currentPrice - priceStart) / priceStart) * 100;
                const recentChange = ((currentPrice - price3Ago) / price3Ago) * 100;

                // === FACTOR 2: Velocidad (rate of change) ===
                const velocity1 = currentPrice - price1Ago;
                const velocity2 = price1Ago - price2Ago;
                const velocity3 = price2Ago - price3Ago;
                const avgVelocity = (velocity1 + velocity2 + velocity3) / 3;
                const velocityScore = Math.abs(avgVelocity) / (currentPrice * 0.0001); // Normalizado

                // === FACTOR 3: Aceleraci√≥n (cambio en velocidad) ===
                const accel1 = velocity1 - velocity2;
                const accel2 = velocity2 - velocity3;
                const acceleration = (accel1 + accel2) / 2;
                const accelScore = Math.abs(acceleration) / (currentPrice * 0.00005);

                // === FACTOR 4: Consistencia direccional ===
                let consistentBars = 0;
                const direction = totalChange > 0 ? 1 : -1;
                for (let i = prices.length - 1; i > 0; i--) {
                    const barChange = prices[i] - prices[i - 1];
                    if ((barChange > 0 && direction > 0) || (barChange < 0 && direction < 0)) {
                        consistentBars++;
                    } else {
                        break;
                    }
                }
                const consistencyScore = (consistentBars / Math.min(5, prices.length - 1)) * 100;

                // === FACTOR 5: Volatilidad relativa ===
                const calcStdDev = (arr) => {
                    if (arr.length < 2) return 0;
                    const mean = arr.reduce((a, b) => a + b, 0) / arr.length;
                    return Math.sqrt(arr.map(v => Math.pow(v - mean, 2)).reduce((a, b) => a + b, 0) / arr.length);
                };
                const recentVol = calcStdDev(prices.slice(-4));
                const historicalVol = calcStdDev(prices);
                const volExpansion = historicalVol > 0 ? (recentVol / historicalVol) : 1;

                // === PUNTUACI√ìN COMBINADA ===
                const momentumScore = Math.min(100, Math.abs(recentChange) * 150);
                const combinedScore = (
                    momentumScore * 0.40 +
                    Math.min(100, velocityScore * 25) * 0.25 +
                    Math.min(100, accelScore * 30) * 0.15 +
                    consistencyScore * 0.20
                );

                // Umbrales basados en sensibilidad (1=bajo, 2=medio, 3=alto) - AJUSTADOS PARA MEJOR DETECCI√ìN
                const impulseThresholds = { 1: { score: 25, change: 0.04 }, 2: { score: 15, change: 0.02 }, 3: { score: 8, change: 0.008 } };
                const iThresh = impulseThresholds[impulseSensitivity] || impulseThresholds[2];
                // Considerar impulso si tiene score suficiente O cambio suficiente (m√°s flexible)
                const isImpulse = (combinedScore >= iThresh.score && Math.abs(recentChange) > iThresh.change * 0.5) ||
                    (Math.abs(recentChange) > iThresh.change && combinedScore >= iThresh.score * 0.6);

                const impulseDirection = totalChange > 0 ? 'BULLISH' : 'BEARISH';

                // Calcular m√©tricas que est√°n impulsando
                const metrics = Object.entries(constants.SIGNAL_METRICS);
                const metricStrengths = [];

                metrics.forEach(([key, config]) => {
                    const strength = calculateMetricStrength(rows, config, 6);
                    // Solo incluir m√©tricas que van en la direcci√≥n del impulso
                    if ((impulseDirection === 'BULLISH' && strength.direction === 'BULLISH') ||
                        (impulseDirection === 'BEARISH' && strength.direction === 'BEARISH')) {
                        metricStrengths.push({
                            key,
                            label: config.shortLabel,
                            ...strength
                        });
                    }
                });

                metricStrengths.sort((a, b) => b.strength - a.strength);

                // Calcular agotamiento mejorado
                // Si la aceleraci√≥n es negativa (desacelerando), hay agotamiento
                const isDecelerating = (impulseDirection === 'BULLISH' && acceleration < 0) ||
                    (impulseDirection === 'BEARISH' && acceleration > 0);
                const decelFactor = isDecelerating ? Math.min(100, Math.abs(acceleration / avgVelocity) * 100) : 0;

                // Tambi√©n check de m√©tricas perdiendo fuerza
                const recentMetricStrength = calculateMetricStrength(rows.slice(-3), constants.SIGNAL_METRICS['delta-flow'] || Object.values(constants.SIGNAL_METRICS)[0], 3);
                const olderMetricStrength = calculateMetricStrength(rows.slice(-6, -3), constants.SIGNAL_METRICS['delta-flow'] || Object.values(constants.SIGNAL_METRICS)[0], 3);
                const metricExhaustion = olderMetricStrength.strength > 0
                    ? Math.max(0, 100 - (recentMetricStrength.strength / olderMetricStrength.strength) * 100)
                    : 0;

                const exhaustion = Math.min(100, (decelFactor * 0.6 + metricExhaustion * 0.4));

                return {
                    active: isImpulse,
                    direction: impulseDirection,
                    strength: Math.round(combinedScore),
                    change: totalChange,
                    recentChange: recentChange,
                    velocity: avgVelocity,
                    acceleration: acceleration,
                    consistency: consistentBars,
                    volExpansion: volExpansion,
                    topMetrics: metricStrengths.slice(0, 3),
                    exhaustion: Math.round(exhaustion)
                };
            }, [dataSource, calculateMetricStrength, impulseSensitivity]);

            // ===== VOLATILITY INTELLIGENCE (Multi-Timeframe) =====
            const volatilityAnalysis = useMemo(() => {
                const defaultReturn = {
                    active: false, state: 'NORMAL', regime: 'NEUTRAL',
                    windows: {
                        '30s': { vol: 0, atr: 0, ratio: 100, state: 'NORMAL' },
                        '60s': { vol: 0, atr: 0, ratio: 100, state: 'NORMAL' },
                        '300s': { vol: 0, atr: 0, ratio: 100, state: 'NORMAL' }
                    },
                    strength: 0, expansion: 0, trend: 'STABLE',
                    percentile: 50, topMetrics: []
                };

                if (!dataSource?.rows?.length || dataSource.rows.length < 10) {
                    return defaultReturn;
                }

                const rows = dataSource.rows;
                const n = rows.length;
                const priceCol = 'Underlying_Price';

                // Extraer precios
                const prices = rows.map(r => parseFloat(r[priceCol]) || 0).filter(p => p > 0);
                if (prices.length < 10) {
                    return defaultReturn;
                }

                // Funci√≥n para calcular volatilidad (desviaci√≥n est√°ndar de retornos)
                const calcVolatility = (priceArr) => {
                    if (priceArr.length < 3) return 0;
                    const returns = [];
                    for (let i = 1; i < priceArr.length; i++) {
                        if (priceArr[i - 1] > 0) {
                            returns.push((priceArr[i] - priceArr[i - 1]) / priceArr[i - 1] * 100);
                        }
                    }
                    if (returns.length < 2) return 0;
                    const mean = returns.reduce((a, b) => a + b, 0) / returns.length;
                    const variance = returns.map(r => Math.pow(r - mean, 2)).reduce((a, b) => a + b, 0) / returns.length;
                    return Math.sqrt(variance);
                };

                // Funci√≥n para calcular ATR simplificado
                const calcATR = (priceArr) => {
                    if (priceArr.length < 2) return 0;
                    let sum = 0;
                    for (let i = 1; i < priceArr.length; i++) {
                        sum += Math.abs(priceArr[i] - priceArr[i - 1]);
                    }
                    return sum / (priceArr.length - 1);
                };

                // Calcular precio promedio para cada ventana
                const calcAvgPrice = (arr) => arr.length > 0 ? arr.reduce((a, b) => a + b, 0) / arr.length : 0;

                // Umbrales basados en sensibilidad
                const sensThresholds = { 1: 1.3, 2: 1.15, 3: 1.05 };
                const expansionThreshold = sensThresholds[volatilitySensitivity] || 1.15;

                // Ventanas de tiempo (asumiendo ~1 segundo por fila, ajustar si es diferente)
                const window30 = Math.min(30, Math.floor(prices.length * 0.15));
                const window60 = Math.min(60, Math.floor(prices.length * 0.30));
                const window300 = Math.min(300, Math.floor(prices.length * 0.80));

                // Volatilidad en cada ventana
                const prices30 = prices.slice(-window30);
                const prices60 = prices.slice(-window60);
                const prices300 = prices.slice(-window300);

                const vol30 = calcVolatility(prices30);
                const vol60 = calcVolatility(prices60);
                const vol300 = calcVolatility(prices300);

                // ATR en cada ventana
                const atr30 = calcATR(prices30);
                const atr60 = calcATR(prices60);
                const atr300 = calcATR(prices300);

                // Precio promedio en cada ventana
                const avg30 = calcAvgPrice(prices30);
                const avg60 = calcAvgPrice(prices60);
                const avg300 = calcAvgPrice(prices300);

                // Volatilidad como % del precio
                const volPct30 = avg30 > 0 ? (atr30 / avg30) * 100 : 0;
                const volPct60 = avg60 > 0 ? (atr60 / avg60) * 100 : 0;
                const volPct300 = avg300 > 0 ? (atr300 / avg300) * 100 : 0;

                // Comparar volatilidades para detectar expansi√≥n/contracci√≥n
                const shortVsLong = vol300 > 0 ? vol30 / vol300 : 1;
                const medVsLong = vol300 > 0 ? vol60 / vol300 : 1;

                // Estado de volatilidad
                let state = 'NORMAL';
                let regime = 'NEUTRAL';
                let active = false;

                if (shortVsLong > expansionThreshold && medVsLong > (expansionThreshold * 0.9)) {
                    state = 'EXPANDING';
                    regime = 'HIGH';
                    active = true;
                } else if (shortVsLong < (1 / expansionThreshold) && medVsLong < (1 / (expansionThreshold * 0.9))) {
                    state = 'CONTRACTING';
                    regime = 'LOW';
                    active = true;
                } else if (vol30 > vol60 * 1.1) {
                    state = 'RISING';
                    regime = vol30 > vol300 ? 'HIGH' : 'NEUTRAL';
                } else if (vol30 < vol60 * 0.9) {
                    state = 'FALLING';
                    regime = vol30 < vol300 ? 'LOW' : 'NEUTRAL';
                }

                // Tendencia de volatilidad (comparando ventanas)
                let trend = 'STABLE';
                if (vol30 > vol60 * 1.05 && vol60 > vol300 * 1.05) {
                    trend = 'ACCELERATING';
                } else if (vol30 < vol60 * 0.95 && vol60 < vol300 * 0.95) {
                    trend = 'DECELERATING';
                } else if (vol30 > vol60) {
                    trend = 'INCREASING';
                } else if (vol30 < vol60) {
                    trend = 'DECREASING';
                }

                // Calcular expansi√≥n como porcentaje
                const expansion = Math.round((shortVsLong - 1) * 100);

                // Percentil de volatilidad actual vs hist√≥rica
                const currentVol = vol30;
                const allVols = [];
                for (let i = window30; i < prices.length; i++) {
                    const windowPrices = prices.slice(i - window30, i);
                    allVols.push(calcVolatility(windowPrices));
                }
                const sortedVols = allVols.filter(v => v > 0).sort((a, b) => a - b);
                const percentileIdx = sortedVols.findIndex(v => v >= currentVol);
                const percentile = sortedVols.length > 0
                    ? Math.round((percentileIdx / sortedVols.length) * 100)
                    : 50;

                // Score combinado (0-100)
                const strength = Math.min(100, Math.abs(expansion) + (percentile > 80 ? 30 : percentile < 20 ? 30 : 0) + (active ? 20 : 0));

                // Determinar estado por ventana
                const getWindowState = (shortVol, longVol, thresh) => {
                    const ratio = longVol > 0 ? shortVol / longVol : 1;
                    if (ratio > thresh) return 'EXPANSION';
                    if (ratio < (1 / thresh)) return 'COMPRESSION';
                    return 'NORMAL';
                };

                // Estado global simplificado para UI
                let uiState = 'NORMAL';
                if (state === 'EXPANDING' || shortVsLong > 1.15) uiState = 'EXPANSION';
                else if (state === 'CONTRACTING' || shortVsLong < 0.85) uiState = 'COMPRESSION';

                // Windows object para UI
                const windows = {
                    '30s': {
                        vol: parseFloat(vol30.toFixed(4)),
                        atr: parseFloat(atr30.toFixed(2)),
                        ratio: Math.round(shortVsLong * 100),
                        state: shortVsLong > 1.1 ? 'EXPANSION' : shortVsLong < 0.9 ? 'COMPRESSION' : 'NORMAL'
                    },
                    '60s': {
                        vol: parseFloat(vol60.toFixed(4)),
                        atr: parseFloat(atr60.toFixed(2)),
                        ratio: Math.round(medVsLong * 100),
                        state: medVsLong > 1.1 ? 'EXPANSION' : medVsLong < 0.9 ? 'COMPRESSION' : 'NORMAL'
                    },
                    '300s': {
                        vol: parseFloat(vol300.toFixed(4)),
                        atr: parseFloat(atr300.toFixed(2)),
                        ratio: 100, // Base reference
                        state: 'NORMAL' // Reference baseline
                    }
                };

                // Precio actual, apertura, high, low
                const currentPrice = prices[prices.length - 1];
                const openPrice = prices[0];
                const sessionHigh = Math.max(...prices);
                const sessionLow = Math.min(...prices);
                const priceChange = currentPrice - openPrice;
                const priceChangePct = openPrice > 0 ? (priceChange / openPrice) * 100 : 0;
                const sessionRange = sessionHigh - sessionLow;
                const rangePercent = sessionLow > 0 ? (sessionRange / sessionLow) * 100 : 0;

                // Posici√≥n del precio dentro del rango
                const pricePosition = sessionRange > 0 ? ((currentPrice - sessionLow) / sessionRange) * 100 : 50;

                // Volatility forecast basado en patrones
                let forecast = 'NEUTRAL';
                if (shortVsLong > 1.2 && medVsLong > 1.1) {
                    forecast = 'EXPANSION_LIKELY';
                } else if (shortVsLong < 0.8 && medVsLong < 0.9) {
                    forecast = 'COMPRESSION_LIKELY';
                } else if (vol30 > vol60 * 1.15) {
                    forecast = 'BUILDING';
                } else if (vol30 < vol60 * 0.85) {
                    forecast = 'FADING';
                }

                // Obtener TODAS las m√©tricas correlacionadas con volatilidad
                const allMetrics = [];
                const metricsToCheck = Object.keys(constants.SIGNAL_METRICS || {});
                metricsToCheck.forEach(key => {
                    const config = constants.SIGNAL_METRICS?.[key];
                    if (config) {
                        const strength = calculateMetricStrength(rows, config, 10);
                        allMetrics.push({
                            key,
                            label: config.shortLabel || key,
                            ...strength
                        });
                    }
                });
                allMetrics.sort((a, b) => b.strength - a.strength);

                return {
                    active,
                    state: uiState,
                    regime,
                    windows,
                    strength,
                    trend,
                    percentile,
                    expansion,
                    forecast,
                    // Price data
                    price: {
                        current: currentPrice,
                        open: openPrice,
                        high: sessionHigh,
                        low: sessionLow,
                        change: priceChange,
                        changePct: priceChangePct,
                        range: sessionRange,
                        rangePct: rangePercent,
                        position: pricePosition
                    },
                    // Metrics
                    topMetrics: allMetrics.slice(0, 3),
                    allMetrics: allMetrics,
                    // Raw data for debugging
                    vol30: vol30.toFixed(4),
                    vol60: vol60.toFixed(4),
                    vol300: vol300.toFixed(4),
                    shortVsLong: shortVsLong.toFixed(2),
                    medVsLong: medVsLong.toFixed(2)
                };
            }, [dataSource, volatilitySensitivity, calculateMetricStrength, volatilityMetricFilter]);

            // ===== TICK OPPORTUNITY DETECTOR + √çNDICE DE DOMINANCIA DIRECCIONAL (IDD) =====
            // Combina: Rango + Participaci√≥n + Impulso + IDD = Probabilidad de captar ticks
            const tickOpportunity = useMemo(() => {
                const defaultReturn = {
                    score: 0,
                    level: 'LOW', // LOW, MEDIUM, HIGH, EXTREME
                    active: false,
                    components: {
                        range: 0,          // Contribuci√≥n del rango
                        momentum: 0,       // Contribuci√≥n del momentum/impulso
                        participation: 0,  // Contribuci√≥n de la participaci√≥n
                        acceleration: 0,   // Velocidad del movimiento
                        // IDD Components (nuevo)
                        divergence: 0,     // Divergencia Call vs Put
                        dominance: 0,      // Fuerza de dominancia
                        amplitude: 0       // Amplitud del spread
                    },
                    ticksExpected: 0,
                    direction: 'NEUTRAL',
                    recentTicks: 0,
                    avgTicksPerMin: 0,
                    maxTicksRecent: 0,
                    confidence: 0,
                    // IDD espec√≠ficos (nuevo)
                    idd: {
                        callStrength: 0,
                        putStrength: 0,
                        spreadRatio: 0,
                        dominantSide: 'NONE',
                        metricBreakdown: [],
                        trendingUp: [],
                        trendingDown: [],
                        divergentMetrics: 0,
                        algorithm: 'dominance'
                    },
                    // Debug original
                    rangeRatio: '0',
                    momentumRatio: '0',
                    accelerationRatio: '0'
                };

                if (!dataSource?.rows?.length || dataSource.rows.length < 20) {
                    return defaultReturn;
                }

                const rows = dataSource.rows;
                const n = rows.length;
                const priceCol = 'Underlying_Price';

                // Extraer precios
                const prices = rows.map(r => parseFloat(r[priceCol]) || 0).filter(p => p > 0);
                if (prices.length < 20) return defaultReturn;

                // ============================================================
                // PARTE 1: AN√ÅLISIS ORIGINAL DE EXPANSI√ìN DE TICKS
                // ============================================================

                // === 1. AN√ÅLISIS DE RANGO (Range Score) ===
                const recentPrices = prices.slice(-30);
                const priceHigh = Math.max(...recentPrices);
                const priceLow = Math.min(...recentPrices);
                const currentRange = priceHigh - priceLow;

                const historicalRanges = [];
                for (let i = 30; i < prices.length; i++) {
                    const windowPrices = prices.slice(i - 30, i);
                    const h = Math.max(...windowPrices);
                    const l = Math.min(...windowPrices);
                    historicalRanges.push(h - l);
                }
                const avgHistoricalRange = historicalRanges.length > 0
                    ? historicalRanges.reduce((a, b) => a + b, 0) / historicalRanges.length
                    : currentRange;

                const rangeRatio = avgHistoricalRange > 0 ? currentRange / avgHistoricalRange : 1;
                const rangeScore = Math.min(100, Math.max(0, (rangeRatio - 0.5) * 100));

                // === 2. AN√ÅLISIS DE MOMENTUM/IMPULSO (Momentum Score) ===
                const priceChanges = [];
                for (let i = 1; i < recentPrices.length; i++) {
                    priceChanges.push(Math.abs(recentPrices[i] - recentPrices[i - 1]));
                }
                const avgChange = priceChanges.reduce((a, b) => a + b, 0) / (priceChanges.length || 1);
                const recentChange = priceChanges.slice(-5).reduce((a, b) => a + b, 0) / 5;

                const directionSum = recentPrices.slice(-10).reduce((acc, p, i, arr) => {
                    if (i === 0) return 0;
                    return acc + (p > arr[i - 1] ? 1 : p < arr[i - 1] ? -1 : 0);
                }, 0);
                const priceDirection = directionSum > 3 ? 'BULLISH' : directionSum < -3 ? 'BEARISH' : 'NEUTRAL';

                const momentumRatio = avgChange > 0 ? recentChange / avgChange : 1;
                const momentumScore = Math.min(100, Math.max(0, momentumRatio * 50));

                // === 3. AN√ÅLISIS DE PARTICIPACI√ìN (usando m√©tricas) ===
                let participationScore = 0;
                const metricsToCheck = ['money-flow', 'delta-flow', 'iv-flow', 'gex', 'vanna-flow'];
                let activeMetrics = 0;
                let totalMetricStrength = 0;

                metricsToCheck.forEach(key => {
                    const config = constants.SIGNAL_METRICS?.[key];
                    if (config) {
                        const strength = calculateMetricStrength(rows, config, 10);
                        if (strength.strength > 30) {
                            activeMetrics++;
                            totalMetricStrength += strength.strength;
                        }
                    }
                });

                participationScore = Math.min(100, (activeMetrics / metricsToCheck.length) * 100 + (totalMetricStrength / metricsToCheck.length) * 0.5);

                // === 4. AN√ÅLISIS DE ACELERACI√ìN ===
                const recentVelocity = priceChanges.slice(-5).reduce((a, b) => a + b, 0);
                const previousVelocity = priceChanges.slice(-10, -5).reduce((a, b) => a + b, 0);
                const accelerationRatio = previousVelocity > 0 ? recentVelocity / previousVelocity : 1;
                const accelerationScore = Math.min(100, Math.max(0, (accelerationRatio - 0.5) * 100));

                // === 5. CALCULAR TICKS RECIENTES ===
                let tickCount = 0;
                for (let i = 1; i < recentPrices.length; i++) {
                    if (recentPrices[i] !== recentPrices[i - 1]) {
                        tickCount++;
                    }
                }

                let maxTicks = tickCount;
                for (let i = 30; i < prices.length; i++) {
                    const windowPrices = prices.slice(i - 30, i);
                    let wTicks = 0;
                    for (let j = 1; j < windowPrices.length; j++) {
                        if (windowPrices[j] !== windowPrices[j - 1]) wTicks++;
                    }
                    maxTicks = Math.max(maxTicks, wTicks);
                }

                // ============================================================
                // PARTE 2: √çNDICE DE DOMINANCIA DIRECCIONAL (IDD) - NUEVO
                // ============================================================
                const lookback = Math.min(tickLookback, n);
                const recentRows = rows.slice(-lookback);
                const metricsToAnalyze = tickMetricFilter || Object.keys(constants.SIGNAL_METRICS);
                const metricResults = [];
                let totalCallStrength = 0;
                let totalPutStrength = 0;
                let divergentCount = 0;
                const trendingUp = [];
                const trendingDown = [];

                metricsToAnalyze.forEach(metricKey => {
                    const config = constants.SIGNAL_METRICS[metricKey];
                    if (!config) return;

                    const callSeries = recentRows.map(r => parseFloat(r[config.call]) || 0);
                    const putSeries = recentRows.map(r => Math.abs(parseFloat(r[config.put]) || 0));

                    const avgPeriod = Math.min(tickAvgPeriod, callSeries.length);
                    const recentCallAvg = callSeries.slice(-avgPeriod).reduce((a, b) => a + b, 0) / avgPeriod;
                    const recentPutAvg = putSeries.slice(-avgPeriod).reduce((a, b) => a + b, 0) / avgPeriod;

                    const callTrend = callSeries.length >= 5
                        ? (callSeries.slice(-1)[0] - callSeries.slice(-5)[0]) / 5
                        : 0;
                    const putTrend = putSeries.length >= 5
                        ? (putSeries.slice(-1)[0] - putSeries.slice(-5)[0]) / 5
                        : 0;

                    const total = recentCallAvg + recentPutAvg;
                    const callRatio = total > 0 ? recentCallAvg / total : 0.5;
                    const putRatio = total > 0 ? recentPutAvg / total : 0.5;

                    const isDivergent = (callTrend > 0 && putTrend < 0) || (callTrend < 0 && putTrend > 0);
                    const hasDominance = Math.max(callRatio, putRatio) >= (tickRatioThreshold / (tickRatioThreshold + 1));

                    if (isDivergent && hasDominance) {
                        divergentCount++;
                    }

                    if (callTrend > putTrend && callRatio > 0.55) {
                        trendingUp.push({ metric: config.shortLabel, strength: callRatio * 100, trend: callTrend });
                        totalCallStrength += recentCallAvg;
                    } else if (putTrend > callTrend && putRatio > 0.55) {
                        trendingDown.push({ metric: config.shortLabel, strength: putRatio * 100, trend: putTrend });
                        totalPutStrength += recentPutAvg;
                    }

                    metricResults.push({
                        metric: config.shortLabel,
                        label: config.label,
                        callAvg: recentCallAvg,
                        putAvg: recentPutAvg,
                        callTrend,
                        putTrend,
                        callRatio: callRatio * 100,
                        putRatio: putRatio * 100,
                        isDivergent,
                        hasDominance,
                        dominant: callRatio > putRatio ? 'CALL' : 'PUT'
                    });
                });

                // Calcular scores IDD (recientes)
                const totalMetrics = metricResults.length || 1;
                const divergenceScore = Math.min(100, (divergentCount / totalMetrics) * 150);

                const totalStrength = totalCallStrength + totalPutStrength;
                const dominanceRatioIDD = totalStrength > 0
                    ? Math.abs(totalCallStrength - totalPutStrength) / totalStrength
                    : 0;
                const dominanceScore = Math.min(100, dominanceRatioIDD * 150);

                const maxSpread = metricResults.reduce((max, m) => {
                    const spread = Math.abs(m.callRatio - m.putRatio);
                    return spread > max ? spread : max;
                }, 0);
                const amplitudeScore = Math.min(100, maxSpread * 2);

                const dominantSide = totalCallStrength > totalPutStrength * tickRatioThreshold
                    ? 'CALLS'
                    : totalPutStrength > totalCallStrength * tickRatioThreshold
                        ? 'PUTS'
                        : 'BALANCED';

                // ============================================================
                // IDD AN√ÅLISIS DE SESI√ìN COMPLETA (Long-Term)
                // ============================================================
                const allRows = rows; // TODA la sesi√≥n
                let sessionCallStrength = 0;
                let sessionPutStrength = 0;
                let sessionDivergentCount = 0;
                const sessionTrendingUp = [];
                const sessionTrendingDown = [];
                const sessionMetricResults = [];

                metricsToAnalyze.forEach(metricKey => {
                    const config = constants.SIGNAL_METRICS[metricKey];
                    if (!config) return;

                    const callSeries = allRows.map(r => parseFloat(r[config.call]) || 0);
                    const putSeries = allRows.map(r => Math.abs(parseFloat(r[config.put]) || 0));

                    // Promedios de TODA LA SESI√ìN
                    const sessionCallAvg = callSeries.reduce((a, b) => a + b, 0) / callSeries.length;
                    const sessionPutAvg = putSeries.reduce((a, b) => a + b, 0) / putSeries.length;

                    // Tendencia lineal de toda la sesi√≥n
                    const callTrendSession = callSeries.length >= 10
                        ? (callSeries.slice(-1)[0] - callSeries[0]) / callSeries.length
                        : 0;
                    const putTrendSession = putSeries.length >= 10
                        ? (putSeries.slice(-1)[0] - putSeries[0]) / putSeries.length
                        : 0;

                    const totalSession = sessionCallAvg + sessionPutAvg;
                    const callRatioSession = totalSession > 0 ? sessionCallAvg / totalSession : 0.5;
                    const putRatioSession = totalSession > 0 ? sessionPutAvg / totalSession : 0.5;

                    const isDivergentSession = (callTrendSession > 0 && putTrendSession < 0) || (callTrendSession < 0 && putTrendSession > 0);
                    const hasDominanceSession = Math.max(callRatioSession, putRatioSession) >= 0.6;

                    if (isDivergentSession && hasDominanceSession) {
                        sessionDivergentCount++;
                    }

                    if (callTrendSession > putTrendSession && callRatioSession > 0.55) {
                        sessionTrendingUp.push({ metric: config.shortLabel, strength: callRatioSession * 100, trend: callTrendSession });
                        sessionCallStrength += sessionCallAvg;
                    } else if (putTrendSession > callTrendSession && putRatioSession > 0.55) {
                        sessionTrendingDown.push({ metric: config.shortLabel, strength: putRatioSession * 100, trend: putTrendSession });
                        sessionPutStrength += sessionPutAvg;
                    }

                    sessionMetricResults.push({
                        metric: config.shortLabel,
                        label: config.label,
                        callAvg: sessionCallAvg,
                        putAvg: sessionPutAvg,
                        callTrend: callTrendSession,
                        putTrend: putTrendSession,
                        callRatio: callRatioSession * 100,
                        putRatio: putRatioSession * 100,
                        isDivergent: isDivergentSession,
                        hasDominance: hasDominanceSession,
                        dominant: callRatioSession > putRatioSession ? 'CALL' : 'PUT'
                    });
                });

                const sessionTotalStrength = sessionCallStrength + sessionPutStrength;
                const sessionDominanceRatio = sessionTotalStrength > 0
                    ? Math.abs(sessionCallStrength - sessionPutStrength) / sessionTotalStrength
                    : 0;

                const sessionDominantSide = sessionCallStrength > sessionPutStrength * 1.2
                    ? 'CALLS'
                    : sessionPutStrength > sessionCallStrength * 1.2
                        ? 'PUTS'
                        : 'BALANCED';

                const sessionMaxSpread = sessionMetricResults.reduce((max, m) => {
                    const spread = Math.abs(m.callRatio - m.putRatio);
                    return spread > max ? spread : max;
                }, 0);

                // Comparaci√≥n: ¬øEl sentimiento reciente coincide con la sesi√≥n?
                const sentimentAlignment = dominantSide === sessionDominantSide ? 'ALIGNED' : 'DIVERGING';
                const shiftIntensity = Math.abs(
                    (totalCallStrength / (totalStrength || 1)) - (sessionCallStrength / (sessionTotalStrength || 1))
                ) * 100;

                // ============================================================
                // PARTE 3: SCORE FINAL COMBINADO
                // ============================================================

                // Score original (expansi√≥n de ticks)
                const originalScore = (
                    rangeScore * 0.30 +
                    momentumScore * 0.30 +
                    participationScore * 0.25 +
                    accelerationScore * 0.15
                );

                // Score IDD (dominancia direccional)
                let iddScore;
                if (tickAlgorithm === 'intensity') {
                    iddScore = divergenceScore * 0.40 + amplitudeScore * 0.35 + momentumScore * 0.25;
                } else if (tickAlgorithm === 'tow') {
                    iddScore = dominanceScore * 0.40 + momentumScore * 0.35 + divergenceScore * 0.25;
                } else {
                    iddScore = divergenceScore * 0.30 + dominanceScore * 0.30 + amplitudeScore * 0.20 + momentumScore * 0.20;
                }

                // Combinar ambos scores: 60% original (ticks) + 40% IDD (direccional)
                let finalScore = originalScore * 0.60 + iddScore * 0.40;

                // Ajuste por sensibilidad
                const sensitivityMultiplier = tickOpportunitySensitivity === 1 ? 0.8 : tickOpportunitySensitivity === 3 ? 1.3 : 1.0;
                finalScore = Math.min(100, finalScore * sensitivityMultiplier);

                // Determinar direcci√≥n combinando m√©tricas y precio
                let direction = priceDirection;
                if (dominantSide === 'CALLS' && trendingUp.length > trendingDown.length) {
                    direction = 'BULLISH';
                } else if (dominantSide === 'PUTS' && trendingDown.length > trendingUp.length) {
                    direction = 'BEARISH';
                }

                // Determinar nivel
                let level = 'LOW';
                let active = false;
                if (finalScore >= 75) {
                    level = 'EXTREME';
                    active = true;
                } else if (finalScore >= 55) {
                    level = 'HIGH';
                    active = true;
                } else if (finalScore >= 35) {
                    level = 'MEDIUM';
                    active = finalScore >= 45;
                }

                const ticksExpected = Math.round((finalScore / 100) * maxTicks * 1.2);

                const confidence = Math.min(100,
                    (rangeScore > 40 ? 20 : 0) +
                    (momentumScore > 40 ? 20 : 0) +
                    (participationScore > 40 ? 20 : 0) +
                    (divergenceScore > 40 ? 20 : 0) +
                    (dominanceScore > 40 ? 20 : 0)
                );

                return {
                    score: Math.round(finalScore),
                    level,
                    active,
                    components: {
                        range: Math.round(rangeScore),
                        momentum: Math.round(momentumScore),
                        participation: Math.round(participationScore),
                        acceleration: Math.round(accelerationScore),
                        divergence: Math.round(divergenceScore),
                        dominance: Math.round(dominanceScore),
                        amplitude: Math.round(amplitudeScore)
                    },
                    ticksExpected,
                    direction,
                    recentTicks: tickCount,
                    avgTicksPerMin: Math.round(tickCount * 2),
                    maxTicksRecent: maxTicks,
                    confidence: Math.round(confidence),
                    // IDD espec√≠ficos
                    idd: {
                        // An√°lisis reciente
                        callStrength: Math.round(totalCallStrength),
                        putStrength: Math.round(totalPutStrength),
                        spreadRatio: dominanceRatioIDD.toFixed(2),
                        dominantSide,
                        metricBreakdown: metricResults.slice(0, 8),
                        trendingUp: trendingUp.slice(0, 4),
                        trendingDown: trendingDown.slice(0, 4),
                        divergentMetrics: divergentCount,
                        algorithm: tickAlgorithm,
                        // An√°lisis de sesi√≥n completa (NUEVO)
                        session: {
                            callStrength: Math.round(sessionCallStrength),
                            putStrength: Math.round(sessionPutStrength),
                            dominanceRatio: sessionDominanceRatio.toFixed(2),
                            dominantSide: sessionDominantSide,
                            trendingUp: sessionTrendingUp.slice(0, 4),
                            trendingDown: sessionTrendingDown.slice(0, 4),
                            divergentMetrics: sessionDivergentCount,
                            maxSpread: Math.round(sessionMaxSpread),
                            totalRows: allRows.length,
                            metricBreakdown: sessionMetricResults.slice(0, 8)
                        },
                        // Comparaci√≥n reciente vs. sesi√≥n
                        comparison: {
                            alignment: sentimentAlignment,
                            shiftIntensity: Math.round(shiftIntensity),
                            message: sentimentAlignment === 'ALIGNED'
                                ? `Sentimiento consistente con toda la sesi√≥n (${sessionDominantSide})`
                                : `‚ö†Ô∏è Cambio reciente: ${dominantSide} vs. Sesi√≥n: ${sessionDominantSide}`
                        }
                    },
                    // Debug
                    rangeRatio: rangeRatio.toFixed(2),
                    momentumRatio: momentumRatio.toFixed(2),
                    accelerationRatio: accelerationRatio.toFixed(2)
                };
            }, [dataSource, calculateMetricStrength, tickMetricFilter, tickAlgorithm, tickLookback, tickRatioThreshold, tickAvgPeriod, tickOpportunitySensitivity]);

            // ===== SWEEP ANALYSIS & LIQUIDITY HUNTER =====
            // Detecta barridos de m√°ximos/m√≠nimos y zonas de liquidez
            const sweepAnalysis = useMemo(() => {
                const defaultReturn = {
                    // Sweep Detection
                    sweep: {
                        active: false,
                        direction: 'NONE', // HUNTING_HIGHS, HUNTING_LOWS, NONE
                        intensity: 0,
                        reversalProb: 0,
                        sweepsUp: 0,
                        sweepsDown: 0,
                        lastSweepTime: null,
                        lastSweepType: null,
                        targetReached: false
                    },
                    // Liquidity Zones
                    liquidity: {
                        above: 0,        // Precio donde hay liquidez arriba
                        below: 0,        // Precio donde hay liquidez abajo
                        nearestTarget: 'NONE', // ABOVE, BELOW, NONE
                        distanceToTarget: 0,
                        targetPct: 0
                    },
                    // Range Expanded Details
                    rangeDetails: {
                        current: 0,
                        average: 0,
                        ratio: 0,
                        position: 'MID', // LOW, MID, HIGH
                        positionPct: 50,
                        expanding: false,
                        contracting: false,
                        rangeHigh: 0,
                        rangeLow: 0
                    },
                    // Momentum Expanded Details
                    momentumDetails: {
                        speed: 0,
                        direction: 'NEUTRAL',
                        directionScore: 0,
                        acceleration: 0,
                        consistency: 0,
                        phase: 'NEUTRAL' // IMPULSE, CORRECTION, CONSOLIDATION, NEUTRAL
                    },
                    // Participation Expanded Details
                    participationDetails: {
                        activeMetrics: 0,
                        totalMetrics: 5,
                        topMetric: { name: '-', strength: 0 },
                        secondMetric: { name: '-', strength: 0 },
                        avgStrength: 0,
                        dominant: 'NONE'
                    },
                    // Acceleration Expanded Details
                    accelerationDetails: {
                        current: 0,
                        previous: 0,
                        ratio: 0,
                        phase: 'NEUTRAL', // IMPULSE, FADING, BUILDING, NEUTRAL
                        duration: 0,
                        peakReached: false
                    }
                };

                if (!dataSource?.rows?.length || dataSource.rows.length < 30) {
                    return defaultReturn;
                }

                const rows = dataSource.rows;
                const n = rows.length;
                const priceCol = 'Underlying_Price';

                // Extraer precios
                const prices = rows.map(r => parseFloat(r[priceCol]) || 0).filter(p => p > 0);
                if (prices.length < 30) return defaultReturn;

                const currentPrice = prices[prices.length - 1];
                const recentPrices = prices.slice(-30);

                // =========================================
                // 1. SWEEP DETECTION (Detecci√≥n de Barridos)
                // =========================================

                // Encontrar swing highs y lows recientes
                const swingHighs = [];
                const swingLows = [];

                for (let i = 5; i < prices.length - 5; i++) {
                    const leftPrices = prices.slice(i - 5, i);
                    const rightPrices = prices.slice(i + 1, i + 6);
                    const current = prices[i];

                    // Swing High: precio m√°s alto que los 5 anteriores y 5 siguientes
                    if (leftPrices.every(p => p < current) && rightPrices.every(p => p < current)) {
                        swingHighs.push({ price: current, index: i });
                    }
                    // Swing Low: precio m√°s bajo que los 5 anteriores y 5 siguientes
                    if (leftPrices.every(p => p > current) && rightPrices.every(p => p > current)) {
                        swingLows.push({ price: current, index: i });
                    }
                }

                // Detectar sweeps (cuando el precio cruza un swing y vuelve)
                let sweepsUp = 0;
                let sweepsDown = 0;
                let lastSweepType = null;
                let lastSweepIndex = 0;

                // Verificar sweeps de highs (hunting longs' stops)
                swingHighs.slice(-10).forEach(sh => {
                    const pricesAfter = prices.slice(sh.index + 1);
                    const crossedAbove = pricesAfter.some(p => p > sh.price);
                    const cameBack = crossedAbove && pricesAfter.slice(-5).some(p => p < sh.price);
                    if (crossedAbove && cameBack) {
                        sweepsUp++;
                        if (sh.index > lastSweepIndex) {
                            lastSweepIndex = sh.index;
                            lastSweepType = 'HIGH';
                        }
                    }
                });

                // Verificar sweeps de lows (hunting shorts' stops)
                swingLows.slice(-10).forEach(sl => {
                    const pricesAfter = prices.slice(sl.index + 1);
                    const crossedBelow = pricesAfter.some(p => p < sl.price);
                    const cameBack = crossedBelow && pricesAfter.slice(-5).some(p => p > sl.price);
                    if (crossedBelow && cameBack) {
                        sweepsDown++;
                        if (sl.index > lastSweepIndex) {
                            lastSweepIndex = sl.index;
                            lastSweepType = 'LOW';
                        }
                    }
                });

                // Determinar direcci√≥n actual del sweep hunting
                const recentHigh = Math.max(...recentPrices.slice(-10));
                const recentLow = Math.min(...recentPrices.slice(-10));
                const pricePosition = (currentPrice - recentLow) / (recentHigh - recentLow || 1);

                let sweepDirection = 'NONE';
                let sweepActive = false;

                // Si est√° cerca de highs y movi√©ndose hacia arriba = hunting highs
                if (pricePosition > 0.85 && recentPrices[recentPrices.length - 1] > recentPrices[recentPrices.length - 3]) {
                    sweepDirection = 'HUNTING_HIGHS';
                    sweepActive = true;
                }
                // Si est√° cerca de lows y movi√©ndose hacia abajo = hunting lows
                else if (pricePosition < 0.15 && recentPrices[recentPrices.length - 1] < recentPrices[recentPrices.length - 3]) {
                    sweepDirection = 'HUNTING_LOWS';
                    sweepActive = true;
                }

                // Calcular intensidad del sweep
                const priceVelocity = Math.abs(recentPrices[recentPrices.length - 1] - recentPrices[recentPrices.length - 5]);
                const avgVelocity = recentPrices.slice(0, -5).reduce((acc, p, i, arr) => {
                    if (i === 0) return 0;
                    return acc + Math.abs(p - arr[i - 1]);
                }, 0) / (recentPrices.length - 6);
                const sweepIntensity = Math.min(100, (priceVelocity / (avgVelocity * 5 || 1)) * 100);

                // Probabilidad de reversi√≥n (basada en sweeps hist√≥ricos)
                const totalSweeps = sweepsUp + sweepsDown;
                const reversalProb = totalSweeps > 0
                    ? Math.min(85, 40 + (totalSweeps * 10) + (sweepActive ? 15 : 0))
                    : sweepActive ? 45 : 20;

                // =========================================
                // 2. LIQUIDITY ZONES
                // =========================================

                // Encontrar niveles de liquidez (swing highs/lows no barridos)
                const unsweptHighs = swingHighs.filter(sh => sh.price > currentPrice).sort((a, b) => a.price - b.price);
                const unsweptLows = swingLows.filter(sl => sl.price < currentPrice).sort((a, b) => b.price - a.price);

                const liquidityAbove = unsweptHighs[0]?.price || Math.max(...recentPrices) * 1.001;
                const liquidityBelow = unsweptLows[0]?.price || Math.min(...recentPrices) * 0.999;

                const distToAbove = liquidityAbove - currentPrice;
                const distToBelow = currentPrice - liquidityBelow;
                const nearestTarget = distToAbove < distToBelow ? 'ABOVE' : 'BELOW';
                const distanceToTarget = Math.min(distToAbove, distToBelow);
                const targetPct = (distanceToTarget / currentPrice) * 100;

                // =========================================
                // 3. RANGE DETAILS EXPANDED
                // =========================================

                const rangeHigh = Math.max(...recentPrices);
                const rangeLow = Math.min(...recentPrices);
                const currentRange = rangeHigh - rangeLow;

                // Rango hist√≥rico
                const historicalRanges = [];
                for (let i = 30; i < prices.length; i++) {
                    const windowPrices = prices.slice(i - 30, i);
                    historicalRanges.push(Math.max(...windowPrices) - Math.min(...windowPrices));
                }
                const avgRange = historicalRanges.length > 0
                    ? historicalRanges.reduce((a, b) => a + b, 0) / historicalRanges.length
                    : currentRange;

                const rangeRatio = avgRange > 0 ? currentRange / avgRange : 1;
                const positionInRange = ((currentPrice - rangeLow) / (currentRange || 1)) * 100;
                const positionLabel = positionInRange < 33 ? 'LOW' : positionInRange > 67 ? 'HIGH' : 'MID';

                // Tendencia del rango
                const prevRange = historicalRanges.slice(-5, -1).reduce((a, b) => a + b, 0) / 4 || currentRange;
                const expanding = currentRange > prevRange * 1.1;
                const contracting = currentRange < prevRange * 0.9;

                // =========================================
                // 4. MOMENTUM DETAILS EXPANDED
                // =========================================

                const priceChanges = [];
                for (let i = 1; i < recentPrices.length; i++) {
                    priceChanges.push(recentPrices[i] - recentPrices[i - 1]);
                }

                const avgSpeed = priceChanges.map(Math.abs).reduce((a, b) => a + b, 0) / priceChanges.length;
                const recentSpeed = priceChanges.slice(-5).map(Math.abs).reduce((a, b) => a + b, 0) / 5;

                // Direcci√≥n
                const directionSum = priceChanges.slice(-10).reduce((acc, c) => acc + (c > 0 ? 1 : c < 0 ? -1 : 0), 0);
                const momDirection = directionSum > 3 ? 'BULLISH' : directionSum < -3 ? 'BEARISH' : 'NEUTRAL';

                // Consistencia (qu√© tan seguido va en la misma direcci√≥n)
                const sameDirection = priceChanges.slice(-10).filter(c =>
                    (momDirection === 'BULLISH' && c > 0) || (momDirection === 'BEARISH' && c < 0)
                ).length;
                const consistency = (sameDirection / 10) * 100;

                // Fase
                let momPhase = 'NEUTRAL';
                if (recentSpeed > avgSpeed * 1.5 && consistency > 60) momPhase = 'IMPULSE';
                else if (recentSpeed < avgSpeed * 0.7) momPhase = 'CONSOLIDATION';
                else if (consistency < 40 && recentSpeed > avgSpeed) momPhase = 'CORRECTION';

                // =========================================
                // 5. PARTICIPATION DETAILS EXPANDED
                // =========================================

                const metricsToCheck = [
                    { key: 'money-flow', name: 'Money Flow' },
                    { key: 'delta-flow', name: 'Delta Flow' },
                    { key: 'premium-flow', name: 'Premium Flow' },
                    { key: 'gex', name: 'GEX' },
                    { key: 'vanna-flow', name: 'Vanna Flow' }
                ];

                const metricStrengths = metricsToCheck.map(m => {
                    const config = constants.SIGNAL_METRICS?.[m.key];
                    if (config) {
                        const result = calculateMetricStrength(rows, config, 10);
                        return { ...m, strength: result.strength, direction: result.direction };
                    }
                    return { ...m, strength: 0, direction: 'NEUTRAL' };
                }).sort((a, b) => b.strength - a.strength);

                const activeMetrics = metricStrengths.filter(m => m.strength > 30).length;
                const avgStrength = metricStrengths.reduce((a, m) => a + m.strength, 0) / metricsToCheck.length;

                // Determinar dominante
                const bullishMetrics = metricStrengths.filter(m => m.direction === 'BULLISH' && m.strength > 40).length;
                const bearishMetrics = metricStrengths.filter(m => m.direction === 'BEARISH' && m.strength > 40).length;
                const participationDominant = bullishMetrics > bearishMetrics ? 'BULLISH'
                    : bearishMetrics > bullishMetrics ? 'BEARISH' : 'MIXED';

                // =========================================
                // 6. ACCELERATION DETAILS EXPANDED
                // =========================================

                const recentVelocity = priceChanges.slice(-5).map(Math.abs).reduce((a, b) => a + b, 0);
                const previousVelocity = priceChanges.slice(-10, -5).map(Math.abs).reduce((a, b) => a + b, 0);
                const accelRatio = previousVelocity > 0 ? recentVelocity / previousVelocity : 1;

                let accelPhase = 'NEUTRAL';
                if (accelRatio > 1.5) accelPhase = 'IMPULSE';
                else if (accelRatio > 1.1) accelPhase = 'BUILDING';
                else if (accelRatio < 0.7) accelPhase = 'FADING';

                // Detectar si lleg√≥ a pico
                const velocityHistory = [];
                for (let i = 5; i < priceChanges.length; i++) {
                    velocityHistory.push(priceChanges.slice(i - 5, i).map(Math.abs).reduce((a, b) => a + b, 0));
                }
                const maxVelocity = Math.max(...velocityHistory);
                const peakReached = recentVelocity > maxVelocity * 0.9;

                return {
                    sweep: {
                        active: sweepActive,
                        direction: sweepDirection,
                        intensity: Math.round(sweepIntensity),
                        reversalProb: Math.round(reversalProb),
                        sweepsUp,
                        sweepsDown,
                        lastSweepType,
                        targetReached: sweepActive && sweepIntensity > 70
                    },
                    liquidity: {
                        above: liquidityAbove,
                        below: liquidityBelow,
                        nearestTarget,
                        distanceToTarget: distanceToTarget.toFixed(2),
                        targetPct: targetPct.toFixed(3)
                    },
                    rangeDetails: {
                        current: currentRange.toFixed(2),
                        average: avgRange.toFixed(2),
                        ratio: rangeRatio.toFixed(2),
                        position: positionLabel,
                        positionPct: Math.round(positionInRange),
                        expanding,
                        contracting,
                        rangeHigh: rangeHigh.toFixed(2),
                        rangeLow: rangeLow.toFixed(2)
                    },
                    momentumDetails: {
                        speed: recentSpeed.toFixed(3),
                        direction: momDirection,
                        directionScore: directionSum,
                        acceleration: ((recentSpeed / avgSpeed - 1) * 100).toFixed(0),
                        consistency: Math.round(consistency),
                        phase: momPhase
                    },
                    participationDetails: {
                        activeMetrics,
                        totalMetrics: metricsToCheck.length,
                        topMetric: metricStrengths[0] || { name: '-', strength: 0 },
                        secondMetric: metricStrengths[1] || { name: '-', strength: 0 },
                        avgStrength: Math.round(avgStrength),
                        dominant: participationDominant
                    },
                    accelerationDetails: {
                        current: recentVelocity.toFixed(3),
                        previous: previousVelocity.toFixed(3),
                        ratio: accelRatio.toFixed(2),
                        phase: accelPhase,
                        peakReached
                    }
                };
            }, [dataSource, calculateMetricStrength]);

            // ===== CONFLUENCE ALERT DETECTOR =====
            // Detecta: 3+ slots misma direcci√≥n + volatility arriba promedio + impulse a favor
            const confluenceAlert = useMemo(() => {
                const alert = {
                    active: false,
                    level: 0, // 0-100
                    type: 'NONE', // NONE, CAUTION, ALERT
                    direction: 'NEUTRAL', // BULLISH, BEARISH, NEUTRAL
                    signals: [],
                    checks: {
                        slotsAligned: false,
                        volatilityHigh: false,
                        impulseConfirms: false
                    },
                    description: ''
                };

                if (!multiSlotMonitor?.length) return alert;

                // === 1. SLOT MONITOR: Contar slots con impulso en cada direcci√≥n ===
                const slotsWithData = multiSlotMonitor.filter(s => s.hasData && s.impulse !== 'NONE');
                const bullishSlots = slotsWithData.filter(s => s.impulse === 'BULLISH');
                const bearishSlots = slotsWithData.filter(s => s.impulse === 'BEARISH');

                // Determinar direcci√≥n dominante de slots
                let slotDirection = 'NEUTRAL';
                let alignedCount = 0;

                if (bullishSlots.length >= 3) {
                    slotDirection = 'BULLISH';
                    alignedCount = bullishSlots.length;
                    alert.checks.slotsAligned = true;
                } else if (bearishSlots.length >= 3) {
                    slotDirection = 'BEARISH';
                    alignedCount = bearishSlots.length;
                    alert.checks.slotsAligned = true;
                }

                // Agregar se√±ales de slots alineados
                if (alert.checks.slotsAligned) {
                    const alignedSlots = slotDirection === 'BULLISH' ? bullishSlots : bearishSlots;
                    alignedSlots.forEach(slot => {
                        alert.signals.push({
                            name: slot.symbol,
                            type: 'SLOT',
                            direction: slot.impulse,
                            value: slot.change
                        });
                    });
                }

                // === 2. VOLATILITY: Arriba del promedio ===
                const volStrength = volatilityAnalysis?.strength || 0;
                const volState = volatilityAnalysis?.state || 'NORMAL';
                // Volatility alta = state EXPANSION o strength > 50
                if (volState === 'EXPANSION' || volStrength > 50) {
                    alert.checks.volatilityHigh = true;
                    alert.signals.push({
                        name: 'VOLATILITY',
                        type: 'VOL',
                        direction: 'NEUTRAL',
                        value: volStrength
                    });
                }

                // === 3. IMPULSE: A favor de la direcci√≥n de los slots ===
                const impulseActive = impulseAnalysis?.active;
                const impulseDir = impulseAnalysis?.direction;
                const impulseStrength = impulseAnalysis?.strength || 0;

                if (impulseActive && slotDirection !== 'NEUTRAL' && impulseDir === slotDirection) {
                    alert.checks.impulseConfirms = true;
                    alert.signals.push({
                        name: 'IMPULSE',
                        type: 'IMP',
                        direction: impulseDir,
                        value: impulseStrength
                    });
                }

                // === DETERMINAR TIPO DE ALERTA ===
                const checksCount = Object.values(alert.checks).filter(Boolean).length;

                if (checksCount === 3) {
                    // ALERTA COMPLETA: 3+ slots + volatility alta + impulse confirma
                    alert.active = true;
                    alert.type = 'ALERT';
                    alert.direction = slotDirection;
                    alert.level = Math.min(100, 60 + (alignedCount * 5) + (volStrength * 0.2) + (impulseStrength * 0.1));
                } else if (checksCount === 2) {
                    // PRECAUCI√ìN: 2 de 3 condiciones
                    alert.active = true;
                    alert.type = 'CAUTION';
                    alert.direction = slotDirection !== 'NEUTRAL' ? slotDirection : (impulseDir || 'NEUTRAL');
                    alert.level = Math.min(70, 30 + (alignedCount * 5) + (volStrength * 0.2));
                } else if (checksCount === 1 && alert.checks.slotsAligned && alignedCount >= 4) {
                    // Solo slots pero muy fuerte (4+)
                    alert.active = true;
                    alert.type = 'CAUTION';
                    alert.direction = slotDirection;
                    alert.level = 40;
                }

                // Descripci√≥n
                if (alert.active) {
                    const parts = [];
                    if (alert.checks.slotsAligned) parts.push(`${alignedCount} slots ${slotDirection}`);
                    if (alert.checks.volatilityHigh) parts.push(`Vol ${volStrength.toFixed(0)}%`);
                    if (alert.checks.impulseConfirms) parts.push(`Impulse ${impulseDir}`);
                    alert.description = parts.join(' + ');
                } else {
                    // Siempre mostrar el estado actual aunque no haya confluencia
                    const parts = [];
                    parts.push(`Slots: ${bullishSlots.length}‚Üë ${bearishSlots.length}‚Üì`);
                    parts.push(`Vol: ${volStrength.toFixed(0)}%`);
                    parts.push(impulseActive ? `Imp: ${impulseDir}` : 'Imp: -');
                    alert.description = parts.join(' | ');
                }

                // Guardar datos adicionales para mostrar siempre
                alert.currentData = {
                    bullishSlots: bullishSlots.length,
                    bearishSlots: bearishSlots.length,
                    totalSlots: slotsWithData.length,
                    volatility: volStrength,
                    volatilityState: volState,
                    impulseActive: impulseActive,
                    impulseDirection: impulseDir,
                    impulseStrength: impulseStrength,
                    slotDirection: slotDirection,
                    checksCount: checksCount
                };

                // Calcular nivel incluso cuando no est√° activo (para mostrar progreso)
                if (!alert.active) {
                    // Calcular un nivel parcial basado en lo que hay
                    let partialLevel = 0;
                    if (bullishSlots.length >= 2 || bearishSlots.length >= 2) partialLevel += 15;
                    if (bullishSlots.length >= 3 || bearishSlots.length >= 3) partialLevel += 15;
                    if (volStrength > 30) partialLevel += 10;
                    if (volStrength > 50) partialLevel += 10;
                    if (impulseActive) partialLevel += 10;
                    alert.level = partialLevel;
                }

                return alert;
            }, [multiSlotMonitor, impulseAnalysis, volatilityAnalysis]);

            // Ref para evitar m√∫ltiples alarmas
            const lastAlertRef = useRef({ active: false, timestamp: 0 });

            // ===== EMERGENCY ALARM SOUND =====
            const playEmergencyAlarm = useCallback((direction) => {
                if (!soundEnabled) return;
                try {
                    if (!audioContextRef.current) {
                        audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)();
                    }
                    const ctx = audioContextRef.current;
                    const now = ctx.currentTime;

                    // Alarma de emergencia - 3 pulsos r√°pidos
                    const baseFreq = direction === 'BULLISH' ? 880 : direction === 'BEARISH' ? 440 : 660;

                    for (let i = 0; i < 3; i++) {
                        const osc = ctx.createOscillator();
                        const gain = ctx.createGain();

                        osc.type = 'square';
                        osc.frequency.setValueAtTime(baseFreq, now + i * 0.15);
                        osc.frequency.setValueAtTime(baseFreq * 1.5, now + i * 0.15 + 0.05);

                        gain.gain.setValueAtTime(0, now + i * 0.15);
                        gain.gain.linearRampToValueAtTime(0.3, now + i * 0.15 + 0.02);
                        gain.gain.linearRampToValueAtTime(0, now + i * 0.15 + 0.12);

                        osc.connect(gain);
                        gain.connect(ctx.destination);

                        osc.start(now + i * 0.15);
                        osc.stop(now + i * 0.15 + 0.15);
                    }
                } catch (e) {
                    console.error('Emergency alarm error:', e);
                }
            }, [soundEnabled]);

            // Trigger alarm when confluence detected - ALERT = alarma fuerte, CAUTION = sonido suave
            useEffect(() => {
                if (confluenceAlert.active && soundEnabled) {
                    const now = Date.now();
                    // Solo alarma si pasaron al menos 30 segundos desde la √∫ltima
                    if (!lastAlertRef.current.active || (now - lastAlertRef.current.timestamp) > 30000) {
                        if (confluenceAlert.type === 'ALERT') {
                            // Alarma fuerte para ALERT
                            playEmergencyAlarm(confluenceAlert.direction);
                        }
                        // CAUTION no tiene alarma sonora (solo visual)
                        lastAlertRef.current = { active: true, timestamp: now, type: confluenceAlert.type };
                    }
                } else if (!confluenceAlert.active) {
                    lastAlertRef.current.active = false;
                }
            }, [confluenceAlert.active, confluenceAlert.type, confluenceAlert.direction, soundEnabled, playEmergencyAlarm]);

            // ===== ALERTAS DE PANELES INTELLIGENCE =====
            useEffect(() => {
                const now = Date.now();
                const cooldownMs = 30000; // 30 segundos entre alertas

                // ALERTA CONFLUENCE
                if (panelAlerts.confluence.enabled) {
                    const level = confluenceAlert.level || 0;
                    if (level >= panelAlerts.confluence.threshold && !panelAlerts.confluence.triggered) {
                        if (now - panelAlerts.confluence.lastTrigger > cooldownMs) {
                            playPanelAlertSound('confluence');
                            setPanelAlerts(prev => ({
                                ...prev,
                                confluence: { ...prev.confluence, triggered: true, lastTrigger: now }
                            }));
                        }
                    } else if (level < panelAlerts.confluence.threshold && panelAlerts.confluence.triggered) {
                        setPanelAlerts(prev => ({
                            ...prev,
                            confluence: { ...prev.confluence, triggered: false }
                        }));
                    }
                }

                // ALERTA TICK OPPORTUNITY
                if (panelAlerts.tickOpportunity.enabled) {
                    const score = tickOpportunity.score || 0;
                    if (score >= panelAlerts.tickOpportunity.threshold && !panelAlerts.tickOpportunity.triggered) {
                        if (now - panelAlerts.tickOpportunity.lastTrigger > cooldownMs) {
                            playPanelAlertSound('tickOpportunity');
                            setPanelAlerts(prev => ({
                                ...prev,
                                tickOpportunity: { ...prev.tickOpportunity, triggered: true, lastTrigger: now }
                            }));
                        }
                    } else if (score < panelAlerts.tickOpportunity.threshold && panelAlerts.tickOpportunity.triggered) {
                        setPanelAlerts(prev => ({
                            ...prev,
                            tickOpportunity: { ...prev.tickOpportunity, triggered: false }
                        }));
                    }
                }

                // ALERTA SWEEP
                if (panelAlerts.sweep.enabled) {
                    const intensity = sweepAnalysis.sweep?.intensity || 0;
                    if (intensity >= panelAlerts.sweep.threshold && sweepAnalysis.sweep?.active && !panelAlerts.sweep.triggered) {
                        if (now - panelAlerts.sweep.lastTrigger > cooldownMs) {
                            playPanelAlertSound('sweep');
                            setPanelAlerts(prev => ({
                                ...prev,
                                sweep: { ...prev.sweep, triggered: true, lastTrigger: now }
                            }));
                        }
                    } else if ((!sweepAnalysis.sweep?.active || intensity < panelAlerts.sweep.threshold) && panelAlerts.sweep.triggered) {
                        setPanelAlerts(prev => ({
                            ...prev,
                            sweep: { ...prev.sweep, triggered: false }
                        }));
                    }
                }
            }, [confluenceAlert.level, tickOpportunity.score, sweepAnalysis.sweep?.intensity, sweepAnalysis.sweep?.active, panelAlerts, playPanelAlertSound]);

            // ===== TOP 3 METRICS GLOBAL (RTH Optimized) =====
            const topMetricsGlobal = useMemo(() => {
                if (!dataSource?.rows?.length) return [];

                const rows = dataSource.rows;
                const metrics = Object.entries(constants.SIGNAL_METRICS);
                const metricStrengths = [];

                metrics.forEach(([key, config]) => {
                    const strength = calculateMetricStrength(rows, config, 10);
                    metricStrengths.push({
                        key,
                        label: config.shortLabel,
                        fullLabel: config.label,
                        color: config.colors?.call || '#4a9eff',
                        ...strength
                    });
                });

                metricStrengths.sort((a, b) => b.strength - a.strength);
                return metricStrengths.slice(0, 3);
            }, [dataSource, calculateMetricStrength]);

            // ===== FLOW LEVELS (Max Cash+/Delta+, Max Cash-/Delta-, Zero, Surges) =====
            const flowLevels = useMemo(() => {
                const result = {
                    plus: null, minus: null, zero: null,
                    surges: [], // Top 3 surges: [{strike, type, value}, ...]
                    price: 0, relatedPrice: 0, symbol: '', relatedSymbol: '',
                    type: flowLevelType // 'cash' or 'delta'
                };
                const profileData = volumeProfileData?.get(selectedSlot);

                if (!profileData || profileData.size === 0) return result;

                let maxPlusStrike = null, maxPlusValue = 0;
                let maxMinusStrike = null, maxMinusValue = 0;
                let latestTimestamp = 0;
                let earliestTimestamp = Infinity;

                // Para detectar surges: comparar mitad reciente vs mitad anterior
                const recentData = new Map(); // strike -> {call, put} en mitad reciente
                const olderData = new Map();  // strike -> {call, put} en mitad anterior

                // Primera pasada: encontrar rango de timestamps
                const allTimestamps = [];
                profileData.forEach((rows) => {
                    rows.forEach(row => {
                        if (row.timestamp) allTimestamps.push(row.timestamp);
                    });
                });
                allTimestamps.sort((a, b) => a - b);
                const midTimestamp = allTimestamps.length > 0
                    ? allTimestamps[Math.floor(allTimestamps.length / 2)]
                    : Date.now();

                const strikeAccum = new Map();

                profileData.forEach((rows) => {
                    rows.forEach(row => {
                        const strike = row.strike;
                        if (!strike || isNaN(strike)) return;

                        // Capturar precios del timestamp m√°s reciente
                        if (row.timestamp > latestTimestamp) {
                            latestTimestamp = row.timestamp;
                            result.price = row.price || 0;
                            result.relatedPrice = row.relatedPrice || 0;
                            result.symbol = row.symbol || '';
                            result.relatedSymbol = row.relatedSymbol || '';
                        }

                        const existing = strikeAccum.get(strike) || { callDelta: 0, putDelta: 0, callCash: 0, putCash: 0 };
                        existing.callDelta += Math.abs(row.dCall || 0);
                        existing.putDelta += Math.abs(row.dPuts || 0);
                        existing.callCash += Math.abs(row.callCash || 0);
                        existing.putCash += Math.abs(row.putCash || 0);
                        strikeAccum.set(strike, existing);

                        // Separar datos recientes vs anteriores para detectar surges
                        const callVal = flowLevelType === 'delta' ? Math.abs(row.dCall || 0) : Math.abs(row.callCash || 0);
                        const putVal = flowLevelType === 'delta' ? Math.abs(row.dPuts || 0) : Math.abs(row.putCash || 0);

                        if (row.timestamp >= midTimestamp) {
                            const rec = recentData.get(strike) || { call: 0, put: 0 };
                            rec.call += callVal;
                            rec.put += putVal;
                            recentData.set(strike, rec);
                        } else {
                            const old = olderData.get(strike) || { call: 0, put: 0 };
                            old.call += callVal;
                            old.put += putVal;
                            olderData.set(strike, old);
                        }
                    });
                });

                // Calcular seg√∫n el tipo seleccionado
                strikeAccum.forEach((data, strike) => {
                    if (flowLevelType === 'delta') {
                        if (data.callDelta > maxPlusValue) {
                            maxPlusValue = data.callDelta;
                            maxPlusStrike = strike;
                        }
                        if (data.putDelta > maxMinusValue) {
                            maxMinusValue = data.putDelta;
                            maxMinusStrike = strike;
                        }
                    } else {
                        if (data.callCash > maxPlusValue) {
                            maxPlusValue = data.callCash;
                            maxPlusStrike = strike;
                        }
                        if (data.putCash > maxMinusValue) {
                            maxMinusValue = data.putCash;
                            maxMinusStrike = strike;
                        }
                    }
                });

                result.plus = maxPlusStrike;
                result.minus = maxMinusStrike;

                // Zero = punto medio entre plus y minus
                if (maxPlusStrike && maxMinusStrike) {
                    result.zero = Math.round((maxPlusStrike + maxMinusStrike) / 2);
                }

                // Detectar Top 3 Surges: strikes con mayor aumento relativo
                // Surge = (reciente - anterior) / max(anterior, 1) * reciente
                // Esto prioriza tanto el incremento como el volumen absoluto
                const allSurges = [];

                recentData.forEach((recent, strike) => {
                    const older = olderData.get(strike) || { call: 0, put: 0 };

                    // Call surge: incremento significativo de calls
                    const callIncrease = recent.call - older.call;
                    if (callIncrease > 0 && recent.call > 0) {
                        // Surge score = incremento * factor de novedad
                        const noveltyFactor = older.call > 0 ? (callIncrease / older.call) : 2;
                        const surgeScore = callIncrease * Math.min(noveltyFactor, 3);
                        allSurges.push({ strike, type: 'call', value: surgeScore, raw: recent.call });
                    }

                    // Put surge: incremento significativo de puts  
                    const putIncrease = recent.put - older.put;
                    if (putIncrease > 0 && recent.put > 0) {
                        const noveltyFactor = older.put > 0 ? (putIncrease / older.put) : 2;
                        const surgeScore = putIncrease * Math.min(noveltyFactor, 3);
                        allSurges.push({ strike, type: 'put', value: surgeScore, raw: recent.put });
                    }
                });

                // Ordenar por valor y tomar top 3
                allSurges.sort((a, b) => b.value - a.value);
                result.surges = allSurges.slice(0, 3);

                return result;
            }, [volumeProfileData, selectedSlot, flowLevelType]);


            // ===== AI ANALYSIS =====
            const requestAiAnalysis = useCallback(async () => {
                if (!aiApiKey || isAnalyzing) return;
                if (Date.now() - lastAnalysisRef.current < 10000) return; // M√≠nimo 10s entre an√°lisis

                setIsAnalyzing(true);
                lastAnalysisRef.current = Date.now();

                try {
                    const analysisData = {
                        compression: compressionAnalysis,
                        pivots: pivotAnalysis,
                        impulse: impulseAnalysis,
                        topMetrics: topMetricsGlobal,
                        timestamp: new Date().toISOString()
                    };

                    const prompt = `Eres un analista cuantitativo experto. Analiza estos datos de Market Intelligence:

COMPRESION:
- Detectada: ${compressionAnalysis.detected ? 'SI' : 'NO'}
- Energ√≠a acumulada: ${compressionAnalysis.energy.toFixed(1)}%
- Volatilidad ratio: ${compressionAnalysis.volRatio?.toFixed(1) || 0}%
- Direcci√≥n probable: ${compressionAnalysis.direction}
- Duraci√≥n: ${compressionAnalysis.duration} barras
- Top m√©tricas: ${compressionAnalysis.topMetrics?.map(m => `${m.label}(${m.strength.toFixed(0)}%)`).join(', ') || 'N/A'}

ULTIMO PIVOT:
- Tipo: ${pivotAnalysis.lastPivot?.type || 'N/A'}
- Precio: ${pivotAnalysis.lastPivot?.price?.toFixed(2) || 'N/A'}
- Hace: ${pivotAnalysis.lastPivot?.barsAgo || 'N/A'} barras
- M√©tricas dominantes: ${pivotAnalysis.lastPivot?.topMetrics?.map(m => `${m.label}(${m.strength.toFixed(0)}%)`).join(', ') || 'N/A'}

IMPULSO:
- Activo: ${impulseAnalysis.active ? 'SI' : 'NO'}
- Direcci√≥n: ${impulseAnalysis.direction}
- Fuerza: ${impulseAnalysis.strength.toFixed(1)}%
- Cambio precio: ${impulseAnalysis.change?.toFixed(3) || 0}%
- Agotamiento: ${impulseAnalysis.exhaustion.toFixed(1)}%
- M√©tricas l√≠deres: ${impulseAnalysis.topMetrics?.map(m => `${m.label}(${m.strength.toFixed(0)}%)`).join(', ') || 'N/A'}

TOP 3 METRICAS ACTUALES:
${topMetricsGlobal.map((m, i) => `${i + 1}. ${m.fullLabel}: ${m.strength.toFixed(1)}% ${m.direction}`).join('\n')}

TAREA: Genera un insight ejecutivo de 3-4 l√≠neas que explique:
1. El estado actual del mercado (compresi√≥n, impulso, o transici√≥n)
2. Qu√© m√©tricas est√°n dominando y qu√© implica
3. Qu√© vigilar o esperar pr√≥ximamente
4. Nivel de confianza/riesgo de la lectura

S√© espec√≠fico con porcentajes. Lenguaje t√©cnico pero claro.`;

                    const response = await fetch('http://localhost:5000/analyze-causal', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-API-Key': aiApiKey
                        },
                        body: JSON.stringify({
                            precio_actual: parseFloat(dataSource?.rows?.[dataSource.rows.length - 1]?.['Underlying_Price']) || 0,
                            causal_data: {
                                totalEvents: 1,
                                causes: {
                                    'Market_Intelligence': {
                                        occurrences: 1,
                                        triggers: topMetricsGlobal.map(m => ({
                                            metric: m.fullLabel,
                                            correlation: m.strength,
                                            direction: m.direction
                                        }))
                                    }
                                }
                            },
                            timestamp: new Date().toLocaleTimeString(),
                            custom_prompt: prompt
                        })
                    });

                    const result = await response.json();

                    if (result.success) {
                        const insight = {
                            text: result.explanation,
                            timestamp: new Date().toLocaleTimeString(),
                            compression: compressionAnalysis.detected,
                            impulse: impulseAnalysis.active,
                            direction: impulseAnalysis.active ? impulseAnalysis.direction :
                                compressionAnalysis.detected ? compressionAnalysis.direction : 'NEUTRAL'
                        };
                        setAiInsight(insight);
                        setAnalysisHistory(prev => [insight, ...prev.slice(0, 9)]);
                    }
                } catch (error) {
                    console.error('AI Analysis error:', error);
                }

                setIsAnalyzing(false);
            }, [aiApiKey, isAnalyzing, compressionAnalysis, pivotAnalysis, impulseAnalysis, topMetricsGlobal, dataSource]);

            // Auto-an√°lisis
            useEffect(() => {
                if (!autoAnalyze || !aiApiKey) return;

                const interval = setInterval(() => {
                    requestAiAnalysis();
                }, analysisInterval * 1000);

                return () => clearInterval(interval);
            }, [autoAnalyze, analysisInterval, aiApiKey, requestAiAnalysis]);

            // ===== CHART RENDERING =====
            useEffect(() => {
                if (!chartRef.current || !dataSource?.rows?.length) {
                    if (chartInstance.current) {
                        chartInstance.current.dispose();
                        chartInstance.current = null;
                    }
                    return;
                }

                if (!chartInstance.current) {
                    chartInstance.current = echarts.init(chartRef.current, null, { renderer: 'canvas' });
                }

                const rows = dataSource.rows;
                const priceCol = 'Underlying_Price';
                const n = rows.length;
                const step = Math.max(1, Math.floor(n / 200));

                const priceData = [];
                const timestamps = [];
                const fullTimestamps = []; // Para tooltip
                const rowIndices = []; // Para calcular m√©tricas en tooltip

                for (let i = 0; i < n; i += step) {
                    priceData.push(parseFloat(rows[i][priceCol]) || 0);
                    rowIndices.push(i);
                    const ts = rows[i][dataSource.timestampHeader];

                    // Extraer hora de diferentes formatos
                    let timeLabel = '';
                    let fullTime = '';

                    if (ts instanceof Date) {
                        // Es un objeto Date
                        fullTime = ts.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
                        timeLabel = ts.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
                    } else if (typeof ts === 'string') {
                        // Si contiene espacio, puede ser "fecha hora"
                        if (ts.includes(' ')) {
                            const parts = ts.split(' ');
                            fullTime = parts[parts.length - 1];
                            timeLabel = parts[parts.length - 1].slice(0, 5); // HH:MM
                        } else if (ts.includes(':')) {
                            // Solo hora
                            fullTime = ts;
                            timeLabel = ts.slice(0, 5);
                        } else {
                            // Intentar parsear como fecha
                            const parsed = new Date(ts);
                            if (!isNaN(parsed.getTime())) {
                                fullTime = parsed.toLocaleTimeString();
                                timeLabel = parsed.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
                            } else {
                                fullTime = ts;
                                timeLabel = ts.slice(-8);
                            }
                        }
                    } else if (typeof ts === 'number') {
                        // Timestamp num√©rico - convertir a hora
                        const date = new Date(ts);
                        fullTime = date.toLocaleTimeString();
                        timeLabel = date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
                    } else {
                        timeLabel = `#${i}`;
                        fullTime = `Row ${i}`;
                    }
                    timestamps.push(timeLabel || `#${i}`);
                    fullTimestamps.push(fullTime || `Row ${i}`);
                }

                // Filtrar pivots seg√∫n el filtro de m√©tricas seleccionado
                const filteredPivots = pivotMetricFilter && pivotMetricFilter.length > 0
                    ? (pivotAnalysis.pivots || []).filter(p =>
                        p.topMetrics && p.topMetrics.some(m => pivotMetricFilter.includes(m.key))
                    )
                    : (pivotAnalysis.pivots || []);

                // Marcar pivots - burbujas elegantes
                const pivotMarkers = filteredPivots.map((pivot, idx) => {
                    // Usar barsAgo para posici√≥n estable (no cambia con nuevos datos)
                    // barsAgo = cu√°ntas barras atr√°s desde el final de los datos originales
                    // Posici√≥n en gr√°fico = final - (barsAgo proporcional al muestreo)
                    const barsFromEnd = pivot.barsAgo || 0;
                    const pivotN = pivot.totalRows || n;
                    const proportionalBarsFromEnd = Math.round((barsFromEnd / pivotN) * (timestamps.length - 1));
                    const dataIdx = Math.max(0, timestamps.length - 1 - proportionalBarsFromEnd);

                    // Usar el precio del punto muestreado para alineaci√≥n exacta
                    const chartPrice = priceData[dataIdx];

                    const total = filteredPivots.length;
                    const isRecent = idx >= total - 2; // √öltimos 2 m√°s destacados

                    // Opacidad gradual basada en posici√≥n (m√°s antiguo = m√°s sutil)
                    const baseOpacity = 0.4 + (idx / total) * 0.4;
                    const opacity = isRecent ? 0.85 : baseOpacity;

                    // Tama√±o basado en fuerza de m√©tricas
                    const strengthFactor = Math.min(1.5, (pivot.avgStrength || 30) / 30);
                    const size = isRecent ? 18 * strengthFactor : 12 * strengthFactor;

                    // Formatear m√©tricas con colores individuales usando rich text de ECharts
                    const metricsLabel = pivot.topMetrics.map(m => {
                        const styleName = m.direction === 'BULLISH' ? 'bull' : m.direction === 'BEARISH' ? 'bear' : 'neut';
                        return `{${styleName}|${m.label} ${m.strength.toFixed(0)}%}`;
                    }).join(' ');

                    // Colores s√≥lidos basados en SENTIMIENTO
                    let fillColor, borderColor;
                    if (pivot.sentiment === 'BULLISH') {
                        // AZUL s√≥lido para sentimiento alcista
                        fillColor = `rgba(59, 130, 246, ${opacity * 0.5})`; // blue-500
                        borderColor = '#3b82f6'; // blue-500 s√≥lido
                    } else if (pivot.sentiment === 'BEARISH') {
                        // ROJO s√≥lido para sentimiento bajista
                        fillColor = `rgba(239, 68, 68, ${opacity * 0.5})`; // red-500
                        borderColor = '#ef4444'; // red-500 s√≥lido
                    } else {
                        // GRIS para neutral
                        fillColor = `rgba(107, 114, 128, ${opacity * 0.5})`; // gray-500
                        borderColor = '#6b7280'; // gray-500 s√≥lido
                    }

                    return {
                        coord: [dataIdx, chartPrice],
                        symbol: 'circle',
                        symbolSize: size,
                        itemStyle: {
                            color: fillColor,
                            borderColor: borderColor,
                            borderWidth: isRecent ? 2.5 : 1.5
                        },
                        label: {
                            show: pivot.sentiment !== 'NEUTRAL', // Solo mostrar etiqueta si es agresivo (BULLISH/BEARISH)
                            position: pivot.type === 'HIGH' ? 'top' : 'bottom',
                            distance: 10,
                            formatter: metricsLabel,
                            fontSize: isRecent ? 11 : 9,
                            fontWeight: isRecent ? 700 : 500,
                            fontFamily: 'system-ui, -apple-system, sans-serif',
                            rich: {
                                bull: { color: '#3b82f6', fontWeight: 'bold', fontSize: isRecent ? 11 : 9 },
                                bear: { color: '#ef4444', fontWeight: 'bold', fontSize: isRecent ? 11 : 9 },
                                neut: { color: '#9ca3af', fontSize: isRecent ? 11 : 9 }
                            },
                            textShadowColor: 'rgba(0,0,0,0.95)',
                            textShadowBlur: 5,
                            textShadowOffsetX: 1,
                            textShadowOffsetY: 1,
                            backgroundColor: 'transparent',
                            padding: [0, 0],
                            borderRadius: 0
                        }
                    };
                });

                // L√≠neas horizontales sutiles en pivots para persistencia visual (CONDICIONAL)
                const pivotLines = visibleModules.pivots ? filteredPivots.slice(-6).map((pivot, idx) => {
                    const isRecent = idx >= 3;
                    return {
                        yAxis: pivot.price,
                        lineStyle: {
                            color: pivot.type === 'HIGH'
                                ? `rgba(239, 68, 68, ${isRecent ? 0.25 : 0.12})`
                                : `rgba(34, 197, 94, ${isRecent ? 0.25 : 0.12})`,
                            width: 1,
                            type: 'dashed'
                        },
                        label: {
                            show: true,
                            position: 'insideEndTop',
                            formatter: pivot.price.toFixed(2),
                            fontSize: 8,
                            color: pivot.type === 'HIGH' ? 'rgba(239,68,68,0.6)' : 'rgba(34,197,94,0.6)',
                            backgroundColor: 'transparent'
                        }
                    };
                }) : [];

                // === ABSORPTION MARKERS - Marcadores bonitos morados y verdes ===
                // Aplicar filtro de m√©tricas tambi√©n al gr√°fico (usa array como pivots)
                const chartFilteredZones = absorptionMetricFilter && absorptionMetricFilter.length > 0
                    ? absorptionAnalysis.zones.filter(z => z.factors && z.factors.some(f => absorptionMetricFilter.includes(f)))
                    : absorptionAnalysis.zones;

                const absorptionMarkers = visibleModules.absorption && chartFilteredZones.length > 0
                    ? chartFilteredZones.slice(-15).map((zone, idx) => {
                        const barsFromEnd = zone.barsAgo || 0;
                        const proportionalBarsFromEnd = Math.round((barsFromEnd / n) * (timestamps.length - 1));
                        const dataIdx = Math.max(0, timestamps.length - 1 - proportionalBarsFromEnd);
                        const chartPrice = priceData[dataIdx] || zone.price;

                        const total = chartFilteredZones.length;
                        const isRecent = idx >= total - 3;

                        // Opacidad gradual
                        const baseOpacity = 0.5 + (idx / total) * 0.4;
                        const opacity = isRecent ? 0.9 : baseOpacity;

                        // Tama√±o basado en intensidad
                        const intensityFactor = Math.min(1.8, (zone.intensity || 50) / 50);
                        const size = isRecent ? 20 * intensityFactor : 14 * intensityFactor;

                        // Colores: BULLISH=Verde esmeralda brillante, BEARISH=Morado/Violeta, NEUTRAL=Rosa
                        let fillColor, borderColor, glowColor;
                        if (zone.type === 'BULLISH') {
                            // Verde esmeralda brillante
                            fillColor = `rgba(16, 185, 129, ${opacity * 0.6})`; // emerald-500
                            borderColor = '#10b981';
                            glowColor = 'rgba(16, 185, 129, 0.5)';
                        } else if (zone.type === 'BEARISH') {
                            // Morado/Violeta vibrante
                            fillColor = `rgba(168, 85, 247, ${opacity * 0.6})`; // purple-500
                            borderColor = '#a855f7';
                            glowColor = 'rgba(168, 85, 247, 0.5)';
                        } else {
                            // Rosa para neutral
                            fillColor = `rgba(236, 72, 153, ${opacity * 0.6})`; // pink-500
                            borderColor = '#ec4899';
                            glowColor = 'rgba(236, 72, 153, 0.5)';
                        }

                        // Label con factores de absorci√≥n
                        const factorsLabel = zone.factors.slice(0, 2).map(f => {
                            const styleName = zone.type === 'BULLISH' ? 'absB' : zone.type === 'BEARISH' ? 'absP' : 'absN';
                            return `{${styleName}|${f}}`;
                        }).join(' ');

                        return {
                            coord: [dataIdx, chartPrice],
                            symbol: 'diamond', // Diamante para diferenciar de pivots
                            symbolSize: size,
                            itemStyle: {
                                color: fillColor,
                                borderColor: borderColor,
                                borderWidth: isRecent ? 3 : 2,
                                shadowBlur: isRecent ? 12 : 6,
                                shadowColor: glowColor
                            },
                            label: {
                                show: zone.class === 'INSTITUTIONAL' || zone.class === 'MAJOR' || isRecent,
                                position: zone.type === 'BEARISH' ? 'bottom' : 'top',
                                distance: 12,
                                formatter: `{score|${zone.score}%} ${factorsLabel}`,
                                fontSize: isRecent ? 10 : 8,
                                fontWeight: isRecent ? 700 : 500,
                                fontFamily: 'system-ui, -apple-system, sans-serif',
                                rich: {
                                    score: {
                                        color: zone.class === 'INSTITUTIONAL' ? '#f59e0b' : '#d946ef',
                                        fontWeight: 'bold',
                                        fontSize: isRecent ? 10 : 8
                                    },
                                    absB: { color: '#10b981', fontWeight: 'bold', fontSize: isRecent ? 9 : 7 }, // Bullish verde
                                    absP: { color: '#a855f7', fontWeight: 'bold', fontSize: isRecent ? 9 : 7 }, // Bearish morado
                                    absN: { color: '#ec4899', fontSize: isRecent ? 9 : 7 } // Neutral rosa
                                },
                                textShadowColor: 'rgba(0,0,0,0.95)',
                                textShadowBlur: 5,
                                textShadowOffsetX: 1,
                                textShadowOffsetY: 1,
                                backgroundColor: 'transparent',
                                padding: [0, 0],
                                borderRadius: 0
                            }
                        };
                    })
                    : [];

                // L√≠neas de absorci√≥n (niveles clave)
                const absorptionLines = visibleModules.absorption && absorptionAnalysis.keyLevels.length > 0
                    ? absorptionAnalysis.keyLevels.slice(0, 3).map((level, idx) => {
                        const isTop = idx === 0;
                        return {
                            yAxis: level.price,
                            lineStyle: {
                                color: level.type === 'BULLISH'
                                    ? `rgba(16, 185, 129, ${isTop ? 0.5 : 0.25})`
                                    : level.type === 'BEARISH'
                                        ? `rgba(168, 85, 247, ${isTop ? 0.5 : 0.25})`
                                        : `rgba(236, 72, 153, ${isTop ? 0.5 : 0.25})`,
                                width: isTop ? 2 : 1,
                                type: 'dotted'
                            },
                            label: {
                                show: true,
                                position: 'insideEndTop',
                                formatter: `ABS ${level.price.toFixed(2)}`,
                                fontSize: 8,
                                color: level.type === 'BULLISH' ? '#10b981' : level.type === 'BEARISH' ? '#a855f7' : '#ec4899',
                                backgroundColor: 'rgba(0,0,0,0.5)',
                                padding: [1, 3],
                                borderRadius: 2
                            }
                        };
                    })
                    : [];

                // === FLOW LEVEL LINES (usando flowLevels del useMemo) ===
                const flowLevelLines = [];

                if (flowLevels.plus || flowLevels.minus || flowLevels.zero) {
                    // S√≠mbolos seg√∫n tipo seleccionado
                    const plusSymbol = flowLevels.type === 'delta' ? 'Œî+' : '$+';
                    const minusSymbol = flowLevels.type === 'delta' ? 'Œî-' : '$-';
                    const zeroSymbol = flowLevels.type === 'delta' ? '0Œî' : '0$';

                    // Formatear precios para labels (ej: "QQQ 510.25 | NQ 21450")
                    const formatPriceLabel = (prefix) => {
                        let label = prefix;
                        if (flowLevels.price > 0 && flowLevels.symbol) {
                            label += ` ${flowLevels.symbol} ${flowLevels.price.toFixed(2)}`;
                            if (flowLevels.relatedPrice > 0 && flowLevels.relatedSymbol) {
                                label += ` | ${flowLevels.relatedSymbol} ${flowLevels.relatedPrice.toFixed(0)}`;
                            }
                        }
                        return label;
                    };

                    // Agregar l√≠neas de niveles
                    if (flowLevels.plus) {
                        flowLevelLines.push({
                            yAxis: flowLevels.plus,
                            lineStyle: { color: 'rgba(59, 130, 246, 0.7)', width: 2, type: 'solid' },
                            label: {
                                show: true,
                                position: 'insideEndTop',
                                formatter: formatPriceLabel(plusSymbol),
                                fontSize: 9,
                                fontWeight: 'bold',
                                color: '#3b82f6',
                                backgroundColor: 'rgba(0,0,0,0.6)',
                                padding: [2, 4],
                                borderRadius: 2
                            }
                        });
                    }
                    if (flowLevels.minus) {
                        flowLevelLines.push({
                            yAxis: flowLevels.minus,
                            lineStyle: { color: 'rgba(239, 68, 68, 0.7)', width: 2, type: 'solid' },
                            label: {
                                show: true,
                                position: 'insideEndTop',
                                formatter: formatPriceLabel(minusSymbol),
                                fontSize: 9,
                                fontWeight: 'bold',
                                color: '#ef4444',
                                backgroundColor: 'rgba(0,0,0,0.6)',
                                padding: [2, 4],
                                borderRadius: 2
                            }
                        });
                    }
                    if (flowLevels.zero) {
                        flowLevelLines.push({
                            yAxis: flowLevels.zero,
                            lineStyle: { color: 'rgba(156, 163, 175, 0.8)', width: 2, type: 'dotted' },
                            label: {
                                show: true,
                                position: 'insideEndTop',
                                formatter: formatPriceLabel(zeroSymbol),
                                fontSize: 9,
                                fontWeight: 'bold',
                                color: '#9ca3af',
                                backgroundColor: 'rgba(0,0,0,0.6)',
                                padding: [2, 4],
                                borderRadius: 2
                            }
                        });
                    }
                }

                // Top 3 Surges como burbujas sutiles semitransparentes
                const surgePoints = [];
                if (flowLevels.surges && flowLevels.surges.length > 0) {
                    const lastXIndex = timestamps.length - 1; // Posici√≥n X al final del gr√°fico

                    flowLevels.surges.forEach((surge, idx) => {
                        const surgeSymbol = surge.type === 'call' ? '‚Üë' : '‚Üì';
                        const size = 24 - (idx * 5); // Tama√±o m√°s sutil: 24, 19, 14
                        const opacity = 0.35 - (idx * 0.08); // M√°s transparente: 0.35, 0.27, 0.19

                        surgePoints.push({
                            coord: [lastXIndex - (idx * 3), surge.strike], // Escalonados hacia la izquierda
                            symbol: 'circle',
                            symbolSize: size,
                            itemStyle: {
                                color: `rgba(251, 191, 36, ${opacity})`,
                                borderColor: 'transparent',
                                borderWidth: 0
                            },
                            label: {
                                show: true,
                                formatter: `${surgeSymbol}${idx + 1}`,
                                color: '#000',
                                fontSize: 10 - idx,
                                fontWeight: 'bold'
                            }
                        });
                    });
                }

                // Combinar l√≠neas de pivots + flow levels + absorci√≥n
                const allMarkLines = [...pivotLines, ...flowLevelLines, ...absorptionLines];

                // Zonas de compresi√≥n e impulso
                const markAreas = [];

                if (compressionAnalysis.detected && compressionAnalysis.duration > 5) {
                    const startIdx = Math.floor((n - compressionAnalysis.duration) / step);
                    markAreas.push([
                        { xAxis: Math.max(0, startIdx), itemStyle: { color: 'rgba(251, 191, 36, 0.1)' } },
                        { xAxis: Math.floor(n / step) - 1 }
                    ]);
                }

                if (impulseAnalysis.active) {
                    const startIdx = Math.floor((n - 10) / step);
                    markAreas.push([
                        {
                            xAxis: Math.max(0, startIdx), itemStyle: {
                                color: impulseAnalysis.direction === 'BULLISH'
                                    ? 'rgba(59, 130, 246, 0.15)'
                                    : 'rgba(239, 68, 68, 0.15)'
                            }
                        },
                        { xAxis: Math.floor(n / step) - 1 }
                    ]);
                }

                const option = {
                    animation: false,
                    backgroundColor: 'transparent',
                    grid: { left: 55, right: 50, top: 30, bottom: 35 },
                    tooltip: {
                        trigger: 'axis',
                        backgroundColor: 'rgba(10, 10, 10, 0.95)',
                        borderColor: '#333',
                        padding: [8, 12],
                        textStyle: { color: '#e5e5e5', fontSize: 11 },
                        formatter: (params) => {
                            const idx = params[0]?.dataIndex;
                            const price = params[0]?.value;
                            const time = fullTimestamps[idx] || timestamps[idx] || '';
                            const rowIdx = rowIndices[idx];

                            // Calcular m√©tricas dominantes para este punto
                            let metricsHtml = '';
                            if (rowIdx !== undefined && rows[rowIdx]) {
                                const windowRows = rows.slice(Math.max(0, rowIdx - 3), rowIdx + 1);
                                const metrics = Object.entries(constants.SIGNAL_METRICS);
                                const metricStrengths = [];

                                metrics.forEach(([key, config]) => {
                                    const str = calculateMetricStrength(windowRows, config, 3);
                                    metricStrengths.push({ label: config.shortLabel, ...str });
                                });

                                metricStrengths.sort((a, b) => b.strength - a.strength);
                                const top3 = metricStrengths.slice(0, 3);

                                metricsHtml = top3.map(m => {
                                    const color = m.direction === 'BULLISH' ? '#60a5fa' : m.direction === 'BEARISH' ? '#f87171' : '#888';
                                    return `<span style="color:${color};">${m.label} ${m.strength.toFixed(0)}%</span>`;
                                }).join(' <span style="color:#444;">|</span> ');
                            }

                            return `<div style="font-family: system-ui, sans-serif;">
                                <div style="color: #888; font-size: 10px; margin-bottom: 2px;">${time}</div>
                                <div style="font-size: 14px; font-weight: bold; color: #fff; margin-bottom: 4px;">$${price?.toFixed(2) || '---'}</div>
                                ${metricsHtml ? `<div style="font-size: 10px; border-top: 1px solid #333; padding-top: 4px; margin-top: 2px;">${metricsHtml}</div>` : ''}
                            </div>`;
                        }
                    },
                    xAxis: {
                        type: 'category',
                        data: timestamps,
                        axisLine: { lineStyle: { color: '#2a2a2a' } },
                        axisLabel: { color: '#888', fontSize: 10, rotate: 0, interval: Math.floor(timestamps.length / 6) },
                        splitLine: { show: false }
                    },
                    yAxis: {
                        type: 'value',
                        scale: true,
                        axisLine: { lineStyle: { color: '#2a2a2a' } },
                        axisLabel: { color: '#888', fontSize: 10, formatter: (v) => v.toFixed(2) },
                        splitLine: { lineStyle: { color: '#1a1a1a', type: 'dashed' } }
                    },
                    dataZoom: [
                        {
                            type: 'inside',
                            start: isZoomed ? 65 : 0,
                            end: 100,
                            zoomOnMouseWheel: false,
                            moveOnMouseMove: false
                        }
                    ],
                    series: [{
                        type: 'line',
                        data: priceData,
                        smooth: 0.3,
                        symbol: 'none',
                        lineStyle: {
                            width: 2.5,
                            color: impulseAnalysis.active
                                ? (impulseAnalysis.direction === 'BULLISH' ? '#3b82f6' : '#ef4444')
                                : '#6b7280'
                        },
                        areaStyle: {
                            color: {
                                type: 'linear',
                                x: 0, y: 0, x2: 0, y2: 1,
                                colorStops: [
                                    {
                                        offset: 0, color: impulseAnalysis.active
                                            ? (impulseAnalysis.direction === 'BULLISH' ? 'rgba(59, 130, 246, 0.25)' : 'rgba(239, 68, 68, 0.25)')
                                            : 'rgba(107, 114, 128, 0.15)'
                                    },
                                    { offset: 1, color: 'transparent' }
                                ]
                            }
                        },
                        markPoint: {
                            data: [...(visibleModules.pivots ? pivotMarkers : []), ...absorptionMarkers, ...surgePoints],
                            animation: false
                        },
                        markLine: {
                            data: allMarkLines,
                            symbol: 'none',
                            animation: false,
                            silent: true
                        },
                        markArea: {
                            data: markAreas
                        }
                    }]
                };

                chartInstance.current.setOption(option, true);

                // Evento doble click para toggle zoom (usando getZr para el canvas)
                const zr = chartInstance.current.getZr();
                zr.off('dblclick');
                zr.on('dblclick', () => {
                    setIsZoomed(prev => !prev);
                });

                return () => {
                    if (chartInstance.current) {
                        chartInstance.current.dispose();
                        chartInstance.current = null;
                    }
                };
            }, [dataSource, pivotAnalysis, compressionAnalysis, impulseAnalysis, isZoomed, flowLevels, pivotMetricFilter, absorptionAnalysis, visibleModules, absorptionMetricFilter]);

            // ===== SOUND TRIGGER EFFECTS =====
            // Impulse sound trigger
            useEffect(() => {
                const prevActive = prevImpulseRef.current.active;
                const prevDir = prevImpulseRef.current.direction;

                // Sonido cuando se activa un nuevo impulso o cambia de direcci√≥n
                if (impulseAnalysis.active && (!prevActive || prevDir !== impulseAnalysis.direction)) {
                    playImpulseSound(impulseAnalysis.direction);
                }

                prevImpulseRef.current = { active: impulseAnalysis.active, direction: impulseAnalysis.direction };
            }, [impulseAnalysis.active, impulseAnalysis.direction, playImpulseSound]);

            // Volatility sound trigger + history
            useEffect(() => {
                const prevState = prevVolatilityRef.current.state;

                // Sonido cuando cambia a EXPANSION o COMPRESSION desde NORMAL
                if (volatilityAnalysis.state !== 'NORMAL' && prevState === 'NORMAL') {
                    playVolatilitySound(volatilityAnalysis.state);
                    // Registrar en historial
                    setSessionHistory(prev => ({
                        ...prev,
                        volatilityEvents: [...prev.volatilityEvents, {
                            timestamp: new Date().toISOString(),
                            state: volatilityAnalysis.state,
                            strength: volatilityAnalysis.strength || 0,
                            trend: volatilityAnalysis.trend,
                            metrics: volatilityAnalysis.topMetrics?.map(m => ({ key: m.key, label: m.label, direction: m.direction, strength: m.strength })) || []
                        }]
                    }));
                }
                // Tambi√©n si cambia de COMPRESSION a EXPANSION o viceversa
                else if (volatilityAnalysis.state !== prevState && volatilityAnalysis.state !== 'NORMAL') {
                    playVolatilitySound(volatilityAnalysis.state);
                    setSessionHistory(prev => ({
                        ...prev,
                        volatilityEvents: [...prev.volatilityEvents, {
                            timestamp: new Date().toISOString(),
                            state: volatilityAnalysis.state,
                            strength: volatilityAnalysis.strength || 0,
                            trend: volatilityAnalysis.trend,
                            metrics: volatilityAnalysis.topMetrics?.map(m => ({ key: m.key, label: m.label, direction: m.direction, strength: m.strength })) || []
                        }]
                    }));
                }

                prevVolatilityRef.current = { state: volatilityAnalysis.state };
            }, [volatilityAnalysis.state, volatilityAnalysis.strength, volatilityAnalysis.topMetrics, playVolatilitySound]);

            // Compression sound trigger + breakout history
            useEffect(() => {
                const prevDetected = prevCompressionRef.current.detected;
                const prevStartTime = prevCompressionRef.current.startTime;
                const prevMetrics = prevCompressionRef.current.metrics;

                // Cuando INICIA una compresi√≥n - guardar momento y m√©tricas
                if (compressionAnalysis.detected && !prevDetected) {
                    playCompressionSound();
                    prevCompressionRef.current = {
                        detected: true,
                        startTime: new Date().toISOString(),
                        metrics: compressionAnalysis.topMetrics || []
                    };
                }
                // Cuando TERMINA una compresi√≥n (breakout) - registrar el evento
                else if (!compressionAnalysis.detected && prevDetected && prevStartTime) {
                    setSessionHistory(prev => ({
                        ...prev,
                        compressionBreakouts: [...prev.compressionBreakouts, {
                            timestamp: new Date().toISOString(),
                            startTime: prevStartTime,
                            direction: compressionAnalysis.direction || 'NEUTRAL',
                            duration: compressionAnalysis.duration || 0,
                            energy: compressionAnalysis.energy || 0,
                            metricsAtStart: prevMetrics?.map(m => ({ key: m.key, label: m.label, direction: m.direction, strength: m.strength })) || [],
                            triggerMetrics: compressionAnalysis.topMetrics?.map(m => ({ key: m.key, label: m.label, direction: m.direction, strength: m.strength })) || []
                        }]
                    }));
                    prevCompressionRef.current = { detected: false, startTime: null, metrics: [] };
                }
                else if (!compressionAnalysis.detected) {
                    prevCompressionRef.current = { detected: false, startTime: null, metrics: [] };
                }
            }, [compressionAnalysis.detected, compressionAnalysis.direction, compressionAnalysis.topMetrics, playCompressionSound]);

            // Pivot history tracking
            useEffect(() => {
                if (pivotAnalysis.lastPivot && pivotAnalysis.pivots?.length > 0) {
                    const lastPivot = pivotAnalysis.lastPivot;
                    const pivotId = `${lastPivot.type}-${lastPivot.price}-${lastPivot.barsAgo}`;

                    setSessionHistory(prev => {
                        // Evitar duplicados
                        const exists = prev.pivots.some(p =>
                            p.type === lastPivot.type &&
                            Math.abs(p.price - lastPivot.price) < 0.01 &&
                            p.barsAgo === lastPivot.barsAgo
                        );
                        if (exists) return prev;

                        return {
                            ...prev,
                            pivots: [...prev.pivots, {
                                timestamp: new Date().toISOString(),
                                type: lastPivot.type,
                                price: lastPivot.price,
                                barsAgo: lastPivot.barsAgo,
                                metrics: lastPivot.topMetrics?.map(m => ({ key: m.key, label: m.label, direction: m.direction, strength: m.strength })) || []
                            }].slice(-100) // Mantener √∫ltimos 100
                        };
                    });
                }
            }, [pivotAnalysis.lastPivot, pivotAnalysis.pivots?.length]);

            // Impulse history tracking - FIXED: Registrar cada impulso detectado
            useEffect(() => {
                const prev = prevImpulseRef.current;

                // Registrar nuevo impulso cuando:
                // 1. Impulso se activa (active cambia de false a true)
                // 2. Direcci√≥n cambia mientras est√° activo
                // 3. Impulso activo con fuerza significativamente diferente (>10 puntos)
                const strengthChanged = Math.abs((impulseAnalysis.strength || 0) - (prev.strength || 0)) > 10;
                const isNewImpulse = impulseAnalysis.active && (
                    !prev.active ||
                    prev.direction !== impulseAnalysis.direction ||
                    (strengthChanged && !prev.recordedStrength)
                );

                if (isNewImpulse) {
                    console.log('Recording impulse:', impulseAnalysis.direction, impulseAnalysis.strength);
                    setSessionHistory(prevHist => ({
                        ...prevHist,
                        impulses: [...prevHist.impulses, {
                            timestamp: new Date().toISOString(),
                            direction: impulseAnalysis.direction,
                            strength: impulseAnalysis.strength || 0,
                            change: impulseAnalysis.change || 0,
                            velocity: impulseAnalysis.velocity || 0,
                            exhaustion: impulseAnalysis.exhaustion || 0,
                            metrics: impulseAnalysis.topMetrics?.map(m => ({ key: m.key, label: m.label, direction: m.direction, strength: m.strength })) || []
                        }].slice(-100)
                    }));
                    prevImpulseRef.current = {
                        active: impulseAnalysis.active,
                        direction: impulseAnalysis.direction,
                        strength: impulseAnalysis.strength,
                        recordedStrength: true
                    };
                } else if (!impulseAnalysis.active && prev.active) {
                    // Impulso termin√≥, resetear
                    prevImpulseRef.current = { active: false, direction: null, strength: 0, recordedStrength: false };
                } else {
                    prevImpulseRef.current = {
                        ...prev,
                        active: impulseAnalysis.active,
                        direction: impulseAnalysis.direction
                    };
                }
            }, [impulseAnalysis.active, impulseAnalysis.direction, impulseAnalysis.strength, impulseAnalysis.topMetrics]);

            // ===== SESSION STATISTICS CALCULATOR =====
            const sessionStats = useMemo(() => {
                const stats = {
                    pivots: { total: 0, highs: 0, lows: 0, metricFrequency: {} },
                    impulses: { total: 0, bullish: 0, bearish: 0, avgStrength: 0, metricFrequency: {} },
                    volatility: { total: 0, expansions: 0, compressions: 0, metricFrequency: {} },
                    breakouts: { total: 0, bullish: 0, bearish: 0, avgDuration: 0, avgEnergy: 0, triggerMetricFrequency: {} }
                };

                // Analizar Pivots
                sessionHistory.pivots.forEach(p => {
                    stats.pivots.total++;
                    if (p.type === 'HIGH') stats.pivots.highs++;
                    else stats.pivots.lows++;
                    p.metrics?.forEach(m => {
                        const key = m.label || m.key;
                        if (!stats.pivots.metricFrequency[key]) {
                            stats.pivots.metricFrequency[key] = { count: 0, bullish: 0, bearish: 0, totalStrength: 0 };
                        }
                        stats.pivots.metricFrequency[key].count++;
                        if (m.direction === 'BULLISH') stats.pivots.metricFrequency[key].bullish++;
                        else if (m.direction === 'BEARISH') stats.pivots.metricFrequency[key].bearish++;
                        stats.pivots.metricFrequency[key].totalStrength += m.strength || 0;
                    });
                });

                // Analizar Impulsos
                let totalImpulseStrength = 0;
                sessionHistory.impulses.forEach(imp => {
                    stats.impulses.total++;
                    totalImpulseStrength += imp.strength || 0;
                    if (imp.direction === 'BULLISH') stats.impulses.bullish++;
                    else stats.impulses.bearish++;
                    imp.metrics?.forEach(m => {
                        const key = m.label || m.key;
                        if (!stats.impulses.metricFrequency[key]) {
                            stats.impulses.metricFrequency[key] = { count: 0, bullish: 0, bearish: 0, totalStrength: 0 };
                        }
                        stats.impulses.metricFrequency[key].count++;
                        if (m.direction === 'BULLISH') stats.impulses.metricFrequency[key].bullish++;
                        else if (m.direction === 'BEARISH') stats.impulses.metricFrequency[key].bearish++;
                        stats.impulses.metricFrequency[key].totalStrength += m.strength || 0;
                    });
                });
                stats.impulses.avgStrength = stats.impulses.total > 0 ? totalImpulseStrength / stats.impulses.total : 0;

                // Analizar Volatilidad
                sessionHistory.volatilityEvents.forEach(v => {
                    stats.volatility.total++;
                    if (v.state === 'EXPANSION') stats.volatility.expansions++;
                    else stats.volatility.compressions++;
                    v.metrics?.forEach(m => {
                        const key = m.label || m.key;
                        if (!stats.volatility.metricFrequency[key]) {
                            stats.volatility.metricFrequency[key] = { count: 0, bullish: 0, bearish: 0, totalStrength: 0 };
                        }
                        stats.volatility.metricFrequency[key].count++;
                        if (m.direction === 'BULLISH') stats.volatility.metricFrequency[key].bullish++;
                        else if (m.direction === 'BEARISH') stats.volatility.metricFrequency[key].bearish++;
                        stats.volatility.metricFrequency[key].totalStrength += m.strength || 0;
                    });
                });

                // Analizar Breakouts de Compresi√≥n
                let totalDuration = 0, totalEnergy = 0;
                sessionHistory.compressionBreakouts.forEach(b => {
                    stats.breakouts.total++;
                    totalDuration += b.duration || 0;
                    totalEnergy += b.energy || 0;
                    if (b.direction === 'BULLISH') stats.breakouts.bullish++;
                    else if (b.direction === 'BEARISH') stats.breakouts.bearish++;
                    b.triggerMetrics?.forEach(m => {
                        const key = m.label || m.key;
                        if (!stats.breakouts.triggerMetricFrequency[key]) {
                            stats.breakouts.triggerMetricFrequency[key] = { count: 0, bullish: 0, bearish: 0, totalStrength: 0 };
                        }
                        stats.breakouts.triggerMetricFrequency[key].count++;
                        if (m.direction === 'BULLISH') stats.breakouts.triggerMetricFrequency[key].bullish++;
                        else if (m.direction === 'BEARISH') stats.breakouts.triggerMetricFrequency[key].bearish++;
                        stats.breakouts.triggerMetricFrequency[key].totalStrength += m.strength || 0;
                    });
                });
                stats.breakouts.avgDuration = stats.breakouts.total > 0 ? totalDuration / stats.breakouts.total : 0;
                stats.breakouts.avgEnergy = stats.breakouts.total > 0 ? totalEnergy / stats.breakouts.total : 0;

                // Ordenar m√©tricas por frecuencia
                const sortMetrics = (freqObj) => {
                    return Object.entries(freqObj)
                        .map(([label, data]) => ({ label, ...data, avgStrength: data.count > 0 ? data.totalStrength / data.count : 0 }))
                        .sort((a, b) => b.count - a.count);
                };

                return {
                    ...stats,
                    pivots: { ...stats.pivots, topMetrics: sortMetrics(stats.pivots.metricFrequency).slice(0, 5) },
                    impulses: { ...stats.impulses, topMetrics: sortMetrics(stats.impulses.metricFrequency).slice(0, 5) },
                    volatility: { ...stats.volatility, topMetrics: sortMetrics(stats.volatility.metricFrequency).slice(0, 5) },
                    breakouts: { ...stats.breakouts, topTriggers: sortMetrics(stats.breakouts.triggerMetricFrequency).slice(0, 5) }
                };
            }, [sessionHistory]);

            // ===== EXPORT TO PDF - 3 PAGE PROFESSIONAL REPORT =====
            const exportToPDF = useCallback(async () => {
                if (isExporting) return;
                setIsExporting(true);

                try {
                    const [html2canvas, jsPDF] = await Promise.all([
                        services.telegram.loadHtml2Canvas(),
                        services.telegram.loadJsPDF()
                    ]);

                    if (!html2canvas || !jsPDF) {
                        alert('Error loading PDF libraries');
                        setIsExporting(false);
                        return;
                    }

                    const pdf = new jsPDF('p', 'mm', 'a4');
                    const pageWidth = pdf.internal.pageSize.getWidth();
                    const pageHeight = pdf.internal.pageSize.getHeight();
                    const margin = 10;

                    // Color scheme
                    const colors = {
                        bg: [15, 15, 15],
                        headerBg: [10, 10, 10],
                        cardBg: [22, 22, 22],
                        border: [40, 40, 40],
                        textPrimary: [245, 245, 245],
                        textSecondary: [180, 180, 180],
                        textMuted: [120, 120, 120],
                        cyan: [0, 212, 255],
                        pink: [255, 51, 102],
                        gold: [255, 200, 0]
                    };

                    // Helper para header de p√°gina
                    const addPageHeader = (pageNum, title, subtitle) => {
                        pdf.setFillColor(...colors.headerBg);
                        pdf.rect(0, 0, pageWidth, 24, 'F');

                        // Logo (primera l√≠nea)
                        pdf.setFontSize(14);
                        pdf.setTextColor(255, 255, 255); // Blanco puro
                        pdf.setFont('helvetica', 'bold');
                        pdf.text('ReloadingTape', margin, 9);
                        pdf.setTextColor(220, 50, 50); // ROJO
                        pdf.setFontSize(10);
                        pdf.setFont('helvetica', 'bolditalic'); // Inclinado
                        pdf.text('Intelligence', margin + 36, 9);
                        pdf.setFont('helvetica', 'normal'); // Reset font

                        // T√≠tulo de p√°gina (segunda l√≠nea, debajo del logo, BLANCO)
                        pdf.setFontSize(9);
                        pdf.setTextColor(255, 255, 255); // BLANCO
                        pdf.setFont('helvetica', 'bold');
                        pdf.text(subtitle || title, margin, 18);

                        // Info derecha
                        pdf.setFontSize(7);
                        pdf.setTextColor(...colors.textMuted);
                        pdf.setFont('helvetica', 'normal');
                        pdf.text(`Page ${pageNum}/3`, pageWidth - margin, 9, { align: 'right' });
                        pdf.text(new Date().toLocaleTimeString(), pageWidth - margin, 16, { align: 'right' });

                        return 28;
                    };

                    // Helper para footer
                    const addPageFooter = () => {
                        pdf.setFillColor(...colors.headerBg);
                        pdf.rect(0, pageHeight - 14, pageWidth, 14, 'F');

                        // Izquierda: Fecha
                        pdf.setFontSize(6);
                        pdf.setTextColor(...colors.textMuted);
                        pdf.text(new Date().toLocaleDateString('es-ES', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' }), margin, pageHeight - 8);
                        pdf.text(selectedSlot || 'Market Analysis', margin, pageHeight - 3);

                        // Derecha: Informaci√≥n de contacto
                        pdf.setTextColor(180, 180, 180);
                        pdf.text('Luis Abraham ReloadingTape', pageWidth - margin, pageHeight - 9, { align: 'right' });
                        pdf.setTextColor(140, 140, 140);
                        pdf.text('Tel: +52 5611949340 | Telegram: t.me/reloadingtape', pageWidth - margin, pageHeight - 4, { align: 'right' });
                    };

                    // Helper para agregar texto con wrap
                    const addWrappedText = (text, x, y, maxWidth, lineHeight = 4) => {
                        const words = text.split(' ');
                        let line = '';
                        let currentY = y;

                        words.forEach(word => {
                            const testLine = line + word + ' ';
                            const textWidth = pdf.getTextWidth(testLine);
                            if (textWidth > maxWidth && line !== '') {
                                pdf.text(line.trim(), x, currentY);
                                line = word + ' ';
                                currentY += lineHeight;
                            } else {
                                line = testLine;
                            }
                        });
                        if (line.trim()) {
                            pdf.text(line.trim(), x, currentY);
                            currentY += lineHeight;
                        }
                        return currentY;
                    };

                    // ============ PAGE 1: SENTIMIENTO ============
                    pdf.setFillColor(15, 15, 15);
                    pdf.rect(0, 0, pageWidth, pageHeight, 'F');
                    let yPos = addPageHeader(1, 'SENTIMIENTO DE MERCADO', 'Market Sentiment');
                    addPageFooter();

                    // Altura √∫til de la p√°gina (sin header ni footer)
                    const usableHeight = pageHeight - 42; // 28 header + 14 footer
                    const chartHeight = usableHeight * 0.42; // 42% para el gr√°fico
                    const sentimentHeight = usableHeight * 0.42; // 42% para sentimiento NASDAQ

                    // === CAPTURE CHART IMAGE - 42% de la p√°gina ===
                    if (chartRef.current) {
                        try {
                            const chartCanvas = await html2canvas(chartRef.current, {
                                backgroundColor: '#0f0f0f',
                                scale: 2,
                                useCORS: true,
                                logging: false
                            });
                            const chartImg = chartCanvas.toDataURL('image/png');
                            const imgWidth = pageWidth - 2 * margin;

                            pdf.setFontSize(10);
                            pdf.setTextColor(200, 200, 200);
                            pdf.setFont('helvetica', 'bold');
                            pdf.text('üìà PRICE ACTION CHART', margin, yPos);
                            pdf.setFontSize(6);
                            pdf.setTextColor(100, 100, 100);
                            pdf.text(new Date().toLocaleTimeString(), pageWidth - margin, yPos, { align: 'right' });
                            yPos += 5;

                            pdf.setFillColor(20, 20, 20);
                            pdf.roundedRect(margin, yPos, imgWidth, chartHeight, 3, 3, 'F');
                            pdf.setDrawColor(60, 60, 60);
                            pdf.setLineWidth(0.5);
                            pdf.roundedRect(margin, yPos, imgWidth, chartHeight, 3, 3, 'S');
                            pdf.addImage(chartImg, 'PNG', margin + 1, yPos + 1, imgWidth - 2, chartHeight - 2);
                            yPos += chartHeight + 5;
                        } catch (e) {
                            console.log('Chart capture failed:', e);
                            yPos += 10;
                        }
                    }

                    // === NASDAQ 100 & S&P 500 SENTIMENT - 42% de la p√°gina ===
                    pdf.setFontSize(9);
                    pdf.setTextColor(200, 200, 200);
                    pdf.setFont('helvetica', 'bold');
                    pdf.text('NASDAQ 100 & S&P 500 SENTIMENT ANALYSIS', margin, yPos);
                    yPos += 5;

                    // Siempre usar datos de window para consistencia
                    const nasdaqSent = window.lastNasdaq100Sentiment || { score: 50, bullish: 0, bearish: 0, neutral: 0, topBullish: [], topBearish: [] };
                    const spSent = window.lastSP500Sentiment || { score: 50, bullishCount: 0, bearishCount: 0 };

                    pdf.setFillColor(18, 20, 24);
                    pdf.roundedRect(margin, yPos, pageWidth - 2 * margin, sentimentHeight, 3, 3, 'F');
                    pdf.setDrawColor(50, 50, 55);
                    pdf.roundedRect(margin, yPos, pageWidth - 2 * margin, sentimentHeight, 3, 3, 'S');

                    // Dividir en 2 columnas
                    const colW = (pageWidth - 2 * margin - 10) / 2;
                    const innerY = yPos + 6;

                    // ‚ïê‚ïê‚ïê COLUMNA IZQUIERDA: SCORES PRINCIPALES ‚ïê‚ïê‚ïê
                    pdf.setFillColor(25, 28, 32);
                    pdf.roundedRect(margin + 3, innerY, colW, sentimentHeight - 12, 2, 2, 'F');

                    pdf.setFontSize(8);
                    pdf.setTextColor(160, 160, 160);
                    pdf.setFont('helvetica', 'bold');
                    pdf.text('MARKET SENTIMENT SCORES', margin + 8, innerY + 8);

                    // NASDAQ 100 Score - Destacado
                    pdf.setFillColor(30, 35, 45);
                    pdf.roundedRect(margin + 6, innerY + 12, colW - 6, 22, 2, 2, 'F');

                    pdf.setFontSize(22);
                    const nasdaqScore = typeof nasdaqSent.score === 'number' ? nasdaqSent.score : 50;
                    const nasdaqColor = nasdaqScore > 60 ? [100, 200, 150] : nasdaqScore < 40 ? [200, 100, 120] : [180, 180, 180];
                    pdf.setTextColor(...nasdaqColor);
                    pdf.text(`${nasdaqScore.toFixed(0)}%`, margin + 10, innerY + 28);
                    pdf.setFontSize(9);
                    pdf.setTextColor(120, 180, 220);
                    pdf.setFont('helvetica', 'bold');
                    pdf.text('NASDAQ 100', margin + 40, innerY + 24);
                    pdf.setFontSize(6);
                    pdf.setTextColor(100, 100, 100);
                    pdf.setFont('helvetica', 'normal');
                    pdf.text(nasdaqSent.label || 'NEUTRAL', margin + 40, innerY + 30);

                    // S&P 500 Score
                    pdf.setFillColor(30, 32, 38);
                    pdf.roundedRect(margin + 6, innerY + 36, colW - 6, 18, 2, 2, 'F');

                    pdf.setFontSize(16);
                    const spScore = typeof spSent.score === 'number' ? spSent.score : 50;
                    const spColor = spScore > 60 ? [100, 180, 140] : spScore < 40 ? [180, 100, 110] : [160, 160, 160];
                    pdf.setTextColor(...spColor);
                    pdf.text(`${spScore.toFixed(0)}%`, margin + 10, innerY + 50);
                    pdf.setFontSize(8);
                    pdf.setTextColor(180, 140, 100);
                    pdf.setFont('helvetica', 'bold');
                    pdf.text('S&P 500', margin + 38, innerY + 47);
                    pdf.setFontSize(6);
                    pdf.setTextColor(100, 100, 100);
                    pdf.setFont('helvetica', 'normal');
                    const spLabel = spScore > 60 ? 'BULLISH' : spScore < 40 ? 'BEARISH' : 'NEUTRAL';
                    pdf.text(spLabel, margin + 38, innerY + 52);

                    // Estad√≠sticas detalladas NASDAQ
                    pdf.setFontSize(7);
                    pdf.setTextColor(150, 150, 150);
                    pdf.setFont('helvetica', 'bold');
                    pdf.text('NASDAQ 100 BREAKDOWN:', margin + 8, innerY + 62);
                    pdf.setFont('helvetica', 'normal');
                    const bullish = nasdaqSent.bullish ?? 0;
                    const bearish = nasdaqSent.bearish ?? 0;
                    const neutral = nasdaqSent.neutral ?? 0;
                    pdf.setTextColor(120, 180, 140);
                    pdf.text(`Bullish: ${bullish}`, margin + 8, innerY + 69);
                    pdf.setTextColor(180, 100, 110);
                    pdf.text(`Bearish: ${bearish}`, margin + 35, innerY + 69);
                    pdf.setTextColor(140, 140, 140);
                    pdf.text(`Neutral: ${neutral}`, margin + 62, innerY + 69);

                    // Barra de sentimiento visual
                    const barWidth = colW - 12;
                    pdf.setFillColor(40, 40, 45);
                    pdf.rect(margin + 8, innerY + 74, barWidth, 5, 'F');
                    const total = Math.max(bullish + bearish + neutral, 1);
                    const bullishWidth = (bullish / total) * barWidth;
                    const bearishWidth = (bearish / total) * barWidth;
                    pdf.setFillColor(80, 180, 120);
                    pdf.rect(margin + 8, innerY + 74, bullishWidth, 5, 'F');
                    pdf.setFillColor(180, 80, 100);
                    pdf.rect(margin + 8 + bullishWidth, innerY + 74, bearishWidth, 5, 'F');

                    // S&P 500 breakdown
                    pdf.setFontSize(7);
                    pdf.setTextColor(150, 150, 150);
                    pdf.setFont('helvetica', 'bold');
                    pdf.text('S&P 500 BREAKDOWN:', margin + 8, innerY + 85);
                    pdf.setFont('helvetica', 'normal');
                    pdf.setTextColor(120, 160, 130);
                    pdf.text(`Bullish: ${spSent.bullishCount || 0}`, margin + 8, innerY + 92);
                    pdf.setTextColor(160, 100, 110);
                    pdf.text(`Bearish: ${spSent.bearishCount || 0}`, margin + 35, innerY + 92);

                    // ‚ïê‚ïê‚ïê COLUMNA DERECHA: TOP MOVERS ‚ïê‚ïê‚ïê
                    pdf.setFillColor(25, 28, 32);
                    pdf.roundedRect(margin + colW + 7, innerY, colW, sentimentHeight - 12, 2, 2, 'F');

                    pdf.setFontSize(8);
                    pdf.setTextColor(160, 160, 160);
                    pdf.setFont('helvetica', 'bold');
                    pdf.text('TOP MOVERS (NASDAQ 100)', margin + colW + 11, innerY + 8);

                    // Bullish section
                    pdf.setFontSize(7);
                    pdf.setTextColor(100, 180, 140);
                    pdf.setFont('helvetica', 'bold');
                    pdf.text('‚ñ≤ TOP GAINERS', margin + colW + 11, innerY + 17);
                    pdf.setFont('helvetica', 'normal');
                    pdf.setTextColor(140, 170, 150);
                    const topBullish = nasdaqSent.topBullish || [];
                    if (topBullish.length > 0) {
                        topBullish.slice(0, 5).forEach((stock, i) => {
                            const symbol = stock.symbol || 'N/A';
                            const change = stock.change ?? stock.changePercent ?? 0;
                            pdf.text(`${symbol}`, margin + colW + 11, innerY + 24 + i * 6);
                            pdf.setTextColor(80, 160, 120);
                            pdf.text(`+${Math.abs(change).toFixed(2)}%`, margin + colW + 35, innerY + 24 + i * 6);
                            pdf.setTextColor(140, 170, 150);
                        });
                    } else {
                        pdf.text('Sin datos disponibles', margin + colW + 11, innerY + 24);
                    }

                    // Bearish section
                    pdf.setFontSize(7);
                    pdf.setFont('helvetica', 'bold');
                    pdf.setTextColor(180, 100, 110);
                    pdf.text('‚ñº TOP LOSERS', margin + colW + 11, innerY + 57);
                    pdf.setFont('helvetica', 'normal');
                    pdf.setTextColor(170, 130, 140);
                    const topBearish = nasdaqSent.topBearish || [];
                    if (topBearish.length > 0) {
                        topBearish.slice(0, 5).forEach((stock, i) => {
                            const symbol = stock.symbol || 'N/A';
                            const change = stock.change ?? stock.changePercent ?? 0;
                            pdf.text(`${symbol}`, margin + colW + 11, innerY + 64 + i * 6);
                            pdf.setTextColor(180, 80, 100);
                            pdf.text(`${change.toFixed(2)}%`, margin + colW + 35, innerY + 64 + i * 6);
                            pdf.setTextColor(170, 130, 140);
                        });
                    } else {
                        pdf.text('Sin datos disponibles', margin + colW + 11, innerY + 64);
                    }

                    yPos += sentimentHeight + 5;

                    // ============ PAGE 2: INTELLIGENCE ============
                    pdf.addPage();
                    pdf.setFillColor(15, 15, 15);
                    pdf.rect(0, 0, pageWidth, pageHeight, 'F');
                    yPos = addPageHeader(2, 'MARKET INTELLIGENCE', 'Analysis Report');
                    addPageFooter();

                    // Current State - 4 boxes compactas
                    const stateBoxW = (pageWidth - 2 * margin - 15) / 4;
                    const stateBoxH = 32;

                    const stateData = [
                        {
                            label: 'COMPRESSION',
                            value: compressionAnalysis.detected ? 'ACTIVE' : 'Inactive',
                            sub: `Energy: ${compressionAnalysis.energy?.toFixed(0) || 0}%`,
                            color: compressionAnalysis.detected ? colors.gold : colors.textMuted
                        },
                        {
                            label: 'IMPULSE',
                            value: impulseAnalysis.active ? impulseAnalysis.direction : 'Inactive',
                            sub: `Strength: ${impulseAnalysis.strength?.toFixed(0) || 0}%`,
                            color: impulseAnalysis.active ? (impulseAnalysis.direction === 'BULLISH' ? colors.cyan : colors.pink) : colors.textMuted
                        },
                        {
                            label: 'VOLATILITY',
                            value: volatilityAnalysis.state || 'Normal',
                            sub: `${volatilityAnalysis.strength?.toFixed(0) || 0}% | ${volatilityAnalysis.regime || 'N/A'}`,
                            color: volatilityAnalysis.state === 'EXPANSION' ? colors.cyan : volatilityAnalysis.state === 'COMPRESSION' ? colors.pink : colors.textMuted
                        },
                        {
                            label: 'LAST PIVOT',
                            value: pivotAnalysis.lastPivot?.type || '-',
                            sub: `$${pivotAnalysis.lastPivot?.price?.toFixed(2) || '-'} | ${pivotAnalysis.lastPivot?.barsAgo || 0} bars`,
                            color: pivotAnalysis.lastPivot?.type === 'HIGH' ? colors.cyan : pivotAnalysis.lastPivot?.type === 'LOW' ? colors.pink : colors.textMuted
                        }
                    ];

                    stateData.forEach((state, idx) => {
                        const x = margin + idx * (stateBoxW + 5);
                        pdf.setFillColor(25, 25, 28);
                        pdf.roundedRect(x, yPos, stateBoxW, stateBoxH, 2, 2, 'F');
                        pdf.setDrawColor(50, 50, 50);
                        pdf.roundedRect(x, yPos, stateBoxW, stateBoxH, 2, 2, 'S');

                        pdf.setFontSize(6);
                        pdf.setTextColor(130, 130, 130);
                        pdf.setFont('helvetica', 'bold');
                        pdf.text(state.label, x + 3, yPos + 7);

                        pdf.setFontSize(10);
                        pdf.setTextColor(...state.color);
                        pdf.text(state.value, x + 3, yPos + 17);

                        pdf.setFontSize(5);
                        pdf.setTextColor(110, 110, 110);
                        pdf.setFont('helvetica', 'normal');
                        pdf.text(state.sub, x + 3, yPos + 25);
                    });

                    yPos += stateBoxH + 6;

                    // Session Statistics - compacto
                    pdf.setFontSize(10);
                    pdf.setTextColor(200, 200, 200);
                    pdf.setFont('helvetica', 'bold');
                    pdf.text('SESSION STATISTICS', margin, yPos);
                    yPos += 6;

                    const sessionStatsBoxW = (pageWidth - 2 * margin - 15) / 4;
                    const sessionStatsH = 24;
                    const sessionStatsData = [
                        { label: 'PIVOTS', value: sessionStats.pivots.total, sub: `${sessionStats.pivots.highs}H / ${sessionStats.pivots.lows}L` },
                        { label: 'IMPULSES', value: sessionStats.impulses.total, sub: `${sessionStats.impulses.bullish}B / ${sessionStats.impulses.bearish}S` },
                        { label: 'VOLATILITY', value: sessionStats.volatility.total, sub: `${sessionStats.volatility.expansions}E / ${sessionStats.volatility.compressions}C` },
                        { label: 'BREAKOUTS', value: sessionStats.breakouts.total, sub: `${sessionStats.breakouts.bullish || 0}B/${sessionStats.breakouts.bearish || 0}S | ${sessionStats.breakouts.avgEnergy?.toFixed(0) || 0}%` }
                    ];

                    sessionStatsData.forEach((stat, idx) => {
                        const x = margin + idx * (sessionStatsBoxW + 5);
                        pdf.setFillColor(22, 24, 28);
                        pdf.roundedRect(x, yPos, sessionStatsBoxW, sessionStatsH, 2, 2, 'F');

                        pdf.setFontSize(6);
                        pdf.setTextColor(130, 130, 130);
                        pdf.setFont('helvetica', 'bold');
                        pdf.text(stat.label, x + 4, yPos + 7);

                        pdf.setFontSize(14);
                        pdf.setTextColor(240, 240, 240);
                        pdf.text(`${stat.value}`, x + 4, yPos + 17);

                        pdf.setFontSize(5);
                        pdf.setTextColor(100, 100, 100);
                        pdf.setFont('helvetica', 'normal');
                        pdf.text(stat.sub, x + 22, yPos + 14);
                    });

                    yPos += sessionStatsH + 8;

                    // Top Metrics - compacto
                    pdf.setFontSize(9);
                    pdf.setTextColor(200, 200, 200);
                    pdf.setFont('helvetica', 'bold');
                    pdf.text('DOMINANT METRICS', margin, yPos);
                    yPos += 6;

                    const metricsBoxH = 42;
                    pdf.setFillColor(20, 22, 25);
                    pdf.roundedRect(margin, yPos, pageWidth - 2 * margin, metricsBoxH, 2, 2, 'F');

                    let metricY = yPos + 5;
                    topMetricsGlobal.slice(0, 7).forEach((m, i) => {
                        const barWidth = Math.min((m.strength / 100) * 80, 80);
                        pdf.setFontSize(6);
                        pdf.setTextColor(170, 170, 170);
                        pdf.text(`${i + 1}. ${m.fullLabel || m.label}`, margin + 4, metricY + 3);

                        // Bar background
                        pdf.setFillColor(40, 40, 40);
                        pdf.rect(margin + 55, metricY, 80, 4, 'F');
                        // Bar fill
                        const barColor = m.direction === 'BULLISH' ? [0, 180, 200] : m.direction === 'BEARISH' ? [200, 80, 100] : [180, 160, 80];
                        pdf.setFillColor(...barColor);
                        pdf.rect(margin + 55, metricY, barWidth, 4, 'F');

                        pdf.setTextColor(200, 200, 200);
                        pdf.text(`${m.strength?.toFixed(0)}%`, margin + 140, metricY + 3);
                        pdf.setTextColor(...barColor);
                        pdf.text(m.direction?.substring(0, 4) || '-', margin + 155, metricY + 3);
                        metricY += 5.5;
                    });

                    yPos += metricsBoxH + 6;

                    // Metric Analysis boxes - 2 columns compactas
                    const halfWidth = (pageWidth - 2 * margin - 8) / 2;
                    const analysisBoxH = 38;

                    // Left: Pivot metrics
                    pdf.setFillColor(22, 25, 22);
                    pdf.roundedRect(margin, yPos, halfWidth, analysisBoxH, 2, 2, 'F');
                    pdf.setDrawColor(60, 80, 60);
                    pdf.roundedRect(margin, yPos, halfWidth, analysisBoxH, 2, 2, 'S');
                    pdf.setFontSize(7);
                    pdf.setTextColor(180, 200, 180);
                    pdf.setFont('helvetica', 'bold');
                    pdf.text('METRICS AT PIVOTS', margin + 4, yPos + 8);
                    pdf.setFontSize(5);
                    pdf.setFont('helvetica', 'normal');
                    pdf.setTextColor(150, 160, 150);
                    let leftYPos = yPos + 14;
                    if (sessionStats.pivots.topMetrics?.length > 0) {
                        sessionStats.pivots.topMetrics.slice(0, 5).forEach((m, i) => {
                            pdf.text(`${i + 1}. ${m.label}: ${m.count}x (${m.avgStrength?.toFixed(0)}%)`, margin + 4, leftYPos);
                            leftYPos += 4.5;
                        });
                    } else {
                        pdf.text('Collecting pivot data...', margin + 4, leftYPos);
                    }

                    // Right: Impulse metrics
                    pdf.setFillColor(25, 22, 22);
                    pdf.roundedRect(margin + halfWidth + 8, yPos, halfWidth, analysisBoxH, 2, 2, 'F');
                    pdf.setDrawColor(80, 60, 60);
                    pdf.roundedRect(margin + halfWidth + 8, yPos, halfWidth, analysisBoxH, 2, 2, 'S');
                    pdf.setFontSize(7);
                    pdf.setTextColor(200, 180, 180);
                    pdf.setFont('helvetica', 'bold');
                    pdf.text('IMPULSE DRIVERS', margin + halfWidth + 12, yPos + 8);
                    pdf.setFontSize(5);
                    pdf.setFont('helvetica', 'normal');
                    pdf.setTextColor(160, 150, 150);
                    let rightYPos = yPos + 14;
                    if (sessionStats.impulses.topMetrics?.length > 0) {
                        sessionStats.impulses.topMetrics.slice(0, 5).forEach((m, i) => {
                            pdf.text(`${i + 1}. ${m.label}: ${m.count}x (${m.bullish}B/${m.bearish}S)`, margin + halfWidth + 12, rightYPos);
                            rightYPos += 4.5;
                        });
                    } else {
                        pdf.text('Collecting impulse data...', margin + halfWidth + 12, rightYPos);
                    }

                    yPos += analysisBoxH + 6;

                    // Session Insights - compacto
                    const insightsHeight = 32;
                    pdf.setFillColor(20, 22, 30);
                    pdf.roundedRect(margin, yPos, pageWidth - 2 * margin, insightsHeight, 2, 2, 'F');
                    pdf.setDrawColor(60, 80, 120);
                    pdf.setLineWidth(0.3);
                    pdf.roundedRect(margin, yPos, pageWidth - 2 * margin, insightsHeight, 2, 2, 'S');

                    pdf.setFontSize(7);
                    pdf.setTextColor(100, 150, 200);
                    pdf.setFont('helvetica', 'bold');
                    pdf.text('SESSION INSIGHTS', margin + 4, yPos + 7);

                    pdf.setFontSize(5);
                    pdf.setTextColor(160, 165, 180);
                    pdf.setFont('helvetica', 'normal');

                    const insightsList = [];
                    if (sessionStats.pivots.total > 0) {
                        insightsList.push(`‚Ä¢ Pivots: ${sessionStats.pivots.total} (${sessionStats.pivots.highs}H/${sessionStats.pivots.lows}L)`);
                    }
                    if (sessionStats.pivots.topMetrics?.[0]) {
                        insightsList.push(`‚Ä¢ Top at pivots: ${sessionStats.pivots.topMetrics[0].label}`);
                    }
                    insightsList.push(`‚Ä¢ Vol: ${volatilityAnalysis.regime || 'Normal'} ${volatilityAnalysis.strength?.toFixed(0) || 0}% | Comp: ${compressionAnalysis.detected ? 'ON' : 'OFF'} | Imp: ${impulseAnalysis.active ? impulseAnalysis.direction : '-'}`);

                    insightsList.slice(0, 4).forEach((insight, i) => {
                        pdf.text(insight, margin + 4, yPos + 13 + i * 5);
                    });

                    // ============ PAGE 3: AN√ÅLISIS CAUSAL ============
                    pdf.addPage();
                    pdf.setFillColor(15, 15, 15);
                    pdf.rect(0, 0, pageWidth, pageHeight, 'F');
                    yPos = addPageHeader(3, 'AN√ÅLISIS CAUSAL', 'Causal Analysis');
                    addPageFooter();

                    // Event Timeline Summary - m√°s grande
                    pdf.setFontSize(11);
                    pdf.setTextColor(200, 200, 200);
                    pdf.setFont('helvetica', 'bold');
                    pdf.text('üìÖ EVENT TIMELINE', margin, yPos);
                    yPos += 8;

                    // Timeline boxes - 3 columns m√°s grandes
                    const timelineBoxW = (pageWidth - 2 * margin - 10) / 3;
                    const timelineBoxH = 60;

                    // Impulses
                    pdf.setFillColor(20, 30, 25);
                    pdf.roundedRect(margin, yPos, timelineBoxW, timelineBoxH, 3, 3, 'F');
                    pdf.setDrawColor(40, 80, 60);
                    pdf.roundedRect(margin, yPos, timelineBoxW, timelineBoxH, 3, 3, 'S');
                    pdf.setFontSize(9);
                    pdf.setTextColor(80, 180, 160);
                    pdf.setFont('helvetica', 'bold');
                    pdf.text(`‚ö° IMPULSES (${sessionHistory.impulses?.length || 0})`, margin + 4, yPos + 10);
                    pdf.setFontSize(6);
                    pdf.setTextColor(150, 180, 170);
                    pdf.setFont('helvetica', 'normal');
                    let impY = yPos + 20;
                    (sessionHistory.impulses || []).slice(-7).reverse().forEach(imp => {
                        const time = new Date(imp.timestamp).toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
                        const dir = imp.direction === 'BULLISH' ? '‚ñ≤' : '‚ñº';
                        pdf.text(`${time} ${dir} ${imp.strength?.toFixed(0) || 0}% - ${imp.direction}`, margin + 4, impY);
                        impY += 5.5;
                    });
                    if (!sessionHistory.impulses?.length) {
                        pdf.text('No impulses recorded yet', margin + 4, impY);
                        pdf.text('Impulses appear with strong', margin + 4, impY + 6);
                        pdf.text('directional momentum', margin + 4, impY + 12);
                    }

                    // Volatility
                    pdf.setFillColor(30, 25, 20);
                    pdf.roundedRect(margin + timelineBoxW + 5, yPos, timelineBoxW, timelineBoxH, 3, 3, 'F');
                    pdf.setDrawColor(80, 60, 40);
                    pdf.roundedRect(margin + timelineBoxW + 5, yPos, timelineBoxW, timelineBoxH, 3, 3, 'S');
                    pdf.setFontSize(9);
                    pdf.setTextColor(200, 160, 80);
                    pdf.setFont('helvetica', 'bold');
                    pdf.text(`üìä VOLATILITY (${sessionHistory.volatilityEvents?.length || 0})`, margin + timelineBoxW + 9, yPos + 10);
                    pdf.setFontSize(6);
                    pdf.setTextColor(180, 165, 140);
                    pdf.setFont('helvetica', 'normal');
                    let volY = yPos + 20;
                    (sessionHistory.volatilityEvents || []).slice(-7).reverse().forEach(v => {
                        const time = new Date(v.timestamp).toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
                        pdf.text(`${time} ${v.state} ${v.strength?.toFixed(0) || 0}%`, margin + timelineBoxW + 9, volY);
                        volY += 5.5;
                    });
                    if (!sessionHistory.volatilityEvents?.length) {
                        pdf.text('No volatility events recorded', margin + timelineBoxW + 9, volY);
                        pdf.text('Events appear during market', margin + timelineBoxW + 9, volY + 6);
                        pdf.text('expansion/compression', margin + timelineBoxW + 9, volY + 12);
                    }

                    // Breakouts
                    pdf.setFillColor(28, 22, 30);
                    pdf.roundedRect(margin + (timelineBoxW + 5) * 2, yPos, timelineBoxW, timelineBoxH, 3, 3, 'F');
                    pdf.setDrawColor(60, 40, 80);
                    pdf.roundedRect(margin + (timelineBoxW + 5) * 2, yPos, timelineBoxW, timelineBoxH, 3, 3, 'S');
                    pdf.setFontSize(9);
                    pdf.setTextColor(180, 100, 160);
                    pdf.setFont('helvetica', 'bold');
                    pdf.text(`üöÄ BREAKOUTS (${sessionHistory.compressionBreakouts?.length || 0})`, margin + (timelineBoxW + 5) * 2 + 4, yPos + 10);
                    pdf.setFontSize(6);
                    pdf.setTextColor(175, 150, 170);
                    pdf.setFont('helvetica', 'normal');
                    let brkY = yPos + 20;
                    (sessionHistory.compressionBreakouts || []).slice(-7).reverse().forEach(b => {
                        const time = new Date(b.timestamp).toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
                        const dir = b.direction === 'BULLISH' ? '‚ñ≤' : '‚ñº';
                        pdf.text(`${time} ${dir} Energy:${b.energy?.toFixed(0) || 0}%`, margin + (timelineBoxW + 5) * 2 + 4, brkY);
                        brkY += 5.5;
                    });
                    if (!sessionHistory.compressionBreakouts?.length) {
                        pdf.text('No breakouts recorded yet', margin + (timelineBoxW + 5) * 2 + 4, brkY);
                        pdf.text('Breakouts occur after', margin + (timelineBoxW + 5) * 2 + 4, brkY + 6);
                        pdf.text('compression phases', margin + (timelineBoxW + 5) * 2 + 4, brkY + 12);
                    }

                    yPos += timelineBoxH + 10;

                    // Pivots Section - nuevo
                    pdf.setFontSize(11);
                    pdf.setTextColor(200, 200, 200);
                    pdf.setFont('helvetica', 'bold');
                    pdf.text('üéØ PIVOT POINTS HISTORY', margin, yPos);
                    yPos += 8;

                    const pivotBoxH = 45;
                    pdf.setFillColor(22, 25, 30);
                    pdf.roundedRect(margin, yPos, pageWidth - 2 * margin, pivotBoxH, 3, 3, 'F');
                    pdf.setDrawColor(50, 60, 80);
                    pdf.roundedRect(margin, yPos, pageWidth - 2 * margin, pivotBoxH, 3, 3, 'S');

                    // Dividir en 2 columnas: Highs y Lows
                    const pivotColW = (pageWidth - 2 * margin - 10) / 2;

                    // Pivot Highs
                    pdf.setFontSize(8);
                    pdf.setTextColor(100, 180, 200);
                    pdf.setFont('helvetica', 'bold');
                    pdf.text(`PIVOT HIGHS (${sessionStats.pivots.highs || 0})`, margin + 5, yPos + 10);
                    pdf.setFontSize(6);
                    pdf.setTextColor(140, 160, 170);
                    pdf.setFont('helvetica', 'normal');
                    const recentHighs = (sessionHistory.pivots || []).filter(p => p.type === 'HIGH').slice(-5);
                    let highY = yPos + 18;
                    recentHighs.forEach(p => {
                        const time = new Date(p.timestamp).toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' });
                        pdf.text(`${time} $${p.price?.toFixed(2) || '-'} - ${p.topMetric || 'N/A'}`, margin + 5, highY);
                        highY += 5;
                    });
                    if (recentHighs.length === 0) pdf.text('No pivot highs recorded', margin + 5, highY);

                    // Pivot Lows
                    pdf.setFontSize(8);
                    pdf.setTextColor(200, 100, 120);
                    pdf.setFont('helvetica', 'bold');
                    pdf.text(`PIVOT LOWS (${sessionStats.pivots.lows || 0})`, margin + pivotColW + 10, yPos + 10);
                    pdf.setFontSize(6);
                    pdf.setTextColor(170, 140, 150);
                    pdf.setFont('helvetica', 'normal');
                    const recentLows = (sessionHistory.pivots || []).filter(p => p.type === 'LOW').slice(-5);
                    let lowY = yPos + 18;
                    recentLows.forEach(p => {
                        const time = new Date(p.timestamp).toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' });
                        pdf.text(`${time} $${p.price?.toFixed(2) || '-'} - ${p.topMetric || 'N/A'}`, margin + pivotColW + 10, lowY);
                        lowY += 5;
                    });
                    if (recentLows.length === 0) pdf.text('No pivot lows recorded', margin + pivotColW + 10, lowY);

                    yPos += pivotBoxH + 10;

                    // AI Causal Analysis - M√°s grande
                    pdf.setFontSize(11);
                    pdf.setTextColor(200, 200, 200);
                    pdf.setFont('helvetica', 'bold');
                    pdf.text('üîç AI CAUSAL ANALYSIS', margin, yPos);
                    yPos += 8;

                    // Generate AI narrative for causal analysis
                    let aiCausalText = '';
                    const causalApiKey = localStorage.getItem('groq_api_key');
                    if (causalApiKey) {
                        try {
                            const causalPrompt = `Eres un analista causal experto. Analiza las CAUSAS Y EFECTOS de estos movimientos:

EVENTOS DE SESI√ìN:
- Impulsos: ${sessionHistory.impulses?.length || 0} (${sessionStats.impulses?.bullish || 0} alcistas, ${sessionStats.impulses?.bearish || 0} bajistas)
- Volatilidad: ${sessionHistory.volatilityEvents?.length || 0} eventos (${sessionStats.volatility?.expansions || 0} expansiones, ${sessionStats.volatility?.compressions || 0} compresiones)
- Breakouts: ${sessionHistory.compressionBreakouts?.length || 0}
- Pivots: ${sessionStats.pivots?.total || 0} (${sessionStats.pivots?.highs || 0} altos, ${sessionStats.pivots?.lows || 0} bajos)

ESTADO ACTUAL:
- Compresi√≥n: ${compressionAnalysis.detected ? 'ACTIVA ' + compressionAnalysis.energy?.toFixed(0) + '%' : 'Inactiva'}
- Impulso: ${impulseAnalysis.active ? impulseAnalysis.direction + ' ' + impulseAnalysis.strength?.toFixed(0) + '%' : 'Inactivo'}
- Volatilidad: ${volatilityAnalysis.state || 'Normal'} (${volatilityAnalysis.strength?.toFixed(0) || 0}%)

M√âTRICAS DOMINANTES:
${topMetricsGlobal.slice(0, 5).map((m, i) => `${i + 1}. ${m.fullLabel || m.label}: ${m.strength?.toFixed(0)}% ${m.direction}`).join('\n')}

Genera un an√°lisis causal COMPLETO (10-12 oraciones) explicando:
1. QU√â caus√≥ los movimientos principales del d√≠a
2. Relaci√≥n causa-efecto entre los eventos detectados
3. Patrones causales identificados en la sesi√≥n
4. Predicci√≥n de pr√≥ximos efectos probables basado en el an√°lisis`;

                            const response = await fetch('http://localhost:5000/analyze-causal', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json', 'X-API-Key': causalApiKey },
                                body: JSON.stringify({
                                    precio_actual: parseFloat(dataSource?.rows?.[dataSource.rows.length - 1]?.['Underlying_Price']) || 0,
                                    causal_data: { totalEvents: 1, causes: {} },
                                    timestamp: new Date().toLocaleTimeString(),
                                    custom_prompt: causalPrompt
                                })
                            });
                            const result = await response.json();
                            if (result.success) aiCausalText = result.explanation;
                        } catch (e) {
                            console.log('AI causal analysis failed:', e);
                            // Generar texto de fallback
                            aiCausalText = `An√°lisis Causal de la Sesi√≥n: La sesi√≥n ha registrado ${sessionStats.pivots?.total || 0} puntos pivote, ${sessionHistory.impulses?.length || 0} impulsos y ${sessionHistory.volatilityEvents?.length || 0} eventos de volatilidad. ${compressionAnalysis.detected ? 'Se detecta una compresi√≥n activa con ' + compressionAnalysis.energy?.toFixed(0) + '% de energ√≠a acumulada, lo que sugiere un potencial breakout inminente.' : 'No hay compresi√≥n activa, el mercado fluye normalmente.'} ${impulseAnalysis.active ? 'El impulso actual es ' + impulseAnalysis.direction + ' con ' + impulseAnalysis.strength?.toFixed(0) + '% de fuerza.' : ''} Los patrones causales indican que los movimientos principales fueron provocados por cambios en el flujo de √≥rdenes institucionales y el equilibrio entre compradores y vendedores.`;
                        }
                    }

                    // Calcular altura disponible para el an√°lisis causal - ocupa todo el resto de la p√°gina
                    const remainingForCausal = pageHeight - yPos - 14;

                    pdf.setFillColor(20, 18, 30);
                    pdf.roundedRect(margin, yPos, pageWidth - 2 * margin, remainingForCausal, 3, 3, 'F');
                    pdf.setDrawColor(100, 80, 140);
                    pdf.setLineWidth(0.5);
                    pdf.roundedRect(margin, yPos, pageWidth - 2 * margin, remainingForCausal, 3, 3, 'S');

                    pdf.setFontSize(9);
                    pdf.setTextColor(160, 140, 200);
                    pdf.setFont('helvetica', 'bold');
                    pdf.text('CAUSAL INTELLIGENCE REPORT', margin + 5, yPos + 10);
                    pdf.setFontSize(6);
                    pdf.setTextColor(100, 100, 130);
                    pdf.setFont('helvetica', 'normal');
                    pdf.text(`Generated: ${new Date().toLocaleTimeString()} | Model: Llama 3.3 70B`, pageWidth - margin - 5, yPos + 10, { align: 'right' });

                    if (aiCausalText) {
                        pdf.setFontSize(7);
                        pdf.setTextColor(180, 180, 200);
                        const causalLines = pdf.splitTextToSize(aiCausalText, pageWidth - 2 * margin - 14);
                        const maxLines = Math.floor((remainingForCausal - 20) / 4);
                        causalLines.slice(0, maxLines).forEach((line, i) => {
                            pdf.text(line, margin + 5, yPos + 18 + i * 4);
                        });
                    } else {
                        pdf.setFontSize(7);
                        pdf.setTextColor(120, 120, 140);
                        pdf.text('Configure la API key de Groq en Configuraci√≥n > Integraciones para habilitar', margin + 5, yPos + 20);
                        pdf.text('el an√°lisis causal con inteligencia artificial. Este an√°lisis identifica las', margin + 5, yPos + 27);
                        pdf.text('causas y efectos de los movimientos del mercado en tiempo real.', margin + 5, yPos + 34);
                    }

                    // Footer ya est√° incluido por addPageFooter()

                    pdf.save(`ReloadingTape_Report_${selectedSlot}_${new Date().toISOString().split('T')[0]}.pdf`);

                } catch (e) {
                    console.error('PDF Export error:', e);
                    alert('Error generating PDF: ' + e.message);
                } finally {
                    setIsExporting(false);
                }
            }, [sessionHistory, sessionStats, selectedSlot, isExporting, compressionAnalysis, impulseAnalysis, volatilityAnalysis, pivotAnalysis, topMetricsGlobal, aiApiKey, dataSource]);

            // ===== RENDER =====
            const formatNum = (n) => {
                if (Math.abs(n) >= 1e6) return (n / 1e6).toFixed(1) + 'M';
                if (Math.abs(n) >= 1e3) return (n / 1e3).toFixed(1) + 'K';
                return n.toFixed(1);
            };

            const getDirectionColor = (dir) => {
                if (dir === 'BULLISH') return '#3b82f6';
                if (dir === 'BEARISH') return '#ef4444';
                return '#6b7280';
            };

            // Estado vac√≠o - sin datos
            if (!dataSource?.rows?.length) {
                return React.createElement('div', {
                    className: "h-full flex flex-col bg-neutral-950"
                },
                    React.createElement('div', {
                        className: "flex-1 flex items-center justify-center"
                    },
                        React.createElement('div', { className: "text-center max-w-md px-6" },
                            React.createElement('div', {
                                className: "w-16 h-16 mx-auto mb-4 rounded-full bg-neutral-800/50 flex items-center justify-center"
                            },
                                React.createElement('span', { className: "text-2xl text-neutral-500" }, "M")
                            ),
                            React.createElement('h2', { className: "text-xl font-semibold text-neutral-300 mb-2" },
                                "Market Intelligence"
                            ),
                            React.createElement('p', { className: "text-sm text-neutral-500 mb-4" },
                                "Load data in any slot to activate the intelligence analysis system. This panel detects compressions, pivots, impulses and identifies the top 3 dominant metrics in real-time."
                            ),
                            React.createElement('div', { className: "flex justify-center gap-3" },
                                React.createElement('div', { className: "px-3 py-2 rounded bg-neutral-800/50 border border-neutral-700" },
                                    React.createElement('span', { className: "text-xs text-neutral-400 block" }, "Compression"),
                                    React.createElement('span', { className: "text-[10px] text-neutral-500" }, "Low volatility detection")
                                ),
                                React.createElement('div', { className: "px-3 py-2 rounded bg-neutral-800/50 border border-neutral-700" },
                                    React.createElement('span', { className: "text-xs text-neutral-400 block" }, "Pivots"),
                                    React.createElement('span', { className: "text-[10px] text-neutral-500" }, "High/Low with metrics")
                                ),
                                React.createElement('div', { className: "px-3 py-2 rounded bg-neutral-800/50 border border-neutral-700" },
                                    React.createElement('span', { className: "text-xs text-neutral-400 block" }, "Impulse"),
                                    React.createElement('span', { className: "text-[10px] text-neutral-500" }, "Momentum analysis")
                                )
                            )
                        )
                    )
                );
            }

            return React.createElement('div', {
                className: "h-full flex flex-col bg-neutral-950"
            },
                // Header
                React.createElement('div', {
                    className: "flex items-center justify-between px-4 py-3 border-b border-neutral-800"
                },
                    React.createElement('div', { className: "flex items-center gap-3" },
                        React.createElement('h2', { className: "text-sm font-bold text-neutral-200 uppercase tracking-wider" }, "Market Intelligence"),
                        React.createElement('select', {
                            value: selectedSlot,
                            onChange: (e) => setSelectedSlot(e.target.value),
                            className: "bg-neutral-800 border border-neutral-700 rounded px-2 py-1 text-xs text-neutral-300"
                        },
                            availableSlots.map(slot =>
                                React.createElement('option', { key: slot, value: slot }, `Slot ${slot}`)
                            )
                        )
                    ),
                    React.createElement('div', { className: "flex items-center gap-2" },
                        // ‚ïê‚ïê‚ïê NASDAQ 100 SENTIMENT INDICATOR ‚ïê‚ïê‚ïê
                        nasdaq100Sentiment && React.createElement('div', {
                            className: "flex items-center gap-2 px-3 py-1.5 rounded-lg mr-2 border transition-all",
                            style: {
                                background: `linear-gradient(135deg, ${nasdaq100Sentiment.color}15 0%, ${nasdaq100Sentiment.color}08 100%)`,
                                borderColor: `${nasdaq100Sentiment.color}40`,
                                boxShadow: Math.abs(nasdaq100Sentiment.score || 0) > 1 ? `0 0 12px ${nasdaq100Sentiment.color}30` : 'none'
                            },
                            title: `NASDAQ 100: ${nasdaq100Sentiment.label}\nScore: ${(nasdaq100Sentiment.score || 0).toFixed(2)}%\nAlcistas: ${nasdaq100Sentiment.bullish || 0}/100\nBajistas: ${nasdaq100Sentiment.bearish || 0}/100`
                        },
                            React.createElement('div', {
                                className: "w-6 h-6 rounded-md flex items-center justify-center text-[10px] font-black",
                                style: {
                                    background: `linear-gradient(135deg, ${nasdaq100Sentiment.color} 0%, ${nasdaq100Sentiment.color}90 100%)`,
                                    color: '#000',
                                    boxShadow: `0 2px 8px ${nasdaq100Sentiment.color}50`
                                }
                            }, 'N'),
                            React.createElement('div', { className: "flex flex-col" },
                                React.createElement('span', {
                                    className: "text-[10px] font-bold uppercase tracking-wide",
                                    style: { color: nasdaq100Sentiment.color }
                                }, nasdaq100Sentiment.label || 'CARGANDO'),
                                React.createElement('span', {
                                    className: "text-[9px] text-neutral-500 font-mono"
                                }, `${nasdaq100Sentiment.bullish || 0}‚Üë ${nasdaq100Sentiment.bearish || 0}‚Üì`)
                            ),
                            // Mini indicador de direcci√≥n
                            React.createElement('div', {
                                className: "text-lg font-bold",
                                style: {
                                    color: nasdaq100Sentiment.color,
                                    textShadow: `0 0 8px ${nasdaq100Sentiment.color}`
                                }
                            }, (nasdaq100Sentiment.score || 0) > 0.5 ? '‚ñ≤' : (nasdaq100Sentiment.score || 0) < -0.5 ? '‚ñº' : '‚óè')
                        ),
                        // Sound controls
                        React.createElement('div', { className: "flex items-center gap-1 mr-2 border-r border-neutral-700 pr-2" },
                            React.createElement('button', {
                                onClick: () => setSoundEnabled(!soundEnabled),
                                className: `w-6 h-6 rounded flex items-center justify-center text-xs transition-all ${soundEnabled ? 'bg-purple-600/30 text-purple-400' : 'bg-neutral-800 text-neutral-600'
                                    }`,
                                title: soundEnabled ? 'Sounds ON' : 'Sounds OFF'
                            }, soundEnabled ? 'üîä' : 'üîá'),
                            soundEnabled && React.createElement('div', { className: "flex gap-0.5" },
                                React.createElement('button', {
                                    onClick: () => setImpulseSoundEnabled(!impulseSoundEnabled),
                                    className: `px-1.5 py-0.5 rounded text-[9px] font-bold transition-all ${impulseSoundEnabled ? 'bg-sky-500/30 text-sky-400' : 'bg-neutral-800 text-neutral-600'
                                        }`,
                                    title: 'Impulse sound'
                                }, 'I'),
                                React.createElement('button', {
                                    onClick: () => setVolatilitySoundEnabled(!volatilitySoundEnabled),
                                    className: `px-1.5 py-0.5 rounded text-[9px] font-bold transition-all ${volatilitySoundEnabled ? 'bg-purple-500/30 text-purple-400' : 'bg-neutral-800 text-neutral-600'
                                        }`,
                                    title: 'Volatility sound'
                                }, 'V'),
                                React.createElement('button', {
                                    onClick: () => setCompressionSoundEnabled(!compressionSoundEnabled),
                                    className: `px-1.5 py-0.5 rounded text-[9px] font-bold transition-all ${compressionSoundEnabled ? 'bg-amber-500/30 text-amber-400' : 'bg-neutral-800 text-neutral-600'
                                        }`,
                                    title: 'Compression sound'
                                }, 'C')
                            ),
                            // Flow Level Type selector
                            React.createElement('select', {
                                value: flowLevelType,
                                onChange: (e) => setFlowLevelType(e.target.value),
                                className: "bg-neutral-800 text-neutral-300 text-[10px] px-1.5 py-0.5 rounded border border-neutral-700 focus:outline-none focus:border-blue-500",
                                title: 'Flow Levels: Cash ($) or Delta (Œî)'
                            },
                                React.createElement('option', { value: 'cash' }, '$ Cash'),
                                React.createElement('option', { value: 'delta' }, 'Œî Delta')
                            )
                        ),
                        // Session Report button
                        React.createElement('button', {
                            onClick: () => setShowReport(true),
                            className: `px-3 py-1.5 rounded text-xs font-medium transition-all ${sessionHistory.pivots.length + sessionHistory.impulses.length > 0
                                ? 'bg-indigo-600/80 text-white hover:bg-indigo-500'
                                : 'bg-neutral-700 text-neutral-400'
                                }`,
                            title: 'Session Intelligence Report'
                        }, `Report (${sessionHistory.pivots.length + sessionHistory.impulses.length + sessionHistory.volatilityEvents.length})`),
                        aiApiKey && React.createElement('button', {
                            onClick: requestAiAnalysis,
                            disabled: isAnalyzing,
                            className: `px-3 py-1.5 rounded text-xs font-medium transition-all ${isAnalyzing
                                ? 'bg-neutral-700 text-neutral-500 cursor-wait'
                                : 'bg-sky-600 text-white hover:bg-sky-500'}`
                        }, isAnalyzing ? 'Analyzing...' : 'AI Analysis'),
                        aiApiKey && React.createElement('button', {
                            onClick: () => setAutoAnalyze(!autoAnalyze),
                            className: `px-2 py-1.5 rounded text-xs font-medium transition-all ${autoAnalyze
                                ? 'bg-green-600 text-white'
                                : 'bg-neutral-700 text-neutral-400 hover:bg-neutral-600'}`
                        }, autoAnalyze ? 'AUTO' : 'Manual')
                    )
                ),

                // === SESSION REPORT MODAL ===
                showReport && React.createElement('div', {
                    className: "fixed inset-0 bg-black/80 flex items-center justify-center z-50 p-4",
                    onClick: (e) => e.target === e.currentTarget && setShowReport(false)
                },
                    React.createElement('div', {
                        className: "bg-neutral-900 border border-neutral-700 rounded-xl max-w-4xl w-full max-h-[85vh] overflow-hidden flex flex-col"
                    },
                        // Modal Header
                        React.createElement('div', {
                            className: "flex items-center justify-between px-6 py-4 border-b border-neutral-800",
                            style: { background: 'linear-gradient(180deg, rgba(45,45,45,1) 0%, rgba(30,30,30,1) 100%)' }
                        },
                            React.createElement('div', null,
                                React.createElement('h2', { className: "text-lg font-bold text-neutral-200" }, "Session Intelligence Report"),
                                React.createElement('p', { className: "text-xs text-neutral-500 mt-0.5" },
                                    `Session started: ${new Date(sessionHistory.sessionStart).toLocaleTimeString()}`
                                )
                            ),
                            React.createElement('div', { className: "flex items-center gap-3" },
                                React.createElement('button', {
                                    onClick: exportToPDF,
                                    disabled: isExporting,
                                    className: `px-4 py-1.5 rounded text-xs font-medium transition-all flex items-center gap-2 ${isExporting
                                        ? 'bg-neutral-700 text-neutral-500 cursor-wait'
                                        : 'bg-indigo-600 text-white hover:bg-indigo-500'
                                        }`
                                },
                                    isExporting ? 'Generating...' : 'Export PDF'
                                ),
                                React.createElement('button', {
                                    onClick: () => setSessionHistory({
                                        pivots: [], impulses: [], volatilityEvents: [], compressionBreakouts: [],
                                        sessionStart: new Date().toISOString()
                                    }),
                                    className: "px-3 py-1.5 rounded text-xs bg-red-600/20 text-red-400 hover:bg-red-600/30 transition-all"
                                }, "Reset"),
                                React.createElement('button', {
                                    onClick: () => setShowReport(false),
                                    className: "w-8 h-8 rounded-full bg-neutral-800 text-neutral-400 hover:bg-neutral-700 flex items-center justify-center text-lg"
                                }, "√ó")
                            )
                        ),
                        // Modal Content
                        React.createElement('div', { className: "flex-1 overflow-auto p-6" },
                            React.createElement('div', { className: "grid grid-cols-1 md:grid-cols-2 gap-6" },

                                // === PIVOTS ANALYSIS ===
                                React.createElement('div', { className: "bg-neutral-800/50 rounded-lg p-4" },
                                    React.createElement('div', { className: "flex items-center justify-between mb-4" },
                                        React.createElement('h3', { className: "text-sm font-bold text-emerald-400 uppercase tracking-wider" }, "Pivot Points"),
                                        React.createElement('div', { className: "flex gap-2 text-xs" },
                                            React.createElement('span', { className: "px-2 py-0.5 rounded bg-green-900/30 text-green-400" },
                                                `${sessionStats.pivots.lows} Lows`
                                            ),
                                            React.createElement('span', { className: "px-2 py-0.5 rounded bg-red-900/30 text-red-400" },
                                                `${sessionStats.pivots.highs} Highs`
                                            )
                                        )
                                    ),
                                    sessionStats.pivots.topMetrics?.length > 0
                                        ? React.createElement('div', { className: "space-y-2" },
                                            React.createElement('p', { className: "text-[10px] text-neutral-500 uppercase mb-2" }, "Most Frequent Metrics at Pivots"),
                                            sessionStats.pivots.topMetrics.map((m, idx) =>
                                                React.createElement('div', { key: m.label, className: "flex items-center gap-3" },
                                                    React.createElement('span', { className: "w-5 text-xs text-neutral-500 font-mono" }, `${idx + 1}.`),
                                                    React.createElement('div', { className: "flex-1" },
                                                        React.createElement('div', { className: "flex justify-between mb-0.5" },
                                                            React.createElement('span', { className: "text-xs text-neutral-300 font-medium" }, m.label),
                                                            React.createElement('span', { className: "text-[10px] text-neutral-400" },
                                                                `${m.count}x (${(m.count / Math.max(1, sessionStats.pivots.total) * 100).toFixed(0)}%)`
                                                            )
                                                        ),
                                                        React.createElement('div', { className: "h-1.5 bg-neutral-700 rounded-full overflow-hidden" },
                                                            React.createElement('div', {
                                                                className: "h-full rounded-full",
                                                                style: {
                                                                    width: `${(m.count / Math.max(1, sessionStats.pivots.topMetrics[0]?.count || 1) * 100)}%`,
                                                                    background: 'linear-gradient(90deg, #10b981, #34d399)'
                                                                }
                                                            })
                                                        )
                                                    ),
                                                    React.createElement('span', { className: "text-[10px] font-mono text-neutral-500" },
                                                        `avg ${m.avgStrength.toFixed(0)}%`
                                                    )
                                                )
                                            )
                                        )
                                        : React.createElement('p', { className: "text-xs text-neutral-500 text-center py-4" }, "No pivot data yet")
                                ),

                                // === IMPULSES ANALYSIS ===
                                React.createElement('div', { className: "bg-neutral-800/50 rounded-lg p-4" },
                                    React.createElement('div', { className: "flex items-center justify-between mb-4" },
                                        React.createElement('h3', { className: "text-sm font-bold text-sky-400 uppercase tracking-wider" }, "Impulses"),
                                        React.createElement('div', { className: "flex gap-2 text-xs" },
                                            React.createElement('span', { className: "px-2 py-0.5 rounded bg-blue-900/30 text-blue-400" },
                                                `${sessionStats.impulses.bullish} Bull`
                                            ),
                                            React.createElement('span', { className: "px-2 py-0.5 rounded bg-red-900/30 text-red-400" },
                                                `${sessionStats.impulses.bearish} Bear`
                                            )
                                        )
                                    ),
                                    React.createElement('div', { className: "text-xs text-neutral-400 mb-3" },
                                        `Avg Strength: ${sessionStats.impulses.avgStrength.toFixed(0)}%`
                                    ),
                                    sessionStats.impulses.topMetrics?.length > 0
                                        ? React.createElement('div', { className: "space-y-2" },
                                            React.createElement('p', { className: "text-[10px] text-neutral-500 uppercase mb-2" }, "Metrics Driving Impulses"),
                                            sessionStats.impulses.topMetrics.map((m, idx) =>
                                                React.createElement('div', { key: m.label, className: "flex items-center gap-3" },
                                                    React.createElement('span', { className: "w-5 text-xs text-neutral-500 font-mono" }, `${idx + 1}.`),
                                                    React.createElement('div', { className: "flex-1" },
                                                        React.createElement('div', { className: "flex justify-between mb-0.5" },
                                                            React.createElement('span', { className: "text-xs text-neutral-300 font-medium" }, m.label),
                                                            React.createElement('div', { className: "flex gap-1" },
                                                                m.bullish > 0 && React.createElement('span', { className: "text-[9px] text-blue-400" }, `${m.bullish}‚Üë`),
                                                                m.bearish > 0 && React.createElement('span', { className: "text-[9px] text-red-400" }, `${m.bearish}‚Üì`)
                                                            )
                                                        ),
                                                        React.createElement('div', { className: "h-1.5 bg-neutral-700 rounded-full overflow-hidden" },
                                                            React.createElement('div', {
                                                                className: "h-full rounded-full",
                                                                style: {
                                                                    width: `${(m.count / Math.max(1, sessionStats.impulses.topMetrics[0]?.count || 1) * 100)}%`,
                                                                    background: 'linear-gradient(90deg, #3b82f6, #60a5fa)'
                                                                }
                                                            })
                                                        )
                                                    ),
                                                    React.createElement('span', { className: "text-[10px] font-mono text-neutral-500" },
                                                        `${m.count}x`
                                                    )
                                                )
                                            )
                                        )
                                        : React.createElement('p', { className: "text-xs text-neutral-500 text-center py-4" }, "No impulse data yet")
                                ),

                                // === VOLATILITY ANALYSIS ===
                                React.createElement('div', { className: "bg-neutral-800/50 rounded-lg p-4" },
                                    React.createElement('div', { className: "flex items-center justify-between mb-4" },
                                        React.createElement('h3', { className: "text-sm font-bold text-purple-400 uppercase tracking-wider" }, "Volatility Events"),
                                        React.createElement('div', { className: "flex gap-2 text-xs" },
                                            React.createElement('span', { className: "px-2 py-0.5 rounded bg-purple-900/30 text-purple-400" },
                                                `${sessionStats.volatility.expansions} Exp`
                                            ),
                                            React.createElement('span', { className: "px-2 py-0.5 rounded bg-amber-900/30 text-amber-400" },
                                                `${sessionStats.volatility.compressions} Comp`
                                            )
                                        )
                                    ),
                                    sessionStats.volatility.topMetrics?.length > 0
                                        ? React.createElement('div', { className: "space-y-2" },
                                            React.createElement('p', { className: "text-[10px] text-neutral-500 uppercase mb-2" }, "Correlated Metrics During Volatility"),
                                            sessionStats.volatility.topMetrics.map((m, idx) =>
                                                React.createElement('div', { key: m.label, className: "flex items-center gap-3" },
                                                    React.createElement('span', { className: "w-5 text-xs text-neutral-500 font-mono" }, `${idx + 1}.`),
                                                    React.createElement('div', { className: "flex-1" },
                                                        React.createElement('div', { className: "flex justify-between mb-0.5" },
                                                            React.createElement('span', { className: "text-xs text-neutral-300 font-medium" }, m.label),
                                                            React.createElement('span', { className: "text-[10px] text-neutral-400" }, `${m.count}x`)
                                                        ),
                                                        React.createElement('div', { className: "h-1.5 bg-neutral-700 rounded-full overflow-hidden" },
                                                            React.createElement('div', {
                                                                className: "h-full rounded-full",
                                                                style: {
                                                                    width: `${(m.count / Math.max(1, sessionStats.volatility.topMetrics[0]?.count || 1) * 100)}%`,
                                                                    background: 'linear-gradient(90deg, #9333ea, #a855f7)'
                                                                }
                                                            })
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                        : React.createElement('p', { className: "text-xs text-neutral-500 text-center py-4" }, "No volatility events yet")
                                ),

                                // === COMPRESSION BREAKOUTS ANALYSIS ===
                                React.createElement('div', { className: "bg-neutral-800/50 rounded-lg p-4" },
                                    React.createElement('div', { className: "flex items-center justify-between mb-4" },
                                        React.createElement('h3', { className: "text-sm font-bold text-amber-400 uppercase tracking-wider" }, "Compression Breakouts"),
                                        React.createElement('span', { className: "text-xs text-neutral-400" },
                                            `${sessionStats.breakouts.total} total`
                                        )
                                    ),
                                    sessionStats.breakouts.total > 0
                                        ? React.createElement('div', null,
                                            React.createElement('div', { className: "grid grid-cols-3 gap-2 mb-4" },
                                                React.createElement('div', { className: "bg-neutral-900/50 rounded p-2 text-center" },
                                                    React.createElement('div', { className: "text-lg font-bold text-blue-400" }, sessionStats.breakouts.bullish),
                                                    React.createElement('div', { className: "text-[10px] text-neutral-500" }, "Bullish")
                                                ),
                                                React.createElement('div', { className: "bg-neutral-900/50 rounded p-2 text-center" },
                                                    React.createElement('div', { className: "text-lg font-bold text-red-400" }, sessionStats.breakouts.bearish),
                                                    React.createElement('div', { className: "text-[10px] text-neutral-500" }, "Bearish")
                                                ),
                                                React.createElement('div', { className: "bg-neutral-900/50 rounded p-2 text-center" },
                                                    React.createElement('div', { className: "text-lg font-bold text-amber-400" },
                                                        `${sessionStats.breakouts.avgEnergy.toFixed(0)}%`
                                                    ),
                                                    React.createElement('div', { className: "text-[10px] text-neutral-500" }, "Avg Energy")
                                                )
                                            ),
                                            sessionStats.breakouts.topTriggers?.length > 0 && React.createElement('div', null,
                                                React.createElement('p', { className: "text-[10px] text-neutral-500 uppercase mb-2" }, "What Triggers Breakouts"),
                                                React.createElement('div', { className: "space-y-2" },
                                                    sessionStats.breakouts.topTriggers.map((m, idx) =>
                                                        React.createElement('div', { key: m.label, className: "flex items-center gap-3" },
                                                            React.createElement('span', { className: "w-5 text-xs text-neutral-500 font-mono" }, `${idx + 1}.`),
                                                            React.createElement('span', { className: "text-xs text-neutral-300 flex-1" }, m.label),
                                                            React.createElement('div', { className: "flex gap-1" },
                                                                m.bullish > 0 && React.createElement('span', { className: "text-[9px] px-1.5 py-0.5 rounded bg-blue-900/40 text-blue-400" }, `${m.bullish}‚Üë`),
                                                                m.bearish > 0 && React.createElement('span', { className: "text-[9px] px-1.5 py-0.5 rounded bg-red-900/40 text-red-400" }, `${m.bearish}‚Üì`)
                                                            ),
                                                            React.createElement('span', { className: "text-[10px] font-mono text-amber-400" }, `${m.count}x`)
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                        : React.createElement('p', { className: "text-xs text-neutral-500 text-center py-4" }, "No breakouts recorded yet")
                                )
                            ),

                            // === SUMMARY INSIGHTS ===
                            (sessionStats.pivots.total + sessionStats.impulses.total > 5) && React.createElement('div', {
                                className: "mt-6 p-4 bg-indigo-900/20 border border-indigo-500/30 rounded-lg"
                            },
                                React.createElement('h4', { className: "text-sm font-bold text-indigo-400 mb-3" }, "Session Insights"),
                                React.createElement('div', { className: "grid grid-cols-1 md:grid-cols-2 gap-4 text-xs text-neutral-300" },
                                    sessionStats.pivots.topMetrics?.[0] && React.createElement('p', null,
                                        "At pivot points, ",
                                        React.createElement('strong', { className: "text-emerald-400" }, sessionStats.pivots.topMetrics[0].label),
                                        ` appears ${(sessionStats.pivots.topMetrics[0].count / Math.max(1, sessionStats.pivots.total) * 100).toFixed(0)}% of the time.`
                                    ),
                                    sessionStats.impulses.topMetrics?.[0] && React.createElement('p', null,
                                        "Impulse moves are primarily driven by ",
                                        React.createElement('strong', { className: "text-sky-400" }, sessionStats.impulses.topMetrics[0].label),
                                        ` (${sessionStats.impulses.topMetrics[0].count} occurrences).`
                                    ),
                                    sessionStats.breakouts.topTriggers?.[0] && React.createElement('p', null,
                                        "Compression breakouts are triggered by ",
                                        React.createElement('strong', { className: "text-amber-400" }, sessionStats.breakouts.topTriggers[0].label),
                                        ` with ${sessionStats.breakouts.bullish > sessionStats.breakouts.bearish ? 'bullish' : 'bearish'} bias.`
                                    ),
                                    sessionStats.volatility.topMetrics?.[0] && React.createElement('p', null,
                                        "During volatility events, ",
                                        React.createElement('strong', { className: "text-purple-400" }, sessionStats.volatility.topMetrics[0].label),
                                        " shows the strongest correlation."
                                    )
                                )
                            )
                        )
                    )
                ),

                // Main Content
                React.createElement('div', { className: "flex-1 overflow-auto p-4" },

                    // === CHART PRINCIPAL - ARRIBA, GRANDE Y ELEGANTE ===
                    React.createElement('div', {
                        className: "bg-neutral-900/60 border border-neutral-800 rounded-xl overflow-hidden mb-4"
                    },
                        // Chart Header elegante
                        React.createElement('div', {
                            className: "flex items-center justify-between px-5 py-3 border-b border-neutral-800/50",
                            style: { background: 'linear-gradient(180deg, rgba(30,30,30,0.9) 0%, rgba(20,20,20,0.95) 100%)' }
                        },
                            React.createElement('div', { className: "flex items-center gap-4" },
                                React.createElement('h3', { className: "text-sm font-semibold text-neutral-200 tracking-wide" },
                                    "Price Action Intelligence"
                                ),
                                // Toggle chart visibility
                                React.createElement('button', {
                                    onClick: () => setShowIntelligenceChart(!showIntelligenceChart),
                                    className: `px-2 py-1 rounded text-[10px] font-medium transition-all cursor-pointer ${showIntelligenceChart
                                        ? 'bg-emerald-500/20 text-emerald-400 border border-emerald-500/30 hover:bg-emerald-500/30'
                                        : 'bg-neutral-800/50 text-neutral-500 border border-neutral-700 hover:text-neutral-300'}`,
                                    title: showIntelligenceChart ? "Hide chart" : "Show chart"
                                }, showIntelligenceChart ? "üìà Chart" : "üìâ Hidden"),
                                // Zoom indicator
                                showIntelligenceChart && React.createElement('button', {
                                    onClick: () => setIsZoomed(!isZoomed),
                                    className: `px-2 py-1 rounded text-[10px] font-medium transition-all cursor-pointer ${isZoomed
                                        ? 'bg-sky-500/20 text-sky-400 border border-sky-500/30'
                                        : 'bg-neutral-800/50 text-neutral-500 border border-neutral-700 hover:text-neutral-300'}`,
                                    title: "Double-click chart or click here to zoom"
                                }, isZoomed ? "ZOOMED (30%)" : "Full View"),
                                // Status badges (only when chart visible)
                                showIntelligenceChart && compressionAnalysis.detected && React.createElement('span', {
                                    className: "px-2.5 py-1 rounded text-[10px] font-bold uppercase tracking-wider",
                                    style: { backgroundColor: 'rgba(251, 191, 36, 0.15)', color: '#fbbf24', border: '1px solid rgba(251, 191, 36, 0.3)' }
                                }, "Compression"),
                                showIntelligenceChart && impulseAnalysis.active && React.createElement('span', {
                                    className: "px-2.5 py-1 rounded text-[10px] font-bold uppercase tracking-wider",
                                    style: {
                                        backgroundColor: impulseAnalysis.direction === 'BULLISH' ? 'rgba(59, 130, 246, 0.15)' : 'rgba(239, 68, 68, 0.15)',
                                        color: impulseAnalysis.direction === 'BULLISH' ? '#3b82f6' : '#ef4444',
                                        border: `1px solid ${impulseAnalysis.direction === 'BULLISH' ? 'rgba(59, 130, 246, 0.3)' : 'rgba(239, 68, 68, 0.3)'}`
                                    }
                                }, `${impulseAnalysis.direction} Impulse`),
                                showIntelligenceChart && volatilityAnalysis.state !== 'NORMAL' && React.createElement('span', {
                                    className: "px-2.5 py-1 rounded text-[10px] font-bold uppercase tracking-wider",
                                    style: {
                                        backgroundColor: volatilityAnalysis.state === 'EXPANSION' ? 'rgba(168, 85, 247, 0.15)' : 'rgba(251, 191, 36, 0.15)',
                                        color: volatilityAnalysis.state === 'EXPANSION' ? '#a855f7' : '#fbbf24',
                                        border: `1px solid ${volatilityAnalysis.state === 'EXPANSION' ? 'rgba(168, 85, 247, 0.3)' : 'rgba(251, 191, 36, 0.3)'}`
                                    }
                                }, `Vol ${volatilityAnalysis.state}`)
                            ),
                            // Legend compacta + Module Selector + hint
                            React.createElement('div', { className: "flex items-center gap-4 text-[10px]" },
                                // === MODULE SELECTOR DROPDOWN ===
                                React.createElement('div', {
                                    className: "relative",
                                    ref: moduleSelectorRef
                                },
                                    React.createElement('button', {
                                        onClick: () => setShowModuleSelector(!showModuleSelector),
                                        className: `flex items-center gap-2 px-3 py-1.5 rounded-lg text-xs font-medium transition-all cursor-pointer ${showModuleSelector
                                            ? 'bg-indigo-500/30 text-indigo-300 border border-indigo-500/50'
                                            : 'bg-neutral-800 text-neutral-400 border border-neutral-700 hover:text-neutral-200 hover:border-neutral-600'
                                            }`
                                    },
                                        React.createElement('span', null, "üìä"),
                                        React.createElement('span', null, "Modules"),
                                        React.createElement('span', {
                                            className: "px-1.5 py-0.5 rounded bg-neutral-700 text-neutral-300 font-mono text-[10px]"
                                        }, Object.values(visibleModules).filter(Boolean).length),
                                        React.createElement('span', {
                                            className: `transition-transform ${showModuleSelector ? 'rotate-180' : ''}`
                                        }, "‚ñº")
                                    ),
                                    // Dropdown menu
                                    showModuleSelector && React.createElement('div', {
                                        className: "absolute top-full right-0 mt-2 w-56 bg-neutral-900 border border-neutral-700 rounded-xl shadow-xl z-50 overflow-hidden"
                                    },
                                        React.createElement('div', { className: "p-2 border-b border-neutral-800" },
                                            React.createElement('span', { className: "text-[10px] text-neutral-500 uppercase font-bold" }, "Show/Hide Intelligence Modules")
                                        ),
                                        // Module toggles
                                        React.createElement('div', { className: "p-2 space-y-1" },
                                            // Confluence Monitor
                                            React.createElement('button', {
                                                onClick: () => toggleModule('confluence'),
                                                className: `w-full flex items-center justify-between px-3 py-2 rounded-lg text-left transition-all cursor-pointer ${visibleModules.confluence
                                                    ? 'bg-blue-500/20 text-blue-300 hover:bg-blue-500/30'
                                                    : 'bg-neutral-800/50 text-neutral-500 hover:bg-neutral-800'
                                                    }`
                                            },
                                                React.createElement('span', { className: "text-xs font-medium" }, "Confluence Monitor"),
                                                React.createElement('span', {
                                                    className: `w-5 h-5 rounded-full flex items-center justify-center text-[10px] font-bold ${visibleModules.confluence ? 'bg-blue-500 text-white' : 'bg-neutral-700 text-neutral-500'
                                                        }`
                                                }, visibleModules.confluence ? "‚úì" : "")
                                            ),
                                            // Tick Opportunity
                                            React.createElement('button', {
                                                onClick: () => toggleModule('tickOpportunity'),
                                                className: `w-full flex items-center justify-between px-3 py-2 rounded-lg text-left transition-all cursor-pointer ${visibleModules.tickOpportunity
                                                    ? 'bg-emerald-500/20 text-emerald-300 hover:bg-emerald-500/30'
                                                    : 'bg-neutral-800/50 text-neutral-500 hover:bg-neutral-800'
                                                    }`
                                            },
                                                React.createElement('span', { className: "text-xs font-medium" }, "Tick Opportunity"),
                                                React.createElement('span', {
                                                    className: `w-5 h-5 rounded-full flex items-center justify-center text-[10px] font-bold ${visibleModules.tickOpportunity ? 'bg-emerald-500 text-white' : 'bg-neutral-700 text-neutral-500'
                                                        }`
                                                }, visibleModules.tickOpportunity ? "‚úì" : "")
                                            ),
                                            // Sweep Analysis
                                            React.createElement('button', {
                                                onClick: () => toggleModule('sweepAnalysis'),
                                                className: `w-full flex items-center justify-between px-3 py-2 rounded-lg text-left transition-all cursor-pointer ${visibleModules.sweepAnalysis
                                                    ? 'bg-purple-500/20 text-purple-300 hover:bg-purple-500/30'
                                                    : 'bg-neutral-800/50 text-neutral-500 hover:bg-neutral-800'
                                                    }`
                                            },
                                                React.createElement('span', { className: "text-xs font-medium" }, "Sweep Analysis"),
                                                React.createElement('span', {
                                                    className: `w-5 h-5 rounded-full flex items-center justify-center text-[10px] font-bold ${visibleModules.sweepAnalysis ? 'bg-purple-500 text-white' : 'bg-neutral-700 text-neutral-500'
                                                        }`
                                                }, visibleModules.sweepAnalysis ? "‚úì" : "")
                                            ),
                                            // Panels Grid (Top 3, etc)
                                            React.createElement('button', {
                                                onClick: () => toggleModule('panelsGrid'),
                                                className: `w-full flex items-center justify-between px-3 py-2 rounded-lg text-left transition-all cursor-pointer ${visibleModules.panelsGrid
                                                    ? 'bg-amber-500/20 text-amber-300 hover:bg-amber-500/30'
                                                    : 'bg-neutral-800/50 text-neutral-500 hover:bg-neutral-800'
                                                    }`
                                            },
                                                React.createElement('span', { className: "text-xs font-medium" }, "Analytics Grid"),
                                                React.createElement('span', {
                                                    className: `w-5 h-5 rounded-full flex items-center justify-center text-[10px] font-bold ${visibleModules.panelsGrid ? 'bg-amber-500 text-white' : 'bg-neutral-700 text-neutral-500'
                                                        }`
                                                }, visibleModules.panelsGrid ? "‚úì" : "")
                                            ),
                                            // Absorption Pivots
                                            React.createElement('button', {
                                                onClick: () => toggleModule('absorption'),
                                                className: `w-full flex items-center justify-between px-3 py-2 rounded-lg text-left transition-all cursor-pointer ${visibleModules.absorption
                                                    ? 'bg-pink-500/20 text-pink-300 hover:bg-pink-500/30'
                                                    : 'bg-neutral-800/50 text-neutral-500 hover:bg-neutral-800'
                                                    }`
                                            },
                                                React.createElement('span', { className: "text-xs font-medium" }, "Absorption Zones"),
                                                React.createElement('span', {
                                                    className: `w-5 h-5 rounded-full flex items-center justify-center text-[10px] font-bold ${visibleModules.absorption ? 'bg-pink-500 text-white' : 'bg-neutral-700 text-neutral-500'
                                                        }`
                                                }, visibleModules.absorption ? "‚úì" : "")
                                            ),
                                            // Pivots tradicionales (Chart markers)
                                            React.createElement('button', {
                                                onClick: () => toggleModule('pivots'),
                                                className: `w-full flex items-center justify-between px-3 py-2 rounded-lg text-left transition-all cursor-pointer ${visibleModules.pivots
                                                    ? 'bg-teal-500/20 text-teal-300 hover:bg-teal-500/30'
                                                    : 'bg-neutral-800/50 text-neutral-500 hover:bg-neutral-800'
                                                    }`
                                            },
                                                React.createElement('span', { className: "text-xs font-medium" }, "Chart Pivots"),
                                                React.createElement('span', {
                                                    className: `w-5 h-5 rounded-full flex items-center justify-center text-[10px] font-bold ${visibleModules.pivots ? 'bg-teal-500 text-white' : 'bg-neutral-700 text-neutral-500'
                                                        }`
                                                }, visibleModules.pivots ? "‚úì" : "")
                                            ),
                                            // AI Narrator
                                            React.createElement('button', {
                                                onClick: () => toggleModule('narrator'),
                                                className: `w-full flex items-center justify-between px-3 py-2 rounded-lg text-left transition-all cursor-pointer ${visibleModules.narrator
                                                    ? 'bg-purple-500/20 text-purple-300 hover:bg-purple-500/30'
                                                    : 'bg-neutral-800/50 text-neutral-500 hover:bg-neutral-800'
                                                    }`
                                            },
                                                React.createElement('span', { className: "text-xs font-medium" }, "AI Narrator"),
                                                React.createElement('span', {
                                                    className: `w-5 h-5 rounded-full flex items-center justify-center text-[10px] font-bold ${visibleModules.narrator ? 'bg-purple-500 text-white' : 'bg-neutral-700 text-neutral-500'
                                                        }`
                                                }, visibleModules.narrator ? "‚úì" : "")
                                            )
                                        ),
                                        // Quick actions
                                        React.createElement('div', { className: "p-2 border-t border-neutral-800 flex gap-2" },
                                            React.createElement('button', {
                                                onClick: () => setVisibleModules({ confluence: true, tickOpportunity: true, sweepAnalysis: true, panelsGrid: true, absorption: true, pivots: true, narrator: true }),
                                                className: "flex-1 px-2 py-1.5 rounded text-[10px] font-medium bg-emerald-500/20 text-emerald-400 hover:bg-emerald-500/30 cursor-pointer"
                                            }, "Show All"),
                                            React.createElement('button', {
                                                onClick: () => setVisibleModules({ confluence: false, tickOpportunity: false, sweepAnalysis: false, panelsGrid: false, absorption: false, pivots: false, narrator: false }),
                                                className: "flex-1 px-2 py-1.5 rounded text-[10px] font-medium bg-red-500/20 text-red-400 hover:bg-red-500/30 cursor-pointer"
                                            }, "Hide All")
                                        )
                                    )
                                ),
                                // Separador (solo si chart visible)
                                showIntelligenceChart && React.createElement('div', { className: "w-px h-4 bg-neutral-700" }),
                                showIntelligenceChart && React.createElement('span', { className: "text-neutral-600 italic" }, "Double-click to zoom"),
                                showIntelligenceChart && React.createElement('div', { className: "flex items-center gap-1.5" },
                                    React.createElement('div', { className: "w-3 h-3 rounded", style: { backgroundColor: 'rgba(251, 191, 36, 0.3)' } }),
                                    React.createElement('span', { className: "text-neutral-500" }, "Compression")
                                ),
                                showIntelligenceChart && React.createElement('div', { className: "flex items-center gap-1.5" },
                                    React.createElement('div', { className: "w-3 h-3 rounded", style: { backgroundColor: 'rgba(59, 130, 246, 0.3)' } }),
                                    React.createElement('span', { className: "text-neutral-500" }, "Bull")
                                ),
                                showIntelligenceChart && React.createElement('div', { className: "flex items-center gap-1.5" },
                                    React.createElement('div', { className: "w-3 h-3 rounded", style: { backgroundColor: 'rgba(239, 68, 68, 0.3)' } }),
                                    React.createElement('span', { className: "text-neutral-500" }, "Bear")
                                ),
                                showIntelligenceChart && React.createElement('div', { className: "flex items-center gap-1.5" },
                                    React.createElement('span', { className: "text-green-500 text-xs" }, "‚ñ≤"),
                                    React.createElement('span', { className: "text-neutral-500" }, "Low")
                                ),
                                showIntelligenceChart && React.createElement('div', { className: "flex items-center gap-1.5" },
                                    React.createElement('span', { className: "text-red-500 text-xs" }, "‚ñº"),
                                    React.createElement('span', { className: "text-neutral-500" }, "High")
                                ),
                                // Leyenda de Absorciones
                                showIntelligenceChart && visibleModules.absorption && React.createElement('div', { className: "flex items-center gap-1.5" },
                                    React.createElement('div', {
                                        className: "w-3 h-3",
                                        style: {
                                            backgroundColor: 'rgba(16, 185, 129, 0.6)',
                                            transform: 'rotate(45deg)',
                                            borderRadius: '2px'
                                        }
                                    }),
                                    React.createElement('span', { className: "text-emerald-400 text-[10px]" }, "Abs Bull")
                                ),
                                showIntelligenceChart && visibleModules.absorption && React.createElement('div', { className: "flex items-center gap-1.5" },
                                    React.createElement('div', {
                                        className: "w-3 h-3",
                                        style: {
                                            backgroundColor: 'rgba(168, 85, 247, 0.6)',
                                            transform: 'rotate(45deg)',
                                            borderRadius: '2px'
                                        }
                                    }),
                                    React.createElement('span', { className: "text-purple-400 text-[10px]" }, "Abs Bear")
                                )
                            )
                        ),
                        // Chart grande (with hide/show transition)
                        React.createElement('div', {
                            ref: chartRef,
                            style: {
                                width: '100%',
                                height: showIntelligenceChart ? '480px' : '0px',
                                padding: showIntelligenceChart ? '8px' : '0px',
                                overflow: 'hidden',
                                transition: 'height 0.3s ease-in-out, padding 0.3s ease-in-out',
                                opacity: showIntelligenceChart ? 1 : 0
                            }
                        })
                    ),

                    // === CONFLUENCE MONITOR - EXPANDED & RESPONSIVE (igual que Tick Opportunity) ===
                    visibleModules.confluence && React.createElement('div', {
                        className: `relative overflow-hidden rounded-xl border-2 transition-all duration-300 mb-4 ${confluenceAlert.active
                            ? confluenceAlert.type === 'ALERT'
                                ? confluenceAlert.direction === 'BULLISH'
                                    ? 'bg-gradient-to-br from-blue-900/40 via-blue-800/30 to-blue-900/40 border-blue-500 shadow-lg shadow-blue-500/20'
                                    : 'bg-gradient-to-br from-red-900/40 via-red-800/30 to-red-900/40 border-red-500 shadow-lg shadow-red-500/20'
                                : 'bg-gradient-to-br from-amber-900/30 via-amber-800/20 to-amber-900/30 border-amber-500 shadow-lg shadow-amber-500/20'
                            : 'bg-neutral-900/60 border-neutral-700'
                            }`
                    },
                        // Header
                        React.createElement('div', {
                            className: "px-4 py-3 border-b border-neutral-800/50 flex flex-col sm:flex-row items-start sm:items-center justify-between gap-2"
                        },
                            React.createElement('div', { className: "flex items-center gap-3" },
                                React.createElement('div', {
                                    className: `w-3 h-10 rounded-full transition-all ${confluenceAlert.active
                                        ? confluenceAlert.type === 'ALERT'
                                            ? confluenceAlert.direction === 'BULLISH'
                                                ? 'bg-blue-500 shadow-lg shadow-blue-500/50 animate-pulse'
                                                : 'bg-red-500 shadow-lg shadow-red-500/50 animate-pulse'
                                            : 'bg-amber-500 shadow-lg shadow-amber-500/50'
                                        : 'bg-neutral-600'
                                        }`
                                }),
                                React.createElement('div', null,
                                    React.createElement('div', { className: "flex items-center gap-2" },
                                        React.createElement('h3', { className: "text-sm font-bold text-neutral-300 uppercase tracking-wider" },
                                            "Confluence Monitor"
                                        ),
                                        // Selector de sensibilidad
                                        React.createElement('div', { className: "flex gap-0.5" },
                                            [1, 2, 3].map(level =>
                                                React.createElement('button', {
                                                    key: level,
                                                    onClick: () => setConfluenceSensitivity(level),
                                                    className: `w-4 h-4 rounded text-[8px] font-bold transition-all ${confluenceSensitivity === level
                                                        ? 'bg-blue-500/40 text-blue-300 border border-blue-500/50'
                                                        : 'bg-neutral-800 text-neutral-500 hover:bg-neutral-700'
                                                        }`,
                                                    title: level === 1 ? 'Low (strict)' : level === 2 ? 'Medium' : 'High (sensitive)'
                                                }, level)
                                            )
                                        ),
                                        // BOT√ìN DE ALARMA
                                        React.createElement('button', {
                                            onClick: () => togglePanelAlert('confluence'),
                                            className: `ml-2 p-1.5 rounded-md transition-all ${panelAlerts.confluence.enabled
                                                ? 'bg-green-500/30 text-green-400 border border-green-500/50 animate-pulse'
                                                : 'bg-neutral-800 text-neutral-500 hover:bg-neutral-700'
                                                }`,
                                            title: panelAlerts.confluence.enabled
                                                ? `üîî Alerta ON (>${panelAlerts.confluence.threshold}%) - Click para desactivar`
                                                : 'üîï Alerta OFF - Click para activar'
                                        }, "üîî")
                                    ),
                                    React.createElement('p', { className: "text-[10px] text-neutral-500" },
                                        "Slot alignment, volatility and impulse detection for high probability signals"
                                    )
                                )
                            ),
                            // Score grande + Badge de estado
                            React.createElement('div', { className: "flex items-center gap-4" },
                                React.createElement('div', { className: "text-right" },
                                    React.createElement('div', { className: "flex items-baseline gap-2" },
                                        React.createElement('span', {
                                            className: `text-4xl font-bold font-mono ${confluenceAlert.active
                                                ? confluenceAlert.type === 'ALERT'
                                                    ? confluenceAlert.direction === 'BULLISH' ? 'text-blue-400' : 'text-red-400'
                                                    : 'text-amber-400'
                                                : 'text-neutral-500'
                                                }`
                                        }, `${(confluenceAlert.level || 0).toFixed(0)}%`),
                                        React.createElement('span', {
                                            className: `text-sm font-bold px-3 py-1 rounded-lg ${confluenceAlert.active
                                                ? confluenceAlert.type === 'ALERT'
                                                    ? confluenceAlert.direction === 'BULLISH'
                                                        ? 'bg-blue-500/30 text-blue-400 animate-pulse'
                                                        : 'bg-red-500/30 text-red-400 animate-pulse'
                                                    : 'bg-amber-500/30 text-amber-400'
                                                : 'bg-neutral-800 text-neutral-500'
                                                }`
                                        }, confluenceAlert.active
                                            ? confluenceAlert.type === 'ALERT'
                                                ? confluenceAlert.direction
                                                : 'CAUTION'
                                            : 'WAITING')
                                    ),
                                    React.createElement('div', { className: "text-[9px] text-neutral-500 mt-0.5" }, "CONFLUENCE LEVEL")
                                )
                            )
                        ),

                        // Barra de progreso principal
                        React.createElement('div', {
                            className: "h-2 bg-neutral-800 transition-all duration-500",
                        },
                            React.createElement('div', {
                                className: "h-full transition-all duration-500",
                                style: {
                                    width: `${confluenceAlert.level || 0}%`,
                                    background: confluenceAlert.active
                                        ? confluenceAlert.type === 'ALERT'
                                            ? confluenceAlert.direction === 'BULLISH'
                                                ? 'linear-gradient(90deg, #1d4ed8, #3b82f6, #60a5fa)'
                                                : 'linear-gradient(90deg, #b91c1c, #ef4444, #f87171)'
                                            : 'linear-gradient(90deg, #b45309, #f59e0b, #fbbf24)'
                                        : 'linear-gradient(90deg, #404040, #525252, #737373)'
                                }
                            })
                        ),

                        // Contenido principal - Grid responsive
                        React.createElement('div', { className: "p-4" },
                            // FILA 1: 3 Componentes con iluminacion
                            React.createElement('div', { className: "grid grid-cols-1 sm:grid-cols-3 gap-4 mb-4" },

                                // SLOTS Component
                                React.createElement('div', {
                                    className: `rounded-xl p-4 transition-all ${confluenceAlert.checks.slotsAligned
                                        ? 'bg-emerald-500/15 border border-emerald-500/30'
                                        : 'bg-neutral-800/50'
                                        }`
                                },
                                    React.createElement('div', { className: "flex items-center justify-between mb-3" },
                                        React.createElement('span', { className: "text-xs text-emerald-400 uppercase font-bold tracking-wide" }, "Slots"),
                                        React.createElement('span', {
                                            className: `text-2xl font-bold font-mono ${confluenceAlert.checks.slotsAligned ? 'text-emerald-400' : 'text-neutral-400'}`
                                        }, confluenceAlert.currentData
                                            ? `${Math.max(confluenceAlert.currentData.bullishSlots || 0, confluenceAlert.currentData.bearishSlots || 0)}`
                                            : '0')
                                    ),
                                    // Visual de slots
                                    React.createElement('div', { className: "flex items-center justify-center gap-3 mb-3" },
                                        React.createElement('div', { className: "text-center" },
                                            React.createElement('span', { className: "text-lg font-bold text-blue-400 font-mono" },
                                                `${confluenceAlert.currentData?.bullishSlots || 0}`
                                            ),
                                            React.createElement('span', { className: "text-xs text-blue-400 ml-1" }, "‚Üë")
                                        ),
                                        React.createElement('div', { className: "w-px h-6 bg-neutral-700" }),
                                        React.createElement('div', { className: "text-center" },
                                            React.createElement('span', { className: "text-lg font-bold text-red-400 font-mono" },
                                                `${confluenceAlert.currentData?.bearishSlots || 0}`
                                            ),
                                            React.createElement('span', { className: "text-xs text-red-400 ml-1" }, "‚Üì")
                                        )
                                    ),
                                    React.createElement('div', { className: "space-y-1 text-[10px]" },
                                        React.createElement('div', { className: "flex justify-between" },
                                            React.createElement('span', { className: "text-neutral-500" }, "Status"),
                                            React.createElement('span', {
                                                className: confluenceAlert.checks.slotsAligned ? 'text-emerald-400 font-bold' : 'text-neutral-400'
                                            }, confluenceAlert.checks.slotsAligned ? 'ALIGNED' : 'WAITING')
                                        ),
                                        React.createElement('p', { className: "text-neutral-500 mt-1 leading-relaxed" },
                                            "Metricas alineadas en direccion"
                                        )
                                    )
                                ),

                                // VOLATILITY Component
                                React.createElement('div', {
                                    className: `rounded-xl p-4 transition-all ${confluenceAlert.checks.volatilityHigh
                                        ? 'bg-purple-500/15 border border-purple-500/30'
                                        : 'bg-neutral-800/50'
                                        }`
                                },
                                    React.createElement('div', { className: "flex items-center justify-between mb-3" },
                                        React.createElement('span', { className: "text-xs text-purple-400 uppercase font-bold tracking-wide" }, "Volatility"),
                                        React.createElement('span', {
                                            className: `text-2xl font-bold font-mono ${confluenceAlert.checks.volatilityHigh ? 'text-purple-400' : 'text-neutral-400'}`
                                        }, `${confluenceAlert.currentData?.volatility?.toFixed(0) || 0}%`)
                                    ),
                                    // Progress bar
                                    React.createElement('div', { className: "h-2 bg-neutral-700 rounded-full overflow-hidden mb-3" },
                                        React.createElement('div', {
                                            className: "h-full rounded-full transition-all",
                                            style: {
                                                width: `${Math.min(100, confluenceAlert.currentData?.volatility || 0)}%`,
                                                background: confluenceAlert.checks.volatilityHigh ? 'linear-gradient(90deg, #9333ea, #a855f7)' : '#525252'
                                            }
                                        })
                                    ),
                                    React.createElement('div', { className: "space-y-1 text-[10px]" },
                                        React.createElement('div', { className: "flex justify-between" },
                                            React.createElement('span', { className: "text-neutral-500" }, "Threshold"),
                                            React.createElement('span', { className: "text-neutral-300 font-mono" }, ">50%")
                                        ),
                                        React.createElement('div', { className: "flex justify-between" },
                                            React.createElement('span', { className: "text-neutral-500" }, "Status"),
                                            React.createElement('span', {
                                                className: confluenceAlert.checks.volatilityHigh ? 'text-purple-400 font-bold' : 'text-neutral-400'
                                            }, confluenceAlert.checks.volatilityHigh ? 'ELEVATED' : 'NORMAL')
                                        ),
                                        React.createElement('p', { className: "text-neutral-500 mt-1 leading-relaxed" },
                                            "Nivel de volatilidad del mercado"
                                        )
                                    )
                                ),

                                // IMPULSE Component
                                React.createElement('div', {
                                    className: `rounded-xl p-4 transition-all ${confluenceAlert.checks.impulseConfirms
                                        ? confluenceAlert.currentData?.impulseDirection === 'BULLISH'
                                            ? 'bg-cyan-500/15 border border-cyan-500/30'
                                            : 'bg-orange-500/15 border border-orange-500/30'
                                        : 'bg-neutral-800/50'
                                        }`
                                },
                                    React.createElement('div', { className: "flex items-center justify-between mb-3" },
                                        React.createElement('span', { className: "text-xs text-cyan-400 uppercase font-bold tracking-wide" }, "Impulse"),
                                        React.createElement('span', {
                                            className: `text-xl font-bold ${confluenceAlert.checks.impulseConfirms
                                                ? confluenceAlert.currentData?.impulseDirection === 'BULLISH' ? 'text-cyan-400' : 'text-orange-400'
                                                : 'text-neutral-400'
                                                }`
                                        }, confluenceAlert.currentData?.impulseActive
                                            ? confluenceAlert.currentData.impulseDirection
                                            : 'NONE')
                                    ),
                                    // Direction indicator
                                    React.createElement('div', { className: "flex items-center justify-center gap-2 mb-3 py-2" },
                                        React.createElement('div', {
                                            className: `w-8 h-8 rounded-full flex items-center justify-center text-lg ${confluenceAlert.currentData?.impulseActive
                                                ? confluenceAlert.currentData?.impulseDirection === 'BULLISH'
                                                    ? 'bg-cyan-500/30 text-cyan-400'
                                                    : 'bg-orange-500/30 text-orange-400'
                                                : 'bg-neutral-700 text-neutral-500'
                                                }`
                                        }, confluenceAlert.currentData?.impulseDirection === 'BULLISH' ? '‚Üë' : confluenceAlert.currentData?.impulseDirection === 'BEARISH' ? '‚Üì' : '‚Äì')
                                    ),
                                    React.createElement('div', { className: "space-y-1 text-[10px]" },
                                        React.createElement('div', { className: "flex justify-between" },
                                            React.createElement('span', { className: "text-neutral-500" }, "Confirms"),
                                            React.createElement('span', {
                                                className: confluenceAlert.checks.impulseConfirms ? 'text-cyan-400 font-bold' : 'text-neutral-400'
                                            }, confluenceAlert.checks.impulseConfirms ? 'YES' : 'NO')
                                        ),
                                        React.createElement('p', { className: "text-neutral-500 mt-1 leading-relaxed" },
                                            "Movimiento impulsivo detectado"
                                        )
                                    )
                                )
                            ),

                            // FILA 2: Stats adicionales
                            React.createElement('div', { className: "grid grid-cols-2 sm:grid-cols-4 gap-3" },
                                // Checks Count
                                React.createElement('div', { className: "bg-neutral-800/30 rounded-lg p-3 text-center" },
                                    React.createElement('div', {
                                        className: `text-2xl font-bold font-mono ${(confluenceAlert.currentData?.checksCount || 0) >= 3 ? 'text-emerald-400'
                                            : (confluenceAlert.currentData?.checksCount || 0) >= 2 ? 'text-amber-400'
                                                : 'text-neutral-500'
                                            }`
                                    }, `${confluenceAlert.currentData?.checksCount || 0}/3`),
                                    React.createElement('div', { className: "text-[10px] text-neutral-500 uppercase" }, "Conditions")
                                ),
                                // Alert Type
                                React.createElement('div', { className: "bg-neutral-800/30 rounded-lg p-3 text-center" },
                                    React.createElement('div', {
                                        className: `text-lg font-bold ${confluenceAlert.type === 'ALERT'
                                            ? confluenceAlert.direction === 'BULLISH' ? 'text-blue-400' : 'text-red-400'
                                            : confluenceAlert.type === 'CAUTION' ? 'text-amber-400' : 'text-neutral-500'
                                            }`
                                    }, confluenceAlert.type || 'NONE'),
                                    React.createElement('div', { className: "text-[10px] text-neutral-500 uppercase" }, "Alert Type")
                                ),
                                // Direction
                                React.createElement('div', { className: "bg-neutral-800/30 rounded-lg p-3 text-center" },
                                    React.createElement('div', {
                                        className: `text-lg font-bold ${confluenceAlert.direction === 'BULLISH' ? 'text-blue-400'
                                            : confluenceAlert.direction === 'BEARISH' ? 'text-red-400'
                                                : 'text-neutral-500'
                                            }`
                                    }, confluenceAlert.direction || 'NEUTRAL'),
                                    React.createElement('div', { className: "text-[10px] text-neutral-500 uppercase" }, "Direction")
                                ),
                                // Status
                                React.createElement('div', { className: "bg-neutral-800/30 rounded-lg p-3 text-center" },
                                    React.createElement('div', {
                                        className: `text-lg font-bold ${confluenceAlert.active ? 'text-emerald-400' : 'text-neutral-500'}`
                                    }, confluenceAlert.active ? 'ACTIVE' : 'IDLE'),
                                    React.createElement('div', { className: "text-[10px] text-neutral-500 uppercase" }, "Status")
                                )
                            )
                        )
                    ),

                    // === TICK OPPORTUNITY PANEL - EXPANDED & RESPONSIVE ===
                    visibleModules.tickOpportunity && React.createElement('div', {
                        className: `relative overflow-hidden rounded-xl border-2 transition-all duration-300 mb-4 ${tickOpportunity.active
                            ? tickOpportunity.level === 'EXTREME'
                                ? 'bg-gradient-to-br from-emerald-900/40 via-emerald-800/30 to-emerald-900/40 border-emerald-500 shadow-lg shadow-emerald-500/20'
                                : tickOpportunity.level === 'HIGH'
                                    ? 'bg-gradient-to-br from-cyan-900/30 via-cyan-800/20 to-cyan-900/30 border-cyan-500 shadow-lg shadow-cyan-500/20'
                                    : 'bg-gradient-to-br from-purple-900/20 via-purple-800/15 to-purple-900/20 border-purple-500/50'
                            : 'bg-neutral-900/60 border-neutral-700'
                            }`
                    },
                        // Header
                        React.createElement('div', {
                            className: "px-4 py-3 border-b border-neutral-800/50 flex flex-col sm:flex-row items-start sm:items-center justify-between gap-2"
                        },
                            React.createElement('div', { className: "flex items-center gap-3" },
                                React.createElement('div', {
                                    className: `w-3 h-10 rounded-full transition-all ${tickOpportunity.level === 'EXTREME' ? 'bg-emerald-500 shadow-lg shadow-emerald-500/50 animate-pulse'
                                        : tickOpportunity.level === 'HIGH' ? 'bg-cyan-500 shadow-lg shadow-cyan-500/50'
                                            : tickOpportunity.level === 'MEDIUM' ? 'bg-purple-500'
                                                : 'bg-neutral-600'
                                        }`
                                }),
                                React.createElement('div', null,
                                    React.createElement('div', { className: "flex items-center gap-2 flex-wrap" },
                                        React.createElement('h3', { className: "text-sm font-bold text-neutral-300 uppercase tracking-wider" },
                                            "Tick Opportunity + IDD"
                                        ),
                                        // Selector de sensibilidad
                                        React.createElement('div', { className: "flex gap-0.5" },
                                            [1, 2, 3].map(level =>
                                                React.createElement('button', {
                                                    key: level,
                                                    onClick: () => setTickOpportunitySensitivity(level),
                                                    className: `w-4 h-4 rounded text-[8px] font-bold transition-all ${tickOpportunitySensitivity === level
                                                        ? 'bg-emerald-500/40 text-emerald-300 border border-emerald-500/50'
                                                        : 'bg-neutral-800 text-neutral-500 hover:bg-neutral-700'
                                                        }`,
                                                    title: level === 1 ? 'Low (strict)' : level === 2 ? 'Medium' : 'High (sensitive)'
                                                }, level)
                                            )
                                        ),
                                        // NUEVO: Selector de Algoritmo (IDD, INTENSITY, TOW)
                                        React.createElement('div', { className: "flex gap-0.5 ml-2" },
                                            ['dominance', 'intensity', 'tow'].map(algo =>
                                                React.createElement('button', {
                                                    key: algo,
                                                    onClick: () => setTickAlgorithm(algo),
                                                    className: `px-2 py-0.5 rounded text-[9px] font-bold transition-all ${tickAlgorithm === algo
                                                        ? algo === 'dominance' ? 'bg-emerald-500/40 text-emerald-300 border border-emerald-500/50'
                                                            : algo === 'intensity' ? 'bg-blue-500/40 text-blue-300 border border-blue-500/50'
                                                                : 'bg-purple-500/40 text-purple-300 border border-purple-500/50'
                                                        : 'bg-neutral-800 text-neutral-500 hover:bg-neutral-700'
                                                        }`,
                                                    title: algo === 'dominance' ? 'IDD: Divergencia + Dominancia' : algo === 'intensity' ? 'INTENSITY: Amplitud + Divergencia' : 'TOW: Dominancia + Momentum'
                                                }, algo === 'dominance' ? 'IDD' : algo.toUpperCase())
                                            )
                                        ),
                                        // NUEVO: Selector de M√©tricas
                                        React.createElement('div', { className: "relative ml-2" },
                                            React.createElement('button', {
                                                onClick: () => setShowTickMetricSelector(!showTickMetricSelector),
                                                className: `px-2 py-0.5 rounded text-[9px] font-bold transition-all ${tickMetricFilter ? 'bg-orange-500/40 text-orange-300 border border-orange-500/50' : 'bg-neutral-800 text-neutral-400 hover:bg-neutral-700'
                                                    }`,
                                                title: 'Seleccionar m√©tricas para an√°lisis causal'
                                            }, tickMetricFilter ? `${tickMetricFilter.length} METRICS` : 'ALL METRICS'),
                                            // Dropdown de m√©tricas
                                            showTickMetricSelector && React.createElement('div', {
                                                className: "absolute top-6 left-0 z-50 bg-neutral-900 border border-neutral-700 rounded-lg p-2 shadow-xl min-w-[200px] max-h-[300px] overflow-y-auto"
                                            },
                                                React.createElement('div', { className: "flex justify-between items-center mb-2 pb-2 border-b border-neutral-700" },
                                                    React.createElement('span', { className: "text-[10px] text-neutral-400 font-bold" }, "M√âTRICAS IDD"),
                                                    React.createElement('button', {
                                                        onClick: () => setTickMetricFilter(null),
                                                        className: "text-[9px] px-1.5 py-0.5 rounded bg-neutral-800 text-neutral-400 hover:bg-neutral-700"
                                                    }, "ALL")
                                                ),
                                                Object.entries(constants.SIGNAL_METRICS).map(([key, config]) =>
                                                    React.createElement('label', {
                                                        key: key,
                                                        className: "flex items-center gap-2 py-1 px-1 hover:bg-neutral-800 rounded cursor-pointer"
                                                    },
                                                        React.createElement('input', {
                                                            type: 'checkbox',
                                                            checked: tickMetricFilter ? tickMetricFilter.includes(key) : true,
                                                            onChange: (e) => {
                                                                if (e.target.checked) {
                                                                    if (!tickMetricFilter) {
                                                                        setTickMetricFilter([key]);
                                                                    } else {
                                                                        setTickMetricFilter([...tickMetricFilter, key]);
                                                                    }
                                                                } else {
                                                                    const newFilter = (tickMetricFilter || Object.keys(constants.SIGNAL_METRICS)).filter(k => k !== key);
                                                                    setTickMetricFilter(newFilter.length > 0 ? newFilter : null);
                                                                }
                                                            },
                                                            className: "w-3 h-3 accent-orange-500"
                                                        }),
                                                        React.createElement('span', { className: "text-[10px] text-neutral-300" }, config.shortLabel),
                                                        React.createElement('span', { className: "text-[9px] text-neutral-500 ml-auto" }, config.label)
                                                    )
                                                )
                                            )
                                        ),
                                        // BOT√ìN DE ALARMA
                                        React.createElement('button', {
                                            onClick: () => togglePanelAlert('tickOpportunity'),
                                            className: `ml-2 p-1.5 rounded-md transition-all ${panelAlerts.tickOpportunity.enabled
                                                ? 'bg-green-500/30 text-green-400 border border-green-500/50 animate-pulse'
                                                : 'bg-neutral-800 text-neutral-500 hover:bg-neutral-700'
                                                }`,
                                            title: panelAlerts.tickOpportunity.enabled
                                                ? `üîî Alerta ON (>${panelAlerts.tickOpportunity.threshold}%) - Click para desactivar`
                                                : 'üîï Alerta OFF - Click para activar'
                                        }, "üîî")
                                    ),
                                    React.createElement('p', { className: "text-[10px] text-neutral-500" },
                                        tickAlgorithm === 'dominance' ? "IDD: Divergencia direccional Call vs Put + Expansi√≥n de ticks"
                                            : tickAlgorithm === 'intensity' ? "INTENSITY: Amplitud del spread + Divergencia m√©trica"
                                                : "TOW: Tug-of-War dominancia + Momentum de precio"
                                    )
                                )
                            ),
                            // Score grande
                            React.createElement('div', { className: "flex items-center gap-4" },
                                React.createElement('div', { className: "text-right" },
                                    React.createElement('div', { className: "flex items-baseline gap-2" },
                                        React.createElement('span', {
                                            className: `text-4xl font-bold font-mono ${tickOpportunity.level === 'EXTREME' ? 'text-emerald-400'
                                                : tickOpportunity.level === 'HIGH' ? 'text-cyan-400'
                                                    : tickOpportunity.level === 'MEDIUM' ? 'text-purple-400'
                                                        : 'text-neutral-500'
                                                }`
                                        }, `${tickOpportunity.score}%`),
                                        React.createElement('span', {
                                            className: `text-sm font-bold px-3 py-1 rounded-lg ${tickOpportunity.level === 'EXTREME' ? 'bg-emerald-500/30 text-emerald-400 animate-pulse'
                                                : tickOpportunity.level === 'HIGH' ? 'bg-cyan-500/30 text-cyan-400'
                                                    : tickOpportunity.level === 'MEDIUM' ? 'bg-purple-500/30 text-purple-400'
                                                        : 'bg-neutral-800 text-neutral-500'
                                                }`
                                        }, tickOpportunity.level)
                                    ),
                                    React.createElement('div', { className: "text-[9px] text-neutral-500 mt-0.5" }, "OPPORTUNITY SCORE")
                                )
                            )
                        ),

                        // Barra de progreso principal
                        React.createElement('div', {
                            className: "h-2 bg-neutral-800 transition-all duration-500",
                        },
                            React.createElement('div', {
                                className: "h-full transition-all duration-500",
                                style: {
                                    width: `${tickOpportunity.score}%`,
                                    background: tickOpportunity.level === 'EXTREME'
                                        ? 'linear-gradient(90deg, #059669, #10b981, #34d399)'
                                        : tickOpportunity.level === 'HIGH'
                                            ? 'linear-gradient(90deg, #0891b2, #06b6d4, #22d3ee)'
                                            : tickOpportunity.level === 'MEDIUM'
                                                ? 'linear-gradient(90deg, #7c3aed, #a855f7, #c084fc)'
                                                : 'linear-gradient(90deg, #404040, #525252, #737373)'
                                }
                            })
                        ),

                        // Contenido principal - Grid responsive
                        React.createElement('div', { className: "p-4" },
                            // FILA 1: 4 Componentes con detalles expandidos
                            React.createElement('div', { className: "grid grid-cols-2 lg:grid-cols-4 gap-4 mb-4" },

                                // RANGE Component
                                React.createElement('div', {
                                    className: `rounded-xl p-4 transition-all ${tickOpportunity.components.range > 60
                                        ? 'bg-purple-500/15 border border-purple-500/30'
                                        : 'bg-neutral-800/50'
                                        }`
                                },
                                    React.createElement('div', { className: "flex items-center justify-between mb-3" },
                                        React.createElement('span', { className: "text-xs text-purple-400 uppercase font-bold tracking-wide" }, "Range"),
                                        React.createElement('span', {
                                            className: `text-2xl font-bold font-mono ${tickOpportunity.components.range > 60 ? 'text-purple-400' : 'text-neutral-400'}`
                                        }, `${tickOpportunity.components.range}`)
                                    ),
                                    // Progress bar
                                    React.createElement('div', { className: "h-2 bg-neutral-700 rounded-full overflow-hidden mb-3" },
                                        React.createElement('div', {
                                            className: "h-full rounded-full transition-all",
                                            style: {
                                                width: `${tickOpportunity.components.range}%`,
                                                background: tickOpportunity.components.range > 60 ? 'linear-gradient(90deg, #9333ea, #a855f7)' : '#525252'
                                            }
                                        })
                                    ),
                                    React.createElement('div', { className: "space-y-1 text-[10px]" },
                                        React.createElement('div', { className: "flex justify-between" },
                                            React.createElement('span', { className: "text-neutral-500" }, "Contribution"),
                                            React.createElement('span', { className: "text-neutral-300 font-mono" }, "30%")
                                        ),
                                        React.createElement('div', { className: "flex justify-between" },
                                            React.createElement('span', { className: "text-neutral-500" }, "Status"),
                                            React.createElement('span', {
                                                className: tickOpportunity.components.range > 60 ? 'text-purple-400 font-bold' : 'text-neutral-400'
                                            }, tickOpportunity.components.range > 60 ? 'WIDE' : tickOpportunity.components.range > 30 ? 'NORMAL' : 'TIGHT')
                                        ),
                                        React.createElement('p', { className: "text-neutral-500 mt-1 leading-relaxed" },
                                            "Amplitud del rango de precio actual vs historico"
                                        )
                                    )
                                ),

                                // MOMENTUM Component
                                React.createElement('div', {
                                    className: `rounded-xl p-4 transition-all ${tickOpportunity.components.momentum > 60
                                        ? 'bg-blue-500/15 border border-blue-500/30'
                                        : 'bg-neutral-800/50'
                                        }`
                                },
                                    React.createElement('div', { className: "flex items-center justify-between mb-3" },
                                        React.createElement('span', { className: "text-xs text-blue-400 uppercase font-bold tracking-wide" }, "Momentum"),
                                        React.createElement('span', {
                                            className: `text-2xl font-bold font-mono ${tickOpportunity.components.momentum > 60 ? 'text-blue-400' : 'text-neutral-400'}`
                                        }, `${tickOpportunity.components.momentum}`)
                                    ),
                                    React.createElement('div', { className: "h-2 bg-neutral-700 rounded-full overflow-hidden mb-3" },
                                        React.createElement('div', {
                                            className: "h-full rounded-full transition-all",
                                            style: {
                                                width: `${tickOpportunity.components.momentum}%`,
                                                background: tickOpportunity.components.momentum > 60 ? 'linear-gradient(90deg, #2563eb, #3b82f6)' : '#525252'
                                            }
                                        })
                                    ),
                                    React.createElement('div', { className: "space-y-1 text-[10px]" },
                                        React.createElement('div', { className: "flex justify-between" },
                                            React.createElement('span', { className: "text-neutral-500" }, "Contribution"),
                                            React.createElement('span', { className: "text-neutral-300 font-mono" }, "30%")
                                        ),
                                        React.createElement('div', { className: "flex justify-between" },
                                            React.createElement('span', { className: "text-neutral-500" }, "Direction"),
                                            React.createElement('span', {
                                                className: `font-bold ${tickOpportunity.direction === 'BULLISH' ? 'text-blue-400' : tickOpportunity.direction === 'BEARISH' ? 'text-red-400' : 'text-neutral-400'}`
                                            }, tickOpportunity.direction)
                                        ),
                                        React.createElement('p', { className: "text-neutral-500 mt-1 leading-relaxed" },
                                            "Velocidad y direccion del cambio de precio"
                                        )
                                    )
                                ),

                                // PARTICIPATION Component
                                React.createElement('div', {
                                    className: `rounded-xl p-4 transition-all ${tickOpportunity.components.participation > 60
                                        ? 'bg-emerald-500/15 border border-emerald-500/30'
                                        : 'bg-neutral-800/50'
                                        }`
                                },
                                    React.createElement('div', { className: "flex items-center justify-between mb-3" },
                                        React.createElement('span', { className: "text-xs text-emerald-400 uppercase font-bold tracking-wide" }, "Participation"),
                                        React.createElement('span', {
                                            className: `text-2xl font-bold font-mono ${tickOpportunity.components.participation > 60 ? 'text-emerald-400' : 'text-neutral-400'}`
                                        }, `${tickOpportunity.components.participation}`)
                                    ),
                                    React.createElement('div', { className: "h-2 bg-neutral-700 rounded-full overflow-hidden mb-3" },
                                        React.createElement('div', {
                                            className: "h-full rounded-full transition-all",
                                            style: {
                                                width: `${tickOpportunity.components.participation}%`,
                                                background: tickOpportunity.components.participation > 60 ? 'linear-gradient(90deg, #059669, #10b981)' : '#525252'
                                            }
                                        })
                                    ),
                                    React.createElement('div', { className: "space-y-1 text-[10px]" },
                                        React.createElement('div', { className: "flex justify-between" },
                                            React.createElement('span', { className: "text-neutral-500" }, "Contribution"),
                                            React.createElement('span', { className: "text-neutral-300 font-mono" }, "25%")
                                        ),
                                        React.createElement('div', { className: "flex justify-between" },
                                            React.createElement('span', { className: "text-neutral-500" }, "Metrics Active"),
                                            React.createElement('span', { className: "text-emerald-400 font-mono" },
                                                `${sweepAnalysis.participationDetails?.activeMetrics || 0}/5`
                                            )
                                        ),
                                        React.createElement('p', { className: "text-neutral-500 mt-1 leading-relaxed" },
                                            "Actividad de flujos: money, delta, premium, GEX"
                                        )
                                    )
                                ),

                                // ACCELERATION Component
                                React.createElement('div', {
                                    className: `rounded-xl p-4 transition-all ${tickOpportunity.components.acceleration > 60
                                        ? 'bg-amber-500/15 border border-amber-500/30'
                                        : 'bg-neutral-800/50'
                                        }`
                                },
                                    React.createElement('div', { className: "flex items-center justify-between mb-3" },
                                        React.createElement('span', { className: "text-xs text-amber-400 uppercase font-bold tracking-wide" }, "Acceleration"),
                                        React.createElement('span', {
                                            className: `text-2xl font-bold font-mono ${tickOpportunity.components.acceleration > 60 ? 'text-amber-400' : 'text-neutral-400'}`
                                        }, `${tickOpportunity.components.acceleration}`)
                                    ),
                                    React.createElement('div', { className: "h-2 bg-neutral-700 rounded-full overflow-hidden mb-3" },
                                        React.createElement('div', {
                                            className: "h-full rounded-full transition-all",
                                            style: {
                                                width: `${tickOpportunity.components.acceleration}%`,
                                                background: tickOpportunity.components.acceleration > 60 ? 'linear-gradient(90deg, #d97706, #f59e0b)' : '#525252'
                                            }
                                        })
                                    ),
                                    React.createElement('div', { className: "space-y-1 text-[10px]" },
                                        React.createElement('div', { className: "flex justify-between" },
                                            React.createElement('span', { className: "text-neutral-500" }, "Contribution"),
                                            React.createElement('span', { className: "text-neutral-300 font-mono" }, "15%")
                                        ),
                                        React.createElement('div', { className: "flex justify-between" },
                                            React.createElement('span', { className: "text-neutral-500" }, "Phase"),
                                            React.createElement('span', {
                                                className: `font-bold ${sweepAnalysis.accelerationDetails?.phase === 'IMPULSE' ? 'text-emerald-400' : sweepAnalysis.accelerationDetails?.phase === 'BUILDING' ? 'text-cyan-400' : 'text-neutral-400'}`
                                            }, sweepAnalysis.accelerationDetails?.phase || 'NEUTRAL')
                                        ),
                                        React.createElement('p', { className: "text-neutral-500 mt-1 leading-relaxed" },
                                            "Velocidad reciente vs anterior, detecta impulsos"
                                        )
                                    )
                                )
                            ),

                            // FILA 2: Stats adicionales - Grid responsive
                            React.createElement('div', { className: "grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-6 gap-3 mb-4" },
                                // Price
                                React.createElement('div', { className: "bg-neutral-800/40 rounded-lg p-3 text-center" },
                                    React.createElement('div', {
                                        className: "text-xl font-bold font-mono",
                                        style: { color: (volatilityAnalysis.price?.changePct || 0) >= 0 ? '#3b82f6' : '#ef4444' }
                                    }, `${(volatilityAnalysis.price?.current || 0).toFixed(2)}`),
                                    React.createElement('div', {
                                        className: "text-[10px] font-mono",
                                        style: { color: (volatilityAnalysis.price?.changePct || 0) >= 0 ? '#3b82f6' : '#ef4444' }
                                    }, `${(volatilityAnalysis.price?.changePct || 0) >= 0 ? '+' : ''}${(volatilityAnalysis.price?.changePct || 0).toFixed(2)}%`),
                                    React.createElement('div', { className: "text-[9px] text-neutral-500 uppercase mt-1" }, "Price")
                                ),
                                // Ticks
                                React.createElement('div', { className: "bg-neutral-800/40 rounded-lg p-3 text-center" },
                                    React.createElement('div', {
                                        className: "text-xl font-bold font-mono",
                                        style: { color: tickOpportunity.recentTicks > 20 ? '#22c55e' : '#737373' }
                                    }, tickOpportunity.recentTicks),
                                    React.createElement('div', { className: "text-[10px] text-neutral-400" }, "recent"),
                                    React.createElement('div', { className: "text-[9px] text-neutral-500 uppercase mt-1" }, "Ticks")
                                ),
                                // Expected
                                React.createElement('div', { className: "bg-neutral-800/40 rounded-lg p-3 text-center" },
                                    React.createElement('div', {
                                        className: "text-xl font-bold font-mono",
                                        style: { color: tickOpportunity.ticksExpected > 15 ? '#06b6d4' : '#737373' }
                                    }, `~${tickOpportunity.ticksExpected}`),
                                    React.createElement('div', { className: "text-[10px] text-neutral-400" }, "projected"),
                                    React.createElement('div', { className: "text-[9px] text-neutral-500 uppercase mt-1" }, "Expected")
                                ),
                                // Volatility State
                                React.createElement('div', { className: "bg-neutral-800/40 rounded-lg p-3 text-center" },
                                    React.createElement('div', {
                                        className: `text-sm font-bold px-2 py-1 rounded ${volatilityAnalysis.state === 'EXPANSION' ? 'bg-purple-500/20 text-purple-400'
                                            : volatilityAnalysis.state === 'COMPRESSION' ? 'bg-amber-500/20 text-amber-400'
                                                : 'bg-neutral-700 text-neutral-500'
                                            }`
                                    }, volatilityAnalysis.state === 'NORMAL' ? 'STABLE' : volatilityAnalysis.state),
                                    React.createElement('div', { className: "text-[9px] text-neutral-500 uppercase mt-2" }, "Volatility")
                                ),
                                // Direction
                                React.createElement('div', { className: "bg-neutral-800/40 rounded-lg p-3 text-center" },
                                    React.createElement('div', {
                                        className: `text-sm font-bold px-2 py-1 rounded ${tickOpportunity.direction === 'BULLISH' ? 'bg-blue-500/20 text-blue-400'
                                            : tickOpportunity.direction === 'BEARISH' ? 'bg-red-500/20 text-red-400'
                                                : 'bg-neutral-700 text-neutral-500'
                                            }`
                                    }, tickOpportunity.direction),
                                    React.createElement('div', { className: "text-[9px] text-neutral-500 uppercase mt-2" }, "Direction")
                                ),
                                // Confidence
                                React.createElement('div', { className: "bg-neutral-800/40 rounded-lg p-3 text-center" },
                                    React.createElement('div', {
                                        className: "text-xl font-bold font-mono",
                                        style: { color: tickOpportunity.confidence >= 75 ? '#22c55e' : tickOpportunity.confidence >= 50 ? '#f59e0b' : '#737373' }
                                    }, `${tickOpportunity.confidence}%`),
                                    React.createElement('div', { className: "text-[10px] text-neutral-400" }, "signal quality"),
                                    React.createElement('div', { className: "text-[9px] text-neutral-500 uppercase mt-1" }, "Confidence")
                                )
                            ),

                            // FILA 3: IDD Analysis Panel
                            tickOpportunity.idd && React.createElement('div', {
                                className: `rounded-xl p-4 mb-4 ${tickOpportunity.idd.dominantSide === 'CALLS' ? 'bg-blue-500/10 border border-blue-500/30'
                                    : tickOpportunity.idd.dominantSide === 'PUTS' ? 'bg-red-500/10 border border-red-500/30'
                                        : 'bg-neutral-800/50 border border-neutral-700'
                                    }`
                            },
                                React.createElement('div', { className: "flex items-center justify-between mb-3" },
                                    React.createElement('div', { className: "flex items-center gap-2" },
                                        React.createElement('span', { className: "text-xs font-bold uppercase tracking-wider text-emerald-400" },
                                            tickAlgorithm === 'dominance' ? "‚ö° IDD ANALYSIS" : tickAlgorithm === 'intensity' ? "üìä INTENSITY" : "üéØ TOW"
                                        ),
                                        React.createElement('span', {
                                            className: `px-2 py-0.5 rounded text-[10px] font-bold ${tickOpportunity.idd.dominantSide === 'CALLS' ? 'bg-blue-500/30 text-blue-300'
                                                : tickOpportunity.idd.dominantSide === 'PUTS' ? 'bg-red-500/30 text-red-300'
                                                    : 'bg-neutral-700 text-neutral-400'
                                                }`
                                        }, tickOpportunity.idd.dominantSide)
                                    ),
                                    React.createElement('div', { className: "text-[10px] text-neutral-400" },
                                        `${tickOpportunity.idd.divergentMetrics || 0} divergencias detectadas`
                                    )
                                ),

                                // BARRA DE DOMINANCIA CALL vs PUT - Estilo Liquidity Zones
                                React.createElement('div', { className: "mb-3" },
                                    // Etiquetas PUTS | CALLS
                                    React.createElement('div', { className: "flex items-center justify-between mb-2" },
                                        React.createElement('div', { className: "flex items-center gap-2" },
                                            React.createElement('div', {
                                                className: `w-3 h-3 rounded-full ${tickOpportunity.idd.dominantSide === 'PUTS' ? 'bg-red-500 animate-pulse' : 'bg-red-500/40'}`
                                            }),
                                            React.createElement('span', { className: "text-sm font-bold text-red-400" }, "PUTS"),
                                            React.createElement('span', { className: "text-[10px] text-neutral-500 font-mono" },
                                                `${(tickOpportunity.idd.trendingDown || []).length} m√©tricas`
                                            )
                                        ),
                                        React.createElement('div', { className: "flex items-center gap-2" },
                                            React.createElement('span', { className: "text-[10px] text-neutral-500 font-mono" },
                                                `${(tickOpportunity.idd.trendingUp || []).length} m√©tricas`
                                            ),
                                            React.createElement('span', { className: "text-sm font-bold text-blue-400" }, "CALLS"),
                                            React.createElement('div', {
                                                className: `w-3 h-3 rounded-full ${tickOpportunity.idd.dominantSide === 'CALLS' ? 'bg-blue-500 animate-pulse' : 'bg-blue-500/40'}`
                                            })
                                        )
                                    ),
                                    // BARRA PRINCIPAL CON C√çRCULO DESLIZANTE
                                    React.createElement('div', { className: "relative h-10 bg-neutral-700/50 rounded-xl overflow-hidden" },
                                        // Gradiente de fondo PUTS (izq) a CALLS (der)
                                        React.createElement('div', {
                                            className: "absolute inset-0 bg-gradient-to-r from-red-500/30 via-neutral-600/20 to-blue-500/30"
                                        }),
                                        // Zona PUTS (izquierda)
                                        React.createElement('div', {
                                            className: "absolute left-0 top-0 h-full bg-gradient-to-r from-red-500/40 to-transparent",
                                            style: { width: '20%' }
                                        }),
                                        // Zona CALLS (derecha)
                                        React.createElement('div', {
                                            className: "absolute right-0 top-0 h-full bg-gradient-to-l from-blue-500/40 to-transparent",
                                            style: { width: '20%' }
                                        }),
                                        // L√≠nea central
                                        React.createElement('div', {
                                            className: "absolute left-1/2 top-0 w-0.5 h-full bg-neutral-500/50"
                                        }),
                                        // C√çRCULO DESLIZANTE - Se mueve seg√∫n dominancia (con sensibilidad mejorada)
                                        React.createElement('div', {
                                            className: `absolute top-1/2 w-7 h-7 rounded-full shadow-xl border-4 transition-all duration-500 z-10 ${tickOpportunity.idd.dominantSide === 'CALLS'
                                                ? 'bg-blue-500 border-blue-300 shadow-blue-500/50'
                                                : tickOpportunity.idd.dominantSide === 'PUTS'
                                                    ? 'bg-red-500 border-red-300 shadow-red-500/50'
                                                    : 'bg-white border-neutral-400'
                                                }`,
                                            style: {
                                                // Calcular posici√≥n con normalizaci√≥n suavizada para mayor sensibilidad
                                                left: `${(() => {
                                                    const callStr = tickOpportunity.idd.callStrength || 0;
                                                    const putStr = tickOpportunity.idd.putStrength || 0;
                                                    const total = callStr + putStr;
                                                    if (total === 0) return 50;

                                                    // Ratio b√°sico
                                                    let callPct = (callStr / total) * 100;

                                                    // Normalizaci√≥n suavizada: mapear [0-100] a rango m√°s visible
                                                    // Aplicar funci√≥n sigmoide para suavizar extremos
                                                    const center = 50;
                                                    const distance = callPct - center;
                                                    // Amplificar diferencias peque√±as cerca del centro
                                                    const amplified = center + (distance * 1.5);

                                                    // Limitar al rango [10, 90] para mejor visibilidad
                                                    return Math.max(10, Math.min(90, amplified));
                                                })()}%`,
                                                transform: 'translate(-50%, -50%)'
                                            }
                                        }),
                                        // Etiquetas en la barra
                                        React.createElement('div', { className: "absolute inset-0 flex items-center justify-between px-4" },
                                            React.createElement('span', { className: "text-[10px] font-bold text-red-400 bg-neutral-900/70 px-2 py-1 rounded" },
                                                `${tickOpportunity.idd.putStrength || 0}`
                                            ),
                                            React.createElement('span', { className: "text-[10px] text-neutral-400" }, "50%"),
                                            React.createElement('span', { className: "text-[10px] font-bold text-blue-400 bg-neutral-900/70 px-2 py-1 rounded" },
                                                `${tickOpportunity.idd.callStrength || 0}`
                                            )
                                        )
                                    ),
                                    // Spread ratio
                                    React.createElement('div', { className: "flex items-center justify-center gap-2 mt-2" },
                                        React.createElement('span', { className: "text-[10px] text-neutral-500" }, "Spread Ratio:"),
                                        React.createElement('span', {
                                            className: `text-sm font-mono font-bold ${parseFloat(tickOpportunity.idd.spreadRatio || 0) > 0.3 ? 'text-emerald-400' : 'text-neutral-400'
                                                }`
                                        }, tickOpportunity.idd.spreadRatio || '0.00')
                                    )
                                ),

                                // M√©tricas trending - Grid compacto
                                React.createElement('div', { className: "grid grid-cols-2 gap-3" },
                                    // Trending DOWN (PUTS favored)
                                    React.createElement('div', { className: "bg-red-500/10 rounded-lg p-2" },
                                        React.createElement('div', { className: "text-[9px] text-red-300 font-bold uppercase mb-1" }, "M√©tricas PUTS"),
                                        React.createElement('div', { className: "flex flex-wrap gap-1" },
                                            (tickOpportunity.idd.trendingDown || []).length > 0
                                                ? tickOpportunity.idd.trendingDown.map(m =>
                                                    React.createElement('span', {
                                                        key: m.metric,
                                                        className: "px-1.5 py-0.5 rounded bg-red-500/20 text-red-300 text-[9px] font-mono"
                                                    }, m.metric)
                                                )
                                                : React.createElement('span', { className: "text-[9px] text-neutral-500" }, "‚Äî")
                                        )
                                    ),
                                    // Trending UP (CALLS favored)
                                    React.createElement('div', { className: "bg-blue-500/10 rounded-lg p-2" },
                                        React.createElement('div', { className: "text-[9px] text-blue-300 font-bold uppercase mb-1" }, "M√©tricas CALLS"),
                                        React.createElement('div', { className: "flex flex-wrap gap-1" },
                                            (tickOpportunity.idd.trendingUp || []).length > 0
                                                ? tickOpportunity.idd.trendingUp.map(m =>
                                                    React.createElement('span', {
                                                        key: m.metric,
                                                        className: "px-1.5 py-0.5 rounded bg-blue-500/20 text-blue-300 text-[9px] font-mono"
                                                    }, m.metric)
                                                )
                                                : React.createElement('span', { className: "text-[9px] text-neutral-500" }, "‚Äî")
                                        )
                                    )
                                ),
                                // Breakdown de m√©tricas si existe
                                tickOpportunity.idd.metricBreakdown && tickOpportunity.idd.metricBreakdown.length > 0 &&
                                React.createElement('div', { className: "mt-3 pt-3 border-t border-neutral-700/50" },
                                    React.createElement('div', { className: "text-[9px] text-neutral-500 uppercase mb-2" }, "Detalle por M√©trica (Reciente)"),
                                    React.createElement('div', { className: "grid grid-cols-4 sm:grid-cols-6 lg:grid-cols-8 gap-1" },
                                        tickOpportunity.idd.metricBreakdown.map(data =>
                                            React.createElement('div', {
                                                key: data.metric,
                                                className: `rounded p-1.5 text-center ${data.callRatio > 55 ? 'bg-blue-500/15' : data.putRatio > 55 ? 'bg-red-500/15' : 'bg-neutral-800/50'
                                                    }`
                                            },
                                                React.createElement('div', {
                                                    className: `text-[10px] font-mono font-bold ${data.callRatio > 55 ? 'text-blue-400' : data.putRatio > 55 ? 'text-red-400' : 'text-neutral-500'
                                                        }`
                                                }, data.callRatio > 55 ? 'C:' + Math.round(data.callRatio) + '%' : data.putRatio > 55 ? 'P:' + Math.round(data.putRatio) + '%' : '~50%'),
                                                React.createElement('div', { className: "text-[8px] text-neutral-500 truncate" }, data.metric)
                                            )
                                        )
                                    )
                                ),

                                // ========== AN√ÅLISIS DE SESI√ìN COMPLETA (NUEVO) ==========
                                tickOpportunity.idd.session && React.createElement('div', { className: "mt-4 pt-4 border-t-2 border-amber-500/30" },
                                    // Header de sesi√≥n
                                    React.createElement('div', { className: "flex items-center justify-between mb-3" },
                                        React.createElement('div', { className: "flex items-center gap-2" },
                                            React.createElement('span', { className: "text-xs font-bold uppercase tracking-wider text-amber-400" },
                                                "üìä AN√ÅLISIS DE SESI√ìN COMPLETA"
                                            ),
                                            React.createElement('span', {
                                                className: `px-2 py-0.5 rounded text-[10px] font-bold ${tickOpportunity.idd.session.dominantSide === 'CALLS' ? 'bg-blue-500/30 text-blue-300'
                                                    : tickOpportunity.idd.session.dominantSide === 'PUTS' ? 'bg-red-500/30 text-red-300'
                                                        : 'bg-neutral-700 text-neutral-400'
                                                    }`
                                            }, tickOpportunity.idd.session.dominantSide)
                                        ),
                                        React.createElement('div', { className: "text-[10px] text-neutral-400" },
                                            `${tickOpportunity.idd.session.totalRows} puntos de datos`
                                        )
                                    ),

                                    // Comparaci√≥n con reciente
                                    tickOpportunity.idd.comparison && React.createElement('div', {
                                        className: `mb-3 p-2 rounded-lg border ${tickOpportunity.idd.comparison.alignment === 'ALIGNED'
                                            ? 'bg-green-500/10 border-green-500/30'
                                            : 'bg-orange-500/10 border-orange-500/30'
                                            }`
                                    },
                                        React.createElement('div', { className: "flex items-center gap-2" },
                                            React.createElement('span', {
                                                className: `text-lg ${tickOpportunity.idd.comparison.alignment === 'ALIGNED' ? 'text-green-400' : 'text-orange-400'}`
                                            }, tickOpportunity.idd.comparison.alignment === 'ALIGNED' ? '‚úì' : '‚ö†Ô∏è'),
                                            React.createElement('div', { className: "flex-1" },
                                                React.createElement('div', {
                                                    className: `text-[10px] font-bold ${tickOpportunity.idd.comparison.alignment === 'ALIGNED' ? 'text-green-300' : 'text-orange-300'
                                                        }`
                                                }, tickOpportunity.idd.comparison.message),
                                                React.createElement('div', { className: "text-[9px] text-neutral-500 mt-0.5" },
                                                    `Intensidad del cambio: ${tickOpportunity.idd.comparison.shiftIntensity}%`
                                                )
                                            )
                                        )
                                    ),

                                    // Barra de sesi√≥n completa
                                    React.createElement('div', { className: "mb-3" },
                                        React.createElement('div', { className: "text-[9px] text-neutral-400 uppercase mb-2" }, "Dominancia en toda la sesi√≥n"),
                                        React.createElement('div', { className: "relative h-8 bg-neutral-700/50 rounded-lg overflow-hidden" },
                                            // Gradiente sesi√≥n
                                            React.createElement('div', {
                                                className: "absolute inset-0 bg-gradient-to-r from-red-500/20 via-neutral-600/10 to-blue-500/20"
                                            }),
                                            // C√çRCULO DESLIZANTE DE SESI√ìN (con sensibilidad mejorada)
                                            React.createElement('div', {
                                                className: `absolute top-1/2 w-6 h-6 rounded-full shadow-lg border-3 transition-all duration-500 z-10 ${tickOpportunity.idd.session.dominantSide === 'CALLS'
                                                    ? 'bg-blue-400 border-blue-200 shadow-blue-400/50'
                                                    : tickOpportunity.idd.session.dominantSide === 'PUTS'
                                                        ? 'bg-red-400 border-red-200 shadow-red-400/50'
                                                        : 'bg-amber-400 border-amber-200'
                                                    }`,
                                                style: {
                                                    left: `${(() => {
                                                        const callStr = tickOpportunity.idd.session.callStrength || 0;
                                                        const putStr = tickOpportunity.idd.session.putStrength || 0;
                                                        const total = callStr + putStr;
                                                        if (total === 0) return 50;

                                                        // Ratio b√°sico
                                                        let callPct = (callStr / total) * 100;

                                                        // Normalizaci√≥n suavizada para sesi√≥n
                                                        const center = 50;
                                                        const distance = callPct - center;
                                                        const amplified = center + (distance * 1.5);

                                                        return Math.max(10, Math.min(90, amplified));
                                                    })()}%`,
                                                    transform: 'translate(-50%, -50%)'
                                                }
                                            }),
                                            // Labels
                                            React.createElement('div', { className: "absolute inset-0 flex items-center justify-between px-3" },
                                                React.createElement('span', { className: "text-[9px] font-bold text-red-300" },
                                                    `P: ${tickOpportunity.idd.session.putStrength}`
                                                ),
                                                React.createElement('span', { className: "text-[9px] font-bold text-blue-300" },
                                                    `C: ${tickOpportunity.idd.session.callStrength}`
                                                )
                                            )
                                        )
                                    ),

                                    // M√©tricas de sesi√≥n
                                    React.createElement('div', { className: "grid grid-cols-2 gap-3 mb-3" },
                                        // PUTS Sesi√≥n
                                        React.createElement('div', { className: "bg-red-500/10 rounded-lg p-2" },
                                            React.createElement('div', { className: "text-[9px] text-red-300 font-bold uppercase mb-1" },
                                                `M√©tricas PUTS (${(tickOpportunity.idd.session.trendingDown || []).length})`
                                            ),
                                            React.createElement('div', { className: "flex flex-wrap gap-1" },
                                                (tickOpportunity.idd.session.trendingDown || []).length > 0
                                                    ? tickOpportunity.idd.session.trendingDown.map(m =>
                                                        React.createElement('span', {
                                                            key: m.metric,
                                                            className: "px-1.5 py-0.5 rounded bg-red-500/20 text-red-300 text-[9px] font-mono"
                                                        }, m.metric)
                                                    )
                                                    : React.createElement('span', { className: "text-[9px] text-neutral-500" }, "‚Äî")
                                            )
                                        ),
                                        // CALLS Sesi√≥n
                                        React.createElement('div', { className: "bg-blue-500/10 rounded-lg p-2" },
                                            React.createElement('div', { className: "text-[9px] text-blue-300 font-bold uppercase mb-1" },
                                                `M√©tricas CALLS (${(tickOpportunity.idd.session.trendingUp || []).length})`
                                            ),
                                            React.createElement('div', { className: "flex flex-wrap gap-1" },
                                                (tickOpportunity.idd.session.trendingUp || []).length > 0
                                                    ? tickOpportunity.idd.session.trendingUp.map(m =>
                                                        React.createElement('span', {
                                                            key: m.metric,
                                                            className: "px-1.5 py-0.5 rounded bg-blue-500/20 text-blue-300 text-[9px] font-mono"
                                                        }, m.metric)
                                                    )
                                                    : React.createElement('span', { className: "text-[9px] text-neutral-500" }, "‚Äî")
                                            )
                                        )
                                    ),

                                    // Stats de sesi√≥n
                                    React.createElement('div', { className: "grid grid-cols-3 gap-2" },
                                        React.createElement('div', { className: "bg-neutral-800/50 rounded-lg p-2 text-center" },
                                            React.createElement('div', { className: "text-[10px] text-amber-400 font-mono font-bold" },
                                                tickOpportunity.idd.session.dominanceRatio
                                            ),
                                            React.createElement('div', { className: "text-[8px] text-neutral-500 uppercase" }, "Dom. Ratio")
                                        ),
                                        React.createElement('div', { className: "bg-neutral-800/50 rounded-lg p-2 text-center" },
                                            React.createElement('div', { className: "text-[10px] text-amber-400 font-mono font-bold" },
                                                tickOpportunity.idd.session.divergentMetrics
                                            ),
                                            React.createElement('div', { className: "text-[8px] text-neutral-500 uppercase" }, "Divergencias")
                                        ),
                                        React.createElement('div', { className: "bg-neutral-800/50 rounded-lg p-2 text-center" },
                                            React.createElement('div', { className: "text-[10px] text-amber-400 font-mono font-bold" },
                                                `${tickOpportunity.idd.session.maxSpread}%`
                                            ),
                                            React.createElement('div', { className: "text-[8px] text-neutral-500 uppercase" }, "Max Spread")
                                        )
                                    )
                                )
                            )
                        )
                    ),

                    // === SWEEP ANALYSIS PANEL - EXPANDED & RESPONSIVE ===
                    visibleModules.sweepAnalysis && React.createElement('div', {
                        className: `relative overflow-hidden rounded-xl border-2 transition-all duration-300 mb-4 ${sweepAnalysis.sweep.active
                            ? sweepAnalysis.sweep.direction === 'HUNTING_HIGHS'
                                ? 'bg-gradient-to-br from-blue-900/40 via-blue-800/30 to-blue-900/40 border-blue-500 shadow-lg shadow-blue-500/20'
                                : 'bg-gradient-to-br from-red-900/40 via-red-800/30 to-red-900/40 border-red-500 shadow-lg shadow-red-500/20'
                            : 'bg-neutral-900/60 border-neutral-800'
                            }`
                    },
                        // Header con alerta de sweep
                        React.createElement('div', {
                            className: "px-4 py-3 border-b border-neutral-800/50 flex flex-col sm:flex-row items-start sm:items-center justify-between gap-2"
                        },
                            React.createElement('div', { className: "flex items-center gap-3" },
                                sweepAnalysis.sweep.active && React.createElement('div', {
                                    className: `w-3 h-10 rounded-full animate-pulse ${sweepAnalysis.sweep.direction === 'HUNTING_HIGHS' ? 'bg-blue-500 shadow-lg shadow-blue-500/50' : 'bg-red-500 shadow-lg shadow-red-500/50'
                                        }`
                                }),
                                !sweepAnalysis.sweep.active && React.createElement('div', { className: "w-3 h-10 rounded-full bg-neutral-600" }),
                                React.createElement('div', null,
                                    React.createElement('div', { className: "flex items-center gap-2" },
                                        React.createElement('h3', { className: "text-sm font-bold text-neutral-300 uppercase tracking-wider" },
                                            "Sweep & Liquidity Analysis"
                                        ),
                                        // Selector de sensibilidad
                                        React.createElement('div', { className: "flex gap-0.5" },
                                            [1, 2, 3].map(level =>
                                                React.createElement('button', {
                                                    key: level,
                                                    onClick: () => setSweepSensitivity(level),
                                                    className: `w-4 h-4 rounded text-[8px] font-bold transition-all ${sweepSensitivity === level
                                                        ? 'bg-purple-500/40 text-purple-300 border border-purple-500/50'
                                                        : 'bg-neutral-800 text-neutral-500 hover:bg-neutral-700'
                                                        }`,
                                                    title: level === 1 ? 'Low (strict)' : level === 2 ? 'Medium' : 'High (sensitive)'
                                                }, level)
                                            )
                                        ),
                                        // BOT√ìN DE ALARMA
                                        React.createElement('button', {
                                            onClick: () => togglePanelAlert('sweep'),
                                            className: `ml-2 p-1.5 rounded-md transition-all ${panelAlerts.sweep.enabled
                                                ? 'bg-green-500/30 text-green-400 border border-green-500/50 animate-pulse'
                                                : 'bg-neutral-800 text-neutral-500 hover:bg-neutral-700'
                                                }`,
                                            title: panelAlerts.sweep.enabled
                                                ? `üîî Alerta ON (Intensity>${panelAlerts.sweep.threshold}%) - Click para desactivar`
                                                : 'üîï Alerta OFF - Click para activar'
                                        }, "üîî")
                                    ),
                                    React.createElement('p', { className: "text-[10px] text-neutral-500" },
                                        "Liquidity sweeps, swing highs/lows and reversal probability"
                                    )
                                )
                            ),
                            // Status badges
                            React.createElement('div', { className: "flex items-center gap-2 flex-wrap" },
                                sweepAnalysis.sweep.active && React.createElement('span', {
                                    className: `text-xs font-bold px-3 py-1.5 rounded-lg animate-pulse ${sweepAnalysis.sweep.direction === 'HUNTING_HIGHS'
                                        ? 'bg-blue-500/30 text-blue-400 border border-blue-500/50'
                                        : 'bg-red-500/30 text-red-400 border border-red-500/50'
                                        }`
                                }, sweepAnalysis.sweep.direction === 'HUNTING_HIGHS' ? 'HUNTING HIGHS' : 'HUNTING LOWS'),
                                React.createElement('span', {
                                    className: "text-[10px] font-mono px-2 py-1 rounded bg-blue-500/20 text-blue-400 border border-blue-500/30"
                                }, `${sweepAnalysis.sweep.sweepsUp} Highs Swept`),
                                React.createElement('span', {
                                    className: "text-[10px] font-mono px-2 py-1 rounded bg-red-500/20 text-red-400 border border-red-500/30"
                                }, `${sweepAnalysis.sweep.sweepsDown} Lows Swept`)
                            )
                        ),

                        // Contenido principal
                        React.createElement('div', { className: "p-4" },

                            // FILA 1: Sweep Detection COMPACTO HORIZONTAL
                            React.createElement('div', {
                                className: `rounded-xl p-3 mb-4 ${sweepAnalysis.sweep.active
                                    ? sweepAnalysis.sweep.direction === 'HUNTING_HIGHS'
                                        ? 'bg-blue-500/10 border border-blue-500/30'
                                        : 'bg-red-500/10 border border-red-500/30'
                                    : 'bg-neutral-800/50'
                                    }`
                            },
                                React.createElement('div', { className: "flex flex-wrap items-center justify-between gap-4" },
                                    // Label
                                    React.createElement('div', { className: "flex items-center gap-2" },
                                        React.createElement('span', { className: "text-sm text-neutral-400 uppercase font-bold" }, "Sweep"),
                                        sweepAnalysis.sweep.active && React.createElement('div', {
                                            className: `w-3 h-3 rounded-full animate-pulse ${sweepAnalysis.sweep.direction === 'HUNTING_HIGHS' ? 'bg-blue-500' : 'bg-red-500'
                                                }`
                                        })
                                    ),
                                    // Target
                                    React.createElement('div', { className: "flex items-center gap-2" },
                                        React.createElement('span', { className: "text-xs text-neutral-500" }, "Target:"),
                                        React.createElement('span', {
                                            className: `text-lg font-bold ${sweepAnalysis.sweep.direction === 'HUNTING_HIGHS' ? 'text-blue-400'
                                                : sweepAnalysis.sweep.direction === 'HUNTING_LOWS' ? 'text-red-400'
                                                    : 'text-neutral-500'
                                                }`
                                        }, sweepAnalysis.sweep.direction === 'HUNTING_HIGHS' ? 'HIGHS'
                                            : sweepAnalysis.sweep.direction === 'HUNTING_LOWS' ? 'LOWS' : 'NONE')
                                    ),
                                    // Intensity
                                    React.createElement('div', { className: "flex items-center gap-2" },
                                        React.createElement('span', { className: "text-xs text-neutral-500" }, "Intensity:"),
                                        React.createElement('span', {
                                            className: "text-lg font-bold font-mono",
                                            style: { color: sweepAnalysis.sweep.intensity > 70 ? '#f59e0b' : sweepAnalysis.sweep.intensity > 40 ? '#a855f7' : '#737373' }
                                        }, `${sweepAnalysis.sweep.intensity}%`)
                                    ),
                                    // Reversal
                                    React.createElement('div', { className: "flex items-center gap-2" },
                                        React.createElement('span', { className: "text-xs text-neutral-500" }, "Reversal:"),
                                        React.createElement('span', {
                                            className: "text-lg font-bold font-mono",
                                            style: { color: sweepAnalysis.sweep.reversalProb > 60 ? '#22c55e' : sweepAnalysis.sweep.reversalProb > 40 ? '#f59e0b' : '#737373' }
                                        }, `${sweepAnalysis.sweep.reversalProb}%`)
                                    ),
                                    // Last
                                    React.createElement('div', { className: "flex items-center gap-2" },
                                        React.createElement('span', { className: "text-xs text-neutral-500" }, "Last:"),
                                        React.createElement('span', {
                                            className: `text-lg font-bold px-2 py-0.5 rounded ${sweepAnalysis.sweep.lastSweepType === 'HIGH'
                                                ? 'bg-blue-500/20 text-blue-400'
                                                : sweepAnalysis.sweep.lastSweepType === 'LOW'
                                                    ? 'bg-red-500/20 text-red-400'
                                                    : 'bg-neutral-800 text-neutral-500'
                                                }`
                                        }, sweepAnalysis.sweep.lastSweepType || 'NONE')
                                    )
                                )
                            ),

                            // FILA 2: LIQUIDITY ZONES - FULL WIDTH CON BARRA GRANDE
                            React.createElement('div', { className: "bg-neutral-800/50 rounded-xl p-4 mb-4" },
                                React.createElement('div', { className: "text-xs text-neutral-300 uppercase font-bold tracking-wide mb-4" }, "Liquidity Zones"),

                                // Contenedor principal de la barra
                                React.createElement('div', { className: "relative" },

                                    // Fila superior: Liquidity Above
                                    React.createElement('div', { className: "flex items-center justify-between mb-2" },
                                        React.createElement('div', { className: "flex items-center gap-2" },
                                            React.createElement('div', { className: "w-3 h-3 rounded-full bg-blue-500" }),
                                            React.createElement('span', { className: "text-sm text-blue-400 font-medium" }, "Liquidity Above"),
                                            React.createElement('span', { className: "text-[10px] text-neutral-500" }, "(stops de shorts)")
                                        ),
                                        React.createElement('div', { className: "flex items-center gap-3" },
                                            React.createElement('span', { className: "text-xl font-mono font-bold text-blue-400" },
                                                `${parseFloat(sweepAnalysis.liquidity.above).toFixed(2)}`
                                            ),
                                            sweepAnalysis.liquidity.nearestTarget === 'ABOVE' &&
                                            React.createElement('span', { className: "text-[10px] bg-blue-500/30 text-blue-400 px-3 py-1 rounded-full font-bold animate-pulse" }, "NEXT TARGET")
                                        )
                                    ),

                                    // BARRA DE LIQUIDEZ GRANDE - TODO EL ANCHO
                                    React.createElement('div', { className: "relative h-10 bg-neutral-700/50 rounded-xl overflow-hidden my-4" },
                                        // Gradiente de fondo
                                        React.createElement('div', {
                                            className: "absolute inset-0 bg-gradient-to-r from-red-500/30 via-neutral-600/20 to-blue-500/30"
                                        }),
                                        // Zonas de liquidez visuales
                                        React.createElement('div', {
                                            className: "absolute left-0 top-0 h-full bg-gradient-to-r from-red-500/40 to-transparent",
                                            style: { width: '15%' }
                                        }),
                                        React.createElement('div', {
                                            className: "absolute right-0 top-0 h-full bg-gradient-to-l from-blue-500/40 to-transparent",
                                            style: { width: '15%' }
                                        }),
                                        // Marcador de posici√≥n actual
                                        React.createElement('div', {
                                            className: "absolute top-1/2 -translate-y-1/2 w-6 h-6 bg-white rounded-full shadow-xl border-4 border-neutral-900 transition-all z-10",
                                            style: { left: `${Math.max(3, Math.min(97, sweepAnalysis.rangeDetails.positionPct))}%`, transform: 'translate(-50%, -50%)' }
                                        }),
                                        // Etiquetas en la barra
                                        React.createElement('div', { className: "absolute inset-0 flex items-center justify-between px-4" },
                                            React.createElement('span', { className: "text-xs font-bold text-red-400 bg-neutral-900/70 px-2 py-1 rounded" },
                                                `${parseFloat(sweepAnalysis.liquidity.below).toFixed(2)}`
                                            ),
                                            React.createElement('span', { className: "text-[10px] text-neutral-400 font-medium" },
                                                `Position: ${sweepAnalysis.rangeDetails.positionPct}%`
                                            ),
                                            React.createElement('span', { className: "text-xs font-bold text-blue-400 bg-neutral-900/70 px-2 py-1 rounded" },
                                                `${parseFloat(sweepAnalysis.liquidity.above).toFixed(2)}`
                                            )
                                        )
                                    ),

                                    // Fila inferior: Liquidity Below
                                    React.createElement('div', { className: "flex items-center justify-between mb-3" },
                                        React.createElement('div', { className: "flex items-center gap-2" },
                                            React.createElement('div', { className: "w-3 h-3 rounded-full bg-red-500" }),
                                            React.createElement('span', { className: "text-sm text-red-400 font-medium" }, "Liquidity Below"),
                                            React.createElement('span', { className: "text-[10px] text-neutral-500" }, "(stops de longs)")
                                        ),
                                        React.createElement('div', { className: "flex items-center gap-3" },
                                            React.createElement('span', { className: "text-xl font-mono font-bold text-red-400" },
                                                `${parseFloat(sweepAnalysis.liquidity.below).toFixed(2)}`
                                            ),
                                            sweepAnalysis.liquidity.nearestTarget === 'BELOW' &&
                                            React.createElement('span', { className: "text-[10px] bg-red-500/30 text-red-400 px-3 py-1 rounded-full font-bold animate-pulse" }, "NEXT TARGET")
                                        )
                                    ),

                                    // Info de distancia
                                    React.createElement('div', { className: "flex items-center justify-center gap-6 pt-2 border-t border-neutral-700" },
                                        React.createElement('div', { className: "text-center" },
                                            React.createElement('span', { className: "text-[10px] text-neutral-500 block" }, "Distance to Target"),
                                            React.createElement('span', { className: "text-lg font-mono font-bold text-cyan-400" }, `${sweepAnalysis.liquidity.distanceToTarget} pts`)
                                        ),
                                        React.createElement('div', { className: "text-center" },
                                            React.createElement('span', { className: "text-[10px] text-neutral-500 block" }, "Target %"),
                                            React.createElement('span', { className: "text-lg font-mono font-bold text-neutral-300" }, `${sweepAnalysis.liquidity.targetPct}%`)
                                        ),
                                        React.createElement('div', { className: "text-center" },
                                            React.createElement('span', { className: "text-[10px] text-neutral-500 block" }, "Nearest"),
                                            React.createElement('span', {
                                                className: `text-lg font-bold ${sweepAnalysis.liquidity.nearestTarget === 'ABOVE' ? 'text-blue-400' : 'text-red-400'}`
                                            }, sweepAnalysis.liquidity.nearestTarget)
                                        )
                                    )
                                )
                            ),

                            // FILA 3: Componentes Expandidos (4 columnas responsive)
                            React.createElement('div', { className: "grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4" },

                                // RANGE DETAILS - Con iluminaci√≥n
                                React.createElement('div', {
                                    className: `rounded-xl p-4 transition-all ${sweepAnalysis.rangeDetails.expanding
                                        ? 'bg-purple-500/15 border border-purple-500/30'
                                        : 'bg-neutral-800/50'
                                        }`
                                },
                                    React.createElement('div', { className: "flex items-center justify-between mb-3" },
                                        React.createElement('span', { className: "text-xs text-purple-400 uppercase font-bold tracking-wide" }, "Range"),
                                        React.createElement('span', {
                                            className: `text-[10px] px-2 py-1 rounded-lg font-bold ${sweepAnalysis.rangeDetails.expanding
                                                ? 'bg-purple-500/30 text-purple-400'
                                                : sweepAnalysis.rangeDetails.contracting
                                                    ? 'bg-amber-500/30 text-amber-400'
                                                    : 'bg-neutral-700 text-neutral-400'
                                                }`
                                        }, sweepAnalysis.rangeDetails.expanding ? 'EXPANDING' : sweepAnalysis.rangeDetails.contracting ? 'CONTRACTING' : 'STABLE')
                                    ),
                                    React.createElement('div', { className: "space-y-2" },
                                        React.createElement('div', { className: "flex justify-between items-center" },
                                            React.createElement('span', { className: "text-[11px] text-neutral-500" }, "Current"),
                                            React.createElement('span', { className: "text-sm text-neutral-200 font-mono font-bold" }, `${sweepAnalysis.rangeDetails.current} pts`)
                                        ),
                                        React.createElement('div', { className: "flex justify-between items-center" },
                                            React.createElement('span', { className: "text-[11px] text-neutral-500" }, "Average"),
                                            React.createElement('span', { className: "text-xs text-neutral-400 font-mono" }, `${sweepAnalysis.rangeDetails.average} pts`)
                                        ),
                                        React.createElement('div', { className: "flex justify-between items-center" },
                                            React.createElement('span', { className: "text-[11px] text-neutral-500" }, "Ratio"),
                                            React.createElement('span', {
                                                className: "text-sm font-mono font-bold",
                                                style: { color: parseFloat(sweepAnalysis.rangeDetails.ratio) > 1.2 ? '#a855f7' : parseFloat(sweepAnalysis.rangeDetails.ratio) < 0.8 ? '#fbbf24' : '#737373' }
                                            }, `${sweepAnalysis.rangeDetails.ratio}x`)
                                        ),
                                        React.createElement('div', { className: "flex justify-between items-center" },
                                            React.createElement('span', { className: "text-[11px] text-neutral-500" }, "Position"),
                                            React.createElement('span', {
                                                className: `text-xs font-bold ${sweepAnalysis.rangeDetails.position === 'HIGH' ? 'text-blue-400'
                                                    : sweepAnalysis.rangeDetails.position === 'LOW' ? 'text-red-400'
                                                        : 'text-neutral-400'
                                                    }`
                                            }, `${sweepAnalysis.rangeDetails.position} (${sweepAnalysis.rangeDetails.positionPct}%)`)
                                        ),
                                        React.createElement('div', { className: "pt-2 border-t border-neutral-700 flex justify-between text-[10px]" },
                                            React.createElement('span', { className: "text-red-400 font-mono font-bold" }, `${sweepAnalysis.rangeDetails.rangeLow}`),
                                            React.createElement('span', { className: "text-blue-400 font-mono font-bold" }, `${sweepAnalysis.rangeDetails.rangeHigh}`)
                                        )
                                    )
                                ),

                                // MOMENTUM DETAILS - Con iluminaci√≥n
                                React.createElement('div', {
                                    className: `rounded-xl p-4 transition-all ${sweepAnalysis.momentumDetails.phase === 'IMPULSE'
                                        ? 'bg-blue-500/15 border border-blue-500/30'
                                        : 'bg-neutral-800/50'
                                        }`
                                },
                                    React.createElement('div', { className: "flex items-center justify-between mb-3" },
                                        React.createElement('span', { className: "text-xs text-blue-400 uppercase font-bold tracking-wide" }, "Momentum"),
                                        React.createElement('span', {
                                            className: `text-[10px] px-2 py-1 rounded-lg font-bold ${sweepAnalysis.momentumDetails.phase === 'IMPULSE'
                                                ? 'bg-emerald-500/30 text-emerald-400'
                                                : sweepAnalysis.momentumDetails.phase === 'CORRECTION'
                                                    ? 'bg-amber-500/30 text-amber-400'
                                                    : sweepAnalysis.momentumDetails.phase === 'CONSOLIDATION'
                                                        ? 'bg-purple-500/30 text-purple-400'
                                                        : 'bg-neutral-700 text-neutral-400'
                                                }`
                                        }, sweepAnalysis.momentumDetails.phase)
                                    ),
                                    React.createElement('div', { className: "space-y-2" },
                                        React.createElement('div', { className: "flex justify-between items-center" },
                                            React.createElement('span', { className: "text-[11px] text-neutral-500" }, "Speed"),
                                            React.createElement('span', { className: "text-sm text-neutral-200 font-mono font-bold" }, `${sweepAnalysis.momentumDetails.speed}/tick`)
                                        ),
                                        React.createElement('div', { className: "flex justify-between items-center" },
                                            React.createElement('span', { className: "text-[11px] text-neutral-500" }, "Direction"),
                                            React.createElement('span', {
                                                className: `text-xs font-bold ${sweepAnalysis.momentumDetails.direction === 'BULLISH' ? 'text-blue-400'
                                                    : sweepAnalysis.momentumDetails.direction === 'BEARISH' ? 'text-red-400'
                                                        : 'text-neutral-400'
                                                    }`
                                            }, `${sweepAnalysis.momentumDetails.direction} (${sweepAnalysis.momentumDetails.directionScore > 0 ? '+' : ''}${sweepAnalysis.momentumDetails.directionScore})`)
                                        ),
                                        React.createElement('div', { className: "flex justify-between items-center" },
                                            React.createElement('span', { className: "text-[11px] text-neutral-500" }, "Accel"),
                                            React.createElement('span', {
                                                className: "text-sm font-mono font-bold",
                                                style: { color: parseInt(sweepAnalysis.momentumDetails.acceleration) > 20 ? '#22c55e' : parseInt(sweepAnalysis.momentumDetails.acceleration) < -20 ? '#ef4444' : '#737373' }
                                            }, `${parseInt(sweepAnalysis.momentumDetails.acceleration) > 0 ? '+' : ''}${sweepAnalysis.momentumDetails.acceleration}%`)
                                        ),
                                        React.createElement('div', null,
                                            React.createElement('div', { className: "flex justify-between items-center mb-1" },
                                                React.createElement('span', { className: "text-[11px] text-neutral-500" }, "Consistency"),
                                                React.createElement('span', { className: "text-xs text-neutral-300 font-mono font-bold" }, `${sweepAnalysis.momentumDetails.consistency}%`)
                                            ),
                                            React.createElement('div', { className: "h-1.5 bg-neutral-700 rounded-full overflow-hidden" },
                                                React.createElement('div', {
                                                    className: "h-full rounded-full transition-all",
                                                    style: {
                                                        width: `${sweepAnalysis.momentumDetails.consistency}%`,
                                                        background: sweepAnalysis.momentumDetails.consistency > 60 ? '#22c55e' : '#f59e0b'
                                                    }
                                                })
                                            )
                                        )
                                    )
                                ),

                                // PARTICIPATION DETAILS - Con iluminaci√≥n
                                React.createElement('div', {
                                    className: `rounded-xl p-4 transition-all ${sweepAnalysis.participationDetails.activeMetrics >= 3
                                        ? 'bg-emerald-500/15 border border-emerald-500/30'
                                        : 'bg-neutral-800/50'
                                        }`
                                },
                                    React.createElement('div', { className: "flex items-center justify-between mb-3" },
                                        React.createElement('span', { className: "text-xs text-emerald-400 uppercase font-bold tracking-wide" }, "Participation"),
                                        React.createElement('span', {
                                            className: `text-[10px] px-2 py-1 rounded-lg font-bold ${sweepAnalysis.participationDetails.dominant === 'BULLISH'
                                                ? 'bg-blue-500/30 text-blue-400'
                                                : sweepAnalysis.participationDetails.dominant === 'BEARISH'
                                                    ? 'bg-red-500/30 text-red-400'
                                                    : 'bg-neutral-700 text-neutral-400'
                                                }`
                                        }, sweepAnalysis.participationDetails.dominant)
                                    ),
                                    React.createElement('div', { className: "space-y-2" },
                                        React.createElement('div', { className: "flex justify-between items-center" },
                                            React.createElement('span', { className: "text-[11px] text-neutral-500" }, "Active"),
                                            React.createElement('span', {
                                                className: "text-sm font-bold",
                                                style: { color: sweepAnalysis.participationDetails.activeMetrics >= 3 ? '#22c55e' : '#737373' }
                                            }, `${sweepAnalysis.participationDetails.activeMetrics}/${sweepAnalysis.participationDetails.totalMetrics}`)
                                        ),
                                        React.createElement('div', { className: "flex justify-between items-center" },
                                            React.createElement('span', { className: "text-[11px] text-neutral-500" }, "Top"),
                                            React.createElement('span', { className: "text-xs text-emerald-400 font-bold" },
                                                `${sweepAnalysis.participationDetails.topMetric.name}`
                                            )
                                        ),
                                        React.createElement('div', { className: "flex justify-between items-center" },
                                            React.createElement('span', { className: "text-[11px] text-neutral-500" }, "Strength"),
                                            React.createElement('span', { className: "text-sm text-emerald-400 font-mono font-bold" },
                                                `${sweepAnalysis.participationDetails.topMetric.strength}%`
                                            )
                                        ),
                                        React.createElement('div', null,
                                            React.createElement('div', { className: "flex justify-between items-center mb-1" },
                                                React.createElement('span', { className: "text-[11px] text-neutral-500" }, "Avg"),
                                                React.createElement('span', { className: "text-xs text-neutral-300 font-mono font-bold" }, `${sweepAnalysis.participationDetails.avgStrength}%`)
                                            ),
                                            React.createElement('div', { className: "h-1.5 bg-neutral-700 rounded-full overflow-hidden" },
                                                React.createElement('div', {
                                                    className: "h-full rounded-full bg-emerald-500 transition-all",
                                                    style: { width: `${sweepAnalysis.participationDetails.avgStrength}%` }
                                                })
                                            )
                                        )
                                    )
                                ),

                                // ACCELERATION DETAILS - Con iluminaci√≥n
                                React.createElement('div', {
                                    className: `rounded-xl p-4 transition-all ${sweepAnalysis.accelerationDetails.phase === 'IMPULSE' || sweepAnalysis.accelerationDetails.phase === 'BUILDING'
                                        ? 'bg-amber-500/15 border border-amber-500/30'
                                        : 'bg-neutral-800/50'
                                        }`
                                },
                                    React.createElement('div', { className: "flex items-center justify-between mb-3" },
                                        React.createElement('span', { className: "text-xs text-amber-400 uppercase font-bold tracking-wide" }, "Acceleration"),
                                        React.createElement('span', {
                                            className: `text-[10px] px-2 py-1 rounded-lg font-bold ${sweepAnalysis.accelerationDetails.phase === 'IMPULSE'
                                                ? 'bg-emerald-500/30 text-emerald-400'
                                                : sweepAnalysis.accelerationDetails.phase === 'BUILDING'
                                                    ? 'bg-cyan-500/30 text-cyan-400'
                                                    : sweepAnalysis.accelerationDetails.phase === 'FADING'
                                                        ? 'bg-red-500/30 text-red-400'
                                                        : 'bg-neutral-700 text-neutral-400'
                                                }`
                                        }, sweepAnalysis.accelerationDetails.phase)
                                    ),
                                    React.createElement('div', { className: "space-y-2" },
                                        React.createElement('div', { className: "flex justify-between items-center" },
                                            React.createElement('span', { className: "text-[11px] text-neutral-500" }, "Current"),
                                            React.createElement('span', { className: "text-sm text-neutral-200 font-mono font-bold" }, sweepAnalysis.accelerationDetails.current)
                                        ),
                                        React.createElement('div', { className: "flex justify-between items-center" },
                                            React.createElement('span', { className: "text-[11px] text-neutral-500" }, "Previous"),
                                            React.createElement('span', { className: "text-xs text-neutral-400 font-mono" }, sweepAnalysis.accelerationDetails.previous)
                                        ),
                                        React.createElement('div', { className: "flex justify-between items-center" },
                                            React.createElement('span', { className: "text-[11px] text-neutral-500" }, "Ratio"),
                                            React.createElement('span', {
                                                className: "text-sm font-mono font-bold",
                                                style: { color: parseFloat(sweepAnalysis.accelerationDetails.ratio) > 1.3 ? '#22c55e' : parseFloat(sweepAnalysis.accelerationDetails.ratio) < 0.7 ? '#ef4444' : '#737373' }
                                            }, `${sweepAnalysis.accelerationDetails.ratio}x`)
                                        ),
                                        React.createElement('div', { className: "flex justify-between items-center" },
                                            React.createElement('span', { className: "text-[11px] text-neutral-500" }, "Peak"),
                                            React.createElement('span', {
                                                className: `text-xs font-bold ${sweepAnalysis.accelerationDetails.peakReached ? 'text-amber-400' : 'text-neutral-500'}`
                                            }, sweepAnalysis.accelerationDetails.peakReached ? 'REACHED' : 'Building...')
                                        )
                                    )
                                )
                            )
                        )
                    ),

                    // === ANALYTICS GRID - SPECIALIZED PROFESSIONAL PANELS ===
                    visibleModules.panelsGrid && React.createElement('div', {
                        className: "rounded-xl border border-neutral-800/50 bg-gradient-to-br from-neutral-900/90 to-neutral-950/90 p-4 mb-4"
                    },
                        // Header del grid
                        React.createElement('div', { className: "flex items-center justify-between mb-4 pb-3 border-b border-neutral-800/50" },
                            React.createElement('div', { className: "flex items-center gap-3" },
                                React.createElement('div', { className: "w-1 h-6 rounded-full bg-gradient-to-b from-amber-500 to-orange-600" }),
                                React.createElement('h2', { className: "text-sm font-bold text-neutral-200 uppercase tracking-wider" },
                                    "Advanced Analytics Grid"
                                )
                            ),
                            React.createElement('span', { className: "text-[10px] text-neutral-500 font-mono" },
                                `${topMetricsGlobal.length} metrics active`
                            )
                        ),

                        // Grid de 4 paneles
                        React.createElement('div', { className: "grid grid-cols-1 md:grid-cols-2 xl:grid-cols-4 gap-4" },

                            // === TOP 3 METRICS PANEL - ENHANCED ===
                            React.createElement('div', {
                                className: `relative overflow-hidden rounded-xl transition-all duration-300 ${topMetricsGlobal[0]?.direction === 'BULLISH'
                                    ? 'bg-gradient-to-br from-blue-900/20 via-neutral-900/80 to-neutral-900/80 border border-blue-500/30'
                                    : topMetricsGlobal[0]?.direction === 'BEARISH'
                                        ? 'bg-gradient-to-br from-red-900/20 via-neutral-900/80 to-neutral-900/80 border border-red-500/30'
                                        : 'bg-neutral-900/80 border border-neutral-800'
                                    }`
                            },
                                // Accent bar
                                React.createElement('div', {
                                    className: "absolute top-0 left-0 right-0 h-1",
                                    style: {
                                        background: topMetricsGlobal[0]?.direction === 'BULLISH'
                                            ? 'linear-gradient(90deg, #3b82f6, #60a5fa)'
                                            : topMetricsGlobal[0]?.direction === 'BEARISH'
                                                ? 'linear-gradient(90deg, #ef4444, #f87171)'
                                                : 'linear-gradient(90deg, #525252, #737373)'
                                    }
                                }),
                                React.createElement('div', { className: "p-4 pt-5" },
                                    React.createElement('div', { className: "flex items-center justify-between mb-3" },
                                        React.createElement('h3', { className: "text-xs font-bold text-neutral-300 uppercase tracking-wider" },
                                            "Dominant Metrics"
                                        ),
                                        React.createElement('span', {
                                            className: `text-[9px] font-bold px-2 py-0.5 rounded-full ${topMetricsGlobal[0]?.direction === 'BULLISH' ? 'bg-blue-500/20 text-blue-400'
                                                : topMetricsGlobal[0]?.direction === 'BEARISH' ? 'bg-red-500/20 text-red-400'
                                                    : 'bg-neutral-700 text-neutral-400'
                                                }`
                                        }, topMetricsGlobal[0]?.direction || 'NEUTRAL')
                                    ),
                                    React.createElement('div', { className: "space-y-3" },
                                        topMetricsGlobal.map((metric, idx) =>
                                            React.createElement('div', { key: metric.key, className: "flex items-center gap-3" },
                                                React.createElement('span', {
                                                    className: "w-6 h-6 flex items-center justify-center rounded-lg text-xs font-bold",
                                                    style: {
                                                        background: idx === 0 ? 'linear-gradient(135deg, #fbbf24, #f59e0b)'
                                                            : idx === 1 ? 'linear-gradient(135deg, #94a3b8, #64748b)'
                                                                : 'linear-gradient(135deg, #78716c, #57534e)',
                                                        color: '#000'
                                                    }
                                                }, idx + 1),
                                                React.createElement('div', { className: "flex-1" },
                                                    React.createElement('div', { className: "flex justify-between items-center mb-1" },
                                                        React.createElement('span', { className: "text-xs font-medium text-neutral-300" }, metric.fullLabel),
                                                        React.createElement('span', {
                                                            className: "text-xs font-bold font-mono",
                                                            style: { color: getDirectionColor(metric.direction) }
                                                        }, `${metric.strength.toFixed(0)}%`)
                                                    ),
                                                    React.createElement('div', { className: "h-1.5 bg-neutral-800 rounded-full overflow-hidden" },
                                                        React.createElement('div', {
                                                            className: "h-full rounded-full transition-all",
                                                            style: {
                                                                width: `${metric.strength}%`,
                                                                background: `linear-gradient(90deg, ${getDirectionColor(metric.direction)}, ${getDirectionColor(metric.direction)}aa)`
                                                            }
                                                        })
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            ),

                            // === FLOW LEVELS PANEL - ENHANCED ===
                            React.createElement('div', {
                                className: `relative overflow-hidden rounded-xl transition-all duration-300 ${flowLevels.surges?.length > 0
                                    ? 'bg-gradient-to-br from-amber-900/20 via-neutral-900/80 to-neutral-900/80 border border-amber-500/30'
                                    : 'bg-neutral-900/80 border border-neutral-800'
                                    }`
                            },
                                // Accent bar
                                React.createElement('div', {
                                    className: "absolute top-0 left-0 right-0 h-1",
                                    style: { background: 'linear-gradient(90deg, #f59e0b, #fbbf24)' }
                                }),
                                React.createElement('div', { className: "p-4 pt-5" },
                                    React.createElement('div', { className: "flex items-center justify-between mb-3" },
                                        React.createElement('h3', { className: "text-xs font-bold text-neutral-300 uppercase tracking-wider" },
                                            "Flow Levels"
                                        ),
                                        React.createElement('span', { className: "text-[9px] font-mono text-amber-400" },
                                            flowLevels.type === 'delta' ? 'DELTA' : 'CASH'
                                        )
                                    ),
                                    (flowLevels.plus || flowLevels.minus || flowLevels.zero)
                                        ? React.createElement('div', { className: "space-y-2" },
                                            // Plus/Minus levels
                                            React.createElement('div', { className: "grid grid-cols-2 gap-2" },
                                                flowLevels.plus && React.createElement('div', {
                                                    className: "flex items-center justify-between p-2 rounded-lg bg-blue-500/10 border border-blue-500/30"
                                                },
                                                    React.createElement('span', { className: "text-blue-400 font-bold text-xs" },
                                                        flowLevels.type === 'delta' ? 'Œî+' : '$+'
                                                    ),
                                                    React.createElement('span', { className: "text-neutral-200 font-mono text-sm font-bold" },
                                                        flowLevels.plus.toFixed(0)
                                                    )
                                                ),
                                                flowLevels.minus && React.createElement('div', {
                                                    className: "flex items-center justify-between p-2 rounded-lg bg-red-500/10 border border-red-500/30"
                                                },
                                                    React.createElement('span', { className: "text-red-400 font-bold text-xs" },
                                                        flowLevels.type === 'delta' ? 'Œî-' : '$-'
                                                    ),
                                                    React.createElement('span', { className: "text-neutral-200 font-mono text-sm font-bold" },
                                                        flowLevels.minus.toFixed(0)
                                                    )
                                                )
                                            ),
                                            // Surges - M√ÅS VIVOS Y LLAMATIVOS
                                            flowLevels.surges?.length > 0 && React.createElement('div', { className: "pt-2 border-t border-amber-500/30" },
                                                React.createElement('div', { className: "flex items-center gap-2 mb-2" },
                                                    React.createElement('span', { className: "text-[10px] font-bold text-amber-400 uppercase animate-pulse" }, "üî• SURGES"),
                                                    React.createElement('span', { className: "text-[9px] text-amber-300/70" }, `${flowLevels.surges.length} detected`)
                                                ),
                                                React.createElement('div', { className: "flex flex-wrap gap-2" },
                                                    flowLevels.surges.slice(0, 3).map((surge, idx) =>
                                                        React.createElement('div', {
                                                            key: `surge-${idx}`,
                                                            className: `relative overflow-hidden flex items-center gap-1.5 px-3 py-1.5 rounded-lg text-sm font-bold transition-all ${idx === 0
                                                                ? 'bg-gradient-to-r from-amber-500/40 to-orange-500/40 text-amber-200 border border-amber-400/60 shadow-lg shadow-amber-500/30 animate-pulse'
                                                                : idx === 1
                                                                    ? 'bg-gradient-to-r from-amber-500/25 to-orange-500/25 text-amber-300 border border-amber-500/40 shadow-md shadow-amber-500/20'
                                                                    : 'bg-amber-500/15 text-amber-400 border border-amber-500/30'
                                                                }`,
                                                            style: idx === 0 ? {
                                                                boxShadow: '0 0 15px rgba(245, 158, 11, 0.4), inset 0 0 20px rgba(245, 158, 11, 0.1)'
                                                            } : {}
                                                        },
                                                            // Glow effect para el primero
                                                            idx === 0 && React.createElement('div', {
                                                                className: "absolute inset-0 bg-gradient-to-r from-amber-400/20 to-orange-400/20 animate-pulse"
                                                            }),
                                                            React.createElement('span', {
                                                                className: `relative z-10 ${surge.type === 'call' ? 'text-blue-300' : 'text-red-300'}`
                                                            }, surge.type === 'call' ? '‚ñ≤' : '‚ñº'),
                                                            React.createElement('span', { className: "relative z-10 font-mono tracking-wider" }, surge.strike.toFixed(0)),
                                                            idx === 0 && React.createElement('span', {
                                                                className: "relative z-10 text-[10px] text-amber-200/80 font-normal ml-1"
                                                            }, "HOT")
                                                        )
                                                    )
                                                )
                                            ),
                                            // Price info
                                            flowLevels.price > 0 && React.createElement('div', { className: "text-[10px] text-neutral-500 pt-2" },
                                                `${flowLevels.symbol} ${flowLevels.price.toFixed(2)}`,
                                                flowLevels.relatedPrice > 0 && ` | ${flowLevels.relatedSymbol} ${flowLevels.relatedPrice.toFixed(0)}`
                                            )
                                        )
                                        : React.createElement('div', { className: "text-center py-6" },
                                            React.createElement('span', { className: "text-xs text-neutral-500" }, "No flow levels detected")
                                        )
                                )
                            ),

                            // === MULTI-SLOT MONITOR PANEL - ENHANCED ===
                            React.createElement('div', {
                                className: `relative overflow-hidden rounded-xl transition-all duration-300 ${multiSlotMonitor.some(s => s.impulse !== 'NONE')
                                    ? 'bg-gradient-to-br from-purple-900/20 via-neutral-900/80 to-neutral-900/80 border border-purple-500/30'
                                    : 'bg-neutral-900/80 border border-neutral-800'
                                    }`
                            },
                                // Accent bar
                                React.createElement('div', {
                                    className: "absolute top-0 left-0 right-0 h-1",
                                    style: { background: 'linear-gradient(90deg, #a855f7, #c084fc)' }
                                }),
                                React.createElement('div', { className: "p-4 pt-5" },
                                    React.createElement('div', { className: "flex items-center justify-between mb-3" },
                                        React.createElement('h3', { className: "text-xs font-bold text-neutral-300 uppercase tracking-wider" },
                                            "Slot Monitor"
                                        ),
                                        // Selector de sensibilidad
                                        React.createElement('div', { className: "flex items-center gap-1" },
                                            [1, 2, 3].map(level =>
                                                React.createElement('button', {
                                                    key: level,
                                                    onClick: () => setSurgeSensitivity(level),
                                                    className: `w-4 h-4 rounded text-[8px] font-bold transition-all ${surgeSensitivity === level
                                                        ? 'bg-purple-500/40 text-purple-300 border border-purple-500/50'
                                                        : 'bg-neutral-800 text-neutral-500 hover:bg-neutral-700'
                                                        }`,
                                                    title: level === 1 ? 'Low' : level === 2 ? 'Medium' : 'High'
                                                }, level)
                                            )
                                        )
                                    ),
                                    // Slots en 2 filas: VIX arriba solo, resto abajo
                                    React.createElement('div', { className: "space-y-2" },
                                        // VIX - fila superior, m√°s grande
                                        (() => {
                                            const vixSlot = multiSlotMonitor.find(s => s.isVIX) || {
                                                hasData: false,
                                                price: 0,
                                                change: 0,
                                                impulse: 'NONE',
                                                isVIX: true
                                            };

                                            const hasImpulse = vixSlot.impulse !== 'NONE';
                                            const isBullish = vixSlot.impulse === 'BULLISH';
                                            const isBearish = vixSlot.impulse === 'BEARISH';

                                            let bgColor = 'bg-neutral-800/50';
                                            let borderColor = 'border-neutral-700/50';
                                            let textColor = 'text-neutral-400';

                                            if (!vixSlot.hasData) {
                                                bgColor = 'bg-neutral-900/30';
                                                borderColor = 'border-neutral-800/30';
                                            } else if (isBullish) {
                                                bgColor = 'bg-blue-500/20';
                                                borderColor = 'border-blue-500/50';
                                                textColor = 'text-blue-400';
                                            } else if (isBearish) {
                                                bgColor = 'bg-red-500/20';
                                                borderColor = 'border-red-500/50';
                                                textColor = 'text-red-400';
                                            }

                                            return React.createElement('div', {
                                                className: `${bgColor} border ${borderColor} rounded-lg p-2 transition-all ${hasImpulse ? 'animate-pulse' : ''}`,
                                                title: vixSlot.hasData ? `Vol: ${vixSlot.volatility?.toFixed(3)}% | Threshold: ${vixSlot.threshold?.toFixed(3)}%` : 'No data'
                                            },
                                                React.createElement('div', { className: "flex items-center justify-between" },
                                                    React.createElement('div', { className: "flex items-center gap-2" },
                                                        React.createElement('span', { className: `text-sm font-bold ${textColor}` }, '‚ö° VIX'),
                                                        React.createElement('span', { className: "text-[9px] text-amber-500 bg-amber-500/20 px-1.5 py-0.5 rounded" }, 'INVERTED')
                                                    ),
                                                    React.createElement('div', { className: "flex items-center gap-3" },
                                                        React.createElement('span', {
                                                            className: `text-lg font-mono font-bold ${vixSlot.hasData ? (isBullish ? 'text-blue-300' : isBearish ? 'text-red-300' : 'text-neutral-300') : 'text-neutral-600'}`
                                                        }, vixSlot.hasData ? vixSlot.price.toFixed(2) : '‚Äî'),
                                                        React.createElement('span', {
                                                            className: `text-sm font-mono ${vixSlot.hasData ? (vixSlot.change >= 0 ? 'text-green-400' : 'text-red-400') : 'text-neutral-600'}`
                                                        }, vixSlot.hasData ? `${vixSlot.change >= 0 ? '+' : ''}${vixSlot.change.toFixed(2)}%` : '‚Äî')
                                                    )
                                                ),
                                                hasImpulse && React.createElement('div', { className: "mt-2 h-1.5 bg-neutral-700 rounded-full overflow-hidden" },
                                                    React.createElement('div', {
                                                        className: `h-full rounded-full ${isBullish ? 'bg-blue-500' : 'bg-red-500'}`,
                                                        style: { width: `${vixSlot.intensity}%` }
                                                    })
                                                ),
                                                React.createElement('div', { className: "mt-1 text-[9px] text-neutral-500 text-right" },
                                                    `VIX Up = Bearish | VIX Down = Bullish`
                                                )
                                            );
                                        })(),
                                        // Otros slots - fila inferior
                                        React.createElement('div', { className: "grid grid-cols-4 gap-1.5" },
                                            multiSlotMonitor.filter(s => !s.isVIX).map(slot => {
                                                const hasImpulse = slot.impulse !== 'NONE';
                                                const isBullish = slot.impulse === 'BULLISH';
                                                const isBearish = slot.impulse === 'BEARISH';

                                                let bgColor = 'bg-neutral-800/50';
                                                let borderColor = 'border-neutral-700/50';
                                                let textColor = 'text-neutral-400';
                                                let priceColor = 'text-neutral-300';
                                                let changeColor = 'text-neutral-500';

                                                if (!slot.hasData) {
                                                    bgColor = 'bg-neutral-900/30';
                                                    borderColor = 'border-neutral-800/30';
                                                    textColor = 'text-neutral-600';
                                                } else if (isBullish) {
                                                    bgColor = 'bg-blue-500/20';
                                                    borderColor = 'border-blue-500/50';
                                                    textColor = 'text-blue-400';
                                                    priceColor = 'text-blue-300';
                                                    changeColor = 'text-blue-400';
                                                } else if (isBearish) {
                                                    bgColor = 'bg-red-500/20';
                                                    borderColor = 'border-red-500/50';
                                                    textColor = 'text-red-400';
                                                    priceColor = 'text-red-300';
                                                    changeColor = 'text-red-400';
                                                } else if (slot.hasData) {
                                                    if (slot.change > 0) changeColor = 'text-green-500/70';
                                                    else if (slot.change < 0) changeColor = 'text-red-500/70';
                                                }

                                                return React.createElement('div', {
                                                    key: slot.slot,
                                                    className: `${bgColor} border ${borderColor} rounded-lg p-2 text-center transition-all ${hasImpulse ? 'animate-pulse' : ''}`,
                                                    title: slot.hasData ? `Vol: ${slot.volatility?.toFixed(3)}% | Threshold: ${slot.threshold?.toFixed(3)}%` : 'No data'
                                                },
                                                    React.createElement('div', { className: `text-[10px] font-bold ${textColor} truncate` },
                                                        slot.symbol.slice(0, 8)
                                                    ),
                                                    React.createElement('div', { className: `text-sm font-mono font-bold ${priceColor}` },
                                                        slot.hasData ? slot.price.toFixed(slot.price > 100 ? 0 : 2) : '‚Äî'
                                                    ),
                                                    React.createElement('div', { className: `text-[10px] font-mono ${changeColor}` },
                                                        slot.hasData ? `${slot.change >= 0 ? '+' : ''}${slot.change.toFixed(2)}%` : '‚Äî'
                                                    ),
                                                    hasImpulse && React.createElement('div', { className: "mt-1 h-1 bg-neutral-700 rounded-full overflow-hidden" },
                                                        React.createElement('div', {
                                                            className: `h-full rounded-full ${isBullish ? 'bg-blue-500' : 'bg-red-500'}`,
                                                            style: { width: `${slot.intensity}%` }
                                                        })
                                                    )
                                                );
                                            })
                                        )
                                    )
                                )
                            ),

                            // === COMPRESSION PANEL - ENHANCED ===
                            React.createElement('div', {
                                className: `relative overflow-hidden rounded-xl transition-all duration-300 ${compressionAnalysis.detected
                                    ? 'bg-gradient-to-br from-amber-900/20 via-neutral-900/80 to-neutral-900/80 border border-amber-500/30'
                                    : 'bg-neutral-900/80 border border-neutral-800'
                                    }`
                            },
                                // Accent bar
                                React.createElement('div', {
                                    className: "absolute top-0 left-0 right-0 h-1",
                                    style: { background: 'linear-gradient(90deg, #f59e0b, #ea580c)' }
                                }),
                                React.createElement('div', { className: "p-4 pt-5" },
                                    React.createElement('div', { className: "flex items-center justify-between mb-3" },
                                        React.createElement('div', { className: "flex items-center gap-2" },
                                            React.createElement('h3', { className: "text-xs font-bold text-neutral-300 uppercase tracking-wider" },
                                                "Compression"
                                            ),
                                            // Selector de sensibilidad
                                            React.createElement('div', { className: "flex gap-0.5" },
                                                [1, 2, 3].map(level =>
                                                    React.createElement('button', {
                                                        key: level,
                                                        onClick: () => setCompressionSensitivity(level),
                                                        className: `w-4 h-4 rounded text-[8px] font-bold transition-all ${compressionSensitivity === level
                                                            ? 'bg-amber-500/40 text-amber-300 border border-amber-500/50'
                                                            : 'bg-neutral-800 text-neutral-500 hover:bg-neutral-700'
                                                            }`,
                                                        title: level === 1 ? 'Low' : level === 2 ? 'Medium' : 'High'
                                                    }, level)
                                                )
                                            )
                                        ),
                                        compressionAnalysis.detected
                                            ? React.createElement('span', {
                                                className: "px-2 py-0.5 rounded text-[10px] font-bold bg-amber-500/20 text-amber-400 animate-pulse"
                                            }, `ACTIVE ${compressionAnalysis.compressionLevel}%`)
                                            : React.createElement('span', {
                                                className: "px-2 py-0.5 rounded text-[10px] text-neutral-500"
                                            }, `Vol: ${compressionAnalysis.volRatio}%`)
                                    ),
                                    React.createElement('div', { className: "space-y-3" },
                                        // Compression Level meter
                                        React.createElement('div', null,
                                            React.createElement('div', { className: "flex justify-between text-xs mb-1" },
                                                React.createElement('span', { className: "text-neutral-500" }, "Compression Level"),
                                                React.createElement('span', { className: "font-mono text-amber-400" },
                                                    compressionAnalysis.detected ? `${compressionAnalysis.compressionLevel}%` : "---"
                                                )
                                            ),
                                            React.createElement('div', { className: "h-2 bg-neutral-800 rounded-full overflow-hidden" },
                                                React.createElement('div', {
                                                    className: "h-full rounded-full transition-all",
                                                    style: {
                                                        width: `${compressionAnalysis.compressionLevel || 0}%`,
                                                        background: compressionAnalysis.detected
                                                            ? 'linear-gradient(90deg, #f59e0b, #fbbf24)'
                                                            : 'linear-gradient(90deg, #525252, #737373)'
                                                    }
                                                })
                                            )
                                        ),
                                        // Energy meter
                                        React.createElement('div', null,
                                            React.createElement('div', { className: "flex justify-between text-xs mb-1" },
                                                React.createElement('span', { className: "text-neutral-500" }, "Energy Accumulated"),
                                                React.createElement('span', { className: "font-mono text-orange-400" }, `${compressionAnalysis.energy}%`)
                                            ),
                                            React.createElement('div', { className: "h-1.5 bg-neutral-800 rounded-full overflow-hidden" },
                                                React.createElement('div', {
                                                    className: "h-full rounded-full transition-all",
                                                    style: {
                                                        width: `${compressionAnalysis.energy}%`,
                                                        background: 'linear-gradient(90deg, #ea580c, #fb923c)'
                                                    }
                                                })
                                            )
                                        ),
                                        // Stats
                                        React.createElement('div', { className: "grid grid-cols-3 gap-2 text-xs" },
                                            React.createElement('div', { className: "bg-neutral-800/50 rounded p-2" },
                                                React.createElement('span', { className: "text-neutral-500 block text-[10px]" }, "Vol Ratio"),
                                                React.createElement('span', {
                                                    className: "font-mono",
                                                    style: { color: compressionAnalysis.volRatio < 80 ? '#fbbf24' : '#a3a3a3' }
                                                }, `${compressionAnalysis.volRatio}%`)
                                            ),
                                            React.createElement('div', { className: "bg-neutral-800/50 rounded p-2" },
                                                React.createElement('span', { className: "text-neutral-500 block text-[10px]" }, "Duration"),
                                                React.createElement('span', { className: "font-mono text-neutral-300" }, `${compressionAnalysis.duration}`)
                                            ),
                                            React.createElement('div', { className: "bg-neutral-800/50 rounded p-2" },
                                                React.createElement('span', { className: "text-neutral-500 block text-[10px]" }, "Breakout"),
                                                React.createElement('span', {
                                                    className: "font-medium",
                                                    style: { color: getDirectionColor(compressionAnalysis.direction) }
                                                }, compressionAnalysis.direction === 'NEUTRAL' ? '---' : compressionAnalysis.direction.slice(0, 4))
                                            )
                                        ),
                                        // Top metrics
                                        compressionAnalysis.topMetrics?.length > 0 && React.createElement('div', null,
                                            React.createElement('span', { className: "text-[10px] text-neutral-500 uppercase" }, "Leading Metrics"),
                                            React.createElement('div', { className: "flex gap-1 mt-1 flex-wrap" },
                                                compressionAnalysis.topMetrics.map(m =>
                                                    React.createElement('span', {
                                                        key: m.key,
                                                        className: "px-2 py-0.5 rounded text-[10px] font-medium bg-neutral-800",
                                                        style: { color: getDirectionColor(m.direction) }
                                                    }, `${m.label} ${m.strength.toFixed(0)}%`)
                                                )
                                            )
                                        )
                                    )
                                )
                            ),

                            // === IMPULSE PANEL (Enhanced) ===
                            React.createElement('div', {
                                className: `bg-neutral-900/80 border rounded-lg p-4 ${impulseAnalysis.active
                                    ? (impulseAnalysis.direction === 'BULLISH' ? 'border-blue-500/50' : 'border-red-500/50')
                                    : 'border-neutral-800'}`
                            },
                                React.createElement('div', { className: "flex items-center justify-between mb-3" },
                                    React.createElement('div', { className: "flex items-center gap-2" },
                                        React.createElement('h3', { className: "text-xs font-bold text-neutral-400 uppercase tracking-wider" },
                                            "Impulse"
                                        ),
                                        // Selector de sensibilidad
                                        React.createElement('div', { className: "flex gap-0.5" },
                                            [1, 2, 3].map(level =>
                                                React.createElement('button', {
                                                    key: level,
                                                    onClick: () => setImpulseSensitivity(level),
                                                    className: `w-5 h-5 rounded text-[9px] font-bold transition-all ${impulseSensitivity === level
                                                        ? 'bg-sky-500/30 text-sky-400 border border-sky-500/50'
                                                        : 'bg-neutral-800 text-neutral-500 hover:bg-neutral-700'
                                                        }`,
                                                    title: level === 1 ? 'Low sensitivity' : level === 2 ? 'Medium sensitivity' : 'High sensitivity'
                                                }, level)
                                            )
                                        )
                                    ),
                                    impulseAnalysis.active
                                        ? React.createElement('span', {
                                            className: `px-2 py-0.5 rounded text-[10px] font-bold animate-pulse`,
                                            style: {
                                                backgroundColor: `${getDirectionColor(impulseAnalysis.direction)}20`,
                                                color: getDirectionColor(impulseAnalysis.direction)
                                            }
                                        }, `${impulseAnalysis.direction} ${impulseAnalysis.strength}%`)
                                        : React.createElement('span', {
                                            className: "px-2 py-0.5 rounded text-[10px] text-neutral-500"
                                        }, "Monitoring")
                                ),
                                React.createElement('div', { className: "space-y-3" },
                                    // Combined Strength meter
                                    React.createElement('div', null,
                                        React.createElement('div', { className: "flex justify-between text-xs mb-1" },
                                            React.createElement('span', { className: "text-neutral-500" }, "Combined Score"),
                                            React.createElement('span', {
                                                className: "font-mono",
                                                style: { color: impulseAnalysis.active ? getDirectionColor(impulseAnalysis.direction) : '#666' }
                                            }, `${impulseAnalysis.strength}%`)
                                        ),
                                        React.createElement('div', { className: "h-2 bg-neutral-800 rounded-full overflow-hidden" },
                                            React.createElement('div', {
                                                className: "h-full rounded-full transition-all",
                                                style: {
                                                    width: `${impulseAnalysis.strength}%`,
                                                    backgroundColor: impulseAnalysis.active ? getDirectionColor(impulseAnalysis.direction) : '#525252'
                                                }
                                            })
                                        )
                                    ),
                                    // Exhaustion meter
                                    React.createElement('div', null,
                                        React.createElement('div', { className: "flex justify-between text-xs mb-1" },
                                            React.createElement('span', { className: "text-neutral-500" }, "Exhaustion"),
                                            React.createElement('span', {
                                                className: "font-mono",
                                                style: { color: impulseAnalysis.exhaustion > 60 ? '#fbbf24' : impulseAnalysis.exhaustion > 80 ? '#ef4444' : '#22c55e' }
                                            }, `${impulseAnalysis.exhaustion}%`)
                                        ),
                                        React.createElement('div', { className: "h-1.5 bg-neutral-800 rounded-full overflow-hidden" },
                                            React.createElement('div', {
                                                className: "h-full rounded-full transition-all",
                                                style: {
                                                    width: `${impulseAnalysis.exhaustion}%`,
                                                    background: impulseAnalysis.exhaustion > 60
                                                        ? 'linear-gradient(90deg, #fbbf24, #ef4444)'
                                                        : 'linear-gradient(90deg, #22c55e, #86efac)'
                                                }
                                            })
                                        )
                                    ),
                                    // Multi-factor Stats Grid
                                    React.createElement('div', { className: "grid grid-cols-4 gap-2 text-xs" },
                                        React.createElement('div', { className: "bg-neutral-800/50 rounded p-2" },
                                            React.createElement('span', { className: "text-neutral-500 block text-[10px]" }, "Change"),
                                            React.createElement('span', {
                                                className: "font-mono text-[11px]",
                                                style: { color: (impulseAnalysis.change || 0) >= 0 ? '#3b82f6' : '#ef4444' }
                                            }, `${(impulseAnalysis.change || 0) >= 0 ? '+' : ''}${(impulseAnalysis.change || 0).toFixed(2)}%`)
                                        ),
                                        React.createElement('div', { className: "bg-neutral-800/50 rounded p-2" },
                                            React.createElement('span', { className: "text-neutral-500 block text-[10px]" }, "Velocity"),
                                            React.createElement('span', {
                                                className: "font-mono text-[11px]",
                                                style: { color: (impulseAnalysis.velocity || 0) >= 0 ? '#3b82f6' : '#ef4444' }
                                            }, `${(impulseAnalysis.velocity || 0) >= 0 ? '+' : ''}${(impulseAnalysis.velocity || 0).toFixed(2)}`)
                                        ),
                                        React.createElement('div', { className: "bg-neutral-800/50 rounded p-2" },
                                            React.createElement('span', { className: "text-neutral-500 block text-[10px]" }, "Accel"),
                                            React.createElement('span', {
                                                className: "font-mono text-[11px]",
                                                style: { color: (impulseAnalysis.acceleration || 0) >= 0 ? '#22c55e' : '#ef4444' }
                                            }, `${(impulseAnalysis.acceleration || 0) >= 0 ? '+' : ''}${(impulseAnalysis.acceleration || 0).toFixed(2)}`)
                                        ),
                                        React.createElement('div', { className: "bg-neutral-800/50 rounded p-2" },
                                            React.createElement('span', { className: "text-neutral-500 block text-[10px]" }, "Consist"),
                                            React.createElement('span', {
                                                className: "font-mono text-[11px]",
                                                style: { color: (impulseAnalysis.consistency || 0) >= 3 ? '#22c55e' : '#a3a3a3' }
                                            }, `${impulseAnalysis.consistency || 0} bars`)
                                        )
                                    ),
                                    // Top metrics
                                    impulseAnalysis.topMetrics?.length > 0 && React.createElement('div', null,
                                        React.createElement('span', { className: "text-[10px] text-neutral-500 uppercase" }, "Driving Metrics"),
                                        React.createElement('div', { className: "flex gap-1 mt-1 flex-wrap" },
                                            impulseAnalysis.topMetrics.map(m =>
                                                React.createElement('span', {
                                                    key: m.key,
                                                    className: "px-2 py-0.5 rounded text-[10px] font-medium",
                                                    style: {
                                                        backgroundColor: `${getDirectionColor(m.direction)}20`,
                                                        color: getDirectionColor(m.direction)
                                                    }
                                                }, `${m.label} ${m.strength.toFixed(0)}%`)
                                            )
                                        )
                                    )
                                )
                            )
                        ) // Cierre del grid de 4 columnas
                    ), // Cierre del Analytics Grid container

                    // === PIVOT HISTORY - FULL WIDTH ===
                    visibleModules.pivots && React.createElement('div', {
                        className: "w-full bg-neutral-900/80 border border-neutral-800 rounded-lg p-4 relative mt-4"
                    },
                        React.createElement('div', { className: "flex items-center justify-between mb-3" },
                            React.createElement('div', { className: "flex items-center gap-2" },
                                React.createElement('h3', { className: "text-xs font-bold text-neutral-400 uppercase tracking-wider" },
                                    "Pivots"
                                ),
                                // Selector de sensibilidad
                                React.createElement('div', { className: "flex gap-0.5" },
                                    [1, 2, 3].map(level =>
                                        React.createElement('button', {
                                            key: level,
                                            onClick: () => setPivotSensitivity(level),
                                            className: `w-5 h-5 rounded text-[9px] font-bold transition-all ${pivotSensitivity === level
                                                ? 'bg-emerald-500/30 text-emerald-400 border border-emerald-500/50'
                                                : 'bg-neutral-800 text-neutral-500 hover:bg-neutral-700'
                                                }`,
                                            title: level === 1 ? 'Low (strict)' : level === 2 ? 'Medium' : 'High (all pivots)'
                                        }, level)
                                    )
                                ),
                                // Separador
                                React.createElement('div', { className: "w-px h-4 bg-neutral-700 mx-1" }),
                                // Bot√≥n filtro de m√©tricas
                                React.createElement('button', {
                                    onClick: () => setShowPivotMetricSelector(!showPivotMetricSelector),
                                    className: `px-2 py-1 rounded text-[9px] font-medium transition-all flex items-center gap-1 ${pivotMetricFilter
                                        ? 'bg-amber-500/30 text-amber-400 border border-amber-500/50'
                                        : 'bg-neutral-800 text-neutral-500 hover:bg-neutral-700 border border-neutral-700'
                                        }`,
                                    title: pivotMetricFilter ? `Filtering: ${pivotMetricFilter.join(', ')}` : 'Filter by metric'
                                },
                                    React.createElement('span', null, 'F'),
                                    pivotMetricFilter ? `${pivotMetricFilter.length}` : 'All'
                                )
                            ),
                            React.createElement('div', { className: "flex items-center gap-2" },
                                pivotMetricFilter && React.createElement('button', {
                                    onClick: () => setPivotMetricFilter(null),
                                    className: "text-[9px] text-neutral-500 hover:text-red-400 transition-colors",
                                    title: "Clear filter"
                                }, "X"),
                                React.createElement('span', { className: "text-[10px] text-neutral-500" },
                                    `${(() => {
                                        const filtered = pivotMetricFilter
                                            ? (pivotAnalysis.pivots || []).filter(p => p.topMetrics?.some(m => pivotMetricFilter.includes(m.key)))
                                            : (pivotAnalysis.pivots || []);
                                        return filtered.length;
                                    })()} detected`
                                )
                            )
                        ),
                        // Dropdown selector de m√©tricas
                        showPivotMetricSelector && React.createElement('div', {
                            ref: pivotMetricSelectorRef,
                            className: "absolute top-12 left-4 z-50 bg-neutral-800 border border-neutral-600 rounded-lg shadow-xl p-3 min-w-[200px]"
                        },
                            React.createElement('div', { className: "flex items-center justify-between mb-2" },
                                React.createElement('span', { className: "text-[10px] text-neutral-400 uppercase font-medium" }, "Filter by Metric"),
                                React.createElement('button', {
                                    onClick: () => setShowPivotMetricSelector(false),
                                    className: "text-neutral-500 hover:text-neutral-300 text-xs"
                                }, "√ó")
                            ),
                            React.createElement('div', { className: "grid grid-cols-2 gap-1 mb-2" },
                                Object.entries(constants.SIGNAL_METRICS).map(([key, config]) =>
                                    React.createElement('button', {
                                        key: key,
                                        onClick: () => {
                                            setPivotMetricFilter(prev => {
                                                if (!prev) return [key];
                                                if (prev.includes(key)) {
                                                    const newFilter = prev.filter(k => k !== key);
                                                    return newFilter.length === 0 ? null : newFilter;
                                                }
                                                return [...prev, key];
                                            });
                                        },
                                        className: `px-2 py-1 rounded text-[9px] font-medium transition-all ${pivotMetricFilter?.includes(key)
                                            ? 'bg-emerald-500/30 text-emerald-400 border border-emerald-500/50'
                                            : 'bg-neutral-700/50 text-neutral-400 hover:bg-neutral-600/50 border border-transparent'
                                            }`
                                    }, config.shortLabel)
                                )
                            ),
                            React.createElement('div', { className: "flex gap-1 mt-2 pt-2 border-t border-neutral-700" },
                                React.createElement('button', {
                                    onClick: () => setPivotMetricFilter(null),
                                    className: "flex-1 px-2 py-1 rounded text-[9px] bg-neutral-700 text-neutral-300 hover:bg-neutral-600"
                                }, "Show All"),
                                React.createElement('button', {
                                    onClick: () => setShowPivotMetricSelector(false),
                                    className: "flex-1 px-2 py-1 rounded text-[9px] bg-emerald-600/50 text-emerald-300 hover:bg-emerald-500/50"
                                }, "Apply")
                            )
                        ),
                        // Lista de pivots filtrada
                        (() => {
                            const filteredPivots = pivotMetricFilter
                                ? (pivotAnalysis.pivots || []).filter(p => p.topMetrics?.some(m => pivotMetricFilter.includes(m.key)))
                                : (pivotAnalysis.pivots || []);
                            return filteredPivots.length > 0
                                ? React.createElement('div', { className: "flex gap-2 overflow-x-auto pb-2" },
                                    filteredPivots.slice().reverse().map((pivot, idx) =>
                                        React.createElement('div', {
                                            key: idx,
                                            className: `flex-shrink-0 p-3 rounded-lg border ${pivot.type === 'HIGH'
                                                ? 'bg-red-900/20 border-red-500/30'
                                                : 'bg-green-900/20 border-green-500/30'}`
                                        },
                                            React.createElement('div', { className: "flex items-center gap-2 mb-1" },
                                                React.createElement('span', {
                                                    className: "text-sm",
                                                    style: { color: pivot.type === 'HIGH' ? '#ef4444' : '#22c55e' }
                                                }, pivot.type === 'HIGH' ? 'v' : '^'),
                                                React.createElement('span', { className: "text-xs font-medium text-neutral-300" },
                                                    pivot.type
                                                ),
                                                React.createElement('span', { className: "text-[10px] text-neutral-500" },
                                                    `${pivot.barsAgo}b`
                                                )
                                            ),
                                            React.createElement('div', { className: "text-xs font-mono text-neutral-400 mb-1" },
                                                `$${pivot.price?.toFixed(2) || 'N/A'}`
                                            ),
                                            React.createElement('div', { className: "flex gap-1 flex-wrap" },
                                                (pivot.topMetrics || []).slice(0, 2).map(m =>
                                                    React.createElement('span', {
                                                        key: m.key,
                                                        className: `px-1.5 py-0.5 rounded text-[9px] font-medium ${pivotMetricFilter?.includes(m.key)
                                                            ? 'bg-amber-500/30 text-amber-400'
                                                            : 'bg-neutral-800 text-neutral-400'
                                                            }`
                                                    }, m.label)
                                                )
                                            )
                                        )
                                    )
                                )
                                : React.createElement('p', { className: "text-xs text-neutral-500" },
                                    pivotMetricFilter ? "No pivots with selected metrics" : "No pivots detected"
                                );
                        })()
                    ),

                    // === ABSORPTION PIVOTS PANEL - FULL WIDTH ===
                    visibleModules.absorption && React.createElement('div', {
                        className: `w-full relative overflow-hidden rounded-xl border-2 transition-all duration-300 mt-4 ${absorptionAnalysis.activeAbsorption && absorptionAnalysis.totalAbsorptions > 0
                            ? absorptionAnalysis.dominantSide === 'BULLISH'
                                ? 'bg-gradient-to-br from-emerald-900/40 via-emerald-800/30 to-emerald-900/40 border-emerald-500 shadow-lg shadow-emerald-500/20'
                                : absorptionAnalysis.dominantSide === 'BEARISH'
                                    ? 'bg-gradient-to-br from-rose-900/40 via-rose-800/30 to-rose-900/40 border-rose-500 shadow-lg shadow-rose-500/20'
                                    : 'bg-gradient-to-br from-purple-900/40 via-purple-800/30 to-purple-900/40 border-purple-500 shadow-lg shadow-purple-500/20'
                            : 'bg-neutral-900/60 border-neutral-800'
                            }`
                    },
                        // Header
                        React.createElement('div', {
                            className: "px-4 py-3 border-b border-neutral-800/50 flex flex-col sm:flex-row items-start sm:items-center justify-between gap-2"
                        },
                            React.createElement('div', { className: "flex items-center gap-3" },
                                absorptionAnalysis.activeAbsorption && React.createElement('div', {
                                    className: `w-3 h-10 rounded-full animate-pulse ${absorptionAnalysis.dominantSide === 'BULLISH' ? 'bg-emerald-500 shadow-lg shadow-emerald-500/50'
                                        : absorptionAnalysis.dominantSide === 'BEARISH' ? 'bg-rose-500 shadow-lg shadow-rose-500/50'
                                            : 'bg-purple-500 shadow-lg shadow-purple-500/50'
                                        }`
                                }),
                                !absorptionAnalysis.activeAbsorption && React.createElement('div', { className: "w-3 h-10 rounded-full bg-neutral-600" }),
                                React.createElement('div', null,
                                    React.createElement('div', { className: "flex items-center gap-2" },
                                        React.createElement('h3', { className: "text-sm font-bold text-neutral-300 uppercase tracking-wider" },
                                            "Absorption Zones"
                                        ),
                                        // Selector de sensibilidad
                                        React.createElement('div', { className: "flex gap-0.5" },
                                            [1, 2, 3].map(level =>
                                                React.createElement('button', {
                                                    key: level,
                                                    onClick: () => setAbsorptionSensitivity(level),
                                                    className: `w-4 h-4 rounded text-[8px] font-bold transition-all ${absorptionSensitivity === level
                                                        ? 'bg-pink-500/40 text-pink-300 border border-pink-500/50'
                                                        : 'bg-neutral-800 text-neutral-500 hover:bg-neutral-700'
                                                        }`,
                                                    title: level === 1 ? 'Low (strict)' : level === 2 ? 'Medium' : 'High (sensitive)'
                                                }, level)
                                            )
                                        ),
                                        // NUEVO: Selector de filtro de m√©tricas igual que pivots
                                        // Separador
                                        React.createElement('div', { className: "w-px h-4 bg-neutral-700 mx-1" }),
                                        // Bot√≥n filtro de m√©tricas
                                        React.createElement('button', {
                                            onClick: () => setShowAbsorptionMetricSelector(!showAbsorptionMetricSelector),
                                            className: `px-2 py-1 rounded text-[9px] font-medium transition-all flex items-center gap-1 ${absorptionMetricFilter
                                                ? 'bg-pink-500/30 text-pink-400 border border-pink-500/50'
                                                : 'bg-neutral-800 text-neutral-500 hover:bg-neutral-700 border border-neutral-700'
                                                }`,
                                            title: absorptionMetricFilter ? `Filtering: ${absorptionMetricFilter.join(', ')}` : 'Filter by factor'
                                        },
                                            React.createElement('span', null, 'üéØ'),
                                            absorptionMetricFilter ? `${absorptionMetricFilter.length}` : 'All'
                                        ),
                                        // Bot√≥n para limpiar filtro
                                        absorptionMetricFilter && React.createElement('button', {
                                            onClick: () => setAbsorptionMetricFilter(null),
                                            className: "text-[9px] text-neutral-500 hover:text-red-400 transition-colors ml-1",
                                            title: "Clear filter"
                                        }, "‚úï")
                                    ),
                                    React.createElement('p', { className: "text-[10px] text-neutral-500" },
                                        "Institutional activity detection - price absorption zones"
                                    )
                                )
                            ),
                            // Status badges
                            React.createElement('div', { className: "flex items-center gap-2 flex-wrap" },
                                absorptionAnalysis.activeAbsorption && React.createElement('span', {
                                    className: `text-xs font-bold px-3 py-1.5 rounded-lg animate-pulse ${absorptionAnalysis.dominantSide === 'BULLISH'
                                        ? 'bg-emerald-500/30 text-emerald-400 border border-emerald-500/50'
                                        : absorptionAnalysis.dominantSide === 'BEARISH'
                                            ? 'bg-rose-500/30 text-rose-400 border border-rose-500/50'
                                            : 'bg-purple-500/30 text-purple-400 border border-purple-500/50'
                                        }`
                                }, `ABSORPTION ${absorptionAnalysis.dominantSide}`),
                                React.createElement('span', {
                                    className: "text-[10px] font-mono px-2 py-1 rounded bg-emerald-500/20 text-emerald-400 border border-emerald-500/30"
                                }, `${absorptionAnalysis.bullishCount} Bullish`),
                                React.createElement('span', {
                                    className: "text-[10px] font-mono px-2 py-1 rounded bg-rose-500/20 text-rose-400 border border-rose-500/30"
                                }, `${absorptionAnalysis.bearishCount} Bearish`),
                                React.createElement('span', {
                                    className: `text-[10px] font-mono px-2 py-1 rounded ${absorptionAnalysis.institutionalActivity > 50
                                        ? 'bg-amber-500/20 text-amber-400 border border-amber-500/30'
                                        : 'bg-neutral-800 text-neutral-400 border border-neutral-700'
                                        }`
                                }, `${absorptionAnalysis.institutionalActivity}% Institutional`)
                            )
                        ),

                        // Dropdown selector de m√©tricas para absorci√≥n (igual que pivots)
                        showAbsorptionMetricSelector && React.createElement('div', {
                            ref: absorptionMetricSelectorRef,
                            className: "absolute top-20 left-4 z-50 bg-neutral-800 border border-neutral-600 rounded-lg shadow-xl p-3 min-w-[220px]"
                        },
                            React.createElement('div', { className: "flex items-center justify-between mb-2" },
                                React.createElement('span', { className: "text-[10px] text-neutral-400 uppercase font-medium" }, "Filter by Absorption Factor"),
                                React.createElement('button', {
                                    onClick: () => setShowAbsorptionMetricSelector(false),
                                    className: "text-neutral-500 hover:text-neutral-300 text-xs"
                                }, "√ó")
                            ),
                            React.createElement('div', { className: "grid grid-cols-2 gap-1 mb-2" },
                                Object.entries(ABSORPTION_FACTORS).map(([key, config]) =>
                                    React.createElement('button', {
                                        key: key,
                                        onClick: () => {
                                            setAbsorptionMetricFilter(prev => {
                                                if (!prev) return [key];
                                                if (prev.includes(key)) {
                                                    const newFilter = prev.filter(k => k !== key);
                                                    return newFilter.length === 0 ? null : newFilter;
                                                }
                                                return [...prev, key];
                                            });
                                        },
                                        className: `px-2 py-1.5 rounded text-[9px] font-medium transition-all ${absorptionMetricFilter?.includes(key)
                                            ? 'bg-pink-500/30 text-pink-400 border border-pink-500/50'
                                            : 'bg-neutral-700/50 text-neutral-400 hover:bg-neutral-600/50 border border-transparent'
                                            }`
                                    }, config.shortLabel)
                                )
                            ),
                            React.createElement('div', { className: "flex gap-1 mt-2 pt-2 border-t border-neutral-700" },
                                React.createElement('button', {
                                    onClick: () => setAbsorptionMetricFilter(null),
                                    className: "flex-1 px-2 py-1 rounded text-[9px] bg-neutral-700 text-neutral-300 hover:bg-neutral-600"
                                }, "Show All"),
                                React.createElement('button', {
                                    onClick: () => setShowAbsorptionMetricSelector(false),
                                    className: "flex-1 px-2 py-1 rounded text-[9px] bg-pink-600/50 text-pink-300 hover:bg-pink-500/50"
                                }, "Apply")
                            )
                        ),

                        // Filtrar zonas por m√©trica seleccionada (ahora usa array como pivots)
                        (() => {
                            const filteredZones = absorptionMetricFilter && absorptionMetricFilter.length > 0
                                ? absorptionAnalysis.zones.filter(z => z.factors && z.factors.some(f => absorptionMetricFilter.includes(f)))
                                : absorptionAnalysis.zones;

                            return React.createElement('div', { className: "p-4" },

                                // FILA 1: Absorption Summary Bar
                                React.createElement('div', {
                                    className: `rounded-xl p-4 mb-4 ${absorptionAnalysis.activeAbsorption
                                        ? 'bg-gradient-to-r from-pink-500/10 via-purple-500/10 to-pink-500/10 border border-pink-500/30'
                                        : 'bg-neutral-800/50'
                                        }`
                                },
                                    React.createElement('div', { className: "flex flex-wrap items-center justify-between gap-4" },
                                        // Status
                                        React.createElement('div', { className: "flex items-center gap-3" },
                                            React.createElement('span', { className: "text-sm text-neutral-400 uppercase font-bold" }, "Status"),
                                            React.createElement('span', {
                                                className: `text-lg font-bold ${absorptionAnalysis.activeAbsorption ? 'text-pink-400' : 'text-neutral-500'
                                                    }`
                                            }, absorptionAnalysis.activeAbsorption ? 'ACTIVE' : 'MONITORING'),
                                            absorptionAnalysis.activeAbsorption && React.createElement('div', {
                                                className: "w-3 h-3 rounded-full animate-pulse bg-pink-500"
                                            })
                                        ),
                                        // Total zones
                                        React.createElement('div', { className: "flex items-center gap-2" },
                                            React.createElement('span', { className: "text-xs text-neutral-500" }, "Zones:"),
                                            React.createElement('span', { className: "text-lg font-bold text-pink-400 font-mono" },
                                                absorptionAnalysis.totalAbsorptions
                                            )
                                        ),
                                        // Absorption strength
                                        React.createElement('div', { className: "flex items-center gap-2" },
                                            React.createElement('span', { className: "text-xs text-neutral-500" }, "Strength:"),
                                            React.createElement('span', {
                                                className: "text-lg font-bold font-mono",
                                                style: {
                                                    color: absorptionAnalysis.absorptionStrength === 'INSTITUTIONAL' ? '#f59e0b'
                                                        : absorptionAnalysis.absorptionStrength === 'MAJOR' ? '#a855f7'
                                                            : absorptionAnalysis.absorptionStrength === 'MODERATE' ? '#3b82f6'
                                                                : '#737373'
                                                }
                                            }, absorptionAnalysis.absorptionStrength)
                                        ),
                                        // Recent 
                                        React.createElement('div', { className: "flex items-center gap-2" },
                                            React.createElement('span', { className: "text-xs text-neutral-500" }, "Recent:"),
                                            React.createElement('span', {
                                                className: `text-lg font-bold font-mono ${absorptionAnalysis.recentAbsorptions > 0 ? 'text-amber-400' : 'text-neutral-500'}`
                                            }, absorptionAnalysis.recentAbsorptions)
                                        )
                                    )
                                ),

                                // FILA 2: Absorption Zones Grid
                                filteredZones.length > 0 && React.createElement('div', {
                                    className: "mb-4"
                                },
                                    React.createElement('div', { className: "flex items-center justify-between text-xs text-neutral-400 uppercase font-bold tracking-wide mb-3" },
                                        React.createElement('span', null, "Active Absorption Zones"),
                                        absorptionMetricFilter && absorptionMetricFilter.length > 0 && React.createElement('span', {
                                            className: "text-pink-400 normal-case"
                                        }, `Filtered: ${absorptionMetricFilter.join(', ')}`)
                                    ),
                                    React.createElement('div', { className: "grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-3" },
                                        filteredZones.slice(0, 6).map((zone, idx) =>
                                            React.createElement('div', {
                                                key: idx,
                                                className: `rounded-lg p-3 border transition-all ${zone.class === 'INSTITUTIONAL'
                                                    ? 'bg-amber-500/10 border-amber-500/40 shadow-lg shadow-amber-500/10'
                                                    : zone.class === 'MAJOR'
                                                        ? 'bg-purple-500/10 border-purple-500/30'
                                                        : zone.class === 'MODERATE'
                                                            ? 'bg-blue-500/10 border-blue-500/30'
                                                            : 'bg-neutral-800/50 border-neutral-700'
                                                    }`
                                            },
                                                // Zone header
                                                React.createElement('div', { className: "flex items-center justify-between mb-2" },
                                                    React.createElement('div', { className: "flex items-center gap-2" },
                                                        React.createElement('span', {
                                                            className: `w-2 h-2 rounded-full ${zone.type === 'BULLISH' ? 'bg-emerald-500'
                                                                : zone.type === 'BEARISH' ? 'bg-rose-500'
                                                                    : 'bg-purple-500'
                                                                }`
                                                        }),
                                                        React.createElement('span', {
                                                            className: `text-xs font-bold ${zone.type === 'BULLISH' ? 'text-emerald-400'
                                                                : zone.type === 'BEARISH' ? 'text-rose-400'
                                                                    : 'text-purple-400'
                                                                }`
                                                        }, zone.type)
                                                    ),
                                                    React.createElement('span', {
                                                        className: `text-[10px] px-2 py-0.5 rounded-full font-bold ${zone.class === 'INSTITUTIONAL'
                                                            ? 'bg-amber-500/30 text-amber-400'
                                                            : zone.class === 'MAJOR'
                                                                ? 'bg-purple-500/30 text-purple-400'
                                                                : 'bg-neutral-700 text-neutral-400'
                                                            }`
                                                    }, zone.class)
                                                ),
                                                // Price level
                                                React.createElement('div', { className: "text-lg font-mono font-bold text-neutral-200 mb-2" },
                                                    zone.price ? `$${zone.price.toFixed(2)}` : '---'
                                                ),
                                                // Score bar
                                                React.createElement('div', { className: "mb-2" },
                                                    React.createElement('div', { className: "flex justify-between text-[10px] mb-1" },
                                                        React.createElement('span', { className: "text-neutral-500" }, "Score"),
                                                        React.createElement('span', {
                                                            className: "font-mono",
                                                            style: { color: zone.score >= 80 ? '#f59e0b' : zone.score >= 60 ? '#a855f7' : '#3b82f6' }
                                                        }, `${zone.score}%`)
                                                    ),
                                                    React.createElement('div', { className: "h-1.5 bg-neutral-700 rounded-full overflow-hidden" },
                                                        React.createElement('div', {
                                                            className: "h-full rounded-full transition-all",
                                                            style: {
                                                                width: `${zone.score}%`,
                                                                background: zone.score >= 80
                                                                    ? 'linear-gradient(90deg, #f59e0b, #fbbf24)'
                                                                    : zone.score >= 60
                                                                        ? 'linear-gradient(90deg, #a855f7, #c084fc)'
                                                                        : 'linear-gradient(90deg, #3b82f6, #60a5fa)'
                                                            }
                                                        })
                                                    )
                                                ),
                                                // Factors
                                                React.createElement('div', { className: "flex flex-wrap gap-1" },
                                                    zone.factors.slice(0, 4).map((factor, fIdx) =>
                                                        React.createElement('span', {
                                                            key: fIdx,
                                                            className: `text-[9px] px-1.5 py-0.5 rounded font-medium ${factor === 'DELTA_DIV' ? 'bg-blue-500/20 text-blue-400'
                                                                : factor === 'VOL_ABS' ? 'bg-purple-500/20 text-purple-400'
                                                                    : factor === 'OPT_FLOW' ? 'bg-cyan-500/20 text-cyan-400'
                                                                        : factor === 'GEX_PIN' ? 'bg-amber-500/20 text-amber-400'
                                                                            : factor === 'SM_DIV' ? 'bg-emerald-500/20 text-emerald-400'
                                                                                : factor === 'VANNA' ? 'bg-pink-500/20 text-pink-400'
                                                                                    : 'bg-neutral-700 text-neutral-400'
                                                                }`
                                                        }, factor)
                                                    )
                                                )
                                            )
                                        )
                                    )
                                ),

                                // FILA 3: Key Levels & Stats
                                React.createElement('div', { className: "grid grid-cols-1 lg:grid-cols-2 gap-4" },

                                    // Key Price Levels
                                    React.createElement('div', { className: "bg-neutral-800/50 rounded-xl p-4" },
                                        React.createElement('div', { className: "text-xs text-pink-400 uppercase font-bold tracking-wide mb-3" },
                                            "Key Absorption Levels"
                                        ),
                                        absorptionAnalysis.keyLevels.length > 0
                                            ? React.createElement('div', { className: "space-y-2" },
                                                absorptionAnalysis.keyLevels.slice(0, 5).map((level, idx) =>
                                                    React.createElement('div', {
                                                        key: idx,
                                                        className: "flex items-center justify-between p-2 rounded-lg bg-neutral-900/50"
                                                    },
                                                        React.createElement('div', { className: "flex items-center gap-2" },
                                                            React.createElement('span', {
                                                                className: `w-3 h-3 rounded-full ${level.type === 'BULLISH' ? 'bg-emerald-500'
                                                                    : level.type === 'BEARISH' ? 'bg-rose-500'
                                                                        : 'bg-purple-500'
                                                                    }`
                                                            }),
                                                            React.createElement('span', { className: "text-sm font-mono font-bold text-neutral-200" },
                                                                `$${level.price.toFixed(2)}`
                                                            )
                                                        ),
                                                        React.createElement('div', { className: "flex items-center gap-2" },
                                                            React.createElement('span', {
                                                                className: `text-[10px] font-bold ${level.strength >= 80 ? 'text-amber-400'
                                                                    : level.strength >= 60 ? 'text-purple-400'
                                                                        : 'text-neutral-400'
                                                                    }`
                                                            }, `${level.strength}%`),
                                                            React.createElement('span', {
                                                                className: `text-[9px] px-1.5 py-0.5 rounded ${level.type === 'BULLISH' ? 'bg-emerald-500/20 text-emerald-400'
                                                                    : level.type === 'BEARISH' ? 'bg-rose-500/20 text-rose-400'
                                                                        : 'bg-purple-500/20 text-purple-400'
                                                                    }`
                                                            }, level.type)
                                                        )
                                                    )
                                                )
                                            )
                                            : React.createElement('p', { className: "text-xs text-neutral-500 text-center py-4" },
                                                "No absorption levels detected"
                                            )
                                    ),

                                    // Stats summary
                                    React.createElement('div', { className: "bg-neutral-800/50 rounded-xl p-4" },
                                        React.createElement('div', { className: "text-xs text-pink-400 uppercase font-bold tracking-wide mb-3" },
                                            "Absorption Statistics"
                                        ),
                                        React.createElement('div', { className: "grid grid-cols-2 gap-3" },
                                            // Bullish vs Bearish ratio
                                            React.createElement('div', { className: "bg-neutral-900/50 rounded-lg p-3" },
                                                React.createElement('span', { className: "text-[10px] text-neutral-500 block mb-1" }, "Bull/Bear Ratio"),
                                                React.createElement('div', { className: "flex items-baseline gap-1" },
                                                    React.createElement('span', { className: "text-xl font-bold text-emerald-400 font-mono" },
                                                        absorptionAnalysis.bullishCount
                                                    ),
                                                    React.createElement('span', { className: "text-neutral-500" }, "/"),
                                                    React.createElement('span', { className: "text-xl font-bold text-rose-400 font-mono" },
                                                        absorptionAnalysis.bearishCount
                                                    )
                                                )
                                            ),
                                            // Institutional %
                                            React.createElement('div', { className: "bg-neutral-900/50 rounded-lg p-3" },
                                                React.createElement('span', { className: "text-[10px] text-neutral-500 block mb-1" }, "Institutional Activity"),
                                                React.createElement('span', {
                                                    className: "text-xl font-bold font-mono",
                                                    style: { color: absorptionAnalysis.institutionalActivity > 50 ? '#f59e0b' : '#737373' }
                                                }, `${absorptionAnalysis.institutionalActivity}%`)
                                            ),
                                            // Total zones
                                            React.createElement('div', { className: "bg-neutral-900/50 rounded-lg p-3" },
                                                React.createElement('span', { className: "text-[10px] text-neutral-500 block mb-1" }, "Total Zones"),
                                                React.createElement('span', { className: "text-xl font-bold text-pink-400 font-mono" },
                                                    absorptionAnalysis.totalAbsorptions
                                                )
                                            ),
                                            // Dominant
                                            React.createElement('div', { className: "bg-neutral-900/50 rounded-lg p-3" },
                                                React.createElement('span', { className: "text-[10px] text-neutral-500 block mb-1" }, "Dominant Side"),
                                                React.createElement('span', {
                                                    className: `text-lg font-bold ${absorptionAnalysis.dominantSide === 'BULLISH' ? 'text-emerald-400'
                                                        : absorptionAnalysis.dominantSide === 'BEARISH' ? 'text-rose-400'
                                                            : 'text-purple-400'
                                                        }`
                                                }, absorptionAnalysis.dominantSide)
                                            )
                                        )
                                    )
                                )
                            );
                        })() // Cierre del IIFE de filteredZones
                    ),

                    // === NARRADOR EN ESPA√ëOL - AN√ÅLISIS EN TIEMPO REAL ===
                    visibleModules.narrator && React.createElement('div', {
                        className: "w-full mt-4 bg-gradient-to-br from-neutral-900 via-neutral-900/95 to-neutral-950 rounded-xl border border-neutral-700/50 shadow-2xl"
                    },
                        // Header con indicadores principales
                        React.createElement('div', {
                            className: "flex items-center justify-between px-5 py-3 border-b border-neutral-800/80 bg-gradient-to-r from-neutral-800/50 to-transparent"
                        },
                            React.createElement('div', { className: "flex items-center gap-3" },
                                React.createElement('div', {
                                    className: `w-2 h-8 rounded-full ${impulseAnalysis.active
                                        ? impulseAnalysis.direction === 'BULLISH' ? 'bg-blue-500 shadow-lg shadow-blue-500/50' : 'bg-red-500 shadow-lg shadow-red-500/50'
                                        : compressionAnalysis.detected ? 'bg-amber-500 animate-pulse' : 'bg-neutral-600'
                                        }`
                                }),
                                React.createElement('div', null,
                                    React.createElement('h3', { className: "text-sm font-semibold text-neutral-200 tracking-wide" },
                                        "NARRADOR DE MERCADO"
                                    ),
                                    React.createElement('p', { className: "text-[10px] text-neutral-500" },
                                        `Analisis en tiempo real | ${new Date().toLocaleTimeString('es-ES')}`
                                    )
                                )
                            ),
                            React.createElement('div', { className: "flex items-center gap-3" },
                                // Indicador LATERAL/TENDENCIAL
                                React.createElement('div', {
                                    className: `px-4 py-2 rounded-lg text-sm font-bold border-2 ${impulseAnalysis.active
                                        ? impulseAnalysis.direction === 'BULLISH'
                                            ? 'bg-blue-500/20 text-blue-400 border-blue-500/50 shadow-lg shadow-blue-500/20'
                                            : 'bg-red-500/20 text-red-400 border-red-500/50 shadow-lg shadow-red-500/20'
                                        : 'bg-amber-500/20 text-amber-400 border-amber-500/50 animate-pulse'
                                        }`
                                }, impulseAnalysis.active ? 'TENDENCIAL' : 'LATERAL'),
                                // Sentimiento
                                React.createElement('div', {
                                    className: `px-3 py-1.5 rounded-lg text-xs font-medium border ${(topMetricsGlobal.filter(m => m.direction === 'BULLISH').length > topMetricsGlobal.filter(m => m.direction === 'BEARISH').length)
                                        ? 'bg-blue-500/10 text-blue-400 border-blue-500/30'
                                        : (topMetricsGlobal.filter(m => m.direction === 'BEARISH').length > topMetricsGlobal.filter(m => m.direction === 'BULLISH').length)
                                            ? 'bg-red-500/10 text-red-400 border-red-500/30'
                                            : 'bg-neutral-700/50 text-neutral-400 border-neutral-600'
                                        }`
                                },
                                    topMetricsGlobal.filter(m => m.direction === 'BULLISH').length > topMetricsGlobal.filter(m => m.direction === 'BEARISH').length ? 'ALCISTA' :
                                        topMetricsGlobal.filter(m => m.direction === 'BEARISH').length > topMetricsGlobal.filter(m => m.direction === 'BULLISH').length ? 'BAJISTA' : 'NEUTRAL'
                                )
                            )
                        ),

                        // Cuerpo del narrador
                        React.createElement('div', { className: "p-4 space-y-3" },

                            // ANALISIS PRINCIPAL EN TEXTO
                            React.createElement('div', {
                                className: `bg-neutral-800/40 rounded-lg p-4 border-l-4 ${impulseAnalysis.active
                                    ? impulseAnalysis.direction === 'BULLISH' ? 'border-l-blue-500' : 'border-l-red-500'
                                    : 'border-l-amber-500'
                                    }`
                            },
                                React.createElement('div', { className: "text-sm text-neutral-200 leading-relaxed space-y-3" },

                                    // ESTADO DEL MERCADO: LATERAL O TENDENCIAL
                                    React.createElement('p', null,
                                        React.createElement('span', { className: "text-white font-bold" }, "ESTADO: "),
                                        impulseAnalysis.active
                                            ? React.createElement('span', { className: impulseAnalysis.direction === 'BULLISH' ? 'text-blue-400' : 'text-red-400' },
                                                `Mercado en TENDENCIA ${impulseAnalysis.direction === 'BULLISH' ? 'ALCISTA' : 'BAJISTA'}. `,
                                                `Fuerza del impulso: ${(impulseAnalysis.strength || 0).toFixed(0)}%. `,
                                                `Velocidad: ${(impulseAnalysis.velocity || 0) >= 0 ? '+' : ''}${(impulseAnalysis.velocity || 0).toFixed(2)}. `,
                                                `Aceleracion: ${(impulseAnalysis.acceleration || 0) >= 0 ? '+' : ''}${(impulseAnalysis.acceleration || 0).toFixed(2)}. `,
                                                (impulseAnalysis.acceleration || 0) > 0.5 ? 'ACELERANDO - momentum creciente.' :
                                                    (impulseAnalysis.acceleration || 0) < -0.5 ? 'DESACELERANDO - posible agotamiento.' :
                                                        'Velocidad estable.'
                                            )
                                            : React.createElement('span', { className: "text-amber-400" },
                                                `Mercado LATERAL en consolidacion. `,
                                                compressionAnalysis.detected
                                                    ? `Energia acumulada: ${(compressionAnalysis.energy || 0).toFixed(0)}%. ${compressionAnalysis.energy > 70 ? 'ALTA probabilidad de ruptura inminente.' : 'Esperando catalizador.'}`
                                                    : 'Sin presion direccional significativa. Operar con cautela en rangos.'
                                            )
                                    ),

                                    // CAMBIOS DE VELOCIDAD
                                    React.createElement('p', null,
                                        React.createElement('span', { className: "text-white font-bold" }, "VELOCIDAD: "),
                                        (() => {
                                            const vel = impulseAnalysis.velocity || 0;
                                            const accel = impulseAnalysis.acceleration || 0;
                                            if (Math.abs(accel) > 1) {
                                                return React.createElement('span', { className: accel > 0 ? 'text-emerald-400' : 'text-rose-400' },
                                                    accel > 0
                                                        ? `ACELERACION DETECTADA (+${accel.toFixed(2)}). El precio esta ganando momentum ${vel > 0 ? 'alcista' : 'bajista'}. Posible continuacion del movimiento.`
                                                        : `DESACELERACION DETECTADA (${accel.toFixed(2)}). El momentum se esta agotando. Vigilar posible giro o consolidacion.`
                                                );
                                            } else if (Math.abs(vel) > 0.5) {
                                                return React.createElement('span', { className: vel > 0 ? 'text-blue-400' : 'text-red-400' },
                                                    `Velocidad ${vel > 0 ? 'positiva' : 'negativa'} (${vel.toFixed(2)}). Movimiento ${vel > 0 ? 'alcista' : 'bajista'} en curso con velocidad ${Math.abs(vel) > 1 ? 'alta' : 'moderada'}.`
                                                );
                                            } else {
                                                return React.createElement('span', { className: "text-neutral-400" },
                                                    `Velocidad neutra (${vel.toFixed(2)}). Sin movimiento direccional significativo. Mercado en equilibrio.`
                                                );
                                            }
                                        })()
                                    ),

                                    // ABSORCION INSTITUCIONAL
                                    React.createElement('p', null,
                                        React.createElement('span', { className: "text-white font-bold" }, "ABSORCION: "),
                                        absorptionAnalysis.activeAbsorption
                                            ? React.createElement('span', {
                                                className: absorptionAnalysis.dominantSide === 'BULLISH' ? 'text-emerald-400' :
                                                    absorptionAnalysis.dominantSide === 'BEARISH' ? 'text-rose-400' : 'text-pink-400'
                                            },
                                                `DETECTADA absorcion ${absorptionAnalysis.dominantSide === 'BULLISH' ? 'ALCISTA' : absorptionAnalysis.dominantSide === 'BEARISH' ? 'BAJISTA' : 'MIXTA'}. `,
                                                `${absorptionAnalysis.totalAbsorptions} zonas institucionales. `,
                                                `Actividad: ${absorptionAnalysis.institutionalActivity}%. `,
                                                `Ratio alcista/bajista: ${absorptionAnalysis.bullishCount}/${absorptionAnalysis.bearishCount}. `,
                                                absorptionAnalysis.institutionalActivity > 60
                                                    ? 'FUERTE presencia institucional - niveles de precio importantes.'
                                                    : 'Interes institucional moderado.'
                                            )
                                            : React.createElement('span', { className: "text-neutral-500" },
                                                "Sin absorcion institucional significativa. Accion de precio dominada por flujo minorista."
                                            )
                                    ),

                                    // VOLATILIDAD
                                    React.createElement('p', null,
                                        React.createElement('span', { className: "text-white font-bold" }, "VOLATILIDAD: "),
                                        React.createElement('span', {
                                            className: volatilityAnalysis.state === 'EXPANSION' ? 'text-purple-400' :
                                                volatilityAnalysis.state === 'COMPRESSION' ? 'text-amber-400' : 'text-neutral-400'
                                        },
                                            volatilityAnalysis.state === 'EXPANSION'
                                                ? `EN EXPANSION (${(volatilityAnalysis.strength || 0).toFixed(0)}%). Movimientos amplios esperados. Aumentar stops y objetivos.`
                                                : volatilityAnalysis.state === 'COMPRESSION'
                                                    ? `COMPRIMIDA. Acumulando energia para proximo movimiento. Preparar entradas en ruptura.`
                                                    : `Normal. Condiciones estandar de trading.`
                                        )
                                    ),

                                    // SWEEP/BARRIDO
                                    sweepAnalysis.sweep?.active && React.createElement('p', null,
                                        React.createElement('span', { className: "text-white font-bold" }, "BARRIDO: "),
                                        React.createElement('span', {
                                            className: sweepAnalysis.sweep?.direction === 'HUNTING_HIGHS' ? 'text-blue-400' : 'text-red-400'
                                        },
                                            `DETECTADO barrido ${sweepAnalysis.sweep?.direction === 'HUNTING_HIGHS' ? 'de maximos (ALCISTA)' : 'de minimos (BAJISTA)'}. `,
                                            `Intensidad: ${(sweepAnalysis.sweep?.intensity || 0).toFixed(0)}%. `,
                                            `Prob. de giro: ${(sweepAnalysis.sweep?.reversalProb || 0).toFixed(0)}%. `,
                                            sweepAnalysis.sweep?.targetReached ? 'OBJETIVO ALCANZADO - vigilar senal de giro.' : ''
                                        )
                                    ),

                                    // CORRELACION DE METRICAS
                                    React.createElement('p', null,
                                        React.createElement('span', { className: "text-white font-bold" }, "SENALES: "),
                                        topMetricsGlobal.length > 0
                                            ? React.createElement('span', { className: "text-cyan-400" },
                                                `${topMetricsGlobal.length} indicadores activos. `,
                                                `Principal: ${topMetricsGlobal[0]?.label || 'N/A'} (${(topMetricsGlobal[0]?.strength || 0).toFixed(0)}%). `,
                                                (() => {
                                                    const bulls = topMetricsGlobal.filter(m => m.direction === 'BULLISH').length;
                                                    const bears = topMetricsGlobal.filter(m => m.direction === 'BEARISH').length;
                                                    if (bulls > bears) return `Sesgo ALCISTA (${bulls} vs ${bears}).`;
                                                    if (bears > bulls) return `Sesgo BAJISTA (${bears} vs ${bulls}).`;
                                                    return 'Senales mixtas - sin consenso direccional.';
                                                })()
                                            )
                                            : React.createElement('span', { className: "text-neutral-500" },
                                                "Datos insuficientes para analisis de correlacion."
                                            )
                                    )
                                )
                            ),

                            // FILA DE METRICAS COMPACTAS
                            React.createElement('div', { className: "grid grid-cols-6 gap-2" },
                                // Impulso
                                React.createElement('div', {
                                    className: `rounded-lg p-2 text-center border ${impulseAnalysis.active
                                        ? impulseAnalysis.direction === 'BULLISH' ? 'bg-blue-500/10 border-blue-500/30' : 'bg-red-500/10 border-red-500/30'
                                        : 'bg-neutral-800/50 border-neutral-700/50'
                                        }`
                                },
                                    React.createElement('div', { className: "text-[9px] text-neutral-500 uppercase" }, "IMPULSO"),
                                    React.createElement('div', {
                                        className: `text-lg font-bold font-mono ${impulseAnalysis.active
                                            ? impulseAnalysis.direction === 'BULLISH' ? 'text-blue-400' : 'text-red-400'
                                            : 'text-neutral-500'
                                            }`
                                    }, impulseAnalysis.active ? `${(impulseAnalysis.strength || 0).toFixed(0)}%` : '--')
                                ),
                                // Velocidad
                                React.createElement('div', {
                                    className: `rounded-lg p-2 text-center border ${Math.abs(impulseAnalysis.velocity || 0) > 0.5
                                        ? (impulseAnalysis.velocity || 0) > 0 ? 'bg-emerald-500/10 border-emerald-500/30' : 'bg-rose-500/10 border-rose-500/30'
                                        : 'bg-neutral-800/50 border-neutral-700/50'
                                        }`
                                },
                                    React.createElement('div', { className: "text-[9px] text-neutral-500 uppercase" }, "VELOC"),
                                    React.createElement('div', {
                                        className: `text-lg font-bold font-mono ${Math.abs(impulseAnalysis.velocity || 0) > 0.5
                                            ? (impulseAnalysis.velocity || 0) > 0 ? 'text-emerald-400' : 'text-rose-400'
                                            : 'text-neutral-500'
                                            }`
                                    }, `${(impulseAnalysis.velocity || 0) >= 0 ? '+' : ''}${(impulseAnalysis.velocity || 0).toFixed(1)}`)
                                ),
                                // Aceleracion
                                React.createElement('div', {
                                    className: `rounded-lg p-2 text-center border ${Math.abs(impulseAnalysis.acceleration || 0) > 0.3
                                        ? (impulseAnalysis.acceleration || 0) > 0 ? 'bg-emerald-500/10 border-emerald-500/30' : 'bg-rose-500/10 border-rose-500/30'
                                        : 'bg-neutral-800/50 border-neutral-700/50'
                                        }`
                                },
                                    React.createElement('div', { className: "text-[9px] text-neutral-500 uppercase" }, "ACCEL"),
                                    React.createElement('div', {
                                        className: `text-lg font-bold font-mono ${Math.abs(impulseAnalysis.acceleration || 0) > 0.3
                                            ? (impulseAnalysis.acceleration || 0) > 0 ? 'text-emerald-400' : 'text-rose-400'
                                            : 'text-neutral-500'
                                            }`
                                    }, `${(impulseAnalysis.acceleration || 0) >= 0 ? '+' : ''}${(impulseAnalysis.acceleration || 0).toFixed(1)}`)
                                ),
                                // Absorcion
                                React.createElement('div', {
                                    className: `rounded-lg p-2 text-center border ${absorptionAnalysis.activeAbsorption
                                        ? absorptionAnalysis.dominantSide === 'BULLISH' ? 'bg-emerald-500/10 border-emerald-500/30' : 'bg-rose-500/10 border-rose-500/30'
                                        : 'bg-neutral-800/50 border-neutral-700/50'
                                        }`
                                },
                                    React.createElement('div', { className: "text-[9px] text-neutral-500 uppercase" }, "ABSORP"),
                                    React.createElement('div', {
                                        className: `text-lg font-bold font-mono ${absorptionAnalysis.activeAbsorption
                                            ? absorptionAnalysis.dominantSide === 'BULLISH' ? 'text-emerald-400' : 'text-rose-400'
                                            : 'text-neutral-500'
                                            }`
                                    }, absorptionAnalysis.totalAbsorptions || 0)
                                ),
                                // Volatilidad
                                React.createElement('div', {
                                    className: `rounded-lg p-2 text-center border ${volatilityAnalysis.state === 'EXPANSION' ? 'bg-purple-500/10 border-purple-500/30' :
                                        volatilityAnalysis.state === 'COMPRESSION' ? 'bg-amber-500/10 border-amber-500/30' :
                                            'bg-neutral-800/50 border-neutral-700/50'
                                        }`
                                },
                                    React.createElement('div', { className: "text-[9px] text-neutral-500 uppercase" }, "VOLAT"),
                                    React.createElement('div', {
                                        className: `text-lg font-bold font-mono ${volatilityAnalysis.state === 'EXPANSION' ? 'text-purple-400' :
                                            volatilityAnalysis.state === 'COMPRESSION' ? 'text-amber-400' : 'text-neutral-500'
                                            }`
                                    }, `${(volatilityAnalysis.strength || 0).toFixed(0)}%`)
                                ),
                                // Pivots
                                React.createElement('div', {
                                    className: "rounded-lg p-2 text-center border bg-neutral-800/50 border-neutral-700/50"
                                },
                                    React.createElement('div', { className: "text-[9px] text-neutral-500 uppercase" }, "PIVOTS"),
                                    React.createElement('div', { className: "text-lg font-bold font-mono text-cyan-400" },
                                        pivotAnalysis.pivots?.length || 0
                                    )
                                )
                            ),

                            // Barra de sesion
                            React.createElement('div', {
                                className: "flex items-center justify-between px-3 py-2 bg-neutral-800/30 rounded-lg border border-neutral-700/30 text-[10px]"
                            },
                                React.createElement('span', { className: "text-neutral-500" },
                                    `SESION: ${sessionStats.impulses?.total || 0} impulsos | ${sessionStats.breakouts?.total || 0} rupturas | ${sessionStats.volatility?.expansions || 0} eventos vol`
                                ),
                                React.createElement('div', { className: "flex items-center gap-2" },
                                    aiApiKey && aiNarratorEnabled && React.createElement('span', {
                                        className: "text-emerald-500 flex items-center gap-1"
                                    },
                                        React.createElement('span', { className: "w-1.5 h-1.5 rounded-full bg-emerald-500 animate-pulse" }),
                                        "IA ACTIVA"
                                    ),
                                    React.createElement('span', { className: "text-neutral-600" },
                                        `Slot ${selectedSlot}`
                                    )
                                )
                            )
                        )
                    )
                )
            );
        };
        // --- END: components/MarketIntelligencePanel.tsx ---

        // --- START: components/DVILSHPanel.tsx ---
        // Panel DVILSH - RSI de 2 Fases: GEX + Vanna (Diego Vilchis) - 8 CASOS COMPLETOS
        components.DVILSHPanel = ({ dataSources, globalConfig }) => {
            const { useState, useEffect, useMemo, useRef } = React;

            const [selectedSlot, setSelectedSlot] = useState('1');
            const [lookbackPeriod, setLookbackPeriod] = useState(50);
            const [isZoomed, setIsZoomed] = useState(true);
            const [signalsEnabled, setSignalsEnabled] = useState(false);
            const gexChartRef = useRef(null);
            const vannaChartRef = useRef(null);
            const rsiChartRef = useRef(null);
            const priceChartRef = useRef(null);
            const gexChart = useRef(null);
            const vannaChart = useRef(null);
            const rsiChart = useRef(null);
            const priceChart = useRef(null);

            // Umbrales configurables
            const GEX_THRESHOLD_HIGH = 35;  // GEX "GRANDE"
            const GEX_THRESHOLD_LOW = 20;   // GEX "PEQUE√ëO"
            const DOMINANCE_THRESHOLD = 55; // % dominancia para considerar "alta"
            const VANNA_PEAK_LARGE = 35000; // Pico "MAYOR" de Vanna (m√°s sensible)
            const VANNA_PEAK_SMALL = 15000; // Pico "MENOR" de Vanna (m√°s sensible)

            // Obtener datos
            const dataSource = dataSources && dataSources.get ? dataSources.get(selectedSlot) : null;
            const rows = dataSource && dataSource.rows ? dataSource.rows : [];
            const n = rows.length;

            // AN√ÅLISIS FASE 1 + FASE 2 (Completo seg√∫n Diego Vilchis)
            const analysis = useMemo(() => {
                const result = {
                    // Series temporales
                    timestamps: [],
                    gexSize: [],
                    dominance: [],
                    vannaNet: [],
                    vannaPeaks: [],
                    rsiValues: [],
                    casoLabels: [],
                    priceData: [],
                    signalMarkers: [],
                    escenarios: [], // Array de escenarios para cada punto

                    // Valores actuales
                    currentGexSize: 0,
                    currentDominance: 50,
                    currentVannaNet: 0,
                    currentVannaPeak: 0,
                    currentRsi: 50,
                    currentCaso: null,
                    currentSignal: 'NEUTRAL',

                    // Estado FASE 1
                    fase1Scenario: 'NEUTRAL',
                    fase1Label: '',

                    // Estado FASE 2
                    fase2Caso: null,
                    fase2Label: '',
                    fase2Signal: 'NEUTRAL'
                };

                if (n < 10) return result;

                // Usar TODOS los datos disponibles del d√≠a completo
                const dataRows = rows;

                // Calcular series temporales
                dataRows.forEach((row, idx) => {
                    result.timestamps.push(idx);

                    // Precio (buscar en diferentes columnas posibles)
                    const price = parseFloat(row['Close'] || row['Last'] || row['Price'] || row['Underlying_Price'] || 0);
                    result.priceData.push(price);

                    // Variable 1: Tama√±o del GEX (0-60+)
                    const callGex = Math.abs(parseFloat(row['Call_GEX']) || 0);
                    const putGex = Math.abs(parseFloat(row['Put_GEX']) || 0);
                    const totalGex = callGex + putGex;
                    const gexSize = Math.min(60, (totalGex / 1000000) * 8);
                    result.gexSize.push(gexSize);

                    // Variable 2: Dominancia (% GEX positivo vs negativo)
                    const dominance = totalGex > 0 ? (callGex / totalGex) * 100 : 50;
                    result.dominance.push(dominance);

                    // Variable 3: Picos de Vanna
                    const vannaNet = parseFloat(row['Net_Vanna_Flow']) || 0;
                    result.vannaNet.push(vannaNet);

                    // Detectar pico de Vanna relativo en ventana de 5 minutos
                    let vannaPeak = 0;
                    if (idx >= 5) {
                        const window = result.vannaNet.slice(idx - 5, idx);
                        const avgVanna = window.reduce((a, b) => a + b, 0) / window.length;
                        vannaPeak = Math.abs(vannaNet - avgVanna);
                    } else if (idx > 0) {
                        vannaPeak = Math.abs(vannaNet - result.vannaNet[idx - 1]);
                    }
                    result.vannaPeaks.push(vannaPeak);
                });

                // Valores actuales (√∫ltimo punto)
                const lastIdx = result.gexSize.length - 1;
                result.currentGexSize = result.gexSize[lastIdx] || 0;
                result.currentDominance = result.dominance[lastIdx] || 50;
                result.currentVannaNet = result.vannaNet[lastIdx] || 0;
                result.currentVannaPeak = result.vannaPeaks[lastIdx] || 0;

                // ===== FASE 1: Determinar Escenario (2.1, 2.2, 2.3, 2.4) =====
                const isGexGrande = result.currentGexSize >= GEX_THRESHOLD_HIGH;
                const isGexPequeno = result.currentGexSize <= GEX_THRESHOLD_LOW;
                const isDomPositiva = result.currentDominance > DOMINANCE_THRESHOLD;
                const isDomNegativa = result.currentDominance < (100 - DOMINANCE_THRESHOLD);

                if (isGexGrande && isDomPositiva) {
                    result.fase1Scenario = '2.1';
                    result.fase1Label = 'GEX GRANDE + Dominancia POSITIVA';
                } else if (isGexGrande && isDomNegativa) {
                    result.fase1Scenario = '2.2';
                    result.fase1Label = 'GEX GRANDE + Dominancia NEGATIVA';
                } else if (isGexPequeno && isDomPositiva) {
                    result.fase1Scenario = '2.3';
                    result.fase1Label = 'GEX PEQUE√ëO + Dominancia POSITIVA';
                } else if (isGexPequeno && isDomNegativa) {
                    result.fase1Scenario = '2.4';
                    result.fase1Label = 'GEX PEQUE√ëO + Dominancia NEGATIVA';
                } else {
                    result.fase1Scenario = 'NEUTRAL';
                    result.fase1Label = 'Sin escenario definido';
                }

                // ===== FASE 2: Determinar Caso (1-8) seg√∫n Picos de Vanna =====
                const isVannaPeakLarge = result.currentVannaPeak >= VANNA_PEAK_LARGE;
                const isVannaPeakSmall = result.currentVannaPeak >= VANNA_PEAK_SMALL && result.currentVannaPeak < VANNA_PEAK_LARGE;
                const isVannaPositive = result.currentVannaNet > 0;
                const isVannaNegative = result.currentVannaNet < 0;

                // Calcular RSI LENTO basado en cambios de precio (21 per√≠odos)
                const rsiPeriod = 21;
                dataRows.forEach((row, idx) => {
                    const gexSize = result.gexSize[idx];
                    const dominance = result.dominance[idx];
                    const vannaNet = result.vannaNet[idx];
                    const vannaPeak = result.vannaPeaks[idx];

                    // Calcular RSI puro tradicional (sin ajustes)
                    let rsiValue = 50;
                    if (idx >= rsiPeriod) {
                        let gains = 0;
                        let losses = 0;
                        for (let i = 1; i <= rsiPeriod; i++) {
                            const change = result.priceData[idx - i + 1] - result.priceData[idx - i];
                            if (change > 0) gains += change;
                            else losses += Math.abs(change);
                        }
                        const avgGain = gains / rsiPeriod;
                        const avgLoss = losses / rsiPeriod;
                        if (avgLoss === 0) rsiValue = 100;
                        else {
                            const rs = avgGain / avgLoss;
                            rsiValue = 100 - (100 / (1 + rs));
                        }
                    }

                    // Determinar escenario en este punto
                    const isGexGrandeHere = gexSize >= GEX_THRESHOLD_HIGH;
                    const isGexPequenoHere = gexSize <= GEX_THRESHOLD_LOW;
                    const isDomPositivaHere = dominance > DOMINANCE_THRESHOLD;
                    const isDomNegativaHere = dominance < (100 - DOMINANCE_THRESHOLD);

                    let caso = null;
                    let casoLabel = '';
                    let escenario = '';

                    // GEX GRANDE
                    if (isGexGrandeHere) {
                        if (isDomPositivaHere) { // Escenario 2.1
                            escenario = 'Esc 2.1: GEX GRANDE + Dom POSITIVA';
                            if (vannaNet < 0 && vannaPeak >= VANNA_PEAK_LARGE) {
                                caso = 1;
                                casoLabel = 'Caso 1: Pico MAYOR Vanna(-) ‚Üí SOBREVENTA';
                            } else if (vannaNet > 0 && vannaPeak >= VANNA_PEAK_SMALL) {
                                caso = 2;
                                casoLabel = 'Caso 2: Pico MENOR Vanna(+) ‚Üí SOBREVENTA';
                            }
                        } else if (isDomNegativaHere) { // Escenario 2.2
                            escenario = 'Esc 2.2: GEX GRANDE + Dom NEGATIVA';
                            if (vannaNet > 0 && vannaPeak >= VANNA_PEAK_LARGE) {
                                caso = 3;
                                casoLabel = 'Caso 3: Pico MAYOR Vanna(+) ‚Üí SOBRECOMPRA';
                            } else if (vannaNet < 0 && vannaPeak >= VANNA_PEAK_SMALL) {
                                caso = 4;
                                casoLabel = 'Caso 4: Pico MENOR Vanna(-) ‚Üí SOBREVENTA';
                            }
                        }
                    }
                    // GEX PEQUE√ëO
                    else if (isGexPequenoHere) {
                        if (isDomPositivaHere) { // Escenario 2.3
                            escenario = 'Esc 2.3: GEX PEQUE√ëO + Dom POSITIVA';
                            if (vannaNet > 0 && vannaPeak >= VANNA_PEAK_LARGE) {
                                caso = 5;
                                casoLabel = 'Caso 5: Pico MAYOR Vanna(+) ‚Üí SOBREVENTA';
                            } else if (vannaNet < 0 && vannaPeak >= VANNA_PEAK_SMALL) {
                                caso = 6;
                                casoLabel = 'Caso 6: Pico MENOR Vanna(-) ‚Üí SOBRECOMPRA';
                            }
                        } else if (isDomNegativaHere) { // Escenario 2.4
                            escenario = 'Esc 2.4: GEX PEQUE√ëO + Dom NEGATIVA';
                            if (vannaNet < 0 && vannaPeak >= VANNA_PEAK_LARGE) {
                                caso = 7;
                                casoLabel = 'Caso 7: Pico MAYOR Vanna(-) ‚Üí SOBREVENTA';
                            } else if (vannaNet > 0 && vannaPeak >= VANNA_PEAK_SMALL) {
                                caso = 8;
                                casoLabel = 'Caso 8: Pico MENOR Vanna(+) ‚Üí SOBRECOMPRA';
                            }
                        }
                    }

                    // Detectar PIVOTS REALES en precio (picos y valles)
                    if (caso && idx >= 10 && idx < result.priceData.length - 5) {
                        const currentPrice = result.priceData[idx];
                        const leftWindow = result.priceData.slice(idx - 5, idx);
                        const rightWindow = result.priceData.slice(idx + 1, idx + 6);

                        // Pivot HIGH (pico): precio actual es m√°ximo local
                        const isPivotHigh = leftWindow.every(p => currentPrice >= p) &&
                            rightWindow.every(p => currentPrice >= p) &&
                            rsiValue >= 70;

                        // Pivot LOW (valle): precio actual es m√≠nimo local
                        const isPivotLow = leftWindow.every(p => currentPrice <= p) &&
                            rightWindow.every(p => currentPrice <= p) &&
                            rsiValue <= 30;

                        if (isPivotHigh || isPivotLow) {
                            result.signalMarkers.push({
                                xAxis: idx,
                                yAxis: currentPrice,
                                symbol: 'circle',
                                symbolSize: 18,
                                itemStyle: {
                                    color: isPivotLow ? 'rgba(34, 197, 94, 0.4)' : 'rgba(239, 68, 68, 0.4)',
                                    borderColor: isPivotLow ? '#22c55e' : '#ef4444',
                                    borderWidth: 2
                                },
                                label: {
                                    show: true,
                                    formatter: 'C' + caso,
                                    position: isPivotLow ? 'bottom' : 'top',
                                    color: isPivotLow ? '#22c55e' : '#ef4444',
                                    fontSize: 9,
                                    fontWeight: 'bold',
                                    offset: [0, isPivotLow ? 10 : -10]
                                },
                                tooltip: {
                                    formatter: 'üìç PIVOT ' + (isPivotLow ? 'LOW' : 'HIGH') + '<br/>' + casoLabel + '<br/>RSI: ' + rsiValue.toFixed(1) + '<br/>Precio: $' + currentPrice.toFixed(2)
                                }
                            });
                        }
                    }

                    // RSI ya est√° calculado correctamente, solo almacenar
                    result.rsiValues.push(rsiValue);
                    result.casoLabels.push(casoLabel);
                    result.escenarios.push(escenario);
                });

                // Valores actuales finales
                result.currentRsi = result.rsiValues[lastIdx] || 50;
                result.currentCaso = null;
                result.fase2Label = 'Sin se√±al activa';

                // Determinar caso actual
                if (isGexGrande) {
                    if (isDomPositiva) { // 2.1
                        if (isVannaNegative && isVannaPeakLarge) {
                            result.currentCaso = 1;
                            result.fase2Label = 'Caso 1: Pico MAYOR Vanna(-) ‚Üí SOBREVENTA';
                            result.fase2Signal = 'SOBREVENTA';
                        } else if (isVannaPositive && isVannaPeakSmall) {
                            result.currentCaso = 2;
                            result.fase2Label = 'Caso 2: Pico MENOR Vanna(+) ‚Üí SOBREVENTA';
                            result.fase2Signal = 'SOBREVENTA';
                        }
                    } else if (isDomNegativa) { // 2.2
                        if (isVannaPositive && isVannaPeakLarge) {
                            result.currentCaso = 3;
                            result.fase2Label = 'Caso 3: Pico MAYOR Vanna(+) ‚Üí SOBRECOMPRA';
                            result.fase2Signal = 'SOBRECOMPRA';
                        } else if (isVannaNegative && isVannaPeakSmall) {
                            result.currentCaso = 4;
                            result.fase2Label = 'Caso 4: Pico MENOR Vanna(-) ‚Üí SOBREVENTA';
                            result.fase2Signal = 'SOBREVENTA';
                        }
                    }
                } else if (isGexPequeno) {
                    if (isDomPositiva) { // 2.3
                        if (isVannaPositive && isVannaPeakLarge) {
                            result.currentCaso = 5;
                            result.fase2Label = 'Caso 5: Pico MAYOR Vanna(+) ‚Üí SOBREVENTA';
                            result.fase2Signal = 'SOBREVENTA';
                        } else if (isVannaNegative && isVannaPeakSmall) {
                            result.currentCaso = 6;
                            result.fase2Label = 'Caso 6: Pico MENOR Vanna(-) ‚Üí SOBRECOMPRA';
                            result.fase2Signal = 'SOBRECOMPRA';
                        }
                    } else if (isDomNegativa) { // 2.4
                        if (isVannaNegative && isVannaPeakLarge) {
                            result.currentCaso = 7;
                            result.fase2Label = 'Caso 7: Pico MAYOR Vanna(-) ‚Üí SOBREVENTA';
                            result.fase2Signal = 'SOBREVENTA';
                        } else if (isVannaPositive && isVannaPeakSmall) {
                            result.currentCaso = 8;
                            result.fase2Label = 'Caso 8: Pico MENOR Vanna(+) ‚Üí SOBRECOMPRA';
                            result.fase2Signal = 'SOBRECOMPRA';
                        }
                    }
                }

                return result;
            }, [rows, n, lookbackPeriod]);

            // Gr√°fico FASE 1: GEX Size + Dominancia
            useEffect(() => {
                if (!gexChartRef.current || n < 10) return;
                try {
                    if (!gexChart.current) gexChart.current = echarts.init(gexChartRef.current, null, { renderer: 'canvas' });
                    gexChart.current.setOption({
                        animation: false,
                        backgroundColor: 'transparent',
                        grid: { left: 60, right: 60, top: 40, bottom: 30 },
                        tooltip: {
                            trigger: 'axis',
                            backgroundColor: 'rgba(0,0,0,0.9)',
                            borderColor: '#555',
                            textStyle: { color: '#fff', fontSize: 11 },
                            formatter: function (params) {
                                let result = `Punto ${params[0].axisValue}<br/>`;
                                params.forEach(p => {
                                    result += `${p.marker}${p.seriesName}: <b>${p.value.toFixed(2)}</b><br/>`;
                                });
                                return result;
                            }
                        },
                        legend: {
                            data: ['GEX Size', 'Dominancia %'],
                            textStyle: { color: '#888', fontSize: 10 },
                            top: 8
                        },
                        xAxis: {
                            type: 'category',
                            data: analysis.timestamps,
                            axisLabel: { show: false },
                            axisLine: { lineStyle: { color: '#444' } }
                        },
                        yAxis: [
                            {
                                type: 'value',
                                name: 'GEX Size',
                                min: 0,
                                max: 60,
                                axisLabel: { color: '#4a9eff', fontSize: 10 },
                                axisLine: { lineStyle: { color: '#4a9eff' } },
                                splitLine: { lineStyle: { color: '#222' } }
                            },
                            {
                                type: 'value',
                                name: 'Dominancia %',
                                min: 0,
                                max: 100,
                                axisLabel: { color: '#f97316', fontSize: 10 },
                                axisLine: { lineStyle: { color: '#f97316' } },
                                splitLine: { show: false }
                            }
                        ],
                        series: [
                            {
                                name: 'GEX Size',
                                type: 'line',
                                data: analysis.gexSize,
                                lineStyle: { color: '#4a9eff', width: 2 },
                                itemStyle: { color: '#4a9eff' },
                                showSymbol: false,
                                smooth: true
                            },
                            {
                                name: 'Dominancia %',
                                type: 'line',
                                data: analysis.dominance,
                                lineStyle: { color: '#f97316', width: 2 },
                                itemStyle: { color: '#f97316' },
                                showSymbol: false,
                                yAxisIndex: 1,
                                smooth: true,
                                markLine: {
                                    silent: true,
                                    symbol: 'none',
                                    data: [
                                        { yAxis: 55, lineStyle: { color: '#f97316', type: 'dashed', width: 1 }, label: { formatter: '55% (Alta)' } },
                                        { yAxis: 45, lineStyle: { color: '#ef4444', type: 'dashed', width: 1 }, label: { formatter: '45% (Baja)' } }
                                    ]
                                }
                            }
                        ]
                    }, true);
                } catch (e) { console.error('[DVILSH] GEX chart error:', e); }
            }, [analysis, n]);

            // Gr√°fico FASE 2: Vanna Net + Picos
            useEffect(() => {
                if (!vannaChartRef.current || n < 10) return;
                try {
                    if (!vannaChart.current) vannaChart.current = echarts.init(vannaChartRef.current, null, { renderer: 'canvas' });
                    vannaChart.current.setOption({
                        animation: false,
                        backgroundColor: 'transparent',
                        grid: { left: 60, right: 30, top: 40, bottom: 30 },
                        tooltip: {
                            trigger: 'axis',
                            backgroundColor: 'rgba(0,0,0,0.9)',
                            borderColor: '#555',
                            textStyle: { color: '#fff', fontSize: 11 },
                            formatter: function (params) {
                                let result = `Punto ${params[0].axisValue}<br/>`;
                                params.forEach(p => {
                                    result += `${p.marker}${p.seriesName}: <b>${p.value.toFixed(0)}</b><br/>`;
                                });
                                return result;
                            }
                        },
                        legend: {
                            data: ['Vanna Net', 'Picos'],
                            textStyle: { color: '#888', fontSize: 10 },
                            top: 8
                        },
                        xAxis: {
                            type: 'category',
                            data: analysis.timestamps,
                            axisLabel: { show: false },
                            axisLine: { lineStyle: { color: '#444' } }
                        },
                        yAxis: {
                            type: 'value',
                            axisLabel: { color: '#888', fontSize: 10 },
                            axisLine: { lineStyle: { color: '#666' } },
                            splitLine: { lineStyle: { color: '#222' } }
                        },
                        series: [
                            {
                                name: 'Vanna Net',
                                type: 'line',
                                data: analysis.vannaNet,
                                lineStyle: { width: 2 },
                                itemStyle: {
                                    color: function (params) {
                                        return params.value >= 0 ? '#22c55e' : '#ef4444';
                                    }
                                },
                                areaStyle: {
                                    color: function (params) {
                                        return params.value >= 0
                                            ? 'rgba(34, 197, 94, 0.2)'
                                            : 'rgba(239, 68, 68, 0.2)';
                                    }
                                },
                                showSymbol: false,
                                smooth: true
                            },
                            {
                                name: 'Picos',
                                type: 'bar',
                                data: analysis.vannaPeaks,
                                itemStyle: { color: '#fbbf24', opacity: 0.6 },
                                barWidth: '60%'
                            }
                        ]
                    }, true);
                } catch (e) { console.error('[DVILSH] Vanna chart error:', e); }
            }, [analysis, n]);

            // Gr√°fico RSI DVILSH con Casos en Tooltip
            useEffect(() => {
                if (!rsiChartRef.current || n < 10) return;
                try {
                    if (!rsiChart.current) rsiChart.current = echarts.init(rsiChartRef.current, null, { renderer: 'canvas' });
                    rsiChart.current.setOption({
                        animation: false,
                        backgroundColor: 'transparent',
                        grid: { left: 60, right: 30, top: 40, bottom: 30 },
                        tooltip: {
                            trigger: 'axis',
                            backgroundColor: 'rgba(0,0,0,0.95)',
                            borderColor: '#a855f7',
                            borderWidth: 2,
                            textStyle: { color: '#fff', fontSize: 11 },
                            formatter: function (params) {
                                const idx = params[0].dataIndex;
                                const rsiVal = params[0].value.toFixed(1);
                                const caso = analysis.casoLabels[idx];
                                let result = `<b>RSI DVILSH: ${rsiVal}</b><br/>`;
                                if (caso) {
                                    result += `<span style="color:#fbbf24">‚ö° ${caso}</span>`;
                                } else {
                                    result += `<span style="color:#666">Sin se√±al activa</span>`;
                                }
                                return result;
                            }
                        },
                        xAxis: {
                            type: 'category',
                            data: analysis.timestamps,
                            axisLabel: { show: false },
                            axisLine: { lineStyle: { color: '#444' } }
                        },
                        yAxis: {
                            type: 'value',
                            min: 0,
                            max: 100,
                            axisLabel: { color: '#888', fontSize: 10 },
                            axisLine: { lineStyle: { color: '#666' } },
                            splitLine: { lineStyle: { color: '#222' } }
                        },
                        visualMap: {
                            show: false,
                            pieces: [
                                { lte: 30, color: '#22c55e' },
                                { gt: 30, lte: 70, color: '#a855f7' },
                                { gt: 70, color: '#ef4444' }
                            ]
                        },
                        series: [
                            {
                                name: 'RSI DVILSH',
                                type: 'line',
                                data: analysis.rsiValues,
                                lineStyle: { width: 3 },
                                showSymbol: false,
                                smooth: true,
                                markLine: {
                                    silent: true,
                                    symbol: 'none',
                                    lineStyle: { type: 'dashed', width: 2 },
                                    label: { fontSize: 10, color: '#fff' },
                                    data: [
                                        { yAxis: 70, lineStyle: { color: '#ef4444' }, label: { formatter: 'SOBRECOMPRA (70)' } },
                                        { yAxis: 30, lineStyle: { color: '#22c55e' }, label: { formatter: 'SOBREVENTA (30)' } },
                                        { yAxis: 50, lineStyle: { color: '#666', width: 1 }, label: { formatter: 'Neutral' } }
                                    ]
                                },
                                markArea: {
                                    silent: true,
                                    itemStyle: { color: 'rgba(239, 68, 68, 0.1)' },
                                    data: [[{ yAxis: 70 }, { yAxis: 100 }]]
                                }
                            }
                        ]
                    }, true);
                } catch (e) { console.error('[DVILSH] RSI chart error:', e); }
            }, [analysis, n]);

            // Gr√°fico de Price Action con se√±ales
            useEffect(() => {
                if (!priceChartRef.current || n < 10) return;
                try {
                    if (!priceChart.current) priceChart.current = echarts.init(priceChartRef.current, null, { renderer: 'canvas' });

                    priceChart.current.setOption({
                        animation: false,
                        backgroundColor: 'transparent',
                        grid: { left: 60, right: 20, top: 50, bottom: 80 },
                        title: {
                            text: 'Historial de Precio con Se√±ales DVILSH RSI',
                            left: 'center',
                            top: 8,
                            textStyle: { color: '#fff', fontSize: 13, fontWeight: 'bold' }
                        },
                        tooltip: {
                            trigger: 'axis',
                            backgroundColor: 'rgba(0,0,0,0.95)',
                            borderColor: '#666',
                            borderWidth: 1,
                            textStyle: { color: '#fff', fontSize: 12 },
                            axisPointer: {
                                type: 'cross',
                                lineStyle: { color: '#999', type: 'dashed' },
                                label: { backgroundColor: '#333' }
                            },
                            formatter: function (params) {
                                if (!params || !params[0]) return '';
                                const idx = params[0].dataIndex;
                                const price = params[0].value;
                                const rsi = analysis.rsiValues[idx];
                                const caso = analysis.casoLabels[idx];
                                const gexSize = analysis.gexSize[idx];
                                const escenario = analysis.escenarios?.[idx] || '';

                                let result = `<div style="padding:5px;min-width:200px;">`;
                                result += `<b style="color:#3b82f6;font-size:13px;">${params[0].axisValue}</b><br/>`;
                                result += `<div style="margin-top:5px;padding:3px 0;border-top:1px solid #444;"></div>`;
                                result += `<div style="margin:3px 0;">üíµ Precio: <b style="color:#10b981;">$${price.toFixed(2)}</b></div>`;
                                result += `<div style="margin:3px 0;">üìä RSI: <b style="color:#f59e0b;">${rsi.toFixed(1)}</b></div>`;
                                result += `<div style="margin:3px 0;">üéØ GEX: <b style="color:#8b5cf6;">${gexSize.toFixed(1)}M</b></div>`;
                                if (escenario) {
                                    result += `<div style="margin:3px 0;">üìã ${escenario}</div>`;
                                }
                                if (caso) {
                                    const isBuy = rsi <= 30;
                                    const color = isBuy ? '#22c55e' : '#ef4444';
                                    const emoji = isBuy ? 'üü¢' : 'üî¥';
                                    result += `<div style="margin-top:5px;padding:5px;background:${color}20;border:1px solid ${color}60;border-radius:4px;">`;
                                    result += `${emoji} <b style="color:${color};">${caso}</b>`;
                                    result += `</div>`;
                                }
                                result += `</div>`;
                                return result;
                            }
                        },
                        dataZoom: [
                            {
                                type: 'inside',
                                start: isZoomed ? 0 : 70,
                                end: 100,
                                zoomOnMouseWheel: true,
                                moveOnMouseMove: true,
                                filterMode: 'none'
                            }
                        ],
                        xAxis: {
                            type: 'category',
                            data: analysis.timestamps,
                            axisLabel: {
                                show: true,
                                color: '#888',
                                fontSize: 10,
                                rotate: 45,
                                interval: Math.floor(n / 10)
                            },
                            axisLine: { lineStyle: { color: '#444' } },
                            axisTick: { show: true, lineStyle: { color: '#444' } }
                        },
                        yAxis: {
                            type: 'value',
                            scale: true,
                            axisLabel: {
                                color: '#888',
                                fontSize: 11,
                                formatter: '${value}'
                            },
                            axisLine: { show: true, lineStyle: { color: '#666' } },
                            splitLine: { lineStyle: { color: '#2a2a2a', type: 'dashed' } }
                        },
                        series: [
                            {
                                name: 'Precio',
                                type: 'line',
                                data: analysis.priceData,
                                lineStyle: {
                                    color: '#3b82f6',
                                    width: 2.5
                                },
                                itemStyle: { color: '#3b82f6' },
                                showSymbol: false,
                                smooth: false,
                                areaStyle: {
                                    color: {
                                        type: 'linear',
                                        x: 0, y: 0, x2: 0, y2: 1,
                                        colorStops: [
                                            { offset: 0, color: 'rgba(59, 130, 246, 0.4)' },
                                            { offset: 1, color: 'rgba(59, 130, 246, 0.05)' }
                                        ]
                                    }
                                },
                                markPoint: {
                                    symbol: 'pin',
                                    symbolSize: 50,
                                    label: {
                                        show: true,
                                        color: '#fff',
                                        fontSize: 11,
                                        fontWeight: 'bold',
                                        offset: [0, -5]
                                    },
                                    data: signalsEnabled && analysis.signalMarkers ? analysis.signalMarkers.map(marker => ({
                                        ...marker,
                                        itemStyle: {
                                            color: marker.itemStyle.color,
                                            borderColor: '#000',
                                            borderWidth: 2
                                        }
                                    })) : [],
                                    animation: true,
                                    animationDuration: 600,
                                    animationEasing: 'elasticOut'
                                }
                            }
                        ]
                    }, true);

                    // Evento doble click para toggle zoom (usando getZr para el canvas)
                    const zr = priceChart.current.getZr();
                    zr.off('dblclick');
                    zr.on('dblclick', () => {
                        setIsZoomed(prev => !prev);
                    });
                } catch (e) { console.error('[DVILSH] Price chart error:', e); }
            }, [analysis, n, isZoomed, signalsEnabled]);

            useEffect(() => {
                const resize = () => {
                    try {
                        gexChart.current?.resize();
                        vannaChart.current?.resize();
                        rsiChart.current?.resize();
                        priceChart.current?.resize();
                    } catch (e) { }
                };
                window.addEventListener('resize', resize);
                return () => window.removeEventListener('resize', resize);
            }, []);

            useEffect(() => () => {
                try {
                    gexChart.current?.dispose();
                    vannaChart.current?.dispose();
                    rsiChart.current?.dispose();
                    priceChart.current?.dispose();
                } catch (e) { }
            }, []);

            return React.createElement('div', { className: "space-y-4 p-4" },
                // Header con estado actual
                React.createElement('div', { className: "bg-gradient-to-r from-purple-900/30 via-neutral-800/50 to-purple-900/30 rounded-xl p-4 border border-purple-500/30" },
                    React.createElement('div', { className: "flex items-center justify-between flex-wrap gap-4" },
                        React.createElement('div', { className: "flex items-center gap-4" },
                            React.createElement('div', { className: "flex items-center gap-2" },
                                React.createElement('div', { className: "w-3 h-12 rounded-full bg-gradient-to-b from-purple-500 via-pink-500 to-orange-500" }),
                                React.createElement('div', null,
                                    React.createElement('h2', { className: "text-xl font-bold text-white tracking-wide" }, "‚ö° DVILSH RSI"),
                                    React.createElement('p', { className: "text-[10px] text-neutral-400" }, "RSI de 2 Fases: GEX + Vanna (Diego Vilchis)")
                                ),
                                React.createElement('button', {
                                    className: `px-2 py-1 rounded text-xs font-bold transition-all ml-3 ${signalsEnabled
                                            ? 'bg-green-600/50 border border-green-500 text-green-300'
                                            : 'bg-red-600/50 border border-red-500 text-red-300'
                                        }`,
                                    onClick: () => setSignalsEnabled(prev => !prev)
                                }, signalsEnabled ? 'ON' : 'OFF')
                            ),
                            React.createElement('div', { className: "flex gap-1 ml-4" },
                                ['1', '2', '3', '4'].map(function (s) {
                                    return React.createElement('button', {
                                        key: s,
                                        onClick: function () { setSelectedSlot(s); },
                                        className: 'px-3 py-1.5 rounded-lg text-xs font-bold transition-all ' + (selectedSlot === s ? 'bg-purple-500/30 text-purple-400 border border-purple-500/50' : 'bg-neutral-800 text-neutral-500 hover:bg-neutral-700 border border-neutral-700')
                                    }, 'S' + s);
                                })
                            )
                        ),
                        React.createElement('div', { className: "flex items-center gap-6" },
                            React.createElement('div', { className: "text-center" },
                                React.createElement('div', { className: "text-[10px] text-neutral-500 mb-1" }, "FASE 1: ESCENARIO"),
                                React.createElement('div', {
                                    className: "px-3 py-1.5 rounded-lg text-sm font-bold border",
                                    style: {
                                        backgroundColor: analysis.fase1Scenario !== 'NEUTRAL' ? 'rgba(168, 85, 247, 0.2)' : 'rgba(100, 100, 100, 0.2)',
                                        borderColor: analysis.fase1Scenario !== 'NEUTRAL' ? 'rgba(168, 85, 247, 0.5)' : 'rgba(100, 100, 100, 0.5)',
                                        color: analysis.fase1Scenario !== 'NEUTRAL' ? '#a855f7' : '#666'
                                    }
                                }, analysis.fase1Scenario)
                            ),
                            React.createElement('div', { className: "text-center" },
                                React.createElement('div', { className: "text-[10px] text-neutral-500 mb-1" }, "FASE 2: CASO"),
                                React.createElement('div', {
                                    className: "px-3 py-1.5 rounded-lg text-sm font-bold border",
                                    style: {
                                        backgroundColor: analysis.currentCaso ? 'rgba(251, 191, 36, 0.2)' : 'rgba(100, 100, 100, 0.2)',
                                        borderColor: analysis.currentCaso ? 'rgba(251, 191, 36, 0.5)' : 'rgba(100, 100, 100, 0.5)',
                                        color: analysis.currentCaso ? '#fbbf24' : '#666'
                                    }
                                }, analysis.currentCaso ? 'Caso ' + analysis.currentCaso : 'SIN SE√ëAL')
                            ),
                            React.createElement('div', { className: "text-center" },
                                React.createElement('div', { className: "text-[10px] text-neutral-500 mb-1" }, "RSI DVILSH"),
                                React.createElement('div', {
                                    className: 'px-4 py-1.5 rounded-lg text-lg font-bold font-mono border ' + (
                                        analysis.currentRsi <= 30 ? 'bg-green-500/20 text-green-400 border-green-500/50' :
                                            analysis.currentRsi >= 70 ? 'bg-red-500/20 text-red-400 border-red-500/50' :
                                                'bg-neutral-800 text-neutral-400 border-neutral-700'
                                    )
                                }, analysis.currentRsi.toFixed(1))
                            ),
                            analysis.fase2Signal !== 'NEUTRAL' && React.createElement('div', {
                                className: 'px-4 py-2 rounded-xl text-sm font-bold animate-pulse ' + (
                                    analysis.fase2Signal === 'SOBREVENTA' ? 'bg-green-500/30 text-green-400 border-2 border-green-500' :
                                        'bg-red-500/30 text-red-400 border-2 border-red-500'
                                )
                            }, '‚ö° ' + analysis.fase2Signal)
                        )
                    ),
                    analysis.fase2Label && React.createElement('div', {
                        className: "mt-3 pt-3 border-t border-neutral-800 text-xs text-neutral-400"
                    },
                        React.createElement('span', { className: "text-neutral-500" }, "An√°lisis: "),
                        React.createElement('span', { className: "text-white" }, analysis.fase1Label),
                        React.createElement('span', { className: "text-neutral-600" }, ' ‚Üí '),
                        React.createElement('span', { className: "text-yellow-400" }, analysis.fase2Label)
                    )
                ),

                // M√©tricas clave
                React.createElement('div', { className: "grid grid-cols-2 md:grid-cols-6 gap-3" },
                    React.createElement('div', { className: "bg-neutral-900/80 rounded-lg p-3 border border-neutral-800" },
                        React.createElement('div', { className: "text-[10px] text-neutral-500 mb-1" }, "GEX SIZE"),
                        React.createElement('div', {
                            className: 'text-xl font-bold font-mono ' + (
                                analysis.currentGexSize >= GEX_THRESHOLD_HIGH ? 'text-green-400' :
                                    analysis.currentGexSize <= GEX_THRESHOLD_LOW ? 'text-orange-400' : 'text-neutral-400'
                            )
                        }, analysis.currentGexSize.toFixed(1)),
                        React.createElement('div', { className: "text-[9px] text-neutral-600" },
                            analysis.currentGexSize >= GEX_THRESHOLD_HIGH ? 'GRANDE' :
                                analysis.currentGexSize <= GEX_THRESHOLD_LOW ? 'PEQUE√ëO' : 'MEDIO'
                        )
                    ),
                    React.createElement('div', { className: "bg-neutral-900/80 rounded-lg p-3 border border-neutral-800" },
                        React.createElement('div', { className: "text-[10px] text-neutral-500 mb-1" }, "DOMINANCIA"),
                        React.createElement('div', {
                            className: 'text-xl font-bold font-mono ' + (
                                analysis.currentDominance > DOMINANCE_THRESHOLD ? 'text-blue-400' :
                                    analysis.currentDominance < (100 - DOMINANCE_THRESHOLD) ? 'text-red-400' : 'text-neutral-400'
                            )
                        }, analysis.currentDominance.toFixed(1) + '%'),
                        React.createElement('div', { className: "text-[9px] text-neutral-600" },
                            analysis.currentDominance > DOMINANCE_THRESHOLD ? 'CALLS' :
                                analysis.currentDominance < (100 - DOMINANCE_THRESHOLD) ? 'PUTS' : 'NEUTRAL'
                        )
                    ),
                    React.createElement('div', { className: "bg-neutral-900/80 rounded-lg p-3 border border-neutral-800" },
                        React.createElement('div', { className: "text-[10px] text-neutral-500 mb-1" }, "VANNA NET"),
                        React.createElement('div', {
                            className: 'text-xl font-bold font-mono ' + (analysis.currentVannaNet > 0 ? 'text-green-400' : 'text-red-400')
                        }, (analysis.currentVannaNet >= 0 ? '+' : '') + (analysis.currentVannaNet / 1000).toFixed(2) + 'K'),
                        React.createElement('div', { className: "text-[9px] text-neutral-600" },
                            analysis.currentVannaNet > 0 ? 'POSITIVO' : 'NEGATIVO'
                        )
                    ),
                    React.createElement('div', { className: "bg-neutral-900/80 rounded-lg p-3 border border-neutral-800" },
                        React.createElement('div', { className: "text-[10px] text-neutral-500 mb-1" }, "PICO VANNA"),
                        React.createElement('div', {
                            className: 'text-xl font-bold font-mono ' + (
                                analysis.currentVannaPeak >= VANNA_PEAK_LARGE ? 'text-amber-400' :
                                    analysis.currentVannaPeak >= VANNA_PEAK_SMALL ? 'text-amber-600' : 'text-neutral-500'
                            )
                        }, (analysis.currentVannaPeak / 1000).toFixed(1) + 'K'),
                        React.createElement('div', { className: "text-[9px] text-neutral-600" },
                            analysis.currentVannaPeak >= VANNA_PEAK_LARGE ? 'MAYOR' :
                                analysis.currentVannaPeak >= VANNA_PEAK_SMALL ? 'MENOR' : 'BAJO'
                        )
                    ),
                    React.createElement('div', { className: "bg-neutral-900/80 rounded-lg p-3 border border-neutral-800" },
                        React.createElement('div', { className: "text-[10px] text-neutral-500 mb-1" }, "DATOS"),
                        React.createElement('div', { className: "text-xl font-bold font-mono text-neutral-400" }, n),
                        React.createElement('div', { className: "text-[9px] text-neutral-600" }, 'Lookback: ' + lookbackPeriod)
                    ),
                    React.createElement('div', { className: "bg-neutral-900/80 rounded-lg p-3 border border-neutral-800" },
                        React.createElement('div', { className: "text-[10px] text-neutral-500 mb-1" }, "SLOT"),
                        React.createElement('div', { className: "text-xl font-bold font-mono text-purple-400" }, 'S' + selectedSlot),
                        React.createElement('div', { className: "text-[9px] text-neutral-600" }, 'CSV ' + selectedSlot)
                    )
                ),

                // Gr√°fico de Price Action Inteligente (Full Width)
                React.createElement('div', { className: "bg-gradient-to-br from-neutral-900/50 via-blue-900/10 to-neutral-900/50 rounded-xl p-3 border border-blue-500/30" },
                    React.createElement('div', { className: "flex items-center justify-between mb-2" },
                        React.createElement('div', { className: "flex items-center gap-2" },
                            React.createElement('h3', { className: "text-sm font-bold text-white" }, "üìä PRICE ACTION + Se√±ales DVILSH"),
                            React.createElement('span', { className: "text-[10px] px-2 py-0.5 rounded bg-blue-500/20 text-blue-400 border border-blue-500/30" }, "Historial de Se√±ales")
                        ),
                        React.createElement('div', { className: "flex items-center gap-4 text-[10px]" },
                            React.createElement('div', { className: "flex items-center gap-1" },
                                React.createElement('span', { className: "text-green-400" }, "‚ñ≤"),
                                React.createElement('span', { className: "text-neutral-400" }, "Sobreventa")
                            ),
                            React.createElement('div', { className: "flex items-center gap-1" },
                                React.createElement('span', { className: "text-red-400" }, "‚ñº"),
                                React.createElement('span', { className: "text-neutral-400" }, "Sobrecompra")
                            ),
                            React.createElement('span', { className: "text-neutral-500" }, "C1-C8 = Casos activos")
                        )
                    ),
                    React.createElement('div', { ref: priceChartRef, style: { width: '100%', height: '450px' } })
                ),

                // Gr√°ficos Fase 1 y Fase 2
                React.createElement('div', { className: "grid grid-cols-1 lg:grid-cols-2 gap-4" },
                    React.createElement('div', { className: "bg-neutral-900/50 rounded-xl p-3 border border-neutral-800" },
                        React.createElement('div', { className: "flex items-center justify-between mb-2" },
                            React.createElement('h3', { className: "text-sm font-bold text-white" }, "FASE 1: GEX Tama√±o + Dominancia"),
                            React.createElement('div', { className: "text-[10px] text-neutral-500" }, "Variable 1 + Variable 2")
                        ),
                        React.createElement('div', { ref: gexChartRef, style: { width: '100%', height: '200px' } })
                    ),
                    React.createElement('div', { className: "bg-neutral-900/50 rounded-xl p-3 border border-neutral-800" },
                        React.createElement('div', { className: "flex items-center justify-between mb-2" },
                            React.createElement('h3', { className: "text-sm font-bold text-white" }, "FASE 2: Vanna Flow + Picos"),
                            React.createElement('div', { className: "text-[10px] text-neutral-500" }, "Variable 3")
                        ),
                        React.createElement('div', { ref: vannaChartRef, style: { width: '100%', height: '200px' } })
                    )
                ),

                // Gr√°fico RSI DVILSH (Full Width)
                React.createElement('div', { className: "bg-neutral-900/50 rounded-xl p-3 border border-neutral-800" },
                    React.createElement('div', { className: "flex items-center justify-between mb-2" },
                        React.createElement('h3', { className: "text-sm font-bold text-white" }, "RSI DVILSH (Resultado Final de 2 Fases)"),
                        React.createElement('div', { className: "flex items-center gap-4" },
                            React.createElement('span', { className: "text-[10px] text-green-400" }, "‚â§30 = Sobreventa"),
                            React.createElement('span', { className: "text-[10px] text-red-400" }, "‚â•70 = Sobrecompra"),
                            React.createElement('span', { className: "text-[10px] text-neutral-500" }, "Hover para ver Casos")
                        )
                    ),
                    React.createElement('div', { ref: rsiChartRef, style: { width: '100%', height: '180px' } })
                ),

                // Matriz de 8 Casos
                React.createElement('div', { className: "bg-neutral-900/50 rounded-xl p-4 border border-neutral-800" },
                    React.createElement('h3', { className: "text-sm font-bold text-white mb-3" }, "üìã MATRIZ DE 8 CASOS (Diego Vilchis)"),
                    React.createElement('div', { className: "grid grid-cols-1 md:grid-cols-2 gap-4" },
                        // GEX GRANDE
                        React.createElement('div', { className: "space-y-2" },
                            React.createElement('div', { className: "text-xs font-bold text-green-400 border-b border-neutral-700 pb-1 mb-2" }, "üü¢ GEX GRANDE (‚â•35)"),
                            React.createElement('div', {
                                className: 'text-[10px] p-2 rounded border ' + (analysis.currentCaso === 1 ? 'bg-green-500/20 border-green-500' : 'bg-neutral-800/50 border-neutral-700')
                            },
                                React.createElement('span', { className: "font-bold text-green-400" }, "Caso 1 (2.1): "),
                                "Pico MAYOR Vanna(-) ‚Üí SOBREVENTA"
                            ),
                            React.createElement('div', {
                                className: 'text-[10px] p-2 rounded border ' + (analysis.currentCaso === 2 ? 'bg-green-500/20 border-green-500' : 'bg-neutral-800/50 border-neutral-700')
                            },
                                React.createElement('span', { className: "font-bold text-green-400" }, "Caso 2 (2.1): "),
                                "Pico MENOR Vanna(+) ‚Üí SOBREVENTA"
                            ),
                            React.createElement('div', {
                                className: 'text-[10px] p-2 rounded border ' + (analysis.currentCaso === 3 ? 'bg-red-500/20 border-red-500' : 'bg-neutral-800/50 border-neutral-700')
                            },
                                React.createElement('span', { className: "font-bold text-red-400" }, "Caso 3 (2.2): "),
                                "Pico MAYOR Vanna(+) ‚Üí SOBRECOMPRA"
                            ),
                            React.createElement('div', {
                                className: 'text-[10px] p-2 rounded border ' + (analysis.currentCaso === 4 ? 'bg-green-500/20 border-green-500' : 'bg-neutral-800/50 border-neutral-700')
                            },
                                React.createElement('span', { className: "font-bold text-green-400" }, "Caso 4 (2.2): "),
                                "Pico MENOR Vanna(-) ‚Üí SOBREVENTA"
                            )
                        ),
                        // GEX PEQUE√ëO
                        React.createElement('div', { className: "space-y-2" },
                            React.createElement('div', { className: "text-xs font-bold text-orange-400 border-b border-neutral-700 pb-1 mb-2" }, "üü† GEX PEQUE√ëO (‚â§20)"),
                            React.createElement('div', {
                                className: 'text-[10px] p-2 rounded border ' + (analysis.currentCaso === 5 ? 'bg-green-500/20 border-green-500' : 'bg-neutral-800/50 border-neutral-700')
                            },
                                React.createElement('span', { className: "font-bold text-green-400" }, "Caso 5 (2.3): "),
                                "Pico MAYOR Vanna(+) ‚Üí SOBREVENTA"
                            ),
                            React.createElement('div', {
                                className: 'text-[10px] p-2 rounded border ' + (analysis.currentCaso === 6 ? 'bg-red-500/20 border-red-500' : 'bg-neutral-800/50 border-neutral-700')
                            },
                                React.createElement('span', { className: "font-bold text-red-400" }, "Caso 6 (2.3): "),
                                "Pico MENOR Vanna(-) ‚Üí SOBRECOMPRA"
                            ),
                            React.createElement('div', {
                                className: 'text-[10px] p-2 rounded border ' + (analysis.currentCaso === 7 ? 'bg-green-500/20 border-green-500' : 'bg-neutral-800/50 border-neutral-700')
                            },
                                React.createElement('span', { className: "font-bold text-green-400" }, "Caso 7 (2.4): "),
                                "Pico MAYOR Vanna(-) ‚Üí SOBREVENTA"
                            ),
                            React.createElement('div', {
                                className: 'text-[10px] p-2 rounded border ' + (analysis.currentCaso === 8 ? 'bg-red-500/20 border-red-500' : 'bg-neutral-800/50 border-neutral-700')
                            },
                                React.createElement('span', { className: "font-bold text-red-400" }, "Caso 8 (2.4): "),
                                "Pico MENOR Vanna(+) ‚Üí SOBRECOMPRA"
                            )
                        )
                    )
                ),

                // Mensaje si no hay datos suficientes
                n < 10 && React.createElement('div', {
                    className: "text-center py-8 text-neutral-500 bg-neutral-900/50 rounded-xl border border-neutral-800"
                },
                    React.createElement('p', { className: "text-lg" }, "‚ö†Ô∏è Datos insuficientes"),
                    React.createElement('p', { className: "text-sm mt-2" }, 'Slot ' + selectedSlot + ' - ' + n + ' filas disponibles (m√≠nimo 10)')
                )
            );
        };
        // --- END: components/DVILSHPanel.tsx ---

        // --- START: components/MarketScanner.tsx ---
        // Scanner de Instrumentos en Tiempo Real (SPY, QQQ, SPX, NDX, VIX, GLD, USO, SLV, TLT, NQ, ES, ZB, ZN, GC, CL)
        components.MarketScanner = ({ isVisible, onClose }) => {
            const { useState, useEffect, useCallback, useRef } = React;

            // Lista de s√≠mbolos a monitorear (Yahoo Finance format)
            const SYMBOLS = [
                { symbol: 'SPY', name: 'S&P 500 ETF', type: 'ETF', yahoo: 'SPY' },
                { symbol: 'QQQ', name: 'Nasdaq 100 ETF', type: 'ETF', yahoo: 'QQQ' },
                { symbol: 'SPX', name: 'S&P 500 Index', type: 'Index', yahoo: '^GSPC' },
                { symbol: 'NDX', name: 'Nasdaq 100 Index', type: 'Index', yahoo: '^NDX' },
                { symbol: 'VIX', name: 'Volatility Index', type: 'Index', yahoo: '^VIX' },
                { symbol: 'GLD', name: 'Gold ETF', type: 'ETF', yahoo: 'GLD' },
                { symbol: 'USO', name: 'Oil ETF', type: 'ETF', yahoo: 'USO' },
                { symbol: 'SLV', name: 'Silver ETF', type: 'ETF', yahoo: 'SLV' },
                { symbol: 'TLT', name: 'Treasury Bond ETF', type: 'ETF', yahoo: 'TLT' },
                { symbol: 'NQ', name: 'Nasdaq Futures', type: 'Futures', yahoo: 'NQ=F' },
                { symbol: 'ES', name: 'S&P Futures', type: 'Futures', yahoo: 'ES=F' },
                { symbol: 'ZB', name: 'T-Bond Futures', type: 'Futures', yahoo: 'ZB=F' },
                { symbol: 'ZN', name: '10Y Note Futures', type: 'Futures', yahoo: 'ZN=F' },
                { symbol: 'GC', name: 'Gold Futures', type: 'Futures', yahoo: 'GC=F' },
                { symbol: 'CL', name: 'Crude Oil Futures', type: 'Futures', yahoo: 'CL=F' }
            ];

            const [scannerData, setScannerData] = useState([]);
            const [isLoading, setIsLoading] = useState(false);
            const [lastUpdate, setLastUpdate] = useState(null);
            const [sortBy, setSortBy] = useState('volatility'); // 'volatility', 'change', 'volume'
            const [autoRefresh, setAutoRefresh] = useState(true);
            const [refreshInterval, setRefreshInterval] = useState(10); // seconds
            const [error, setError] = useState(null);
            const intervalRef = useRef(null);
            const historyRef = useRef({}); // Para calcular volatilidad hist√≥rica

            // Proxy CORS para Yahoo Finance
            const CORS_PROXIES = [
                'https://api.allorigins.win/raw?url=',
                'https://corsproxy.io/?',
                'https://api.codetabs.com/v1/proxy?quest='
            ];

            // Fetch data from Yahoo Finance
            const fetchSymbolData = useCallback(async (symbolInfo) => {
                const yahooUrl = `https://query1.finance.yahoo.com/v8/finance/chart/${symbolInfo.yahoo}?interval=1m&range=1d`;

                for (const proxy of CORS_PROXIES) {
                    try {
                        const response = await fetch(proxy + encodeURIComponent(yahooUrl), {
                            headers: { 'Accept': 'application/json' }
                        });

                        if (!response.ok) continue;

                        const data = await response.json();
                        const result = data?.chart?.result?.[0];

                        if (!result) continue;

                        const meta = result.meta || {};
                        const quote = result.indicators?.quote?.[0] || {};
                        const timestamps = result.timestamp || [];
                        const closes = quote.close || [];
                        const volumes = quote.volume || [];
                        const highs = quote.high || [];
                        const lows = quote.low || [];

                        // Datos actuales
                        const currentPrice = meta.regularMarketPrice || closes[closes.length - 1] || 0;
                        const previousClose = meta.chartPreviousClose || meta.previousClose || currentPrice;
                        const change = currentPrice - previousClose;
                        const changePercent = previousClose !== 0 ? (change / previousClose) * 100 : 0;

                        // Volumen
                        const currentVolume = volumes.reduce((a, b) => (a || 0) + (b || 0), 0);
                        const avgVolume = meta.averageDailyVolume10Day || meta.averageDailyVolume3Month || currentVolume;
                        const volumeRatio = avgVolume > 0 ? (currentVolume / avgVolume) * 100 : 100;

                        // Volatilidad (rango del d√≠a vs precio)
                        const dayHigh = Math.max(...highs.filter(h => h != null));
                        const dayLow = Math.min(...lows.filter(l => l != null));
                        const dayRange = dayHigh - dayLow;
                        const volatility = currentPrice > 0 ? (dayRange / currentPrice) * 100 : 0;

                        // Calcular ATR aproximado (√∫ltimas 14 barras)
                        const recentHighs = highs.slice(-14).filter(h => h != null);
                        const recentLows = lows.slice(-14).filter(l => l != null);
                        const recentCloses = closes.slice(-15).filter(c => c != null);
                        let atrSum = 0;
                        for (let i = 1; i < recentHighs.length; i++) {
                            const tr = Math.max(
                                recentHighs[i] - recentLows[i],
                                Math.abs(recentHighs[i] - (recentCloses[i - 1] || recentCloses[i])),
                                Math.abs(recentLows[i] - (recentCloses[i - 1] || recentCloses[i]))
                            );
                            atrSum += tr;
                        }
                        const atr = recentHighs.length > 1 ? atrSum / (recentHighs.length - 1) : dayRange;
                        const atrPercent = currentPrice > 0 ? (atr / currentPrice) * 100 : 0;

                        // Velocidad (cambio en √∫ltimos 5 minutos)
                        const recentPrices = closes.slice(-5).filter(c => c != null);
                        const priceVelocity = recentPrices.length >= 2
                            ? ((recentPrices[recentPrices.length - 1] - recentPrices[0]) / recentPrices[0]) * 100
                            : 0;

                        // Historial para calcular delta relativo
                        const prevData = historyRef.current[symbolInfo.symbol];
                        const deltaPrice = prevData ? currentPrice - prevData.price : 0;
                        const deltaVolume = prevData ? currentVolume - prevData.volume : 0;

                        // Guardar en historial
                        historyRef.current[symbolInfo.symbol] = { price: currentPrice, volume: currentVolume, time: Date.now() };

                        // Score de actividad (combinaci√≥n de volatilidad + volumen + velocidad)
                        const activityScore = (volatility * 2) + (Math.abs(changePercent)) + (volumeRatio / 50) + (Math.abs(priceVelocity) * 3);

                        return {
                            ...symbolInfo,
                            price: currentPrice,
                            previousClose,
                            change,
                            changePercent,
                            volume: currentVolume,
                            avgVolume,
                            volumeRatio,
                            dayHigh,
                            dayLow,
                            dayRange,
                            volatility,
                            atr,
                            atrPercent,
                            priceVelocity,
                            deltaPrice,
                            deltaVolume,
                            activityScore,
                            lastUpdate: new Date().toLocaleTimeString()
                        };
                    } catch (e) {
                        continue;
                    }
                }

                // Si todos los proxies fallan, devolver datos vac√≠os
                return {
                    ...symbolInfo,
                    price: 0,
                    change: 0,
                    changePercent: 0,
                    volume: 0,
                    volumeRatio: 0,
                    volatility: 0,
                    activityScore: 0,
                    error: true
                };
            }, []);

            // Fetch all symbols
            const fetchAllData = useCallback(async () => {
                setIsLoading(true);
                setError(null);

                try {
                    const results = await Promise.all(SYMBOLS.map(s => fetchSymbolData(s)));
                    setScannerData(results.filter(r => !r.error));
                    setLastUpdate(new Date().toLocaleTimeString());
                } catch (e) {
                    setError('Error fetching data');
                    console.error('Scanner error:', e);
                }

                setIsLoading(false);
            }, [fetchSymbolData]);

            // Auto-refresh
            useEffect(() => {
                if (isVisible && autoRefresh) {
                    fetchAllData();
                    intervalRef.current = setInterval(fetchAllData, refreshInterval * 1000);
                }
                return () => {
                    if (intervalRef.current) clearInterval(intervalRef.current);
                };
            }, [isVisible, autoRefresh, refreshInterval, fetchAllData]);

            // Sort data
            const sortedData = [...scannerData].sort((a, b) => {
                switch (sortBy) {
                    case 'volatility': return b.activityScore - a.activityScore;
                    case 'change': return Math.abs(b.changePercent) - Math.abs(a.changePercent);
                    case 'volume': return b.volumeRatio - a.volumeRatio;
                    case 'velocity': return Math.abs(b.priceVelocity) - Math.abs(a.priceVelocity);
                    default: return 0;
                }
            });

            // Format number
            const formatNum = (num, decimals = 2) => {
                if (num === undefined || num === null) return '-';
                if (Math.abs(num) >= 1e9) return (num / 1e9).toFixed(1) + 'B';
                if (Math.abs(num) >= 1e6) return (num / 1e6).toFixed(1) + 'M';
                if (Math.abs(num) >= 1e3) return (num / 1e3).toFixed(1) + 'K';
                return num.toFixed(decimals);
            };

            if (!isVisible) return null;

            return React.createElement('div', {
                className: "fixed inset-0 bg-black/80 backdrop-blur-sm z-50 flex items-center justify-center p-4",
                onClick: (e) => e.target === e.currentTarget && onClose()
            },
                React.createElement('div', {
                    className: "bg-neutral-900 rounded-2xl shadow-2xl w-full max-w-6xl max-h-[90vh] overflow-hidden border border-neutral-700",
                    onClick: (e) => e.stopPropagation()
                },
                    // Header
                    React.createElement('div', {
                        className: "flex items-center justify-between px-6 py-4 border-b border-neutral-700",
                        style: { background: 'linear-gradient(90deg, rgba(59,130,246,0.2) 0%, rgba(139,92,246,0.2) 100%)' }
                    },
                        React.createElement('div', { className: "flex items-center gap-4" },
                            React.createElement('h2', { className: "text-xl font-bold text-white" }, "üîç Market Scanner"),
                            React.createElement('span', { className: "text-xs text-neutral-400" },
                                `${sortedData.length} instruments ‚Ä¢ Last: ${lastUpdate || 'Loading...'}`
                            ),
                            isLoading && React.createElement('div', {
                                className: "w-4 h-4 border-2 border-blue-500 border-t-transparent rounded-full animate-spin"
                            })
                        ),
                        React.createElement('div', { className: "flex items-center gap-3" },
                            // Sort selector
                            React.createElement('select', {
                                value: sortBy,
                                onChange: (e) => setSortBy(e.target.value),
                                className: "bg-neutral-800 border border-neutral-600 rounded-lg px-3 py-1.5 text-xs text-gray-200"
                            },
                                React.createElement('option', { value: 'volatility' }, 'Activity Score'),
                                React.createElement('option', { value: 'change' }, '% Change'),
                                React.createElement('option', { value: 'volume' }, 'Volume Ratio'),
                                React.createElement('option', { value: 'velocity' }, 'Velocity')
                            ),
                            // Refresh interval
                            React.createElement('select', {
                                value: refreshInterval,
                                onChange: (e) => setRefreshInterval(parseInt(e.target.value)),
                                className: "bg-neutral-800 border border-neutral-600 rounded-lg px-3 py-1.5 text-xs text-gray-200"
                            },
                                React.createElement('option', { value: '5' }, '5s'),
                                React.createElement('option', { value: '10' }, '10s'),
                                React.createElement('option', { value: '30' }, '30s'),
                                React.createElement('option', { value: '60' }, '60s')
                            ),
                            // Auto-refresh toggle
                            React.createElement('button', {
                                onClick: () => setAutoRefresh(!autoRefresh),
                                className: `px-3 py-1.5 rounded-lg text-xs font-medium transition-all ${autoRefresh
                                    ? 'bg-green-600/40 border border-green-500 text-green-300'
                                    : 'bg-neutral-700 border border-neutral-600 text-neutral-400'
                                    }`
                            }, autoRefresh ? '‚óè LIVE' : '‚óã PAUSED'),
                            // Manual refresh
                            React.createElement('button', {
                                onClick: fetchAllData,
                                disabled: isLoading,
                                className: "px-3 py-1.5 rounded-lg text-xs font-medium bg-blue-600/40 border border-blue-500 text-blue-300 hover:bg-blue-600/60"
                            }, '‚Üª Refresh'),
                            // Close button
                            React.createElement('button', {
                                onClick: onClose,
                                className: "text-neutral-400 hover:text-white text-xl"
                            }, '‚úï')
                        )
                    ),

                    // Table Header
                    React.createElement('div', {
                        className: "grid grid-cols-12 gap-2 px-6 py-2 bg-neutral-800/50 text-[10px] font-bold text-neutral-400 uppercase tracking-wider"
                    },
                        React.createElement('div', { className: "col-span-2" }, "Symbol"),
                        React.createElement('div', { className: "text-right" }, "Price"),
                        React.createElement('div', { className: "text-right" }, "Change"),
                        React.createElement('div', { className: "text-right" }, "% Chg"),
                        React.createElement('div', { className: "text-right" }, "Vol Ratio"),
                        React.createElement('div', { className: "text-right" }, "Volatility"),
                        React.createElement('div', { className: "text-right" }, "ATR %"),
                        React.createElement('div', { className: "text-right" }, "Velocity"),
                        React.createElement('div', { className: "text-right" }, "Range"),
                        React.createElement('div', { className: "col-span-2 text-center" }, "Activity")
                    ),

                    // Data rows
                    React.createElement('div', {
                        className: "overflow-y-auto",
                        style: { maxHeight: 'calc(90vh - 180px)' }
                    },
                        sortedData.length === 0
                            ? React.createElement('div', { className: "text-center py-12 text-neutral-500" },
                                isLoading ? 'Loading market data...' : 'No data available. Click Refresh.'
                            )
                            : sortedData.map((item, idx) => {
                                const isPositive = item.changePercent >= 0;
                                const color = isPositive ? '#4ade80' : '#f87171';
                                const bgColor = isPositive ? 'rgba(74, 222, 128, 0.05)' : 'rgba(248, 113, 113, 0.05)';
                                const velocityColor = item.priceVelocity >= 0 ? '#4ade80' : '#f87171';

                                // Activity bar width
                                const maxActivity = Math.max(...sortedData.map(d => d.activityScore), 1);
                                const activityWidth = (item.activityScore / maxActivity) * 100;
                                const activityColor = item.activityScore > maxActivity * 0.7
                                    ? '#ef4444'
                                    : item.activityScore > maxActivity * 0.4
                                        ? '#f59e0b'
                                        : '#22c55e';

                                return React.createElement('div', {
                                    key: item.symbol,
                                    className: "grid grid-cols-12 gap-2 px-6 py-3 border-b border-neutral-800 hover:bg-neutral-800/30 transition-all",
                                    style: { background: idx === 0 ? 'rgba(239, 68, 68, 0.1)' : bgColor }
                                },
                                    // Symbol + Name
                                    React.createElement('div', { className: "col-span-2 flex items-center gap-2" },
                                        React.createElement('div', null,
                                            React.createElement('div', { className: "font-bold text-white text-sm" }, item.symbol),
                                            React.createElement('div', { className: "text-[9px] text-neutral-500" }, item.type)
                                        ),
                                        idx === 0 && React.createElement('span', {
                                            className: "text-[9px] px-1.5 py-0.5 rounded bg-red-500/30 text-red-400 font-bold animate-pulse"
                                        }, 'HOT')
                                    ),
                                    // Price
                                    React.createElement('div', { className: "text-right font-mono text-sm text-white" },
                                        formatNum(item.price, item.price < 10 ? 4 : 2)
                                    ),
                                    // Change
                                    React.createElement('div', {
                                        className: "text-right font-mono text-sm",
                                        style: { color }
                                    }, (isPositive ? '+' : '') + formatNum(item.change, 2)),
                                    // % Change
                                    React.createElement('div', {
                                        className: "text-right font-mono text-sm font-bold",
                                        style: { color }
                                    }, (isPositive ? '+' : '') + item.changePercent.toFixed(2) + '%'),
                                    // Volume Ratio
                                    React.createElement('div', {
                                        className: "text-right font-mono text-sm",
                                        style: { color: item.volumeRatio > 150 ? '#f59e0b' : item.volumeRatio > 100 ? '#4ade80' : '#9ca3af' }
                                    }, item.volumeRatio.toFixed(0) + '%'),
                                    // Volatility
                                    React.createElement('div', {
                                        className: "text-right font-mono text-sm",
                                        style: { color: item.volatility > 2 ? '#ef4444' : item.volatility > 1 ? '#f59e0b' : '#9ca3af' }
                                    }, item.volatility.toFixed(2) + '%'),
                                    // ATR %
                                    React.createElement('div', { className: "text-right font-mono text-sm text-neutral-400" },
                                        item.atrPercent.toFixed(3) + '%'
                                    ),
                                    // Velocity (5min)
                                    React.createElement('div', {
                                        className: "text-right font-mono text-sm font-bold",
                                        style: { color: velocityColor }
                                    }, (item.priceVelocity >= 0 ? '‚Üë' : '‚Üì') + Math.abs(item.priceVelocity).toFixed(3) + '%'),
                                    // Day Range
                                    React.createElement('div', { className: "text-right font-mono text-[10px] text-neutral-500" },
                                        formatNum(item.dayLow, 2) + ' - ' + formatNum(item.dayHigh, 2)
                                    ),
                                    // Activity Score Bar
                                    React.createElement('div', { className: "col-span-2 flex items-center gap-2" },
                                        React.createElement('div', {
                                            className: "flex-1 h-4 bg-neutral-800 rounded-full overflow-hidden"
                                        },
                                            React.createElement('div', {
                                                className: "h-full rounded-full transition-all duration-500",
                                                style: {
                                                    width: `${activityWidth}%`,
                                                    background: `linear-gradient(90deg, ${activityColor}88, ${activityColor})`,
                                                    boxShadow: `0 0 10px ${activityColor}66`
                                                }
                                            })
                                        ),
                                        React.createElement('span', {
                                            className: "text-[10px] font-mono font-bold min-w-[35px]",
                                            style: { color: activityColor }
                                        }, item.activityScore.toFixed(1))
                                    )
                                );
                            })
                    ),

                    // Footer with legend
                    React.createElement('div', {
                        className: "px-6 py-3 border-t border-neutral-700 bg-neutral-800/30 flex items-center justify-between text-[9px] text-neutral-500"
                    },
                        React.createElement('div', { className: "flex gap-4" },
                            React.createElement('span', null, "HOT = Highest Activity"),
                            React.createElement('span', null, "Vol Ratio = Volume vs 10-day Avg"),
                            React.createElement('span', null, "Velocity = 5min price change"),
                            React.createElement('span', null, "Activity = Volatility + Change + Volume + Velocity")
                        ),
                        React.createElement('div', null, "Data: Yahoo Finance (via CORS proxy) ‚Ä¢ ~10-15s delay")
                    )
                )
            );
        };
        // --- END: components/MarketScanner.tsx ---

        // --- START: components/SentimentTab.tsx ---
        // Tab de Sentimiento con Scanner integrado y lista de activos
        components.SentimentTab = ({ onSentimentUpdate, onNasdaq100SentimentUpdate, globalAiEnabled, onAiEnabledChange }) => {
            const { useState, useEffect, useCallback, useRef } = React;

            // Lista de s√≠mbolos a monitorear (Yahoo Finance format)
            const SYMBOLS = [
                { symbol: 'SPY', name: 'S&P 500 ETF', type: 'ETF', yahoo: 'SPY' },
                { symbol: 'QQQ', name: 'Nasdaq 100 ETF', type: 'ETF', yahoo: 'QQQ' },
                { symbol: 'SPX', name: 'S&P 500 Index', type: 'Index', yahoo: '^GSPC' },
                { symbol: 'NDX', name: 'Nasdaq 100 Index', type: 'Index', yahoo: '^NDX' },
                { symbol: 'VIX', name: 'Volatility Index', type: 'Index', yahoo: '^VIX' },
                { symbol: 'GLD', name: 'Gold ETF', type: 'ETF', yahoo: 'GLD' },
                { symbol: 'USO', name: 'Oil ETF', type: 'ETF', yahoo: 'USO' },
                { symbol: 'SLV', name: 'Silver ETF', type: 'ETF', yahoo: 'SLV' },
                { symbol: 'TLT', name: 'Treasury Bond ETF', type: 'ETF', yahoo: 'TLT' },
                { symbol: 'NQ', name: 'Nasdaq Futures', type: 'Futures', yahoo: 'NQ=F' },
                { symbol: 'ES', name: 'S&P Futures', type: 'Futures', yahoo: 'ES=F' },
                { symbol: 'ZB', name: 'T-Bond Futures', type: 'Futures', yahoo: 'ZB=F' },
                { symbol: 'ZN', name: '10Y Note Futures', type: 'Futures', yahoo: 'ZN=F' },
                { symbol: 'GC', name: 'Gold Futures', type: 'Futures', yahoo: 'GC=F' },
                { symbol: 'CL', name: 'Crude Oil Futures', type: 'Futures', yahoo: 'CL=F' },
                { symbol: 'AAPL', name: 'Apple Inc', type: 'Stock', yahoo: 'AAPL' },
                { symbol: 'MSFT', name: 'Microsoft Corp', type: 'Stock', yahoo: 'MSFT' },
                { symbol: 'NVDA', name: 'NVIDIA Corp', type: 'Stock', yahoo: 'NVDA' },
                { symbol: 'TSLA', name: 'Tesla Inc', type: 'Stock', yahoo: 'TSLA' },
                { symbol: 'AMD', name: 'AMD Inc', type: 'Stock', yahoo: 'AMD' }
            ];

            const [scannerData, setScannerData] = useState([]);
            const [isLoading, setIsLoading] = useState(false);
            const [lastUpdate, setLastUpdate] = useState(null);
            const [sortBy, setSortBy] = useState('volatility');
            const [autoRefresh, setAutoRefresh] = useState(true);
            const [refreshInterval, setRefreshInterval] = useState(15);
            const [error, setError] = useState(null);
            const [filterType, setFilterType] = useState('all'); // all, ETF, Index, Futures, Stock
            const intervalRef = useRef(null);
            const historyRef = useRef({});

            // ===== AI NARRATOR para an√°lisis de sentimiento =====
            const [aiNarration, setAiNarration] = useState(null);
            const [isNarrating, setIsNarrating] = useState(false);
            // Usar estado global del header (no local) - con fallback por seguridad
            const aiEnabled = globalAiEnabled !== undefined ? globalAiEnabled : true;
            const setAiEnabled = onAiEnabledChange || (() => { });
            const lastSentimentRef = useRef(null);
            const narrationTimeoutRef = useRef(null);

            // ===== SECTOR ETFs para an√°lisis de sectores =====
            const [sectorData, setSectorData] = useState([]);
            const [sectorLoading, setSectorLoading] = useState(false);

            const SECTOR_ETFS = [
                { symbol: 'XLK', name: 'Technology', sector: 'Tech', yahoo: 'XLK', color: '#3b82f6' },
                { symbol: 'XLF', name: 'Financials', sector: 'Finance', yahoo: 'XLF', color: '#22c55e' },
                { symbol: 'XLE', name: 'Energy', sector: 'Energy', yahoo: 'XLE', color: '#f59e0b' },
                { symbol: 'XLV', name: 'Healthcare', sector: 'Health', yahoo: 'XLV', color: '#ec4899' },
                { symbol: 'XLI', name: 'Industrials', sector: 'Industrial', yahoo: 'XLI', color: '#8b5cf6' },
                { symbol: 'XLY', name: 'Consumer Disc.', sector: 'Cons. Disc', yahoo: 'XLY', color: '#06b6d4' },
                { symbol: 'XLP', name: 'Consumer Staples', sector: 'Cons. Stap', yahoo: 'XLP', color: '#84cc16' },
                { symbol: 'XLU', name: 'Utilities', sector: 'Utilities', yahoo: 'XLU', color: '#64748b' },
                { symbol: 'XLB', name: 'Materials', sector: 'Materials', yahoo: 'XLB', color: '#a855f7' },
                { symbol: 'XLRE', name: 'Real Estate', sector: 'Real Est.', yahoo: 'XLRE', color: '#14b8a6' },
                { symbol: 'XLC', name: 'Communication', sector: 'Comm.', yahoo: 'XLC', color: '#f97316' }
            ];

            // ===== NASDAQ 100 - Acciones m√°s ponderadas para sentimiento =====
            const [nasdaq100Data, setNasdaq100Data] = useState([]);
            const [nasdaq100Loading, setNasdaq100Loading] = useState(false);

            // Top 25 acciones m√°s ponderadas del NASDAQ 100 con su peso aproximado y sector
            const NASDAQ_100_TOP = [
                { symbol: 'AAPL', name: 'Apple Inc', weight: 11.2, sector: 'Technology', yahoo: 'AAPL', color: '#a3a3a3' },
                { symbol: 'MSFT', name: 'Microsoft', weight: 10.8, sector: 'Technology', yahoo: 'MSFT', color: '#00a4ef' },
                { symbol: 'NVDA', name: 'NVIDIA', weight: 8.5, sector: 'Technology', yahoo: 'NVDA', color: '#76b900' },
                { symbol: 'AMZN', name: 'Amazon', weight: 5.4, sector: 'Consumer', yahoo: 'AMZN', color: '#ff9900' },
                { symbol: 'META', name: 'Meta Platforms', weight: 4.8, sector: 'Communication', yahoo: 'META', color: '#0668e1' },
                { symbol: 'GOOGL', name: 'Alphabet A', weight: 3.2, sector: 'Communication', yahoo: 'GOOGL', color: '#4285f4' },
                { symbol: 'GOOG', name: 'Alphabet C', weight: 3.1, sector: 'Communication', yahoo: 'GOOG', color: '#ea4335' },
                { symbol: 'AVGO', name: 'Broadcom', weight: 3.8, sector: 'Technology', yahoo: 'AVGO', color: '#cc092f' },
                { symbol: 'TSLA', name: 'Tesla', weight: 3.2, sector: 'Consumer', yahoo: 'TSLA', color: '#e82127' },
                { symbol: 'COST', name: 'Costco', weight: 2.5, sector: 'Consumer', yahoo: 'COST', color: '#e31837' },
                { symbol: 'NFLX', name: 'Netflix', weight: 2.0, sector: 'Communication', yahoo: 'NFLX', color: '#e50914' },
                { symbol: 'AMD', name: 'AMD', weight: 1.8, sector: 'Technology', yahoo: 'AMD', color: '#ed1c24' },
                { symbol: 'ADBE', name: 'Adobe', weight: 1.7, sector: 'Technology', yahoo: 'ADBE', color: '#ff0000' },
                { symbol: 'QCOM', name: 'Qualcomm', weight: 1.5, sector: 'Technology', yahoo: 'QCOM', color: '#3253dc' },
                { symbol: 'PEP', name: 'PepsiCo', weight: 1.4, sector: 'Consumer', yahoo: 'PEP', color: '#004b93' },
                { symbol: 'LIN', name: 'Linde', weight: 1.3, sector: 'Materials', yahoo: 'LIN', color: '#003366' },
                { symbol: 'CSCO', name: 'Cisco', weight: 1.2, sector: 'Technology', yahoo: 'CSCO', color: '#049fd9' },
                { symbol: 'INTC', name: 'Intel', weight: 1.1, sector: 'Technology', yahoo: 'INTC', color: '#0071c5' },
                { symbol: 'INTU', name: 'Intuit', weight: 1.0, sector: 'Technology', yahoo: 'INTU', color: '#365ebf' },
                { symbol: 'CMCSA', name: 'Comcast', weight: 1.0, sector: 'Communication', yahoo: 'CMCSA', color: '#ff6600' },
                { symbol: 'AMAT', name: 'Applied Materials', weight: 0.9, sector: 'Technology', yahoo: 'AMAT', color: '#ff6600' },
                { symbol: 'MU', name: 'Micron', weight: 0.9, sector: 'Technology', yahoo: 'MU', color: '#0077c8' },
                { symbol: 'ISRG', name: 'Intuitive Surgical', weight: 0.8, sector: 'Healthcare', yahoo: 'ISRG', color: '#003087' },
                { symbol: 'LRCX', name: 'Lam Research', weight: 0.8, sector: 'Technology', yahoo: 'LRCX', color: '#00529b' },
                { symbol: 'REGN', name: 'Regeneron', weight: 0.7, sector: 'Healthcare', yahoo: 'REGN', color: '#0033a0' },
                // Resto del NASDAQ 100
                { symbol: 'KLAC', name: 'KLA Corp', weight: 0.7, sector: 'Technology', yahoo: 'KLAC', color: '#00529b' },
                { symbol: 'SNPS', name: 'Synopsys', weight: 0.7, sector: 'Technology', yahoo: 'SNPS', color: '#7b2d8e' },
                { symbol: 'CDNS', name: 'Cadence Design', weight: 0.6, sector: 'Technology', yahoo: 'CDNS', color: '#00a651' },
                { symbol: 'PANW', name: 'Palo Alto Networks', weight: 0.6, sector: 'Technology', yahoo: 'PANW', color: '#fa582d' },
                { symbol: 'MELI', name: 'MercadoLibre', weight: 0.6, sector: 'Consumer', yahoo: 'MELI', color: '#ffe600' },
                { symbol: 'ASML', name: 'ASML Holding', weight: 0.6, sector: 'Technology', yahoo: 'ASML', color: '#0f238c' },
                { symbol: 'ORLY', name: "O'Reilly Auto", weight: 0.5, sector: 'Consumer', yahoo: 'ORLY', color: '#006341' },
                { symbol: 'FTNT', name: 'Fortinet', weight: 0.5, sector: 'Technology', yahoo: 'FTNT', color: '#ee3124' },
                { symbol: 'ABNB', name: 'Airbnb', weight: 0.5, sector: 'Consumer', yahoo: 'ABNB', color: '#ff5a5f' },
                { symbol: 'MRVL', name: 'Marvell Technology', weight: 0.5, sector: 'Technology', yahoo: 'MRVL', color: '#c8102e' },
                { symbol: 'CTAS', name: 'Cintas', weight: 0.5, sector: 'Industrials', yahoo: 'CTAS', color: '#004c97' },
                { symbol: 'ADP', name: 'ADP', weight: 0.5, sector: 'Industrials', yahoo: 'ADP', color: '#d0271d' },
                { symbol: 'MDLZ', name: 'Mondelez', weight: 0.5, sector: 'Consumer', yahoo: 'MDLZ', color: '#5c2d91' },
                { symbol: 'MAR', name: 'Marriott', weight: 0.5, sector: 'Consumer', yahoo: 'MAR', color: '#c8102e' },
                { symbol: 'PYPL', name: 'PayPal', weight: 0.5, sector: 'Financials', yahoo: 'PYPL', color: '#003087' },
                { symbol: 'MNST', name: 'Monster Beverage', weight: 0.4, sector: 'Consumer', yahoo: 'MNST', color: '#95d600' },
                { symbol: 'GILD', name: 'Gilead Sciences', weight: 0.4, sector: 'Healthcare', yahoo: 'GILD', color: '#be0f34' },
                { symbol: 'CSX', name: 'CSX Corp', weight: 0.4, sector: 'Industrials', yahoo: 'CSX', color: '#0033a0' },
                { symbol: 'ADSK', name: 'Autodesk', weight: 0.4, sector: 'Technology', yahoo: 'ADSK', color: '#0696d7' },
                { symbol: 'CEG', name: 'Constellation Energy', weight: 0.4, sector: 'Utilities', yahoo: 'CEG', color: '#00aeef' },
                { symbol: 'AZN', name: 'AstraZeneca', weight: 0.4, sector: 'Healthcare', yahoo: 'AZN', color: '#830051' },
                { symbol: 'CHTR', name: 'Charter Comm', weight: 0.4, sector: 'Communication', yahoo: 'CHTR', color: '#0077c8' },
                { symbol: 'HON', name: 'Honeywell', weight: 0.4, sector: 'Industrials', yahoo: 'HON', color: '#e41f35' },
                { symbol: 'PCAR', name: 'PACCAR', weight: 0.4, sector: 'Industrials', yahoo: 'PCAR', color: '#c8102e' },
                { symbol: 'CPRT', name: 'Copart', weight: 0.4, sector: 'Industrials', yahoo: 'CPRT', color: '#003087' },
                { symbol: 'VRTX', name: 'Vertex Pharma', weight: 0.4, sector: 'Healthcare', yahoo: 'VRTX', color: '#00a3e0' },
                { symbol: 'CRWD', name: 'CrowdStrike', weight: 0.4, sector: 'Technology', yahoo: 'CRWD', color: '#f01928' },
                { symbol: 'WDAY', name: 'Workday', weight: 0.4, sector: 'Technology', yahoo: 'WDAY', color: '#0875e1' },
                { symbol: 'DXCM', name: 'DexCom', weight: 0.4, sector: 'Healthcare', yahoo: 'DXCM', color: '#88c540' },
                { symbol: 'ROP', name: 'Roper Technologies', weight: 0.4, sector: 'Industrials', yahoo: 'ROP', color: '#003087' },
                { symbol: 'PAYX', name: 'Paychex', weight: 0.3, sector: 'Industrials', yahoo: 'PAYX', color: '#004990' },
                { symbol: 'IDXX', name: 'IDEXX Labs', weight: 0.3, sector: 'Healthcare', yahoo: 'IDXX', color: '#009cde' },
                { symbol: 'KDP', name: 'Keurig Dr Pepper', weight: 0.3, sector: 'Consumer', yahoo: 'KDP', color: '#c8102e' },
                { symbol: 'ODFL', name: 'Old Dominion Freight', weight: 0.3, sector: 'Industrials', yahoo: 'ODFL', color: '#c8102e' },
                { symbol: 'AEP', name: 'American Electric', weight: 0.3, sector: 'Utilities', yahoo: 'AEP', color: '#00529b' },
                { symbol: 'FAST', name: 'Fastenal', weight: 0.3, sector: 'Industrials', yahoo: 'FAST', color: '#003087' },
                { symbol: 'KHC', name: 'Kraft Heinz', weight: 0.3, sector: 'Consumer', yahoo: 'KHC', color: '#c8102e' },
                { symbol: 'ROST', name: 'Ross Stores', weight: 0.3, sector: 'Consumer', yahoo: 'ROST', color: '#c8102e' },
                { symbol: 'EXC', name: 'Exelon', weight: 0.3, sector: 'Utilities', yahoo: 'EXC', color: '#003087' },
                { symbol: 'MCHP', name: 'Microchip Tech', weight: 0.3, sector: 'Technology', yahoo: 'MCHP', color: '#c8102e' },
                { symbol: 'CTSH', name: 'Cognizant', weight: 0.3, sector: 'Technology', yahoo: 'CTSH', color: '#0033a0' },
                { symbol: 'GEHC', name: 'GE HealthCare', weight: 0.3, sector: 'Healthcare', yahoo: 'GEHC', color: '#005eb8' },
                { symbol: 'EA', name: 'Electronic Arts', weight: 0.3, sector: 'Communication', yahoo: 'EA', color: '#ff4747' },
                { symbol: 'VRSK', name: 'Verisk Analytics', weight: 0.3, sector: 'Industrials', yahoo: 'VRSK', color: '#003087' },
                { symbol: 'LULU', name: 'Lululemon', weight: 0.3, sector: 'Consumer', yahoo: 'LULU', color: '#c8102e' },
                { symbol: 'TTWO', name: 'Take-Two Interactive', weight: 0.3, sector: 'Communication', yahoo: 'TTWO', color: '#e41f35' },
                { symbol: 'XEL', name: 'Xcel Energy', weight: 0.3, sector: 'Utilities', yahoo: 'XEL', color: '#00529b' },
                { symbol: 'FANG', name: 'Diamondback Energy', weight: 0.3, sector: 'Energy', yahoo: 'FANG', color: '#003087' },
                { symbol: 'ON', name: 'ON Semiconductor', weight: 0.3, sector: 'Technology', yahoo: 'ON', color: '#00529b' },
                { symbol: 'DDOG', name: 'Datadog', weight: 0.3, sector: 'Technology', yahoo: 'DDOG', color: '#774aa4' },
                { symbol: 'ZS', name: 'Zscaler', weight: 0.3, sector: 'Technology', yahoo: 'ZS', color: '#0090d4' },
                { symbol: 'CDW', name: 'CDW Corp', weight: 0.3, sector: 'Technology', yahoo: 'CDW', color: '#c8102e' },
                { symbol: 'BKR', name: 'Baker Hughes', weight: 0.2, sector: 'Energy', yahoo: 'BKR', color: '#003087' },
                { symbol: 'ANSS', name: 'Ansys', weight: 0.2, sector: 'Technology', yahoo: 'ANSS', color: '#ffb81c' },
                { symbol: 'CSGP', name: 'CoStar Group', weight: 0.2, sector: 'Real Estate', yahoo: 'CSGP', color: '#00529b' },
                { symbol: 'BIIB', name: 'Biogen', weight: 0.2, sector: 'Healthcare', yahoo: 'BIIB', color: '#00a3e0' },
                { symbol: 'GFS', name: 'GlobalFoundries', weight: 0.2, sector: 'Technology', yahoo: 'GFS', color: '#00529b' },
                { symbol: 'TEAM', name: 'Atlassian', weight: 0.2, sector: 'Technology', yahoo: 'TEAM', color: '#0052cc' },
                { symbol: 'ILMN', name: 'Illumina', weight: 0.2, sector: 'Healthcare', yahoo: 'ILMN', color: '#00a99d' },
                { symbol: 'DLTR', name: 'Dollar Tree', weight: 0.2, sector: 'Consumer', yahoo: 'DLTR', color: '#00843d' },
                { symbol: 'MRNA', name: 'Moderna', weight: 0.2, sector: 'Healthcare', yahoo: 'MRNA', color: '#0066cc' },
                { symbol: 'WBD', name: 'Warner Bros Discovery', weight: 0.2, sector: 'Communication', yahoo: 'WBD', color: '#003087' },
                { symbol: 'SBUX', name: 'Starbucks', weight: 0.2, sector: 'Consumer', yahoo: 'SBUX', color: '#00704a' },
                { symbol: 'AMGN', name: 'Amgen', weight: 0.2, sector: 'Healthcare', yahoo: 'AMGN', color: '#0063c3' },
                { symbol: 'PDD', name: 'PDD Holdings', weight: 0.2, sector: 'Consumer', yahoo: 'PDD', color: '#e4393c' },
                { symbol: 'TMUS', name: 'T-Mobile US', weight: 0.2, sector: 'Communication', yahoo: 'TMUS', color: '#e20074' },
                { symbol: 'ARM', name: 'ARM Holdings', weight: 0.2, sector: 'Technology', yahoo: 'ARM', color: '#0091bd' },
                { symbol: 'DASH', name: 'DoorDash', weight: 0.2, sector: 'Consumer', yahoo: 'DASH', color: '#ff3008' },
                { symbol: 'TTD', name: 'The Trade Desk', weight: 0.2, sector: 'Technology', yahoo: 'TTD', color: '#00b140' },
                { symbol: 'SMCI', name: 'Super Micro Computer', weight: 0.2, sector: 'Technology', yahoo: 'SMCI', color: '#003087' },
                { symbol: 'MDB', name: 'MongoDB', weight: 0.2, sector: 'Technology', yahoo: 'MDB', color: '#00ed64' },
                { symbol: 'COIN', name: 'Coinbase', weight: 0.2, sector: 'Financials', yahoo: 'COIN', color: '#0052ff' },
                { symbol: 'SPLK', name: 'Splunk', weight: 0.2, sector: 'Technology', yahoo: 'SPLK', color: '#65a637' },
                { symbol: 'WYNN', name: 'Wynn Resorts', weight: 0.1, sector: 'Consumer', yahoo: 'WYNN', color: '#aa8a53' },
                { symbol: 'SIRI', name: 'Sirius XM', weight: 0.1, sector: 'Communication', yahoo: 'SIRI', color: '#0033a0' },
                { symbol: 'LCID', name: 'Lucid Group', weight: 0.1, sector: 'Consumer', yahoo: 'LCID', color: '#574d45' }
            ];

            // ===== CALENDARIO ECON√ìMICO - Eventos de impacto =====
            const [economicEvents, setEconomicEvents] = useState([]);

            // ===== GOLD SENTIMENT - ORO con ETFs y acciones relacionadas =====
            const [goldData, setGoldData] = useState([]);
            const [goldLoading, setGoldLoading] = useState(false);

            const GOLD_ASSETS = [
                { symbol: 'GLD', name: 'SPDR Gold Trust', type: 'ETF', yahoo: 'GLD', weight: 25 },
                { symbol: 'IAU', name: 'iShares Gold Trust', type: 'ETF', yahoo: 'IAU', weight: 15 },
                { symbol: 'GDX', name: 'Gold Miners ETF', type: 'ETF', yahoo: 'GDX', weight: 15 },
                { symbol: 'GDXJ', name: 'Jr Gold Miners', type: 'ETF', yahoo: 'GDXJ', weight: 10 },
                { symbol: 'NEM', name: 'Newmont Corp', type: 'Stock', yahoo: 'NEM', weight: 10 },
                { symbol: 'GOLD', name: 'Barrick Gold', type: 'Stock', yahoo: 'GOLD', weight: 10 },
                { symbol: 'FNV', name: 'Franco-Nevada', type: 'Stock', yahoo: 'FNV', weight: 5 },
                { symbol: 'WPM', name: 'Wheaton Prec Metals', type: 'Stock', yahoo: 'WPM', weight: 5 },
                { symbol: 'GC=F', name: 'Gold Futures', type: 'Futures', yahoo: 'GC=F', weight: 5 }
            ];

            // ===== CRUDE OIL SENTIMENT - CRUDO con ETFs y acciones relacionadas =====
            const [oilData, setOilData] = useState([]);
            const [oilLoading, setOilLoading] = useState(false);

            const OIL_ASSETS = [
                { symbol: 'USO', name: 'US Oil Fund', type: 'ETF', yahoo: 'USO', weight: 20 },
                { symbol: 'XLE', name: 'Energy Select SPDR', type: 'ETF', yahoo: 'XLE', weight: 15 },
                { symbol: 'OIH', name: 'Oil Services ETF', type: 'ETF', yahoo: 'OIH', weight: 10 },
                { symbol: 'XOP', name: 'Oil & Gas Explor ETF', type: 'ETF', yahoo: 'XOP', weight: 10 },
                { symbol: 'XOM', name: 'Exxon Mobil', type: 'Stock', yahoo: 'XOM', weight: 10 },
                { symbol: 'CVX', name: 'Chevron', type: 'Stock', yahoo: 'CVX', weight: 10 },
                { symbol: 'COP', name: 'ConocoPhillips', type: 'Stock', yahoo: 'COP', weight: 8 },
                { symbol: 'SLB', name: 'Schlumberger', type: 'Stock', yahoo: 'SLB', weight: 7 },
                { symbol: 'OXY', name: 'Occidental Petrol', type: 'Stock', yahoo: 'OXY', weight: 5 },
                { symbol: 'CL=F', name: 'Crude Oil Futures', type: 'Futures', yahoo: 'CL=F', weight: 5 }
            ];

            // ===== MAG7 EARNINGS - Fechas de reportes =====
            const [mag7Earnings, setMag7Earnings] = useState([]);

            const MAG7_COMPANIES = [
                { symbol: 'AAPL', name: 'Apple', color: '#a3a3a3' },
                { symbol: 'MSFT', name: 'Microsoft', color: '#6b8cae' },
                { symbol: 'GOOGL', name: 'Alphabet', color: '#7a9e7e' },
                { symbol: 'AMZN', name: 'Amazon', color: '#c9a66b' },
                { symbol: 'NVDA', name: 'NVIDIA', color: '#8fa87f' },
                { symbol: 'META', name: 'Meta', color: '#7a8fa8' },
                { symbol: 'TSLA', name: 'Tesla', color: '#b87f7f' }
            ];

            // Eventos econ√≥micos importantes (simulados - en producci√≥n usar API real)
            const getEconomicCalendar = useCallback(() => {
                const today = new Date();
                const dayOfWeek = today.getDay();
                const hour = today.getHours();

                // Eventos t√≠picos por d√≠a de la semana (horarios EST)
                const weeklyEvents = {
                    1: [ // Lunes
                        { time: '10:00', event: 'ISM Manufacturing PMI', impact: 'high', actual: null },
                        { time: '14:00', event: 'Fed Speaker', impact: 'medium', actual: null }
                    ],
                    2: [ // Martes
                        { time: '08:30', event: 'PPI Data', impact: 'high', actual: null },
                        { time: '10:00', event: 'Consumer Confidence', impact: 'medium', actual: null },
                        { time: '13:00', event: 'Treasury Auction 10Y', impact: 'medium', actual: null }
                    ],
                    3: [ // Mi√©rcoles
                        { time: '08:30', event: 'CPI Inflation Data', impact: 'high', actual: null },
                        { time: '10:30', event: 'EIA Crude Inventories', impact: 'medium', actual: null },
                        { time: '14:00', event: 'FOMC Minutes / Rate Decision', impact: 'high', actual: null }
                    ],
                    4: [ // Jueves
                        { time: '08:30', event: 'Initial Jobless Claims', impact: 'high', actual: null },
                        { time: '08:30', event: 'Retail Sales', impact: 'high', actual: null },
                        { time: '10:00', event: 'Existing Home Sales', impact: 'low', actual: null }
                    ],
                    5: [ // Viernes
                        { time: '08:30', event: 'Non-Farm Payrolls', impact: 'high', actual: null },
                        { time: '08:30', event: 'Unemployment Rate', impact: 'high', actual: null },
                        { time: '10:00', event: 'U of Michigan Sentiment', impact: 'medium', actual: null }
                    ]
                };

                // Eventos siempre presentes
                const dailyEvents = [
                    { time: '09:30', event: 'US Market Open', impact: 'info', actual: 'NYSE/NASDAQ' },
                    { time: '16:00', event: 'US Market Close', impact: 'info', actual: 'NYSE/NASDAQ' }
                ];

                const todayEvents = weeklyEvents[dayOfWeek] || [];
                const allEvents = [...dailyEvents, ...todayEvents].sort((a, b) => a.time.localeCompare(b.time));

                // Marcar eventos pasados
                return allEvents.map(ev => {
                    const [evHour, evMin] = ev.time.split(':').map(Number);
                    const isPast = hour > evHour || (hour === evHour && today.getMinutes() >= evMin);
                    const isSoon = !isPast && (evHour - hour <= 1);
                    return { ...ev, isPast, isSoon, timeLeft: isPast ? null : `${evHour - hour}h ${60 - today.getMinutes()}m` };
                });
            }, []);

            // ===== NOTICIAS del mercado - RSS Feeds reales =====
            const [newsData, setNewsData] = useState([]);
            const [newsSource, setNewsSource] = useState('mixed'); // mixed, reuters, yahoo, cnbc, investing
            const [sendNewsToTelegram, setSendNewsToTelegram] = useState(false); // Toggle para enviar a Telegram
            const lastSentNewsRef = useRef(null); // Para evitar duplicados

            const RSS_FEEDS = {
                yahoo: 'https://feeds.finance.yahoo.com/rss/2.0/headline?s=^GSPC,^DJI,^IXIC&region=US&lang=en-US',
                cnbc: 'https://search.cnbc.com/rs/search/combinedcms/view.xml?partnerId=wrss01&id=100003114',
                investing: 'https://www.investing.com/rss/news.rss',
                marketwatch: 'https://feeds.marketwatch.com/marketwatch/topstories/',
                reuters: 'https://www.reutersagency.com/feed/?taxonomy=best-sectors&post_type=best'
            };

            // Funci√≥n para enviar noticia a Telegram
            const sendNewsAlert = useCallback(async (news) => {
                if (!window.services?.telegram?.sendTextToTelegram) return;

                const sentimentEmoji = news.sentiment === 'bullish' ? 'üü¢' : news.sentiment === 'bearish' ? 'üî¥' : '‚ö™';
                const impactEmoji = news.impact === 'high' ? 'üî•' : '';

                let message = `üì∞ <b>NOTICIA</b> | ${news.source} ${impactEmoji}\n`;
                message += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`;
                message += `${sentimentEmoji} ${news.title}\n`;
                message += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`;
                message += `‚è∞ ${news.time}\n`;
                if (news.link) {
                    message += `üîó <a href="${news.link}">Leer m√°s</a>`;
                }

                await window.services.telegram.sendTextToTelegram(message, false);
            }, []);

            const fetchMarketNews = useCallback(async () => {
                const allNews = [];
                const feedsToFetch = newsSource === 'mixed'
                    ? ['yahoo', 'cnbc', 'investing']
                    : [newsSource];

                for (const feedKey of feedsToFetch) {
                    const feedUrl = RSS_FEEDS[feedKey] || RSS_FEEDS.yahoo;

                    for (const proxy of CORS_PROXIES) {
                        try {
                            const response = await fetch(proxy + encodeURIComponent(feedUrl), {
                                signal: AbortSignal.timeout(10000)
                            });
                            if (!response.ok) continue;

                            const text = await response.text();
                            const parser = new DOMParser();
                            const xml = parser.parseFromString(text, 'text/xml');
                            const items = xml.querySelectorAll('item');

                            items.forEach((item, idx) => {
                                if (idx >= 5) return; // Max 5 per feed

                                const title = item.querySelector('title')?.textContent || '';
                                const pubDate = item.querySelector('pubDate')?.textContent || '';
                                const link = item.querySelector('link')?.textContent || '';

                                // Calcular tiempo relativo - mejor parsing de fecha
                                let newsDate = new Date(pubDate);
                                // Si la fecha no es v√°lida, usar Date.now() menos el √≠ndice para mantener orden
                                if (isNaN(newsDate.getTime())) {
                                    newsDate = new Date(Date.now() - (idx * 60000 * 10)); // Espaciar 10 min por noticia
                                }
                                const now = new Date();
                                const diffMs = now - newsDate;
                                const diffMins = Math.floor(diffMs / 60000);
                                const diffHours = Math.floor(diffMins / 60);
                                const diffDays = Math.floor(diffHours / 24);

                                let timeAgo = '';
                                if (diffMins < 60) timeAgo = `${diffMins}m ago`;
                                else if (diffHours < 24) timeAgo = `${diffHours}h ago`;
                                else timeAgo = `${diffDays}d ago`;

                                // Detectar sentimiento b√°sico por keywords
                                const lowerTitle = title.toLowerCase();
                                let sentiment = 'neutral';
                                const bullishWords = ['surge', 'rally', 'gain', 'rise', 'jump', 'soar', 'high', 'bull', 'up', 'beat', 'strong', 'optimis'];
                                const bearishWords = ['fall', 'drop', 'plunge', 'sink', 'crash', 'low', 'bear', 'down', 'miss', 'weak', 'fear', 'concern', 'warn'];

                                if (bullishWords.some(w => lowerTitle.includes(w))) sentiment = 'bullish';
                                else if (bearishWords.some(w => lowerTitle.includes(w))) sentiment = 'bearish';

                                // Detectar impacto
                                const highImpactWords = ['fed', 'fomc', 'rate', 'gdp', 'cpi', 'inflation', 'jobs', 'employment', 'crash', 'surge', 'plunge'];
                                const impact = highImpactWords.some(w => lowerTitle.includes(w)) ? 'high' : 'medium';

                                const sourceNames = {
                                    yahoo: 'Yahoo Finance',
                                    cnbc: 'CNBC',
                                    investing: 'Investing.com',
                                    marketwatch: 'MarketWatch',
                                    reuters: 'Reuters'
                                };

                                allNews.push({
                                    id: `${feedKey}-${idx}-${Date.now()}`,
                                    title: title.substring(0, 150),
                                    source: sourceNames[feedKey] || feedKey,
                                    time: timeAgo,
                                    sentiment,
                                    impact,
                                    link,
                                    timestamp: newsDate.getTime()
                                });
                            });

                            break; // √âxito, no probar m√°s proxies
                        } catch (e) {
                            // Intentar siguiente proxy
                        }
                    }
                }

                // Ordenar por timestamp m√°s reciente y limitar a 10
                allNews.sort((a, b) => b.timestamp - a.timestamp);

                if (allNews.length > 0) {
                    const newsToShow = allNews.slice(0, 10);

                    // Enviar noticia m√°s reciente a Telegram si est√° habilitado
                    const mostRecent = newsToShow[0];
                    if (sendNewsToTelegram && mostRecent && mostRecent.title !== lastSentNewsRef.current) {
                        lastSentNewsRef.current = mostRecent.title;
                        sendNewsAlert(mostRecent);
                    }

                    setNewsData(newsToShow);
                } else {
                    // Fallback si no hay noticias
                    setNewsData([
                        { id: 'fb1', title: 'Conectando con feeds de noticias...', source: 'Sistema', time: 'ahora', sentiment: 'neutral', impact: 'low' }
                    ]);
                }
            }, [newsSource, sendNewsToTelegram, sendNewsAlert]);

            // CORS Proxies actualizados para Yahoo Finance - Sentimiento
            const CORS_PROXIES = [
                'https://api.allorigins.win/raw?url=',
                'https://corsproxy.io/?',
                'https://api.codetabs.com/v1/proxy?quest=',
                'https://thingproxy.freeboard.io/fetch/',
                'https://cors-anywhere.herokuapp.com/'
            ];

            // Debug: Log para verificar conexi√≥n Yahoo
            const debugYahooConnection = useCallback(async () => {
                console.log('üîç [SentimentTab] Verificando conexi√≥n Yahoo Finance...');
                const testSymbol = 'SPY';
                const yahooUrl = `https://query1.finance.yahoo.com/v8/finance/chart/${testSymbol}?interval=1d&range=1d`;

                for (let i = 0; i < CORS_PROXIES.length; i++) {
                    const proxy = CORS_PROXIES[i];
                    try {
                        console.log(`   Probando proxy ${i + 1}: ${proxy.substring(0, 30)}...`);
                        const response = await fetch(proxy + encodeURIComponent(yahooUrl), {
                            signal: AbortSignal.timeout(5000)
                        });
                        if (response.ok) {
                            const data = await response.json();
                            if (data.chart?.result?.[0]) {
                                console.log(`‚úÖ [SentimentTab] Proxy ${i + 1} FUNCIONANDO - Yahoo Finance conectado`);
                                return true;
                            }
                        }
                    } catch (e) {
                        console.log(`‚ùå Proxy ${i + 1} fall√≥: ${e.message}`);
                    }
                }
                console.error('‚ùå [SentimentTab] TODOS los proxies fallaron - Sin conexi√≥n a Yahoo Finance');
                return false;
            }, []);

            // Ejecutar verificaci√≥n al montar
            useEffect(() => {
                debugYahooConnection();
            }, [debugYahooConnection]);

            const fetchSymbolData = useCallback(async (symbolInfo) => {
                const yahooUrl = `https://query1.finance.yahoo.com/v8/finance/chart/${symbolInfo.yahoo}?interval=5m&range=1d`;

                for (const proxy of CORS_PROXIES) {
                    try {
                        const response = await fetch(proxy + encodeURIComponent(yahooUrl), { signal: AbortSignal.timeout(8000) });
                        if (!response.ok) continue;

                        const data = await response.json();
                        const result = data.chart?.result?.[0];
                        if (!result) continue;

                        const quote = result.indicators?.quote?.[0];
                        const meta = result.meta;
                        if (!quote || !meta) continue;

                        const closes = quote.close?.filter(c => c != null) || [];
                        const highs = quote.high?.filter(h => h != null) || [];
                        const lows = quote.low?.filter(l => l != null) || [];
                        const volumes = quote.volume?.filter(v => v != null) || [];

                        if (closes.length < 2) continue;

                        const currentPrice = meta.regularMarketPrice || closes[closes.length - 1];
                        const previousClose = meta.previousClose || closes[0];
                        const change = currentPrice - previousClose;
                        const changePercent = (change / previousClose) * 100;

                        const currentVolume = volumes.reduce((a, b) => a + b, 0);
                        const avgVolume = meta.averageDailyVolume10Day || currentVolume;
                        const volumeRatio = avgVolume > 0 ? (currentVolume / avgVolume) * 100 : 0;

                        const dayHigh = meta.regularMarketDayHigh || Math.max(...highs);
                        const dayLow = meta.regularMarketDayLow || Math.min(...lows);
                        const dayRange = dayHigh - dayLow;
                        const volatility = (dayRange / currentPrice) * 100;

                        const atr = closes.length >= 14 ? closes.slice(-14).reduce((sum, c, i, arr) => {
                            if (i === 0) return 0;
                            return sum + Math.abs(c - arr[i - 1]);
                        }, 0) / 13 : dayRange;
                        const atrPercent = (atr / currentPrice) * 100;

                        const prevHistory = historyRef.current[symbolInfo.symbol];
                        const priceVelocity = prevHistory ? ((currentPrice - prevHistory.price) / prevHistory.price) * 100 : 0;
                        const deltaPrice = prevHistory ? currentPrice - prevHistory.price : 0;
                        const deltaVolume = prevHistory ? currentVolume - prevHistory.volume : 0;

                        historyRef.current[symbolInfo.symbol] = { price: currentPrice, volume: currentVolume, time: Date.now() };

                        const activityScore = (volatility * 2) + (Math.abs(changePercent)) + (volumeRatio / 50) + (Math.abs(priceVelocity) * 3);

                        return {
                            ...symbolInfo,
                            price: currentPrice,
                            previousClose,
                            change,
                            changePercent,
                            volume: currentVolume,
                            avgVolume,
                            volumeRatio,
                            dayHigh,
                            dayLow,
                            dayRange,
                            volatility,
                            atr,
                            atrPercent,
                            priceVelocity,
                            deltaPrice,
                            deltaVolume,
                            activityScore,
                            lastUpdate: new Date().toLocaleTimeString()
                        };
                    } catch (e) {
                        continue;
                    }
                }

                return { ...symbolInfo, price: 0, change: 0, changePercent: 0, volume: 0, volumeRatio: 0, volatility: 0, activityScore: 0, error: true };
            }, []);

            const fetchAllData = useCallback(async () => {
                setIsLoading(true);
                setError(null);
                try {
                    const results = await Promise.all(SYMBOLS.map(s => fetchSymbolData(s)));
                    setScannerData(results.filter(r => !r.error));
                    setLastUpdate(new Date().toLocaleTimeString());
                } catch (e) {
                    setError('Error fetching data');
                }
                setIsLoading(false);
            }, [fetchSymbolData]);

            // Fetch sector data
            const fetchSectorData = useCallback(async () => {
                console.log('üìä [SentimentTab] Fetching sector data from Yahoo Finance (REALTIME)...');
                setSectorLoading(true);
                const results = [];
                for (const sector of SECTOR_ETFS) {
                    // interval=1m para datos en tiempo real, range=1d para hoy
                    const yahooUrl = `https://query1.finance.yahoo.com/v8/finance/chart/${sector.yahoo}?interval=1m&range=1d`;
                    for (const proxy of CORS_PROXIES) {
                        try {
                            const response = await fetch(proxy + encodeURIComponent(yahooUrl), { signal: AbortSignal.timeout(8000) });
                            if (!response.ok) continue;
                            const data = await response.json();
                            const result = data.chart?.result?.[0];
                            if (!result) continue;

                            const meta = result.meta;
                            const quote = result.indicators?.quote?.[0];
                            const closes = quote?.close?.filter(c => c != null) || [];

                            // Usar regularMarketPrice para precio en TIEMPO REAL
                            const currentPrice = meta.regularMarketPrice || closes[closes.length - 1];
                            const previousClose = meta.previousClose || meta.chartPreviousClose || closes[0];

                            // Calcular cambio del d√≠a actual
                            const change = currentPrice - previousClose;
                            const changePercent = previousClose > 0 ? (change / previousClose) * 100 : 0;

                            // Performance intrad√≠a (desde apertura)
                            const openPrice = closes[0] || previousClose;
                            const intradayChange = openPrice > 0 ? ((currentPrice - openPrice) / openPrice) * 100 : 0;

                            console.log(`   ${sector.symbol}: $${currentPrice?.toFixed(2)} | ${changePercent >= 0 ? '+' : ''}${changePercent?.toFixed(2)}%`);

                            results.push({ ...sector, price: currentPrice, change, changePercent, weekChange: intradayChange, lastUpdate: new Date().toLocaleTimeString() });
                            break;
                        } catch (e) { continue; }
                    }
                }
                console.log(`‚úÖ [SentimentTab] Sector data loaded: ${results.length}/${SECTOR_ETFS.length} sectores`);
                if (results.length === 0) {
                    console.warn('‚ö†Ô∏è [SentimentTab] No se pudo obtener datos de sectores de Yahoo Finance');
                }
                setSectorData(results.sort((a, b) => b.changePercent - a.changePercent));
                setSectorLoading(false);
            }, []);

            // Fetch NASDAQ 100 data
            const fetchNasdaq100Data = useCallback(async () => {
                console.log('üìà [SentimentTab] Fetching NASDAQ 100 data from Yahoo Finance (REALTIME)...');
                setNasdaq100Loading(true);

                // Fetch en paralelo para mayor velocidad
                const fetchPromises = NASDAQ_100_TOP.map(async (stock) => {
                    // interval=2m para datos casi en tiempo real, range=1d para hoy
                    const yahooUrl = `https://query1.finance.yahoo.com/v8/finance/chart/${stock.yahoo}?interval=2m&range=1d`;
                    for (const proxy of CORS_PROXIES) {
                        try {
                            const response = await fetch(proxy + encodeURIComponent(yahooUrl), { signal: AbortSignal.timeout(8000) });
                            if (!response.ok) continue;
                            const data = await response.json();
                            const result = data.chart?.result?.[0];
                            if (!result) continue;

                            const meta = result.meta;
                            const quote = result.indicators?.quote?.[0];
                            const closes = quote?.close?.filter(c => c != null) || [];
                            const volumes = quote?.volume?.filter(v => v != null) || [];

                            // Usar regularMarketPrice para precio en TIEMPO REAL
                            const currentPrice = meta.regularMarketPrice || closes[closes.length - 1];
                            const previousClose = meta.previousClose || meta.chartPreviousClose || closes[0];

                            // Calcular cambio del d√≠a actual
                            const change = currentPrice - previousClose;
                            const changePercent = previousClose > 0 ? (change / previousClose) * 100 : 0;

                            // Volumen acumulado del d√≠a
                            const totalVolume = volumes.reduce((a, b) => a + (b || 0), 0);
                            const avgDailyVolume = meta.averageDailyVolume10Day || totalVolume;
                            const volumeRatio = avgDailyVolume > 0 ? totalVolume / avgDailyVolume : 1;

                            // Performance intrad√≠a (desde apertura)
                            const openPrice = closes[0] || previousClose;
                            const intradayChange = openPrice > 0 ? ((currentPrice - openPrice) / openPrice) * 100 : 0;

                            // Calcular impacto ponderado en el √≠ndice
                            const weightedImpact = changePercent * (stock.weight / 100);

                            return {
                                ...stock,
                                price: currentPrice,
                                change,
                                changePercent,
                                weekChange: intradayChange,
                                volumeRatio,
                                weightedImpact,
                                volume: totalVolume,
                                lastUpdate: new Date().toLocaleTimeString()
                            };
                        } catch (e) { continue; }
                    }
                    return null;
                });

                const fetchedResults = await Promise.all(fetchPromises);
                const validResults = fetchedResults.filter(r => r !== null);

                console.log(`‚úÖ [SentimentTab] NASDAQ 100 data loaded: ${validResults.length}/${NASDAQ_100_TOP.length} acciones`);
                if (validResults.length === 0) {
                    console.warn('‚ö†Ô∏è [SentimentTab] No se pudo obtener datos de NASDAQ 100 de Yahoo Finance');
                }

                setNasdaq100Data(validResults.sort((a, b) => Math.abs(b.weightedImpact) - Math.abs(a.weightedImpact)));
                setNasdaq100Loading(false);
            }, []);

            // Fetch Gold data
            const fetchGoldData = useCallback(async () => {
                setGoldLoading(true);
                const results = [];
                for (const asset of GOLD_ASSETS) {
                    // interval=2m para datos en tiempo real
                    const yahooUrl = `https://query1.finance.yahoo.com/v8/finance/chart/${asset.yahoo}?interval=2m&range=1d`;
                    for (const proxy of CORS_PROXIES) {
                        try {
                            const response = await fetch(proxy + encodeURIComponent(yahooUrl), { signal: AbortSignal.timeout(8000) });
                            if (!response.ok) continue;
                            const data = await response.json();
                            const result = data.chart?.result?.[0];
                            if (!result) continue;

                            const meta = result.meta;
                            const quote = result.indicators?.quote?.[0];
                            const closes = quote?.close?.filter(c => c != null) || [];

                            // Usar regularMarketPrice para TIEMPO REAL
                            const currentPrice = meta.regularMarketPrice || closes[closes.length - 1];
                            const previousClose = meta.previousClose || meta.chartPreviousClose || closes[0];
                            const change = currentPrice - previousClose;
                            const changePercent = previousClose > 0 ? (change / previousClose) * 100 : 0;
                            const openPrice = closes[0] || previousClose;
                            const intradayChange = openPrice > 0 ? ((currentPrice - openPrice) / openPrice) * 100 : 0;
                            const weightedImpact = changePercent * (asset.weight / 100);

                            results.push({ ...asset, price: currentPrice, change, changePercent, weekChange: intradayChange, weightedImpact, lastUpdate: new Date().toLocaleTimeString() });
                            break;
                        } catch (e) { continue; }
                    }
                }
                setGoldData(results.sort((a, b) => Math.abs(b.weightedImpact) - Math.abs(a.weightedImpact)));
                setGoldLoading(false);
            }, []);

            // Fetch Oil data
            const fetchOilData = useCallback(async () => {
                setOilLoading(true);
                const results = [];
                for (const asset of OIL_ASSETS) {
                    // interval=2m para datos en tiempo real
                    const yahooUrl = `https://query1.finance.yahoo.com/v8/finance/chart/${asset.yahoo}?interval=2m&range=1d`;
                    for (const proxy of CORS_PROXIES) {
                        try {
                            const response = await fetch(proxy + encodeURIComponent(yahooUrl), { signal: AbortSignal.timeout(8000) });
                            if (!response.ok) continue;
                            const data = await response.json();
                            const result = data.chart?.result?.[0];
                            if (!result) continue;

                            const meta = result.meta;
                            const quote = result.indicators?.quote?.[0];
                            const closes = quote?.close?.filter(c => c != null) || [];

                            // Usar regularMarketPrice para TIEMPO REAL
                            const currentPrice = meta.regularMarketPrice || closes[closes.length - 1];
                            const previousClose = meta.previousClose || meta.chartPreviousClose || closes[0];
                            const change = currentPrice - previousClose;
                            const changePercent = previousClose > 0 ? (change / previousClose) * 100 : 0;
                            const openPrice = closes[0] || previousClose;
                            const intradayChange = openPrice > 0 ? ((currentPrice - openPrice) / openPrice) * 100 : 0;
                            const weightedImpact = changePercent * (asset.weight / 100);

                            results.push({ ...asset, price: currentPrice, change, changePercent, weekChange: intradayChange, weightedImpact, lastUpdate: new Date().toLocaleTimeString() });
                            break;
                        } catch (e) { continue; }
                    }
                }
                setOilData(results.sort((a, b) => Math.abs(b.weightedImpact) - Math.abs(a.weightedImpact)));
                setOilLoading(false);
            }, []);

            // Fetch MAG7 earnings (simulated - in production use earnings API)
            const fetchMag7Earnings = useCallback(() => {
                // Fechas aproximadas de earnings Q4 2024 / Q1 2025 (actualizar seg√∫n calendario real)
                const earningsCalendar = [
                    { symbol: 'AAPL', name: 'Apple', nextEarnings: '2025-01-30', quarter: 'Q1 FY25', estimate: '$2.35', color: '#a3a3a3' },
                    { symbol: 'MSFT', name: 'Microsoft', nextEarnings: '2025-01-29', quarter: 'Q2 FY25', estimate: '$3.11', color: '#6b8cae' },
                    { symbol: 'GOOGL', name: 'Alphabet', nextEarnings: '2025-02-04', quarter: 'Q4 2024', estimate: '$2.05', color: '#7a9e7e' },
                    { symbol: 'AMZN', name: 'Amazon', nextEarnings: '2025-02-06', quarter: 'Q4 2024', estimate: '$1.48', color: '#c9a66b' },
                    { symbol: 'NVDA', name: 'NVIDIA', nextEarnings: '2025-02-26', quarter: 'Q4 FY25', estimate: '$0.84', color: '#8fa87f' },
                    { symbol: 'META', name: 'Meta', nextEarnings: '2025-02-05', quarter: 'Q4 2024', estimate: '$6.72', color: '#7a8fa8' },
                    { symbol: 'TSLA', name: 'Tesla', nextEarnings: '2025-01-29', quarter: 'Q4 2024', estimate: '$0.75', color: '#b87f7f' }
                ];

                const today = new Date();
                const enrichedEarnings = earningsCalendar.map(e => {
                    const earningsDate = new Date(e.nextEarnings);
                    const diffDays = Math.ceil((earningsDate - today) / (1000 * 60 * 60 * 24));
                    const isPast = diffDays < 0;
                    const isSoon = diffDays >= 0 && diffDays <= 7;
                    const isThisWeek = diffDays >= 0 && diffDays <= 5;
                    return { ...e, diffDays, isPast, isSoon, isThisWeek };
                }).sort((a, b) => new Date(a.nextEarnings) - new Date(b.nextEarnings));

                setMag7Earnings(enrichedEarnings);
            }, []);

            // Calcular sentimiento del ORO
            const goldSentiment = React.useMemo(() => {
                if (goldData.length === 0) return { score: 0, label: 'Neutral', color: '#9ca3af', bullish: 0, bearish: 0, volatility: 0, range: 0, momentum: 'LATERAL', momentumColor: '#9E9E9E' };
                const totalWeightedImpact = goldData.reduce((sum, s) => sum + (s.weightedImpact || 0), 0);
                const bullishAssets = goldData.filter(s => s.changePercent > 0.2).length;
                const bearishAssets = goldData.filter(s => s.changePercent < -0.2).length;

                // Calcular volatilidad promedio (rango de cambios)
                const changes = goldData.map(s => Math.abs(s.changePercent || 0));
                const avgVolatility = changes.reduce((a, b) => a + b, 0) / changes.length;
                const maxChange = Math.max(...changes);
                const range = maxChange - Math.min(...changes);

                // Determinar momentum/operabilidad
                let momentum, momentumColor;
                const imbalance = Math.abs(bullishAssets - bearishAssets) / goldData.length;
                if (avgVolatility > 1.5 && imbalance > 0.4) { momentum = 'ACTIVO'; momentumColor = '#00E676'; }
                else if (avgVolatility > 0.8 && imbalance > 0.2) { momentum = 'OPERABLE'; momentumColor = '#66BB6A'; }
                else if (avgVolatility < 0.3 || imbalance < 0.1) { momentum = 'LATERAL'; momentumColor = '#9E9E9E'; }
                else { momentum = 'MODERADO'; momentumColor = '#FFA726'; }

                let label, color;
                if (totalWeightedImpact > 0.3) { label = 'ALCISTA'; color = '#7a9e7e'; }
                else if (totalWeightedImpact > 0.1) { label = 'Levemente Alcista'; color = '#9db89d'; }
                else if (totalWeightedImpact < -0.3) { label = 'BAJISTA'; color = '#b87f7f'; }
                else if (totalWeightedImpact < -0.1) { label = 'Levemente Bajista'; color = '#c9a3a3'; }
                else { label = 'Neutral'; color = '#a3a3a3'; }

                return { score: totalWeightedImpact, label, color, bullish: bullishAssets, bearish: bearishAssets, total: goldData.length, volatility: avgVolatility, range: maxChange, momentum, momentumColor };
            }, [goldData]);

            // Calcular sentimiento del CRUDO
            const oilSentiment = React.useMemo(() => {
                if (oilData.length === 0) return { score: 0, label: 'Neutral', color: '#9ca3af', bullish: 0, bearish: 0, volatility: 0, range: 0, momentum: 'LATERAL', momentumColor: '#9E9E9E' };
                const totalWeightedImpact = oilData.reduce((sum, s) => sum + (s.weightedImpact || 0), 0);
                const bullishAssets = oilData.filter(s => s.changePercent > 0.2).length;
                const bearishAssets = oilData.filter(s => s.changePercent < -0.2).length;

                // Calcular volatilidad promedio
                const changes = oilData.map(s => Math.abs(s.changePercent || 0));
                const avgVolatility = changes.reduce((a, b) => a + b, 0) / changes.length;
                const maxChange = Math.max(...changes);
                const range = maxChange - Math.min(...changes);

                // Determinar momentum/operabilidad
                let momentum, momentumColor;
                const imbalance = Math.abs(bullishAssets - bearishAssets) / oilData.length;
                if (avgVolatility > 1.5 && imbalance > 0.4) { momentum = 'ACTIVO'; momentumColor = '#00E676'; }
                else if (avgVolatility > 0.8 && imbalance > 0.2) { momentum = 'OPERABLE'; momentumColor = '#66BB6A'; }
                else if (avgVolatility < 0.3 || imbalance < 0.1) { momentum = 'LATERAL'; momentumColor = '#9E9E9E'; }
                else { momentum = 'MODERADO'; momentumColor = '#FFA726'; }

                let label, color;
                if (totalWeightedImpact > 0.3) { label = 'ALCISTA'; color = '#c9a66b'; }
                else if (totalWeightedImpact > 0.1) { label = 'Levemente Alcista'; color = '#d4bc8a'; }
                else if (totalWeightedImpact < -0.3) { label = 'BAJISTA'; color = '#8c7a6b'; }
                else if (totalWeightedImpact < -0.1) { label = 'Levemente Bajista'; color = '#a3947f'; }
                else { label = 'Neutral'; color = '#a3a3a3'; }

                return { score: totalWeightedImpact, label, color, bullish: bullishAssets, bearish: bearishAssets, total: oilData.length, volatility: avgVolatility, range: maxChange, momentum, momentumColor };
            }, [oilData]);

            // Efecto para actualizar noticias cuando cambie la fuente
            useEffect(() => {
                fetchMarketNews();
            }, [newsSource, fetchMarketNews]);

            useEffect(() => {
                if (autoRefresh) {
                    fetchAllData();
                    fetchSectorData();
                    fetchNasdaq100Data();
                    fetchGoldData();
                    fetchOilData();
                    fetchMag7Earnings();
                    fetchMarketNews();
                    setEconomicEvents(getEconomicCalendar());
                    intervalRef.current = setInterval(fetchAllData, refreshInterval * 1000);
                    // Sectores, NASDAQ 100, Gold, Oil cada 60s, noticias cada 30s
                    const sectorInterval = setInterval(() => {
                        fetchSectorData();
                        fetchNasdaq100Data();
                        fetchGoldData();
                        fetchOilData();
                        setEconomicEvents(getEconomicCalendar());
                    }, 60000);
                    // MAG7 earnings cada 5 minutos (datos no cambian frecuentemente)
                    const earningsInterval = setInterval(fetchMag7Earnings, 300000);
                    const newsInterval = setInterval(() => {
                        fetchMarketNews();
                    }, 30000); // Noticias cada 30 segundos
                    return () => {
                        if (intervalRef.current) clearInterval(intervalRef.current);
                        clearInterval(sectorInterval);
                        clearInterval(earningsInterval);
                        clearInterval(newsInterval);
                    };
                }
                return () => { if (intervalRef.current) clearInterval(intervalRef.current); };
            }, [autoRefresh, refreshInterval, fetchAllData, fetchSectorData, fetchNasdaq100Data, fetchGoldData, fetchOilData, fetchMag7Earnings, fetchMarketNews, getEconomicCalendar]);

            // Filter and sort data
            const filteredData = filterType === 'all' ? scannerData : scannerData.filter(d => d.type === filterType);
            const sortedData = [...filteredData].sort((a, b) => {
                switch (sortBy) {
                    case 'volatility': return b.activityScore - a.activityScore;
                    case 'change': return Math.abs(b.changePercent) - Math.abs(a.changePercent);
                    case 'volume': return b.volumeRatio - a.volumeRatio;
                    case 'velocity': return Math.abs(b.priceVelocity) - Math.abs(a.priceVelocity);
                    default: return 0;
                }
            });

            const topActive = sortedData.slice(0, 5);
            const formatNum = (num, decimals = 2) => {
                if (num === undefined || num === null) return '-';
                if (Math.abs(num) >= 1e9) return (num / 1e9).toFixed(1) + 'B';
                if (Math.abs(num) >= 1e6) return (num / 1e6).toFixed(1) + 'M';
                if (Math.abs(num) >= 1e3) return (num / 1e3).toFixed(1) + 'K';
                return num.toFixed(decimals);
            };

            const btn = "px-3 py-1.5 rounded-lg text-xs font-medium transition-all";
            const select = "bg-neutral-800 border border-neutral-600 rounded-lg px-3 py-1.5 text-xs text-gray-200";

            // Calcular sentimiento general del mercado
            const marketSentiment = React.useMemo(() => {
                if (sectorData.length === 0) return { score: 0, label: 'Neutral', color: '#9ca3af', volatility: 0, range: 0, momentum: 'LATERAL', momentumColor: '#9E9E9E' };
                const avgChange = sectorData.reduce((sum, s) => sum + s.changePercent, 0) / sectorData.length;
                const bullishSectors = sectorData.filter(s => s.changePercent > 0.3).length;
                const bearishSectors = sectorData.filter(s => s.changePercent < -0.3).length;

                // Calcular volatilidad promedio
                const changes = sectorData.map(s => Math.abs(s.changePercent || 0));
                const avgVolatility = changes.reduce((a, b) => a + b, 0) / changes.length;
                const maxChange = Math.max(...changes);

                // Determinar momentum/operabilidad
                let momentum, momentumColor;
                const imbalance = Math.abs(bullishSectors - bearishSectors) / sectorData.length;
                if (avgVolatility > 1.2 && imbalance > 0.5) { momentum = 'ACTIVO'; momentumColor = '#00E676'; }
                else if (avgVolatility > 0.6 && imbalance > 0.3) { momentum = 'OPERABLE'; momentumColor = '#66BB6A'; }
                else if (avgVolatility < 0.25 || imbalance < 0.15) { momentum = 'LATERAL'; momentumColor = '#9E9E9E'; }
                else { momentum = 'MODERADO'; momentumColor = '#FFA726'; }

                if (avgChange > 0.5 && bullishSectors >= 7) return { score: avgChange, label: 'Muy Alcista', color: '#22c55e', bullish: bullishSectors, bearish: bearishSectors, volatility: avgVolatility, range: maxChange, momentum, momentumColor };
                if (avgChange > 0.2 && bullishSectors >= 5) return { score: avgChange, label: 'Alcista', color: '#4ade80', bullish: bullishSectors, bearish: bearishSectors, volatility: avgVolatility, range: maxChange, momentum, momentumColor };
                if (avgChange < -0.5 && bearishSectors >= 7) return { score: avgChange, label: 'Muy Bajista', color: '#ef4444', bullish: bullishSectors, bearish: bearishSectors, volatility: avgVolatility, range: maxChange, momentum, momentumColor };
                if (avgChange < -0.2 && bearishSectors >= 5) return { score: avgChange, label: 'Bajista', color: '#f87171', bullish: bullishSectors, bearish: bearishSectors, volatility: avgVolatility, range: maxChange, momentum, momentumColor };
                return { score: avgChange, label: 'Neutral', color: '#fbbf24', bullish: bullishSectors, bearish: bearishSectors, volatility: avgVolatility, range: maxChange, momentum, momentumColor };
            }, [sectorData]);

            // Calcular sentimiento del NASDAQ 100
            const nasdaq100Sentiment = React.useMemo(() => {
                if (nasdaq100Data.length === 0) return { score: 0, label: 'Neutral', color: '#9ca3af', bullish: 0, bearish: 0, neutral: 0, totalImpact: 0, volatility: 0, range: 0, momentum: 'LATERAL', momentumColor: '#9E9E9E' };

                // Calcular impacto ponderado total
                const totalWeightedImpact = nasdaq100Data.reduce((sum, s) => sum + s.weightedImpact, 0);

                // Contar acciones por sentimiento
                const bullishStocks = nasdaq100Data.filter(s => s.changePercent > 0.3).length;
                const bearishStocks = nasdaq100Data.filter(s => s.changePercent < -0.3).length;
                const neutralStocks = nasdaq100Data.length - bullishStocks - bearishStocks;

                // Calcular volatilidad promedio
                const changes = nasdaq100Data.map(s => Math.abs(s.changePercent || 0));
                const avgVolatility = changes.reduce((a, b) => a + b, 0) / changes.length;
                const maxChange = Math.max(...changes);

                // Determinar momentum/operabilidad
                let momentum, momentumColor;
                const imbalance = Math.abs(bullishStocks - bearishStocks) / nasdaq100Data.length;
                if (avgVolatility > 2.0 && imbalance > 0.3) { momentum = 'ACTIVO'; momentumColor = '#00E676'; }
                else if (avgVolatility > 1.0 && imbalance > 0.15) { momentum = 'OPERABLE'; momentumColor = '#66BB6A'; }
                else if (avgVolatility < 0.5 || imbalance < 0.08) { momentum = 'LATERAL'; momentumColor = '#9E9E9E'; }
                else { momentum = 'MODERADO'; momentumColor = '#FFA726'; }

                // Calcular peso total de alcistas vs bajistas
                const bullishWeight = nasdaq100Data.filter(s => s.changePercent > 0.3).reduce((sum, s) => sum + s.weight, 0);
                const bearishWeight = nasdaq100Data.filter(s => s.changePercent < -0.3).reduce((sum, s) => sum + s.weight, 0);

                // Sentimiento basado en el impacto ponderado y cantidad de acciones
                let label, color;
                if (totalWeightedImpact > 0.3 && bullishStocks >= 15) {
                    label = 'Muy Alcista'; color = '#22c55e';
                } else if (totalWeightedImpact > 0.1 && bullishStocks >= 10) {
                    label = 'Alcista'; color = '#4ade80';
                } else if (totalWeightedImpact < -0.3 && bearishStocks >= 15) {
                    label = 'Muy Bajista'; color = '#ef4444';
                } else if (totalWeightedImpact < -0.1 && bearishStocks >= 10) {
                    label = 'Bajista'; color = '#f87171';
                } else {
                    label = 'Neutral'; color = '#fbbf24';
                }

                // Agrupar por sector
                const sectorSentiment = {};
                nasdaq100Data.forEach(stock => {
                    if (!sectorSentiment[stock.sector]) {
                        sectorSentiment[stock.sector] = { stocks: [], totalWeight: 0, totalImpact: 0, avgChange: 0 };
                    }
                    sectorSentiment[stock.sector].stocks.push(stock);
                    sectorSentiment[stock.sector].totalWeight += stock.weight;
                    sectorSentiment[stock.sector].totalImpact += stock.weightedImpact;
                });

                // Calcular promedio por sector
                Object.keys(sectorSentiment).forEach(sector => {
                    const s = sectorSentiment[sector];
                    s.avgChange = s.stocks.reduce((sum, st) => sum + st.changePercent, 0) / s.stocks.length;
                });

                // Top 5 m√°s alcistas y bajistas (datos REALES del mercado)
                const sortedByChange = [...nasdaq100Data].sort((a, b) => b.changePercent - a.changePercent);
                const topBullish = sortedByChange.slice(0, 5).map(s => ({
                    symbol: s.symbol,
                    name: s.name || s.symbol,
                    change: s.changePercent,
                    sector: s.sector,
                    weight: s.weight
                }));
                const topBearish = sortedByChange.slice(-5).reverse().map(s => ({
                    symbol: s.symbol,
                    name: s.name || s.symbol,
                    change: s.changePercent,
                    sector: s.sector,
                    weight: s.weight
                }));

                return {
                    score: totalWeightedImpact,
                    label,
                    color,
                    bullish: bullishStocks,
                    bearish: bearishStocks,
                    neutral: neutralStocks,
                    bullishWeight,
                    bearishWeight,
                    totalImpact: totalWeightedImpact,
                    sectorSentiment,
                    topBullish,
                    topBearish,
                    volatility: avgVolatility,
                    range: maxChange,
                    momentum,
                    momentumColor
                };
            }, [nasdaq100Data]);

            // Funci√≥n para solicitar an√°lisis de sentimiento de IA
            const requestSentimentNarration = useCallback(async () => {
                console.log('[Sentiment Narrator] Iniciando an√°lisis...');
                console.log('[Sentiment Narrator] sectorData.length:', sectorData.length);

                if (sectorData.length === 0) {
                    console.log('[Sentiment Narrator] Sin datos de sectores, abortando');
                    setAiNarration({ error: 'Sin datos de sectores. Espera a que carguen los datos.' });
                    return;
                }

                setIsNarrating(true);
                try {
                    // Obtener API key de Groq desde localStorage (usa la misma clave que el resto de la app)
                    const groqApiKey = localStorage.getItem('groq_api_key') || '';
                    console.log('[Sentiment Narrator] API Key encontrada:', groqApiKey ? 'S√ç' : 'NO');
                    if (!groqApiKey) {
                        setAiNarration({ error: 'API Key de Groq no configurada. Ve a Configuraci√≥n > Integraciones.' });
                        setIsNarrating(false);
                        return;
                    }

                    // Preparar todos los sectores ordenados
                    const sortedSectors = [...sectorData].sort((a, b) => b.changePercent - a.changePercent);
                    const allSectorsStr = sortedSectors.map(s => `${s.sector} (${s.symbol}): ${s.changePercent > 0 ? '+' : ''}${s.changePercent.toFixed(2)}%`);
                    const topBullish = sortedSectors.slice(0, 3).map(s => `${s.sector} (${s.symbol}): ${s.changePercent > 0 ? '+' : ''}${s.changePercent.toFixed(2)}%`);
                    const topBearish = sortedSectors.slice(-3).reverse().map(s => `${s.sector} (${s.symbol}): ${s.changePercent > 0 ? '+' : ''}${s.changePercent.toFixed(2)}%`);

                    // Obtener VIX del scanner
                    const vixData = scannerData.find(d => d.symbol === 'VIX');
                    const vixInfo = vixData ? `VIX: ${vixData.price.toFixed(2)} (${vixData.changePercent > 0 ? '+' : ''}${vixData.changePercent.toFixed(2)}%)` : 'VIX no disponible';

                    // Top 5 m√°s activos del scanner
                    const top5Activos = scannerData
                        .filter(d => d.symbol !== 'VIX' && d.volume > 0)
                        .sort((a, b) => b.volume - a.volume)
                        .slice(0, 5)
                        .map(d => `${d.symbol}: $${d.price.toFixed(2)} (${d.changePercent > 0 ? '+' : ''}${d.changePercent.toFixed(2)}%) Vol: ${(d.volume / 1000000).toFixed(1)}M`);

                    // Eventos econ√≥micos pr√≥ximos
                    const upcomingEvents = economicEvents.filter(e => !e.isPast && e.impact !== 'info').slice(0, 3);
                    const eventsStr = upcomingEvents.length > 0
                        ? upcomingEvents.map(e => `${e.time} - ${e.event} (${e.impact})`).join(', ')
                        : 'Sin eventos econ√≥micos importantes pr√≥ximos';

                    // ‚ïê‚ïê‚ïê DATOS NASDAQ 100 PARA EL NARRADOR ‚ïê‚ïê‚ïê
                    const nasdaqScoreValue = nasdaq100Sentiment?.score ?? 0;
                    const nasdaqSentimentLabel = nasdaqScoreValue > 1.5 ? 'MUY ALCISTA'
                        : nasdaqScoreValue > 0.5 ? 'ALCISTA'
                            : nasdaqScoreValue > -0.5 ? 'NEUTRAL'
                                : nasdaqScoreValue > -1.5 ? 'BAJISTA' : 'MUY BAJISTA';

                    // Top movers NASDAQ - los que m√°s suben y bajan
                    const nasdaqStocksWithData = (nasdaq100Data || [])
                        .filter(stock => stock && typeof stock.changePercent === 'number')
                        .map(stock => ({
                            symbol: stock.symbol,
                            name: stock.name || stock.symbol,
                            sector: stock.sector || 'Tech',
                            weight: stock.weight || 0,
                            changePercent: stock.changePercent
                        }));

                    const sortedNasdaqByChange = [...nasdaqStocksWithData].sort((a, b) => b.changePercent - a.changePercent);
                    const topNasdaqBullish = sortedNasdaqByChange.slice(0, 5).map(s =>
                        `${s.symbol}: ${(s.changePercent ?? 0) > 0 ? '+' : ''}${(s.changePercent ?? 0).toFixed(2)}% (${s.sector || 'Tech'}, Peso: ${(s.weight ?? 0).toFixed(1)}%)`
                    );
                    const topNasdaqBearish = sortedNasdaqByChange.slice(-5).reverse().map(s =>
                        `${s.symbol}: ${(s.changePercent ?? 0) > 0 ? '+' : ''}${(s.changePercent ?? 0).toFixed(2)}% (${s.sector || 'Tech'}, Peso: ${(s.weight ?? 0).toFixed(1)}%)`
                    );

                    // Mega caps (>3% de peso) - m√°s importantes
                    const megaCaps = nasdaqStocksWithData
                        .filter(s => (s.weight ?? 0) > 3)
                        .sort((a, b) => (b.weight ?? 0) - (a.weight ?? 0))
                        .map(s => `${s.symbol}: ${(s.changePercent ?? 0) > 0 ? '+' : ''}${(s.changePercent ?? 0).toFixed(2)}% (Peso: ${(s.weight ?? 0).toFixed(1)}%)`);

                    // Resumen sectorial NASDAQ
                    const nasdaqSectorSummary = Object.entries(nasdaq100Sentiment?.sectorSentiment || {})
                        .map(([sector, data]) => `${sector}: ${data?.stocks?.filter(s => s.changePercent > 0.3).length ?? 0}‚Üë ${data?.stocks?.filter(s => s.changePercent < -0.3).length ?? 0}‚Üì (${(data?.avgChange ?? 0) > 0 ? '+' : ''}${(data?.avgChange ?? 0).toFixed(2)}%)`)
                        .join(' | ');

                    // Verificar que los datos de NASDAQ est√©n disponibles
                    const nasdaqScore = nasdaq100Sentiment?.score ?? 0;
                    const nasdaqBullish = nasdaq100Sentiment?.bullish ?? 0;
                    const nasdaqBearish = nasdaq100Sentiment?.bearish ?? 0;
                    const nasdaqWeightedBullish = nasdaq100Sentiment?.bullishWeight ?? 0;
                    const nasdaqWeightedBearish = nasdaq100Sentiment?.bearishWeight ?? 0;

                    const prompt = `Eres un analista experto ESPECIALIZADO EN NASDAQ 100 y mercados tecnol√≥gicos. Tu FOCO PRINCIPAL es el NASDAQ 100, pero debes contextualizar con el sentimiento general del mercado (S&P 500).

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   üéØ AN√ÅLISIS PRINCIPAL: NASDAQ 100
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

SENTIMIENTO NASDAQ 100: ${nasdaqSentimentLabel} (Score: ${nasdaqScore.toFixed(2)}%)
‚Ä¢ Acciones alcistas: ${nasdaqBullish} de 100
‚Ä¢ Acciones bajistas: ${nasdaqBearish} de 100
‚Ä¢ Peso alcista ponderado: ${nasdaqWeightedBullish.toFixed(1)}%
‚Ä¢ Peso bajista ponderado: ${nasdaqWeightedBearish.toFixed(1)}%

‚ïê‚ïê‚ïê MEGA CAPS (Peso >3% en √≠ndice) ‚ïê‚ïê‚ïê
${megaCaps.length > 0 ? megaCaps.join('\n') : 'Sin datos de mega caps'}

‚ïê‚ïê‚ïê TOP 5 L√çDERES NASDAQ HOY ‚ïê‚ïê‚ïê
${topNasdaqBullish.join('\n')}

‚ïê‚ïê‚ïê TOP 5 REZAGADOS NASDAQ HOY ‚ïê‚ïê‚ïê
${topNasdaqBearish.join('\n')}

‚ïê‚ïê‚ïê SECTORES NASDAQ ‚ïê‚ïê‚ïê
${nasdaqSectorSummary || 'Cargando datos sectoriales...'}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   üìä CONTEXTO GENERAL DEL MERCADO
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

S&P 500 SECTORES: ${marketSentiment.label} (Score: ${marketSentiment.score.toFixed(2)}%)
Sectores alcistas: ${marketSentiment.bullish}/11 | Bajistas: ${marketSentiment.bearish}/11

Top sectores S&P: ${topBullish.join(' | ')}
Peor sectores S&P: ${topBearish.join(' | ')}

VOLATILIDAD: ${vixInfo}

EVENTOS: ${eventsStr}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   üìù INSTRUCCIONES PARA EL AN√ÅLISIS
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

1. ENFOQUE 70% NASDAQ: Analiza primero el NASDAQ 100, especialmente:
   - Las MEGA CAPS (AAPL, MSFT, NVDA, AMZN, GOOG, META, TSLA) son las m√°s importantes
   - Identifica si hay rotaci√≥n sectorial dentro de tech
   - Nota si semiconductores vs software divergen

2. CONTEXTO 30% GENERAL: Relaciona con el mercado general:
   - ¬øEl NASDAQ est√° en l√≠nea con el S&P o diverge?
   - ¬øEl VIX sugiere complacencia o miedo?

3. SE√ëALES IMPORTANTES A MENCIONAR:
   - Si una mega cap tiene movimiento >2% (impacta el √≠ndice)
   - Si hay divergencia NASDAQ vs S&P (se√±al de rotaci√≥n)
   - Si VIX >25 (miedo extremo) o <12 (complacencia)

RESPONDE EN ESPA√ëOL, m√°ximo 6 frases, DIRECTO y PROFESIONAL. Sin saludos ni despedidas.
PRIORIZA informaci√≥n de NASDAQ 100 sobre todo lo dem√°s.`;

                    const response = await fetch('http://localhost:5000/analyze-sentiment', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            prompt: prompt,
                            groq_api_key: groqApiKey,
                            sentiment_data: {
                                // S&P 500 General
                                label: marketSentiment.label,
                                score: marketSentiment.score,
                                bullish_sectors: marketSentiment.bullish,
                                bearish_sectors: marketSentiment.bearish,
                                top_bullish: topBullish,
                                top_bearish: topBearish,
                                vix: vixData?.price || null,
                                events: upcomingEvents.map(e => e.event),
                                // NASDAQ 100 - Datos principales
                                nasdaq100: {
                                    label: nasdaqSentimentLabel,
                                    score: nasdaq100Sentiment.score,
                                    bullish: nasdaq100Sentiment.bullish,
                                    bearish: nasdaq100Sentiment.bearish,
                                    weightedBullish: nasdaq100Sentiment.bullishWeight,
                                    weightedBearish: nasdaq100Sentiment.bearishWeight,
                                    topBullish: topNasdaqBullish,
                                    topBearish: topNasdaqBearish,
                                    megaCaps: megaCaps
                                }
                            }
                        })
                    });

                    if (!response.ok) {
                        throw new Error(`Error del servidor: ${response.status}`);
                    }

                    const data = await response.json();
                    const narrationData = {
                        text: data.analysis || data.message || 'Sin an√°lisis disponible',
                        timestamp: new Date().toLocaleTimeString(),
                        sentiment: marketSentiment.label,
                        score: marketSentiment.score
                    };
                    setAiNarration(narrationData);
                    // Guardar globalmente para acceso desde Telegram y PDF
                    window.lastAiNarration = narrationData.text;
                    window.lastAiNarrationFull = narrationData;
                } catch (error) {
                    console.error('[AI Narrator] Error:', error);
                    setAiNarration({
                        error: `Error al conectar con AI Narrator: ${error.message}. Verifica que el servidor est√© corriendo (python ai_narrator.py)`
                    });
                }
                setIsNarrating(false);
            }, [sectorData, marketSentiment, scannerData, economicEvents, nasdaq100Data, nasdaq100Sentiment]);

            // Trigger de narraci√≥n cuando cambia el sentimiento (solo si aiEnabled est√° activo)
            useEffect(() => {
                if (!aiEnabled || sectorData.length === 0) return;

                const currentSentiment = marketSentiment.label;
                const hasChanged = lastSentimentRef.current && lastSentimentRef.current !== currentSentiment;

                if (hasChanged) {
                    console.log(`[AI Sentiment Narrator] Sentimiento cambi√≥: ${lastSentimentRef.current} ‚Üí ${currentSentiment}`);

                    // Delay para evitar spam si cambia r√°pido
                    if (narrationTimeoutRef.current) clearTimeout(narrationTimeoutRef.current);
                    narrationTimeoutRef.current = setTimeout(() => {
                        requestSentimentNarration();
                    }, 2000); // 2 segundos de delay
                }

                lastSentimentRef.current = currentSentiment;
            }, [marketSentiment.label, aiEnabled, sectorData.length, requestSentimentNarration]);

            // Actualizar sentimiento global cuando cambie
            useEffect(() => {
                if (onSentimentUpdate && sectorData.length > 0) {
                    onSentimentUpdate({
                        ...marketSentiment,
                        lastUpdate: lastUpdate,
                        sectors: sectorData.map(s => ({ symbol: s.symbol, change: s.changePercent }))
                    });
                }
            }, [marketSentiment, lastUpdate, onSentimentUpdate, sectorData.length]);

            // Actualizar NASDAQ 100 sentiment global cuando cambie
            useEffect(() => {
                if (onNasdaq100SentimentUpdate && nasdaq100Sentiment) {
                    const score = nasdaq100Sentiment.score ?? 0;
                    const label = score > 1.5 ? 'MUY ALCISTA'
                        : score > 0.5 ? 'ALCISTA'
                            : score > -0.5 ? 'NEUTRAL'
                                : score > -1.5 ? 'BAJISTA' : 'MUY BAJISTA';
                    // Colores pastel/grises en lugar de ne√≥n
                    const color = score > 1.5 ? '#7a9e7e'
                        : score > 0.5 ? '#8cb8a0'
                            : score > -0.5 ? '#c9b896'
                                : score > -1.5 ? '#c9a3a3' : '#b87f7f';

                    const sentimentData = {
                        score: score,
                        label: label,
                        color: color,
                        bullish: nasdaq100Sentiment.bullish ?? 0,
                        bearish: nasdaq100Sentiment.bearish ?? 0,
                        neutral: nasdaq100Sentiment.neutral ?? 0,
                        weightedBullish: nasdaq100Sentiment.bullishWeight ?? 0,
                        weightedBearish: nasdaq100Sentiment.bearishWeight ?? 0,
                        sectorData: nasdaq100Sentiment.sectorSentiment || {},
                        topBullish: nasdaq100Sentiment.topBullish || [],
                        topBearish: nasdaq100Sentiment.topBearish || [],
                        lastUpdate: new Date().toLocaleTimeString()
                    };

                    // Guardar en window para acceso desde PDF
                    window.lastNasdaq100Sentiment = sentimentData;

                    onNasdaq100SentimentUpdate(sentimentData);
                }
            }, [nasdaq100Sentiment, onNasdaq100SentimentUpdate]);

            // Guardar S&P 500 sentiment en window para PDF
            useEffect(() => {
                if (marketSentiment) {
                    window.lastSP500Sentiment = {
                        score: ((marketSentiment.bullish / Math.max(marketSentiment.bullish + marketSentiment.bearish, 1)) * 100) || 50,
                        bullishCount: marketSentiment.bullish,
                        bearishCount: marketSentiment.bearish,
                        neutral: marketSentiment.neutral
                    };
                }
            }, [marketSentiment]);

            return React.createElement('div', { className: "flex flex-col h-full p-3 gap-3 overflow-auto" },
                // ===== PANEL DE NARRADOR AI - Explicaci√≥n del Sentimiento (INICIO) =====
                React.createElement('div', { className: "bg-neutral-900/50 rounded-lg border border-neutral-700 p-3 shadow-lg" },
                    // Header del panel AI
                    React.createElement('div', { className: "flex items-center justify-between mb-2" },
                        React.createElement('div', { className: "flex items-center gap-2" },
                            React.createElement('div', {
                                className: "flex items-center gap-2 px-2 py-0.5 rounded bg-neutral-800 border border-neutral-700"
                            },
                                React.createElement('span', { className: "text-xs font-bold text-neutral-300" }, "AI NARRATOR"),
                                React.createElement('span', { className: "text-[9px] text-neutral-500 font-mono" }, "Llama 3.3 70B")
                            ),
                            aiNarration?.timestamp && React.createElement('span', {
                                className: "text-[10px] text-neutral-500 font-mono"
                            }, `Actualizado: ${aiNarration.timestamp}`)
                        ),
                        // Solo bot√≥n de an√°lisis manual (funciona siempre, independiente del toggle)
                        React.createElement('button', {
                            onClick: requestSentimentNarration,
                            disabled: isNarrating || sectorData.length === 0,
                            className: "px-2 py-1 rounded text-[10px] font-medium bg-neutral-700 hover:bg-neutral-600 text-neutral-300 disabled:opacity-30 disabled:cursor-not-allowed"
                        }, isNarrating ? 'Analizando...' : 'Analizar')
                    ),

                    // Contenido de la narraci√≥n
                    isNarrating
                        ? React.createElement('div', { className: "flex items-center justify-center py-4 gap-2" },
                            React.createElement('div', {
                                className: "w-4 h-4 border-2 border-neutral-500 border-t-transparent rounded-full animate-spin"
                            }),
                            React.createElement('span', { className: "text-xs text-neutral-400" },
                                "Analizando..."
                            )
                        )
                        : aiNarration?.error
                            ? React.createElement('div', {
                                className: "p-4 rounded-lg bg-red-900/20 border border-red-500/30 text-sm text-red-300"
                            }, aiNarration.error)
                            : aiNarration?.text
                                ? React.createElement('div', { className: "space-y-2" },
                                    // Sentimiento actual con colores
                                    React.createElement('div', { className: "flex items-center gap-2 pb-2 border-b border-neutral-800" },
                                        React.createElement('div', {
                                            className: "px-2 py-1 rounded font-bold text-xs",
                                            style: {
                                                background: `${marketSentiment.color}20`,
                                                border: `1px solid ${marketSentiment.color}50`,
                                                color: marketSentiment.color
                                            }
                                        }, marketSentiment.label),
                                        React.createElement('div', { className: "text-[10px] text-neutral-500" },
                                            `${marketSentiment.score >= 0 ? '+' : ''}${marketSentiment.score.toFixed(2)}% | `,
                                            `${marketSentiment.bullish || 0} alcistas, ${marketSentiment.bearish || 0} bajistas`
                                        )
                                    ),
                                    // An√°lisis de IA
                                    React.createElement('div', {
                                        className: "text-xs leading-relaxed text-neutral-300",
                                        style: { lineHeight: '1.5' }
                                    }, aiNarration.text)
                                )
                                : React.createElement('div', { className: "text-center py-3 text-neutral-500 text-xs" },
                                    aiEnabled
                                        ? 'Esperando cambio de sentimiento para narrar...'
                                        : 'Narrador AI desactivado. Act√≠valo para obtener an√°lisis autom√°tico cuando cambie el sentimiento.'
                                )
                ),

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // S&P 500 SECTORS - TREEMAP VIBRANTE CON GLOW
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                React.createElement('div', {
                    className: "overflow-hidden",
                    style: {
                        background: '#050508',
                        boxShadow: marketSentiment.score >= 0
                            ? '0 0 20px rgba(33,150,243,0.3), inset 0 0 30px rgba(33,150,243,0.05)'
                            : '0 0 20px rgba(244,67,54,0.3), inset 0 0 30px rgba(244,67,54,0.05)',
                        border: `1px solid ${marketSentiment.score >= 0 ? 'rgba(33,150,243,0.3)' : 'rgba(244,67,54,0.3)'}`
                    }
                },
                    // Header GRANDE con stats
                    React.createElement('div', {
                        className: "px-3 py-2 flex items-center justify-between",
                        style: {
                            background: marketSentiment.score >= 0
                                ? 'linear-gradient(90deg, rgba(13,71,161,0.4) 0%, rgba(5,5,8,0.9) 100%)'
                                : 'linear-gradient(90deg, rgba(183,28,28,0.4) 0%, rgba(5,5,8,0.9) 100%)'
                        }
                    },
                        React.createElement('div', { className: "flex items-center gap-4" },
                            React.createElement('span', { className: "text-white font-black text-sm" }, "S&P 500"),
                            React.createElement('span', {
                                className: "text-xl font-black font-mono",
                                style: {
                                    color: marketSentiment.score >= 0 ? '#42A5F5' : '#EF5350',
                                    textShadow: marketSentiment.score >= 0 ? '0 0 10px rgba(66,165,245,0.5)' : '0 0 10px rgba(239,83,80,0.5)'
                                }
                            }, `${marketSentiment.score >= 0 ? '+' : ''}${marketSentiment.score.toFixed(2)}%`),
                            React.createElement('span', {
                                className: "text-sm font-black px-2 py-1",
                                style: {
                                    background: marketSentiment.score >= 0 ? 'rgba(33,150,243,0.25)' : 'rgba(244,67,54,0.25)',
                                    color: marketSentiment.score >= 0 ? '#64B5F6' : '#EF9A9A',
                                    borderRadius: '2px'
                                }
                            }, marketSentiment.label),
                            // BADGE MOMENTUM/OPERABILIDAD
                            React.createElement('span', {
                                className: "text-xs font-black px-2 py-1",
                                style: {
                                    background: `${marketSentiment.momentumColor}25`,
                                    color: marketSentiment.momentumColor,
                                    boxShadow: `0 0 8px ${marketSentiment.momentumColor}40`
                                }
                            }, marketSentiment.momentum || 'LATERAL'),
                            // VOLATILIDAD
                            React.createElement('span', {
                                className: "text-[10px] font-bold px-1.5 py-0.5 font-mono",
                                style: {
                                    background: 'rgba(156,39,176,0.2)',
                                    color: '#CE93D8'
                                },
                                title: 'Volatilidad promedio'
                            }, `VOL:${(marketSentiment.volatility || 0).toFixed(2)}%`)
                        ),
                        React.createElement('div', { className: "flex items-center gap-4" },
                            React.createElement('span', { className: "text-base font-black font-mono", style: { color: '#42A5F5' } }, `‚Üë${marketSentiment.bullish || 0}`),
                            React.createElement('span', { className: "text-base font-black font-mono", style: { color: '#EF5350' } }, `‚Üì${marketSentiment.bearish || 0}`),
                            React.createElement('span', { className: "text-sm font-bold text-white/60" }, `T:${sectorData.length}`),
                            React.createElement('button', {
                                onClick: () => setAutoRefresh(!autoRefresh),
                                className: "text-xs font-bold px-2 py-1",
                                style: {
                                    background: autoRefresh ? 'rgba(33,150,243,0.3)' : 'rgba(100,100,100,0.2)',
                                    color: autoRefresh ? '#42A5F5' : '#666'
                                }
                            }, autoRefresh ? '‚óè LIVE' : 'OFF'),
                            React.createElement('button', { onClick: fetchAllData, disabled: isLoading, className: "text-sm text-neutral-500 hover:text-white px-1" }, '‚Üª')
                        )
                    ),
                    // Barra de Imbalance S&P - M√ÅS VISIBLE
                    React.createElement('div', { style: { height: '6px', display: 'flex', background: '#000' } },
                        React.createElement('div', {
                            style: {
                                width: `${sectorData.length > 0 ? (marketSentiment.bullish / sectorData.length) * 100 : 50}%`,
                                background: 'linear-gradient(90deg, #0D47A1, #1976D2, #2196F3)',
                                boxShadow: '0 0 10px rgba(33,150,243,0.6)',
                                transition: 'width 0.3s'
                            }
                        }),
                        React.createElement('div', {
                            style: {
                                flex: 1,
                                background: 'linear-gradient(90deg, #F44336, #D32F2F, #B71C1C)',
                                boxShadow: '0 0 10px rgba(244,67,54,0.6)',
                                transition: 'width 0.3s'
                            }
                        })
                    ),
                    // TREEMAP Grid - COLORES VIBRANTES CON GRADIENTE
                    React.createElement('div', {
                        className: "grid",
                        style: { gridTemplateColumns: 'repeat(6, 1fr)', gap: '0', background: '#000', padding: '0' }
                    },
                        sectorData.map((sector, idx) => {
                            const pct = sector.changePercent;
                            const isUp = pct >= 0;
                            const intensity = Math.min(Math.abs(pct) / 2, 1);
                            // Colores VIBRANTES con gradiente
                            const getBg = (p) => {
                                if (p >= 3) return 'linear-gradient(135deg, #1565C0 0%, #0D47A1 100%)';
                                if (p >= 2) return 'linear-gradient(135deg, #1976D2 0%, #1565C0 100%)';
                                if (p >= 1) return 'linear-gradient(135deg, #1E88E5 0%, #1976D2 100%)';
                                if (p >= 0.5) return 'linear-gradient(135deg, #2196F3 0%, #1E88E5 100%)';
                                if (p >= 0.2) return 'linear-gradient(135deg, #1a4a6e 0%, #0f3a55 100%)';
                                if (p >= 0) return 'linear-gradient(135deg, #0f2a3d 0%, #081820 100%)';
                                if (p >= -0.2) return 'linear-gradient(135deg, #3d1a0f 0%, #281008 100%)';
                                if (p >= -0.5) return 'linear-gradient(135deg, #6e2a1a 0%, #4a1a0f 100%)';
                                if (p >= -1) return 'linear-gradient(135deg, #C62828 0%, #B71C1C 100%)';
                                if (p >= -2) return 'linear-gradient(135deg, #D32F2F 0%, #C62828 100%)';
                                if (p >= -3) return 'linear-gradient(135deg, #E53935 0%, #D32F2F 100%)';
                                return 'linear-gradient(135deg, #F44336 0%, #E53935 100%)';
                            };
                            return React.createElement('div', {
                                key: sector.symbol,
                                className: "flex flex-col items-center justify-center cursor-pointer hover:brightness-125 transition-all",
                                style: {
                                    background: getBg(pct),
                                    padding: '12px 4px',
                                    minHeight: '75px',
                                    boxShadow: Math.abs(pct) > 1 ? `inset 0 0 20px rgba(${isUp ? '33,150,243' : '244,67,54'},0.2)` : 'none'
                                },
                                title: sector.name
                            },
                                React.createElement('div', { className: "text-white font-black text-lg leading-none drop-shadow-lg" },
                                    sector.symbol.replace('XL', '')),
                                React.createElement('div', {
                                    className: "text-sm font-black font-mono mt-1",
                                    style: { color: isUp ? '#90CAF9' : '#FFCDD2' }
                                }, (isUp ? '+' : '') + pct.toFixed(2) + '%'),
                                React.createElement('div', { className: "text-white/50 text-[8px] mt-0.5 truncate max-w-full" },
                                    sector.sector)
                            );
                        })
                    ),
                    sectorData.length === 0 && React.createElement('div', {
                        className: "text-center py-8 text-neutral-600 text-xs", style: { background: '#050508' }
                    }, "Cargando...")
                ),

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // NASDAQ 100 - TREEMAP VIBRANTE CON GLOW
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                React.createElement('div', {
                    className: "overflow-hidden",
                    'data-sentiment-capture': 'true',
                    style: {
                        background: '#050508',
                        boxShadow: nasdaq100Sentiment.score >= 0
                            ? '0 0 20px rgba(33,150,243,0.3), inset 0 0 30px rgba(33,150,243,0.05)'
                            : '0 0 20px rgba(244,67,54,0.3), inset 0 0 30px rgba(244,67,54,0.05)',
                        border: `1px solid ${nasdaq100Sentiment.score >= 0 ? 'rgba(33,150,243,0.3)' : 'rgba(244,67,54,0.3)'}`
                    }
                },
                    // Header GRANDE
                    React.createElement('div', {
                        className: "px-3 py-2 flex items-center justify-between",
                        style: {
                            background: nasdaq100Sentiment.score >= 0
                                ? 'linear-gradient(90deg, rgba(13,71,161,0.4) 0%, rgba(5,5,8,0.9) 100%)'
                                : 'linear-gradient(90deg, rgba(183,28,28,0.4) 0%, rgba(5,5,8,0.9) 100%)'
                        }
                    },
                        React.createElement('div', { className: "flex items-center gap-3" },
                            React.createElement('span', { className: "text-white font-black text-sm" }, "NASDAQ 100"),
                            React.createElement('span', {
                                className: "text-xl font-black font-mono",
                                style: {
                                    color: nasdaq100Sentiment.score >= 0 ? '#42A5F5' : '#EF5350',
                                    textShadow: nasdaq100Sentiment.score >= 0 ? '0 0 10px rgba(66,165,245,0.5)' : '0 0 10px rgba(239,83,80,0.5)'
                                }
                            }, `${nasdaq100Sentiment.score >= 0 ? '+' : ''}${(nasdaq100Sentiment.totalImpact || 0).toFixed(2)}%`),
                            React.createElement('span', {
                                className: "text-sm font-black px-2 py-1",
                                style: {
                                    background: nasdaq100Sentiment.score >= 0 ? 'rgba(33,150,243,0.25)' : 'rgba(244,67,54,0.25)',
                                    color: nasdaq100Sentiment.score >= 0 ? '#64B5F6' : '#EF9A9A',
                                    borderRadius: '2px'
                                }
                            }, nasdaq100Sentiment.label),
                            // BADGE MOMENTUM/OPERABILIDAD
                            React.createElement('span', {
                                className: "text-xs font-black px-2 py-1",
                                style: {
                                    background: `${nasdaq100Sentiment.momentumColor || '#9E9E9E'}25`,
                                    color: nasdaq100Sentiment.momentumColor || '#9E9E9E',
                                    boxShadow: `0 0 8px ${nasdaq100Sentiment.momentumColor || '#9E9E9E'}40`
                                }
                            }, nasdaq100Sentiment.momentum || 'LATERAL'),
                            // VOLATILIDAD
                            React.createElement('span', {
                                className: "text-[10px] font-bold px-1.5 py-0.5 font-mono",
                                style: {
                                    background: 'rgba(156,39,176,0.2)',
                                    color: '#CE93D8'
                                },
                                title: 'Volatilidad promedio'
                            }, `VOL:${(nasdaq100Sentiment.volatility || 0).toFixed(2)}%`)
                        ),
                        React.createElement('div', { className: "flex items-center gap-3" },
                            React.createElement('span', { className: "text-base font-black font-mono", style: { color: '#42A5F5' } }, `‚Üë${nasdaq100Sentiment.bullish || 0}`),
                            React.createElement('span', { className: "text-base font-black font-mono", style: { color: '#EF5350' } }, `‚Üì${nasdaq100Sentiment.bearish || 0}`),
                            React.createElement('span', { className: "text-sm font-bold text-white/60" }, `T:${nasdaq100Data.length}`),
                            React.createElement('span', {
                                className: "text-xs font-bold px-2 py-1",
                                style: { background: 'rgba(33,150,243,0.3)', color: '#42A5F5' }
                            }, '‚óè LIVE')
                        )
                    ),
                    // Barra de Imbalance NASDAQ - M√ÅS VISIBLE
                    React.createElement('div', { style: { height: '6px', display: 'flex', background: '#000' } },
                        React.createElement('div', {
                            style: {
                                width: `${nasdaq100Data.length > 0 ? (nasdaq100Sentiment.bullish / nasdaq100Data.length) * 100 : 50}%`,
                                background: 'linear-gradient(90deg, #0D47A1, #1976D2, #2196F3)',
                                boxShadow: '0 0 10px rgba(33,150,243,0.6)',
                                transition: 'width 0.3s'
                            }
                        }),
                        React.createElement('div', {
                            style: {
                                flex: 1,
                                background: 'linear-gradient(90deg, #F44336, #D32F2F, #B71C1C)',
                                boxShadow: '0 0 10px rgba(244,67,54,0.6)',
                                transition: 'width 0.3s'
                            }
                        })
                    ),
                    // TREEMAP - GRID UNIFORME SIN PESOS (sin huecos)
                    React.createElement('div', {
                        style: {
                            display: 'grid',
                            gridTemplateColumns: 'repeat(auto-fill, minmax(52px, 1fr))',
                            gap: '0',
                            background: '#000',
                            padding: '0'
                        }
                    },
                        nasdaq100Data.slice(0, 100).map((stock, idx) => {
                            const pct = stock.changePercent;
                            const isUp = pct >= 0;
                            // Colores VIBRANTES
                            const getBg = (p) => {
                                if (p >= 4) return 'linear-gradient(135deg, #0D47A1 0%, #0a3d8a 100%)';
                                if (p >= 3) return 'linear-gradient(135deg, #1565C0 0%, #0D47A1 100%)';
                                if (p >= 2) return 'linear-gradient(135deg, #1976D2 0%, #1565C0 100%)';
                                if (p >= 1) return 'linear-gradient(135deg, #1E88E5 0%, #1976D2 100%)';
                                if (p >= 0.5) return 'linear-gradient(135deg, #2196F3 0%, #1E88E5 100%)';
                                if (p >= 0.2) return 'linear-gradient(135deg, #1a4a6e 0%, #0f3a55 100%)';
                                if (p >= 0) return 'linear-gradient(135deg, #0f2a3d 0%, #081820 100%)';
                                if (p >= -0.2) return 'linear-gradient(135deg, #3d1a0f 0%, #281008 100%)';
                                if (p >= -0.5) return 'linear-gradient(135deg, #6e2a1a 0%, #4a1a0f 100%)';
                                if (p >= -1) return 'linear-gradient(135deg, #C62828 0%, #B71C1C 100%)';
                                if (p >= -2) return 'linear-gradient(135deg, #D32F2F 0%, #C62828 100%)';
                                if (p >= -3) return 'linear-gradient(135deg, #E53935 0%, #D32F2F 100%)';
                                if (p >= -4) return 'linear-gradient(135deg, #F44336 0%, #E53935 100%)';
                                return 'linear-gradient(135deg, #FF5252 0%, #F44336 100%)';
                            };

                            return React.createElement('div', {
                                key: stock.symbol,
                                className: "flex flex-col items-center justify-center cursor-pointer hover:brightness-125 transition-all",
                                style: {
                                    background: getBg(pct),
                                    padding: '6px 2px',
                                    minHeight: '48px',
                                    boxShadow: Math.abs(pct) > 2 ? `inset 0 0 15px rgba(${isUp ? '33,150,243' : '244,67,54'},0.3)` : 'none'
                                },
                                title: `${stock.name}\n${pct >= 0 ? '+' : ''}${pct.toFixed(2)}%`
                            },
                                React.createElement('div', { className: "text-white font-black text-xs leading-none drop-shadow-lg" }, stock.symbol),
                                React.createElement('div', {
                                    className: "text-[10px] font-bold font-mono mt-0.5",
                                    style: { color: isUp ? '#90CAF9' : '#FFCDD2' }
                                }, (isUp ? '+' : '') + pct.toFixed(2) + '%')
                            );
                        })
                    ),
                    nasdaq100Data.length === 0 && React.createElement('div', {
                        className: "text-center py-8 text-neutral-600 text-xs"
                    }, "Cargando...")
                ),

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // GOLD - TREEMAP VIBRANTE CON GLOW
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                React.createElement('div', {
                    className: "overflow-hidden",
                    style: {
                        background: '#050508',
                        boxShadow: goldSentiment.score >= 0
                            ? '0 0 20px rgba(33,150,243,0.3), inset 0 0 30px rgba(33,150,243,0.05)'
                            : '0 0 20px rgba(244,67,54,0.3), inset 0 0 30px rgba(244,67,54,0.05)',
                        border: `1px solid ${goldSentiment.score >= 0 ? 'rgba(33,150,243,0.3)' : 'rgba(244,67,54,0.3)'}`
                    }
                },
                    // Header GRANDE con stats
                    React.createElement('div', {
                        className: "px-3 py-2 flex items-center justify-between",
                        style: {
                            background: goldSentiment.score >= 0
                                ? 'linear-gradient(90deg, rgba(13,71,161,0.4) 0%, rgba(5,5,8,0.9) 100%)'
                                : 'linear-gradient(90deg, rgba(183,28,28,0.4) 0%, rgba(5,5,8,0.9) 100%)'
                        }
                    },
                        React.createElement('div', { className: "flex items-center gap-3" },
                            React.createElement('span', { className: "text-white font-black text-sm" }, "GOLD"),
                            React.createElement('span', {
                                className: "text-xl font-black font-mono",
                                style: {
                                    color: goldSentiment.score >= 0 ? '#42A5F5' : '#EF5350',
                                    textShadow: goldSentiment.score >= 0 ? '0 0 10px rgba(66,165,245,0.5)' : '0 0 10px rgba(239,83,80,0.5)'
                                }
                            }, `${goldSentiment.score >= 0 ? '+' : ''}${goldSentiment.score.toFixed(2)}%`),
                            React.createElement('span', {
                                className: "text-sm font-black px-2 py-1",
                                style: {
                                    background: goldSentiment.score >= 0 ? 'rgba(33,150,243,0.25)' : 'rgba(244,67,54,0.25)',
                                    color: goldSentiment.score >= 0 ? '#64B5F6' : '#EF9A9A',
                                    borderRadius: '2px'
                                }
                            }, goldSentiment.label),
                            // BADGE MOMENTUM/OPERABILIDAD
                            React.createElement('span', {
                                className: "text-xs font-black px-2 py-1",
                                style: {
                                    background: `${goldSentiment.momentumColor || '#9E9E9E'}25`,
                                    color: goldSentiment.momentumColor || '#9E9E9E',
                                    boxShadow: `0 0 8px ${goldSentiment.momentumColor || '#9E9E9E'}40`
                                }
                            }, goldSentiment.momentum || 'LATERAL'),
                            // VOLATILIDAD
                            React.createElement('span', {
                                className: "text-[10px] font-bold px-1.5 py-0.5 font-mono",
                                style: {
                                    background: 'rgba(156,39,176,0.2)',
                                    color: '#CE93D8'
                                },
                                title: 'Volatilidad promedio'
                            }, `VOL:${(goldSentiment.volatility || 0).toFixed(2)}%`)
                        ),
                        React.createElement('div', { className: "flex items-center gap-3" },
                            React.createElement('span', { className: "text-base font-black font-mono", style: { color: '#42A5F5' } }, `‚Üë${goldSentiment.bullish || 0}`),
                            React.createElement('span', { className: "text-base font-black font-mono", style: { color: '#EF5350' } }, `‚Üì${goldSentiment.bearish || 0}`),
                            React.createElement('span', { className: "text-sm font-bold text-white/60" }, `T:${goldData.length}`)
                        )
                    ),
                    // Barra de Imbalance GOLD - M√ÅS VISIBLE
                    React.createElement('div', { style: { height: '6px', display: 'flex', background: '#000' } },
                        React.createElement('div', {
                            style: {
                                width: `${goldData.length > 0 ? (goldSentiment.bullish / goldData.length) * 100 : 50}%`,
                                background: 'linear-gradient(90deg, #0D47A1, #1976D2, #2196F3)',
                                boxShadow: '0 0 10px rgba(33,150,243,0.6)'
                            }
                        }),
                        React.createElement('div', {
                            style: {
                                flex: 1,
                                background: 'linear-gradient(90deg, #F44336, #D32F2F, #B71C1C)',
                                boxShadow: '0 0 10px rgba(244,67,54,0.6)'
                            }
                        })
                    ),
                    // TREEMAP Grid GOLD - COLORES VIBRANTES
                    React.createElement('div', {
                        style: {
                            display: 'grid',
                            gridTemplateColumns: 'repeat(auto-fill, minmax(70px, 1fr))',
                            gap: '0',
                            background: '#000',
                            padding: '0'
                        }
                    },
                        goldData.map((asset, idx) => {
                            const pct = asset.changePercent || 0;
                            const isUp = pct >= 0;
                            // Colores VIBRANTES con gradiente
                            const getBg = (p) => {
                                if (p >= 2) return 'linear-gradient(135deg, #1565C0 0%, #0D47A1 100%)';
                                if (p >= 1) return 'linear-gradient(135deg, #1976D2 0%, #1565C0 100%)';
                                if (p >= 0.5) return 'linear-gradient(135deg, #1E88E5 0%, #1976D2 100%)';
                                if (p >= 0.2) return 'linear-gradient(135deg, #1a4a6e 0%, #0f3a55 100%)';
                                if (p >= 0) return 'linear-gradient(135deg, #0f2a3d 0%, #081820 100%)';
                                if (p >= -0.2) return 'linear-gradient(135deg, #3d1a0f 0%, #281008 100%)';
                                if (p >= -0.5) return 'linear-gradient(135deg, #6e2a1a 0%, #4a1a0f 100%)';
                                if (p >= -1) return 'linear-gradient(135deg, #C62828 0%, #B71C1C 100%)';
                                if (p >= -2) return 'linear-gradient(135deg, #D32F2F 0%, #C62828 100%)';
                                return 'linear-gradient(135deg, #E53935 0%, #D32F2F 100%)';
                            };
                            const isETF = asset.type === 'ETF';
                            const colSpan = isETF || idx < 2 ? 2 : 1;
                            const fontSize = isETF || idx < 2 ? 'text-lg' : 'text-base';
                            return React.createElement('div', {
                                key: asset.symbol,
                                className: "flex flex-col items-center justify-center cursor-pointer hover:brightness-125 transition-all",
                                style: {
                                    background: getBg(pct),
                                    padding: '10px 2px',
                                    minHeight: isETF ? '65px' : '55px',
                                    gridColumn: `span ${colSpan}`,
                                    boxShadow: Math.abs(pct) > 1 ? `inset 0 0 15px rgba(${isUp ? '33,150,243' : '244,67,54'},0.2)` : 'none'
                                },
                                title: `${asset.name}\n${asset.type}`
                            },
                                React.createElement('div', { className: `text-white font-black ${fontSize} leading-none drop-shadow-lg` }, asset.symbol),
                                React.createElement('div', {
                                    className: "text-sm font-bold font-mono mt-0.5",
                                    style: { color: isUp ? '#90CAF9' : '#FFCDD2' }
                                }, (isUp ? '+' : '') + pct.toFixed(2) + '%')
                            );
                        })
                    ),
                    goldData.length === 0 && React.createElement('div', { className: "text-center py-6 text-neutral-600 text-xs", style: { background: '#050508' } }, "Cargando...")
                ),

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // CRUDE OIL - TREEMAP VIBRANTE CON GLOW  
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                React.createElement('div', {
                    className: "overflow-hidden",
                    style: {
                        background: '#050508',
                        boxShadow: oilSentiment.score >= 0
                            ? '0 0 20px rgba(33,150,243,0.3), inset 0 0 30px rgba(33,150,243,0.05)'
                            : '0 0 20px rgba(244,67,54,0.3), inset 0 0 30px rgba(244,67,54,0.05)',
                        border: `1px solid ${oilSentiment.score >= 0 ? 'rgba(33,150,243,0.3)' : 'rgba(244,67,54,0.3)'}`
                    }
                },
                    // Header GRANDE con stats
                    React.createElement('div', {
                        className: "px-3 py-2 flex items-center justify-between",
                        style: {
                            background: oilSentiment.score >= 0
                                ? 'linear-gradient(90deg, rgba(13,71,161,0.4) 0%, rgba(5,5,8,0.9) 100%)'
                                : 'linear-gradient(90deg, rgba(183,28,28,0.4) 0%, rgba(5,5,8,0.9) 100%)'
                        }
                    },
                        React.createElement('div', { className: "flex items-center gap-3" },
                            React.createElement('span', { className: "text-white font-black text-sm" }, "CRUDE OIL"),
                            React.createElement('span', {
                                className: "text-xl font-black font-mono",
                                style: {
                                    color: oilSentiment.score >= 0 ? '#42A5F5' : '#EF5350',
                                    textShadow: oilSentiment.score >= 0 ? '0 0 10px rgba(66,165,245,0.5)' : '0 0 10px rgba(239,83,80,0.5)'
                                }
                            }, `${oilSentiment.score >= 0 ? '+' : ''}${oilSentiment.score.toFixed(2)}%`),
                            React.createElement('span', {
                                className: "text-sm font-black px-2 py-1",
                                style: {
                                    background: oilSentiment.score >= 0 ? 'rgba(33,150,243,0.25)' : 'rgba(244,67,54,0.25)',
                                    color: oilSentiment.score >= 0 ? '#64B5F6' : '#EF9A9A',
                                    borderRadius: '2px'
                                }
                            }, oilSentiment.label),
                            // BADGE MOMENTUM/OPERABILIDAD
                            React.createElement('span', {
                                className: "text-xs font-black px-2 py-1",
                                style: {
                                    background: `${oilSentiment.momentumColor || '#9E9E9E'}25`,
                                    color: oilSentiment.momentumColor || '#9E9E9E',
                                    boxShadow: `0 0 8px ${oilSentiment.momentumColor || '#9E9E9E'}40`
                                }
                            }, oilSentiment.momentum || 'LATERAL'),
                            // VOLATILIDAD
                            React.createElement('span', {
                                className: "text-[10px] font-bold px-1.5 py-0.5 font-mono",
                                style: {
                                    background: 'rgba(156,39,176,0.2)',
                                    color: '#CE93D8'
                                },
                                title: 'Volatilidad promedio'
                            }, `VOL:${(oilSentiment.volatility || 0).toFixed(2)}%`)
                        ),
                        React.createElement('div', { className: "flex items-center gap-3" },
                            React.createElement('span', { className: "text-base font-black font-mono", style: { color: '#42A5F5' } }, `‚Üë${oilSentiment.bullish || 0}`),
                            React.createElement('span', { className: "text-base font-black font-mono", style: { color: '#EF5350' } }, `‚Üì${oilSentiment.bearish || 0}`),
                            React.createElement('span', { className: "text-sm font-bold text-white/60" }, `T:${oilData.length}`)
                        )
                    ),
                    // Barra de Imbalance OIL - M√ÅS VISIBLE
                    React.createElement('div', { style: { height: '6px', display: 'flex', background: '#000' } },
                        React.createElement('div', {
                            style: {
                                width: `${oilData.length > 0 ? (oilSentiment.bullish / oilData.length) * 100 : 50}%`,
                                background: 'linear-gradient(90deg, #0D47A1, #1976D2, #2196F3)',
                                boxShadow: '0 0 10px rgba(33,150,243,0.6)'
                            }
                        }),
                        React.createElement('div', {
                            style: {
                                flex: 1,
                                background: 'linear-gradient(90deg, #F44336, #D32F2F, #B71C1C)',
                                boxShadow: '0 0 10px rgba(244,67,54,0.6)'
                            }
                        })
                    ),
                    // TREEMAP Grid OIL - COLORES VIBRANTES
                    React.createElement('div', {
                        style: {
                            display: 'grid',
                            gridTemplateColumns: 'repeat(auto-fill, minmax(70px, 1fr))',
                            gap: '0',
                            background: '#000',
                            padding: '0'
                        }
                    },
                        oilData.map((asset, idx) => {
                            const pct = asset.changePercent || 0;
                            const isUp = pct >= 0;
                            // Colores VIBRANTES con gradiente
                            const getBg = (p) => {
                                if (p >= 2) return 'linear-gradient(135deg, #1565C0 0%, #0D47A1 100%)';
                                if (p >= 1) return 'linear-gradient(135deg, #1976D2 0%, #1565C0 100%)';
                                if (p >= 0.5) return 'linear-gradient(135deg, #1E88E5 0%, #1976D2 100%)';
                                if (p >= 0.2) return 'linear-gradient(135deg, #1a4a6e 0%, #0f3a55 100%)';
                                if (p >= 0) return 'linear-gradient(135deg, #0f2a3d 0%, #081820 100%)';
                                if (p >= -0.2) return 'linear-gradient(135deg, #3d1a0f 0%, #281008 100%)';
                                if (p >= -0.5) return 'linear-gradient(135deg, #6e2a1a 0%, #4a1a0f 100%)';
                                if (p >= -1) return 'linear-gradient(135deg, #C62828 0%, #B71C1C 100%)';
                                if (p >= -2) return 'linear-gradient(135deg, #D32F2F 0%, #C62828 100%)';
                                return 'linear-gradient(135deg, #E53935 0%, #D32F2F 100%)';
                            };
                            const isETF = asset.type === 'ETF';
                            const colSpan = isETF || idx < 2 ? 2 : 1;
                            const fontSize = isETF || idx < 2 ? 'text-lg' : 'text-base';
                            return React.createElement('div', {
                                key: asset.symbol,
                                className: "flex flex-col items-center justify-center cursor-pointer hover:brightness-125 transition-all",
                                style: {
                                    background: getBg(pct),
                                    padding: '10px 2px',
                                    minHeight: isETF ? '65px' : '55px',
                                    gridColumn: `span ${colSpan}`,
                                    boxShadow: Math.abs(pct) > 1 ? `inset 0 0 15px rgba(${isUp ? '33,150,243' : '244,67,54'},0.2)` : 'none'
                                },
                                title: `${asset.name}\n${asset.type}`
                            },
                                React.createElement('div', { className: `text-white font-black ${fontSize} leading-none drop-shadow-lg` }, asset.symbol),
                                React.createElement('div', {
                                    className: "text-sm font-bold font-mono mt-0.5",
                                    style: { color: isUp ? '#90CAF9' : '#FFCDD2' }
                                }, (isUp ? '+' : '') + pct.toFixed(2) + '%')
                            );
                        })
                    ),
                    oilData.length === 0 && React.createElement('div', { className: "text-center py-6 text-neutral-600 text-xs", style: { background: '#050508' } }, "Cargando...")
                ),

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // MAG7 EARNINGS - ESTILO VIBRANTE CON GLOW
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                React.createElement('div', {
                    className: "overflow-hidden",
                    style: {
                        background: '#050508',
                        boxShadow: '0 0 20px rgba(106,27,154,0.3), inset 0 0 30px rgba(106,27,154,0.05)',
                        border: '1px solid rgba(106,27,154,0.3)'
                    }
                },
                    React.createElement('div', {
                        className: "px-3 py-2 flex items-center justify-between",
                        style: { background: 'linear-gradient(90deg, rgba(106,27,154,0.4) 0%, rgba(5,5,8,0.9) 100%)' }
                    },
                        React.createElement('div', { className: "flex items-center gap-3" },
                            React.createElement('span', { className: "text-white font-black text-sm" }, "MAG7 EARNINGS"),
                            mag7Earnings.filter(e => e.isSoon && !e.isPast).length > 0 &&
                            React.createElement('span', {
                                className: "text-sm font-black px-2 py-1",
                                style: {
                                    background: 'rgba(255,167,38,0.25)',
                                    color: '#FFB74D',
                                    borderRadius: '2px',
                                    textShadow: '0 0 10px rgba(255,167,38,0.5)'
                                }
                            }, `${mag7Earnings.filter(e => e.isSoon && !e.isPast).length} SOON`)
                        ),
                        React.createElement('span', { className: "text-sm font-bold text-white/60" }, `${mag7Earnings.length} empresas`)
                    ),
                    // Barra decorativa MAG7 - M√ÅS VISIBLE
                    React.createElement('div', {
                        style: {
                            height: '6px',
                            background: 'linear-gradient(90deg, #0D47A1, #1565C0, #6A1B9A, #AB47BC, #C62828, #E53935)',
                            boxShadow: '0 0 15px rgba(106,27,154,0.5)'
                        }
                    }),
                    // Grid MAG7 - SIN GAPS
                    React.createElement('div', {
                        style: {
                            display: 'grid',
                            gridTemplateColumns: 'repeat(7, 1fr)',
                            gap: '0',
                            background: '#000',
                            padding: '0'
                        }
                    },
                        mag7Earnings.map(company => {
                            const earningsDate = new Date(company.nextEarnings);
                            const dateStr = earningsDate.toLocaleDateString('es-ES', { day: 'numeric', month: 'short' });
                            const getBg = () => {
                                if (company.isSoon) return 'linear-gradient(135deg, #4a3f1a 0%, #2a2510 100%)';
                                if (company.isPast) return 'linear-gradient(135deg, #0a0a0a 0%, #050505 100%)';
                                return 'linear-gradient(135deg, #12121a 0%, #0c0c0e 100%)';
                            };
                            return React.createElement('div', {
                                key: company.symbol,
                                className: `flex flex-col items-center justify-center cursor-pointer hover:brightness-125 transition-all ${company.isPast ? 'opacity-35' : ''}`,
                                style: {
                                    background: getBg(),
                                    padding: '12px 2px',
                                    minHeight: '75px',
                                    boxShadow: company.isSoon ? 'inset 0 0 20px rgba(255,167,38,0.15)' : 'none'
                                }
                            },
                                React.createElement('div', {
                                    className: "font-black text-lg leading-none drop-shadow-lg",
                                    style: {
                                        color: company.color,
                                        textShadow: `0 0 10px ${company.color}50`
                                    }
                                }, company.symbol),
                                React.createElement('div', { className: "text-white/80 text-sm font-bold mt-1" }, dateStr),
                                React.createElement('div', { className: "text-white/50 text-xs" }, company.quarter)
                            );
                        })
                    ),
                    mag7Earnings.length === 0 && React.createElement('div', { className: "text-center py-6 text-neutral-600 text-xs", style: { background: '#050508' } }, "Cargando...")
                ),

                // Fila Media: Calendario Econ√≥mico + Noticias
                React.createElement('div', { className: "grid grid-cols-1 lg:grid-cols-2 gap-3" },
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    // CALENDARIO ECON√ìMICO - ESTILO VIBRANTE CON GLOW
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    React.createElement('div', {
                        className: "overflow-hidden",
                        style: {
                            background: '#050508',
                            boxShadow: '0 0 20px rgba(245,158,11,0.2), inset 0 0 30px rgba(245,158,11,0.03)',
                            border: '1px solid rgba(245,158,11,0.2)'
                        }
                    },
                        React.createElement('div', {
                            className: "px-3 py-2 flex items-center justify-between",
                            style: { background: 'linear-gradient(90deg, rgba(245,158,11,0.3) 0%, rgba(5,5,8,0.9) 100%)' }
                        },
                            React.createElement('span', {
                                className: "text-white font-black text-sm",
                                style: { textShadow: '0 0 10px rgba(245,158,11,0.3)' }
                            }, "CALENDARIO ECONOMICO"),
                            React.createElement('span', {
                                className: "text-sm font-bold",
                                style: { color: '#FFA726' }
                            }, new Date().toLocaleDateString('es-ES', { weekday: 'short', day: 'numeric', month: 'short' }).toUpperCase())
                        ),
                        // Barra decorativa
                        React.createElement('div', {
                            style: {
                                height: '4px',
                                background: 'linear-gradient(90deg, #F57C00, #FFA726, #FFB74D)',
                                boxShadow: '0 0 10px rgba(245,158,11,0.5)'
                            }
                        }),
                        React.createElement('div', {
                            className: "p-2 space-y-1 max-h-44 overflow-y-auto",
                            style: { background: '#050508' }
                        },
                            economicEvents.map((event, idx) => {
                                const impactColors = { high: '#EF5350', medium: '#FFA726', low: '#66BB6A', info: '#42A5F5' };
                                const impactBg = { high: 'rgba(239,83,80,0.15)', medium: 'rgba(255,167,38,0.15)', low: 'rgba(102,187,106,0.15)', info: 'rgba(66,165,245,0.15)' };
                                return React.createElement('div', {
                                    key: idx,
                                    className: `flex items-center gap-2 px-2 py-1.5 transition-all ${event.isPast ? 'opacity-40' : ''} ${event.isSoon ? 'ring-1 ring-amber-500/50' : ''}`,
                                    style: {
                                        background: impactBg[event.impact],
                                        boxShadow: event.isSoon ? 'inset 0 0 15px rgba(255,167,38,0.2)' : 'none'
                                    }
                                },
                                    React.createElement('span', {
                                        className: "text-xs font-bold font-mono w-14",
                                        style: { color: '#FFA726' }
                                    }, event.time),
                                    React.createElement('div', {
                                        className: "w-3 h-3 flex-shrink-0",
                                        style: {
                                            background: impactColors[event.impact],
                                            boxShadow: `0 0 8px ${impactColors[event.impact]}`
                                        }
                                    }),
                                    React.createElement('span', { className: "text-xs text-white font-medium flex-1 truncate" }, event.event),
                                    event.isSoon && React.createElement('span', {
                                        className: "text-[10px] px-1.5 py-0.5 font-black animate-pulse",
                                        style: { background: 'rgba(255,167,38,0.3)', color: '#FFB74D' }
                                    }, 'PRONTO'),
                                    event.isPast && React.createElement('span', { className: "text-[10px] text-neutral-600 font-bold" }, 'PASADO')
                                );
                            })
                        ),
                        economicEvents.length === 0 && React.createElement('div', {
                            className: "text-center py-6 text-neutral-600 text-xs",
                            style: { background: '#050508' }
                        }, "Sin eventos hoy")
                    ),

                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    // √öLTIMAS NOTICIAS - ESTILO VIBRANTE CON GLOW
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    React.createElement('div', {
                        className: "overflow-hidden",
                        style: {
                            background: '#050508',
                            boxShadow: '0 0 20px rgba(0,188,212,0.2), inset 0 0 30px rgba(0,188,212,0.03)',
                            border: '1px solid rgba(0,188,212,0.2)'
                        }
                    },
                        React.createElement('div', {
                            className: "px-3 py-2 flex items-center justify-between",
                            style: { background: 'linear-gradient(90deg, rgba(0,188,212,0.3) 0%, rgba(5,5,8,0.9) 100%)' }
                        },
                            React.createElement('div', { className: "flex items-center gap-3" },
                                React.createElement('span', {
                                    className: "text-white font-black text-sm",
                                    style: { textShadow: '0 0 10px rgba(0,188,212,0.3)' }
                                }, "ULTIMAS NOTICIAS"),
                                React.createElement('div', {
                                    className: "w-2 h-2 animate-pulse",
                                    style: { background: '#00E676', boxShadow: '0 0 10px #00E676' }
                                })
                            ),
                            React.createElement('div', { className: "flex items-center gap-2" },
                                React.createElement('button', {
                                    onClick: () => setSendNewsToTelegram(!sendNewsToTelegram),
                                    className: "flex items-center gap-1 px-2 py-0.5 text-[10px] font-black transition-all",
                                    style: {
                                        background: sendNewsToTelegram ? 'rgba(33,150,243,0.3)' : 'rgba(100,100,100,0.2)',
                                        color: sendNewsToTelegram ? '#42A5F5' : '#666',
                                        boxShadow: sendNewsToTelegram ? '0 0 10px rgba(33,150,243,0.3)' : 'none'
                                    }
                                },
                                    React.createElement('span', null, 'üì®'),
                                    React.createElement('span', null, sendNewsToTelegram ? 'ON' : 'OFF')
                                ),
                                React.createElement('select', {
                                    value: newsSource,
                                    onChange: (e) => setNewsSource(e.target.value),
                                    className: "px-2 py-0.5 text-[10px] font-bold focus:outline-none",
                                    style: {
                                        background: '#0a0a0a',
                                        border: '1px solid rgba(0,188,212,0.3)',
                                        color: '#00BCD4'
                                    }
                                },
                                    React.createElement('option', { value: 'mixed' }, 'TODAS'),
                                    React.createElement('option', { value: 'yahoo' }, 'YAHOO'),
                                    React.createElement('option', { value: 'cnbc' }, 'CNBC'),
                                    React.createElement('option', { value: 'investing' }, 'INVESTING'),
                                    React.createElement('option', { value: 'marketwatch' }, 'MARKETWATCH')
                                )
                            )
                        ),
                        // Barra decorativa
                        React.createElement('div', {
                            style: {
                                height: '4px',
                                background: 'linear-gradient(90deg, #006064, #00838F, #00BCD4)',
                                boxShadow: '0 0 10px rgba(0,188,212,0.5)'
                            }
                        }),
                        React.createElement('div', {
                            className: "p-2 space-y-1 max-h-44 overflow-y-auto",
                            style: { background: '#050508' }
                        },
                            [...newsData].sort((a, b) => {
                                const parseTime = (t) => {
                                    if (!t) return 0;
                                    const match = t.match(/(\d+)\s*(min|h|hr|hour|sec|s|m)/i);
                                    if (!match) return 9999;
                                    const num = parseInt(match[1]);
                                    const unit = match[2].toLowerCase();
                                    if (unit.startsWith('s')) return num / 60;
                                    if (unit === 'm' || unit === 'min') return num;
                                    if (unit.startsWith('h')) return num * 60;
                                    return 9999;
                                };
                                return parseTime(a.time) - parseTime(b.time);
                            }).map(news => {
                                const sentimentColors = { bullish: '#66BB6A', bearish: '#EF5350', neutral: '#9E9E9E' };
                                const sentimentIcons = { bullish: '‚Üë', bearish: '‚Üì', neutral: '‚Üí' };
                                return React.createElement('div', {
                                    key: news.id,
                                    className: "flex items-start gap-2 px-2 py-1.5 transition-all cursor-pointer hover:brightness-125",
                                    style: {
                                        background: news.sentiment === 'bullish' ? 'rgba(102,187,106,0.1)' : news.sentiment === 'bearish' ? 'rgba(239,83,80,0.1)' : 'rgba(158,158,158,0.05)'
                                    },
                                    onClick: () => news.link && window.open(news.link, '_blank')
                                },
                                    React.createElement('div', {
                                        className: "w-5 h-5 flex items-center justify-center flex-shrink-0 text-xs font-black",
                                        style: {
                                            background: `${sentimentColors[news.sentiment]}25`,
                                            color: sentimentColors[news.sentiment],
                                            boxShadow: `0 0 8px ${sentimentColors[news.sentiment]}40`
                                        }
                                    }, sentimentIcons[news.sentiment]),
                                    React.createElement('div', { className: "flex-1 min-w-0" },
                                        React.createElement('div', { className: "text-xs text-white font-medium line-clamp-2" }, news.title),
                                        React.createElement('div', { className: "flex items-center gap-2 mt-0.5" },
                                            React.createElement('span', { className: "text-[10px] font-bold", style: { color: '#00BCD4' } }, news.source),
                                            React.createElement('span', { className: "text-[10px] text-neutral-500" }, news.time),
                                            news.impact === 'high' && React.createElement('span', {
                                                className: "text-[10px] px-1 font-black",
                                                style: { background: 'rgba(239,83,80,0.3)', color: '#EF5350' }
                                            }, 'ALTO')
                                        )
                                    )
                                );
                            })
                        ),
                        newsData.length === 0 && React.createElement('div', {
                            className: "text-center py-6 text-neutral-600 text-xs",
                            style: { background: '#050508' }
                        }, "Cargando noticias...")
                    )
                ),

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // TABLA SCANNER TOP - ESTILO VIBRANTE CON GLOW
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                React.createElement('div', {
                    className: "flex-1 overflow-hidden flex flex-col min-h-[200px]",
                    style: {
                        background: '#050508',
                        boxShadow: '0 0 20px rgba(156,39,176,0.2), inset 0 0 30px rgba(156,39,176,0.03)',
                        border: '1px solid rgba(156,39,176,0.2)'
                    }
                },
                    // Header Scanner
                    React.createElement('div', {
                        className: "px-3 py-2 flex items-center justify-between",
                        style: { background: 'linear-gradient(90deg, rgba(156,39,176,0.3) 0%, rgba(5,5,8,0.9) 100%)' }
                    },
                        React.createElement('span', {
                            className: "text-white font-black text-sm",
                            style: { textShadow: '0 0 10px rgba(156,39,176,0.3)' }
                        }, "TOP SCANNER - ACTIVIDAD"),
                        React.createElement('span', {
                            className: "text-sm font-bold px-2 py-0.5",
                            style: { background: 'rgba(156,39,176,0.25)', color: '#CE93D8' }
                        }, `${sortedData.length} ACTIVOS`)
                    ),
                    // Barra decorativa
                    React.createElement('div', {
                        style: {
                            height: '4px',
                            background: 'linear-gradient(90deg, #7B1FA2, #9C27B0, #BA68C8)',
                            boxShadow: '0 0 10px rgba(156,39,176,0.5)'
                        }
                    }),
                    // Table header
                    React.createElement('div', {
                        className: "grid grid-cols-12 gap-2 px-3 py-2 text-[10px] font-black text-white/70 uppercase tracking-wider",
                        style: { background: '#0a0a0c' }
                    },
                        React.createElement('div', { className: "col-span-2" }, "Simbolo"),
                        React.createElement('div', { className: "text-right" }, "Precio"),
                        React.createElement('div', { className: "text-right" }, "Cambio"),
                        React.createElement('div', { className: "text-right" }, "% Chg"),
                        React.createElement('div', { className: "text-right" }, "Vol Ratio"),
                        React.createElement('div', { className: "text-right" }, "Volatilidad"),
                        React.createElement('div', { className: "text-right" }, "ATR %"),
                        React.createElement('div', { className: "text-right" }, "Velocidad"),
                        React.createElement('div', { className: "text-right" }, "Rango"),
                        React.createElement('div', { className: "col-span-2 text-center" }, "Actividad")
                    ),
                    // Table body
                    React.createElement('div', {
                        className: "flex-1 overflow-y-auto",
                        style: { background: '#050508' }
                    },
                        sortedData.length === 0
                            ? React.createElement('div', { className: "text-center py-8 text-neutral-600 text-xs" }, isLoading ? 'Cargando...' : 'Sin datos')
                            : sortedData.map((item, idx) => {
                                const isPositive = item.changePercent >= 0;
                                const color = isPositive ? '#66BB6A' : '#EF5350';
                                const bgColor = isPositive ? 'rgba(102,187,106,0.05)' : 'rgba(239,83,80,0.05)';
                                const velocityColor = item.priceVelocity >= 0 ? '#66BB6A' : '#EF5350';
                                const maxActivity = Math.max(...sortedData.map(d => d.activityScore), 1);
                                const activityWidth = (item.activityScore / maxActivity) * 100;
                                const activityColor = item.activityScore > maxActivity * 0.7 ? '#EF5350' : item.activityScore > maxActivity * 0.4 ? '#FFA726' : '#66BB6A';

                                return React.createElement('div', {
                                    key: item.symbol,
                                    className: "grid grid-cols-12 gap-2 px-3 py-1.5 border-b border-white/5 hover:brightness-125 transition-all",
                                    style: {
                                        background: idx === 0 ? 'rgba(239,83,80,0.15)' : bgColor,
                                        boxShadow: idx === 0 ? 'inset 0 0 20px rgba(239,83,80,0.1)' : 'none'
                                    }
                                },
                                    React.createElement('div', { className: "col-span-2 flex items-center gap-1" },
                                        React.createElement('div', null,
                                            React.createElement('div', { className: "font-black text-white text-xs" }, item.symbol),
                                            React.createElement('div', { className: "text-[9px] text-neutral-500" }, item.type)
                                        ),
                                        idx === 0 && React.createElement('span', {
                                            className: "text-[9px] px-1.5 py-0.5 font-black",
                                            style: { background: 'rgba(239,83,80,0.3)', color: '#EF5350', boxShadow: '0 0 8px rgba(239,83,80,0.3)' }
                                        }, 'HOT')
                                    ),
                                    React.createElement('div', { className: "text-right font-mono text-xs text-white font-bold" }, formatNum(item.price, item.price < 10 ? 4 : 2)),
                                    React.createElement('div', { className: "text-right font-mono text-xs font-bold", style: { color } }, (isPositive ? '+' : '') + formatNum(item.change, 2)),
                                    React.createElement('div', { className: "text-right font-mono text-xs font-black", style: { color, textShadow: `0 0 8px ${color}50` } }, (isPositive ? '+' : '') + item.changePercent.toFixed(2) + '%'),
                                    React.createElement('div', { className: "text-right font-mono text-xs font-bold", style: { color: item.volumeRatio > 150 ? '#FFA726' : item.volumeRatio > 100 ? '#66BB6A' : '#9E9E9E' } }, item.volumeRatio.toFixed(0) + '%'),
                                    React.createElement('div', { className: "text-right font-mono text-xs font-bold", style: { color: item.volatility > 2 ? '#EF5350' : item.volatility > 1 ? '#FFA726' : '#9E9E9E' } }, item.volatility.toFixed(2) + '%'),
                                    React.createElement('div', { className: "text-right font-mono text-xs text-neutral-500" }, item.atrPercent.toFixed(3) + '%'),
                                    React.createElement('div', { className: "text-right font-mono text-xs font-black", style: { color: velocityColor } }, (item.priceVelocity >= 0 ? '+' : '') + item.priceVelocity.toFixed(3) + '%'),
                                    React.createElement('div', { className: "text-right font-mono text-[10px] text-neutral-500" }, formatNum(item.dayLow, 2) + '-' + formatNum(item.dayHigh, 2)),
                                    React.createElement('div', { className: "col-span-2 flex items-center gap-1" },
                                        React.createElement('div', {
                                            className: "flex-1 h-2 overflow-hidden",
                                            style: { background: '#1a1a1a' }
                                        },
                                            React.createElement('div', {
                                                className: "h-full transition-all duration-500",
                                                style: {
                                                    width: `${activityWidth}%`,
                                                    background: `linear-gradient(90deg, ${activityColor}88, ${activityColor})`,
                                                    boxShadow: `0 0 10px ${activityColor}50`
                                                }
                                            })
                                        ),
                                        React.createElement('span', {
                                            className: "text-[10px] font-mono font-black min-w-[28px]",
                                            style: { color: activityColor }
                                        }, item.activityScore.toFixed(1))
                                    )
                                );
                            })
                    ),
                    // Footer
                    React.createElement('div', {
                        className: "px-3 py-1.5 flex items-center justify-between text-[10px]",
                        style: { background: '#0a0a0c', borderTop: '1px solid rgba(156,39,176,0.2)' }
                    },
                        React.createElement('span', { style: { color: '#9E9E9E' } }, "HOT = Mayor Actividad | Vol Ratio = Vol vs Prom 10d"),
                        React.createElement('span', { style: { color: '#CE93D8' } }, "Yahoo Finance ~15s delay")
                    )
                )
            );
        };
        // --- END: components/SentimentTab.tsx ---

        // --- START: components/GlobalConfigPanel.tsx ---
        // PRESETS GLOBALES - LA LEY ABSOLUTA PARA TODOS LOS C√ÅLCULOS
        const GLOBAL_PRESETS = {
            conservative: {
                label: 'Conservative',
                description: 'Menos se√±ales, mayor confirmaci√≥n',
                // Se√±ales y Ratios
                ratio: 3.0,
                bearishRatio: 0.33,  // 1/3
                // Periodos
                sma: 30,
                lookback: 50,
                rsiPeriod: 21,
                velocityPeriod: 7,
                // Keltner
                keltnerEmaPeriod: 30,
                keltnerAtrMult: 4.0,
                keltnerSlopeThreshold: 15000,
                // Thresholds
                spikeThreshold: 1.5,
                intensityThreshold: 60,
                dominanceFilterRatio: 1.2,
                // TOW espec√≠ficos
                towLookback: 30,
                towSignalSmaPeriod: 12,
                // Colores (pueden mantenerse)
                callColor: '#4a9eff',
                putColor: '#ff4444',
                smaColor: 'rgba(150, 150, 150, 0.6)',
                // Power Meters
                powerMeterMode: 'expanded',     // DEFAULT: expanded para ver MA siempre
                powerMeterMAWindow: 300,        // seconds: 30 | 60 | 300
                powerMeterLowThreshold: 40,
                powerMeterMediumThreshold: 70,
                powerMeterHighThreshold: 100
            },
            balanced: {
                label: 'Balanced',
                description: 'Equilibrio entre se√±ales y precisi√≥n',
                // Se√±ales y Ratios
                ratio: 2.0,
                bearishRatio: 0.5,  // 1/2
                // Periodos
                sma: 14,
                lookback: 30,
                rsiPeriod: 14,
                velocityPeriod: 5,
                // Keltner
                keltnerEmaPeriod: 20,
                keltnerAtrMult: 3.0,
                keltnerSlopeThreshold: 10000,
                // Thresholds
                spikeThreshold: 1.0,
                intensityThreshold: 50,
                dominanceFilterRatio: 1.0,
                // TOW espec√≠ficos
                towLookback: 20,
                towSignalSmaPeriod: 8,
                // Colores
                callColor: '#4a9eff',
                putColor: '#ff4444',
                smaColor: 'rgba(150, 150, 150, 0.6)',
                // Power Meters
                powerMeterMode: 'expanded',
                powerMeterMAWindow: 300,
                powerMeterLowThreshold: 40,
                powerMeterMediumThreshold: 70,
                powerMeterHighThreshold: 100
            },
            aggressive: {
                label: 'Aggressive',
                description: 'M√°s se√±ales, reacci√≥n r√°pida',
                // Se√±ales y Ratios
                ratio: 1.5,
                bearishRatio: 0.67,  // 1/1.5
                // Periodos
                sma: 8,
                lookback: 15,
                rsiPeriod: 9,
                velocityPeriod: 3,
                // Keltner
                keltnerEmaPeriod: 10,
                keltnerAtrMult: 2.0,
                keltnerSlopeThreshold: 5000,
                // Thresholds
                spikeThreshold: 0.7,
                intensityThreshold: 40,
                dominanceFilterRatio: 0.8,
                // TOW espec√≠ficos
                towLookback: 10,
                towSignalSmaPeriod: 5,
                // Colores
                callColor: '#4a9eff',
                putColor: '#ff4444',
                smaColor: 'rgba(150, 150, 150, 0.6)',
                // Power Meters
                powerMeterMode: 'expanded',
                powerMeterMAWindow: 60,      // Aggressive usa ventana m√°s corta (1min)
                powerMeterLowThreshold: 30,   // Umbrales m√°s bajos (m√°s sensible)
                powerMeterMediumThreshold: 60,
                powerMeterHighThreshold: 100
            }
        };

        // Funci√≥n para obtener configuraci√≥n completa desde un preset
        const getConfigFromPreset = (presetKey) => {
            const preset = GLOBAL_PRESETS[presetKey] || GLOBAL_PRESETS.balanced;
            return {
                presetKey: presetKey,
                bullishThreshold: preset.ratio,
                bearishThreshold: preset.bearishRatio,
                smaPeriod: preset.sma,
                lookback: preset.lookback,
                rsiPeriod: preset.rsiPeriod,
                velocityPeriod: preset.velocityPeriod,
                keltnerEmaPeriod: preset.keltnerEmaPeriod,
                keltnerAtrMult: preset.keltnerAtrMult,
                keltnerSlopeThreshold: preset.keltnerSlopeThreshold,
                spikeThreshold: preset.spikeThreshold,
                intensityThreshold: preset.intensityThreshold,
                dominanceFilterRatio: preset.dominanceFilterRatio,
                towLookback: preset.towLookback,
                towSignalSmaPeriod: preset.towSignalSmaPeriod,
                callColor: preset.callColor,
                putColor: preset.putColor,
                smaColor: preset.smaColor,
                powerMeterMode: preset.powerMeterMode,
                powerMeterMAWindow: preset.powerMeterMAWindow,
                powerMeterLowThreshold: preset.powerMeterLowThreshold,
                powerMeterMediumThreshold: preset.powerMeterMediumThreshold,
                powerMeterHighThreshold: preset.powerMeterHighThreshold
            };
        };

        components.GlobalConfigPanel = ({ isOpen, onClose, onApplyToAll, currentPreset = 'balanced' }) => {
            const { useState, useEffect } = React;

            // Estado local basado en preset actual
            const [selectedPreset, setSelectedPreset] = useState(currentPreset);
            const [customMode, setCustomMode] = useState(false);

            // Obtener valores del preset seleccionado
            const preset = GLOBAL_PRESETS[selectedPreset] || GLOBAL_PRESETS.balanced;

            // Estados para modo custom (inicializados desde preset)
            const [ratio, setRatio] = useState(preset.ratio);
            const [sma, setSma] = useState(preset.sma);
            const [lookback, setLookback] = useState(preset.lookback);
            const [rsiPeriod, setRsiPeriod] = useState(preset.rsiPeriod);
            const [keltnerEmaPeriod, setKeltnerEmaPeriod] = useState(preset.keltnerEmaPeriod);
            const [keltnerAtrMult, setKeltnerAtrMult] = useState(preset.keltnerAtrMult);
            const [keltnerSlopeThreshold, setKeltnerSlopeThreshold] = useState(preset.keltnerSlopeThreshold);
            const [callColor, setCallColor] = useState(preset.callColor);
            const [putColor, setPutColor] = useState(preset.putColor);
            const [smaColor, setSmaColor] = useState(preset.smaColor);

            // Power Meter states
            const [powerMeterMode, setPowerMeterMode] = useState(preset.powerMeterMode);
            const [powerMeterMAWindow, setPowerMeterMAWindow] = useState(preset.powerMeterMAWindow);
            const [powerMeterLowThreshold, setPowerMeterLowThreshold] = useState(preset.powerMeterLowThreshold);
            const [powerMeterMediumThreshold, setPowerMeterMediumThreshold] = useState(preset.powerMeterMediumThreshold);
            const [powerMeterHighThreshold, setPowerMeterHighThreshold] = useState(preset.powerMeterHighThreshold);

            // Aplicar preset inmediatamente al seleccionar
            const applyPreset = (presetKey) => {
                const p = GLOBAL_PRESETS[presetKey];
                setSelectedPreset(presetKey);
                setCustomMode(false);
                setRatio(p.ratio);
                setSma(p.sma);
                setLookback(p.lookback);
                setRsiPeriod(p.rsiPeriod);
                setKeltnerEmaPeriod(p.keltnerEmaPeriod);
                setKeltnerAtrMult(p.keltnerAtrMult);
                setKeltnerSlopeThreshold(p.keltnerSlopeThreshold);
                setCallColor(p.callColor);
                setPutColor(p.putColor);
                setSmaColor(p.smaColor);
                setPowerMeterMode(p.powerMeterMode);
                setPowerMeterMAWindow(p.powerMeterMAWindow);
                setPowerMeterLowThreshold(p.powerMeterLowThreshold);
                setPowerMeterMediumThreshold(p.powerMeterMediumThreshold);
                setPowerMeterHighThreshold(p.powerMeterHighThreshold);

                // Aplicar inmediatamente
                const config = getConfigFromPreset(presetKey);
                config.callColor = p.callColor;
                config.putColor = p.putColor;
                config.smaColor = p.smaColor;
                console.log('Preset Applied:', presetKey, config);
                onApplyToAll(config);
            };

            // Aplicar configuraci√≥n custom
            const handleApplyCustom = () => {
                const config = {
                    presetKey: 'custom',
                    bullishThreshold: ratio,
                    bearishThreshold: 1 / ratio,
                    smaPeriod: sma,
                    lookback: lookback,
                    rsiPeriod: rsiPeriod,
                    velocityPeriod: Math.max(3, Math.floor(sma / 3)),
                    keltnerEmaPeriod: keltnerEmaPeriod,
                    keltnerAtrMult: keltnerAtrMult,
                    keltnerSlopeThreshold: keltnerSlopeThreshold,
                    spikeThreshold: ratio / 2,
                    intensityThreshold: 50,
                    dominanceFilterRatio: 1.0,
                    towLookback: lookback,
                    towSignalSmaPeriod: Math.max(5, Math.floor(sma / 2)),
                    callColor: callColor,
                    putColor: putColor,
                    smaColor: smaColor,
                    powerMeterMode: powerMeterMode,
                    powerMeterMAWindow: powerMeterMAWindow,
                    powerMeterLowThreshold: powerMeterLowThreshold,
                    powerMeterMediumThreshold: powerMeterMediumThreshold,
                    powerMeterHighThreshold: powerMeterHighThreshold,
                    _updateTimestamp: Date.now()
                };
                console.log('Custom Config Applied:', config);
                onApplyToAll(config);
                onClose();
            };

            if (!isOpen) return null;

            return React.createElement('div', {
                className: "fixed inset-0 bg-black/70 z-[200] flex items-center justify-center",
                onClick: onClose
            },
                React.createElement('div', {
                    className: "bg-neutral-900 border border-neutral-700 rounded-xl shadow-2xl w-full max-w-2xl p-6 max-h-[90vh] overflow-y-auto",
                    onClick: e => e.stopPropagation()
                },
                    // Header
                    React.createElement('div', { className: "flex justify-between items-center mb-6" },
                        React.createElement('h2', { className: "text-xl font-bold text-gray-200" }, "Global Configuration"),
                        React.createElement('button', {
                            onClick: onClose,
                            className: "p-2 rounded-full hover:bg-neutral-700 transition-colors"
                        }, "X")
                    ),

                    // PRESETS - LA LEY ABSOLUTA
                    React.createElement('div', { className: "mb-6" },
                        React.createElement('label', { className: "block text-sm font-semibold text-sky-400 mb-3" }, "QUICK PRESETS (Click to Apply Instantly)"),
                        React.createElement('div', { className: "grid grid-cols-3 gap-3" },
                            Object.entries(GLOBAL_PRESETS).map(([key, p]) =>
                                React.createElement('button', {
                                    key: key,
                                    onClick: () => applyPreset(key),
                                    className: `p-4 rounded-lg border-2 transition-all ${selectedPreset === key && !customMode
                                        ? 'border-sky-500 bg-sky-500/20 text-sky-400 ring-2 ring-sky-500/50'
                                        : 'border-neutral-700 bg-neutral-800/50 text-neutral-300 hover:border-sky-600 hover:bg-sky-900/20'
                                        }`
                                },
                                    React.createElement('div', { className: "font-bold mb-1 text-lg" }, p.label),
                                    React.createElement('div', { className: "text-[10px] opacity-70 mb-2" }, p.description),
                                    React.createElement('div', { className: "text-xs font-mono bg-neutral-900/50 rounded px-2 py-1" },
                                        `R:${p.ratio} | SMA:${p.sma} | RSI:${p.rsiPeriod}`
                                    ),
                                    React.createElement('div', { className: "text-[10px] font-mono opacity-60 mt-1" },
                                        `LB:${p.lookback} | Kelt:${p.keltnerEmaPeriod}/${p.keltnerAtrMult}`
                                    )
                                )
                            )
                        ),
                        React.createElement('div', { className: "mt-3 text-xs text-emerald-400 text-center font-medium" },
                            selectedPreset && !customMode ? `Active: ${GLOBAL_PRESETS[selectedPreset].label} preset applied to all calculations` : 'Select a preset to apply'
                        )
                    ),

                    // Toggle Custom Mode
                    React.createElement('div', { className: "mb-4 flex items-center gap-3" },
                        React.createElement('button', {
                            onClick: () => setCustomMode(!customMode),
                            className: `px-4 py-2 rounded-lg border text-sm font-medium transition-all ${customMode
                                ? 'border-amber-500 bg-amber-500/20 text-amber-400'
                                : 'border-neutral-600 bg-neutral-800 text-neutral-400 hover:border-neutral-500'}`
                        }, customMode ? 'Custom Mode ON' : 'Enable Custom Mode'),
                        customMode && React.createElement('span', { className: "text-xs text-amber-400" }, 'Adjust values below and click Apply')
                    ),

                    // Custom Parameters (solo visible en modo custom)
                    customMode && React.createElement('div', { className: "border border-amber-500/30 rounded-lg p-4 mb-6 bg-amber-900/10" },
                        React.createElement('div', { className: "grid grid-cols-2 gap-4 mb-4" },
                            // Ratio
                            React.createElement('div', null,
                                React.createElement('label', { className: "block text-sm font-medium text-neutral-400 mb-2" },
                                    `Ratio: ${ratio.toFixed(1)} (Bearish: ${(1 / ratio).toFixed(2)})`
                                ),
                                React.createElement('input', {
                                    type: 'range', min: '1', max: '5', step: '0.1', value: ratio,
                                    onChange: (e) => setRatio(parseFloat(e.target.value)),
                                    className: "w-full h-2 bg-neutral-700 rounded-lg appearance-none cursor-pointer accent-amber-500"
                                })
                            ),
                            // SMA
                            React.createElement('div', null,
                                React.createElement('label', { className: "block text-sm font-medium text-neutral-400 mb-2" },
                                    `SMA Period: ${sma}`
                                ),
                                React.createElement('input', {
                                    type: 'range', min: '5', max: '50', step: '1', value: sma,
                                    onChange: (e) => setSma(parseInt(e.target.value)),
                                    className: "w-full h-2 bg-neutral-700 rounded-lg appearance-none cursor-pointer accent-amber-500"
                                })
                            ),
                            // Lookback
                            React.createElement('div', null,
                                React.createElement('label', { className: "block text-sm font-medium text-neutral-400 mb-2" },
                                    `Lookback: ${lookback}`
                                ),
                                React.createElement('input', {
                                    type: 'range', min: '10', max: '100', step: '5', value: lookback,
                                    onChange: (e) => setLookback(parseInt(e.target.value)),
                                    className: "w-full h-2 bg-neutral-700 rounded-lg appearance-none cursor-pointer accent-amber-500"
                                })
                            ),
                            // RSI Period
                            React.createElement('div', null,
                                React.createElement('label', { className: "block text-sm font-medium text-neutral-400 mb-2" },
                                    `RSI Period: ${rsiPeriod}`
                                ),
                                React.createElement('input', {
                                    type: 'range', min: '5', max: '50', step: '1', value: rsiPeriod,
                                    onChange: (e) => setRsiPeriod(parseInt(e.target.value)),
                                    className: "w-full h-2 bg-neutral-700 rounded-lg appearance-none cursor-pointer accent-amber-500"
                                })
                            )
                        ),
                        // Keltner
                        React.createElement('div', { className: "grid grid-cols-3 gap-4 mb-4" },
                            React.createElement('div', null,
                                React.createElement('label', { className: "block text-sm font-medium text-neutral-400 mb-2" },
                                    `Keltner EMA: ${keltnerEmaPeriod}`
                                ),
                                React.createElement('input', {
                                    type: 'range', min: '5', max: '50', step: '5', value: keltnerEmaPeriod,
                                    onChange: (e) => setKeltnerEmaPeriod(parseInt(e.target.value)),
                                    className: "w-full h-2 bg-neutral-700 rounded-lg appearance-none cursor-pointer accent-teal-500"
                                })
                            ),
                            React.createElement('div', null,
                                React.createElement('label', { className: "block text-sm font-medium text-neutral-400 mb-2" },
                                    `ATR Mult: ${keltnerAtrMult.toFixed(1)}`
                                ),
                                React.createElement('input', {
                                    type: 'range', min: '1', max: '10', step: '0.5', value: keltnerAtrMult,
                                    onChange: (e) => setKeltnerAtrMult(parseFloat(e.target.value)),
                                    className: "w-full h-2 bg-neutral-700 rounded-lg appearance-none cursor-pointer accent-teal-500"
                                })
                            ),
                            React.createElement('div', null,
                                React.createElement('label', { className: "block text-sm font-medium text-neutral-400 mb-2" },
                                    `Slope Thr: ${keltnerSlopeThreshold.toLocaleString()}`
                                ),
                                React.createElement('input', {
                                    type: 'range', min: '0', max: '50000', step: '1000', value: keltnerSlopeThreshold,
                                    onChange: (e) => setKeltnerSlopeThreshold(parseFloat(e.target.value)),
                                    className: "w-full h-2 bg-neutral-700 rounded-lg appearance-none cursor-pointer accent-teal-500"
                                })
                            )
                        ),
                        // Colors
                        React.createElement('div', { className: "flex gap-4" },
                            React.createElement('div', { className: "flex items-center gap-2" },
                                React.createElement('label', { className: "text-sm text-neutral-300" }, "Call:"),
                                React.createElement('input', {
                                    type: 'color', value: callColor,
                                    onChange: (e) => setCallColor(e.target.value),
                                    className: "w-10 h-8 bg-transparent border border-neutral-600 rounded cursor-pointer"
                                })
                            ),
                            React.createElement('div', { className: "flex items-center gap-2" },
                                React.createElement('label', { className: "text-sm text-neutral-300" }, "Put:"),
                                React.createElement('input', {
                                    type: 'color', value: putColor,
                                    onChange: (e) => setPutColor(e.target.value),
                                    className: "w-10 h-8 bg-transparent border border-neutral-600 rounded cursor-pointer"
                                })
                            )
                        ),

                        // Apply Custom Button
                        React.createElement('div', { className: "mt-4 flex justify-end" },
                            React.createElement('button', {
                                onClick: handleApplyCustom,
                                className: "px-6 py-2 bg-amber-600 hover:bg-amber-500 rounded-md text-sm font-semibold text-white transition-colors"
                            }, "Apply Custom Settings")
                        )
                    ),

                    // Close button
                    React.createElement('div', { className: "flex justify-end pt-4 border-t border-neutral-700" },
                        React.createElement('button', {
                            onClick: onClose,
                            className: "px-4 py-2 bg-neutral-700 hover:bg-neutral-600 rounded-md text-sm font-semibold transition-colors"
                        }, "Close")
                    )
                )
            );
        };
        // --- END: components/GlobalConfigPanel.tsx ---

        // --- START: components/HeaderBar.tsx ---
        components.HeaderBar = (props) => {
            const { useRef, useState, useEffect } = React;
            const { onFileSelect, onVolumeProfileLoad, fileNames, onAddChart, onClearSlots, onAutoLoadToday, gridLayout, onToggleGrid, timeFrame, onTimeFrameChange, isCollapsed, onToggleCollapse, backtestState, onBacktestAction, onSaveTemplate, onLoadTemplate, onExportTemplate, onImportTemplate, activeTab, onTabChange, expirationOptions, selectedExpirations, onExpirationChange,
                volumeProfileData, // Para mostrar indicador en backtest
                // Telegram props
                isSendingTelegram, telegramStatus, autoTelegramEnabled, autoTelegramInterval, selectedTelegramGroups, onTelegramGroupToggle, onTelegramSend, onAutoTelegramToggle, onAutoTelegramIntervalChange,
                // AI Narrator props
                aiNarratorEnabled, onAiNarratorToggle, onOpenAiConfig
            } = props;
            const templateInputRef = useRef(null);
            const backtestSlotRef = useRef(null);
            const telegramDropdownRef = useRef(null);
            const [showSlots, setShowSlots] = useState(false);
            const [showTelegramGroups, setShowTelegramGroups] = useState(false);
            const [showBacktest, setShowBacktest] = useState(false);

            // Cerrar dropdown de Telegram al hacer clic fuera
            useEffect(() => {
                const handleClickOutside = (e) => {
                    if (telegramDropdownRef.current && !telegramDropdownRef.current.contains(e.target)) {
                        setShowTelegramGroups(false);
                    }
                };
                if (showTelegramGroups) {
                    document.addEventListener('mousedown', handleClickOutside);
                }
                return () => document.removeEventListener('mousedown', handleClickOutside);
            }, [showTelegramGroups]);

            const Slot = ({ slotId, fileName, onFileSelect, onVolumeProfileLoad, compact }) => {
                const handleDataClick = async () => {
                    try {
                        const [fileHandle] = await window.showOpenFilePicker({ types: [{ description: 'CSV', accept: { 'text/csv': ['.csv'] } }], multiple: false });
                        const file = await fileHandle.getFile();
                        const text = await file.text();
                        onFileSelect(text, file, slotId, fileHandle);
                    } catch (err) { if (err.name !== 'AbortError') console.error(err); }
                };
                const handleVolClick = async () => {
                    try {
                        const [fileHandle] = await window.showOpenFilePicker({ types: [{ description: 'Volume Profile CSV', accept: { 'text/csv': ['.csv'] } }], multiple: false });
                        const file = await fileHandle.getFile();
                        const text = await file.text();
                        if (onVolumeProfileLoad) onVolumeProfileLoad(text, file, slotId);
                    } catch (err) { if (err.name !== 'AbortError') console.error(err); }
                };
                return React.createElement('div', { className: "flex items-center gap-0.5 bg-neutral-800/40 rounded px-1 py-0.5" },
                    React.createElement('span', { className: "text-[10px] font-bold text-neutral-500" }, `${slotId}`),
                    React.createElement('span', { className: "text-[10px] text-neutral-400 bg-neutral-900/50 px-1 rounded truncate max-w-12", title: fileName || 'Empty' }, fileName ? fileName.slice(0, 6) : '-'),
                    React.createElement('button', { className: "px-1 py-0.5 text-[9px] bg-sky-900/50 rounded text-sky-300 hover:bg-sky-800/60", onClick: handleDataClick }, "D"),
                    React.createElement('button', { className: "px-1 py-0.5 text-[9px] bg-purple-900/50 rounded text-purple-300 hover:bg-purple-800/60", onClick: handleVolClick }, "V")
                );
            };

            // Estilos compactos
            const btn = "px-1.5 py-0.5 bg-neutral-800/70 border border-neutral-700 rounded text-[10px] font-medium text-neutral-300 hover:bg-neutral-700 transition-all flex items-center gap-1";
            const btnAccent = "px-1.5 py-0.5 bg-sky-900/50 border border-sky-700/50 rounded text-[10px] font-medium text-sky-300 hover:bg-sky-800/60 transition-all flex items-center gap-1";
            const select = "bg-neutral-800/80 border border-neutral-700 rounded text-[10px] text-neutral-200 px-1 py-0.5 focus:outline-none";
            const tabBtn = (active) => `px-2 py-1 text-[10px] font-semibold rounded transition-all whitespace-nowrap ${active ? 'bg-sky-600 text-white' : 'bg-neutral-800/60 text-neutral-400 hover:bg-neutral-700/60 hover:text-neutral-200'}`;

            const handleTemplateFileChange = (e) => { const file = e.target.files?.[0]; if (file) onImportTemplate(file); if (e.target) e.target.value = ''; };

            return React.createElement('header', { className: `sticky top-0 z-50 bg-neutral-900/95 backdrop-blur-md border-b border-neutral-800/80 transition-all ${isCollapsed ? 'py-0.5' : 'py-1'}` },
                // Header principal (siempre visible)
                React.createElement('div', { className: "px-2 sm:px-3 flex items-center justify-between gap-1 sm:gap-2 flex-wrap" },
                    // Izquierda: Logo + Tabs
                    React.createElement('div', { className: "flex items-center gap-1 sm:gap-2 min-w-0" },
                        React.createElement('button', { onClick: onToggleCollapse, className: "text-neutral-500 hover:text-neutral-300 text-sm flex-shrink-0" }, isCollapsed ? '+' : '-'),
                        // Logo completo en una l√≠nea
                        React.createElement('div', { className: "flex items-baseline gap-0.5 flex-shrink-0" },
                            React.createElement('span', { className: "text-xs sm:text-sm font-bold text-neutral-100 tracking-wide" }, "ReloadingTape"),
                            React.createElement('span', { className: "text-[9px] sm:text-[10px] text-sky-500 font-medium italic" }, "Evolution")
                        ),
                        // Tabs - siempre abreviadas para ahorrar espacio
                        React.createElement('div', { className: "flex items-center gap-0.5 ml-1 sm:ml-2 pl-1 sm:pl-2 border-l border-neutral-700" },
                            React.createElement('button', { className: tabBtn(activeTab === 'principal'), onClick: () => onTabChange('principal') }, "Princ"),
                            React.createElement('button', { className: tabBtn(activeTab === 'scalping'), onClick: () => onTabChange('scalping') }, "Scalp"),
                            React.createElement('button', { className: tabBtn(activeTab === 'sentimiento'), onClick: () => onTabChange('sentimiento') }, "Sent"),
                            React.createElement('button', { className: tabBtn(activeTab === 'intel'), onClick: () => onTabChange('intel') }, "Intel"),
                            React.createElement('button', { className: tabBtn(activeTab === 'dvilsh'), onClick: () => onTabChange('dvilsh') }, "DVILSH"),
                            React.createElement('button', { className: tabBtn(activeTab === 'custom'), onClick: () => onTabChange('custom') }, "Cust")
                        ),
                        // AI Narrator toggle + Config - SIEMPRE VISIBLE junto a tabs
                        React.createElement('div', { className: "flex items-center gap-0.5 ml-1" },
                            React.createElement('button', {
                                className: `px-2 py-1 rounded text-[10px] font-bold transition-all border ${aiNarratorEnabled
                                    ? 'bg-neutral-700 text-white border-neutral-600 hover:bg-neutral-600'
                                    : 'bg-neutral-800/70 text-neutral-500 border-neutral-700 hover:bg-neutral-700'}`,
                                onClick: onAiNarratorToggle,
                                title: aiNarratorEnabled ? 'AI Narrator activado' : 'AI Narrator desactivado'
                            }, 'AI'),
                            React.createElement('button', {
                                className: "px-1.5 py-1 rounded text-[10px] font-medium bg-neutral-800/70 border border-neutral-700 text-neutral-400 hover:bg-neutral-700",
                                onClick: props.onOpenAiConfig,
                                title: 'Configurar API Key de Groq para AI Narrator'
                            }, '‚öô')
                        )
                    ),
                    // Centro: Acciones r√°pidas (ocultas en m√≥vil peque√±o)
                    !isCollapsed && React.createElement('div', { className: "hidden md:flex items-center gap-1" },
                        // Data slots toggle
                        React.createElement('button', { className: `${btn} ${showSlots ? 'bg-neutral-700' : ''}`, onClick: () => setShowSlots(!showSlots) }, "Data"),
                        // Time
                        React.createElement('select', { value: timeFrame, onChange: (e) => onTimeFrameChange(e.target.value), className: select },
                            React.createElement('option', { value: "raw" }, "Raw"),
                            React.createElement('option', { value: "1m" }, "1m"),
                            React.createElement('option', { value: "5m" }, "5m")
                        ),
                        // Add chart
                        React.createElement('button', { className: btn, onClick: onAddChart }, "+Ch"),
                        // Grid toggle - cicla entre 1x1, 2x2, 4x4
                        React.createElement('button', { className: btn, onClick: onToggleGrid }, gridLayout),
                        // Config
                        React.createElement('button', { className: btnAccent, onClick: props.onOpenGlobalConfig }, "Cfg"),
                        // Scanner (solo en pantallas grandes)
                        React.createElement('button', { className: "hidden lg:flex px-1.5 py-0.5 bg-purple-900/50 border border-purple-700/50 rounded text-[10px] font-medium text-purple-300 hover:bg-purple-800/60", onClick: props.onOpenScanner }, "Scan"),
                        // Signals toggle
                        React.createElement('button', {
                            className: `flex px-1.5 py-0.5 rounded text-[10px] font-bold transition-all ${props.signalsEnabled
                                    ? 'bg-green-600/50 border border-green-500 text-green-300'
                                    : 'bg-red-600/50 border border-red-500 text-red-300'
                                }`,
                            onClick: props.onToggleSignals
                        }, props.signalsEnabled ? 'ON' : 'OFF')
                    ),
                    // Derecha: Telegram + Templates + Backtest
                    !isCollapsed && React.createElement('div', { className: "flex items-center gap-1" },
                        // === TELEGRAM GLOBAL ===
                        React.createElement('div', {
                            ref: telegramDropdownRef,
                            className: "flex items-center gap-0.5 px-1.5 py-0.5 bg-blue-900/30 border border-blue-700/40 rounded relative"
                        },
                            // Auto toggle
                            React.createElement('button', {
                                onClick: onAutoTelegramToggle,
                                className: `px-1.5 py-0.5 rounded text-[9px] font-bold transition-all ${autoTelegramEnabled
                                    ? 'bg-green-600/50 text-green-300 border border-green-500'
                                    : 'bg-neutral-700/50 text-neutral-400 border border-neutral-600'}`
                            }, autoTelegramEnabled ? 'AUTO' : 'OFF'),
                            // Interval selector
                            autoTelegramEnabled && React.createElement('select', {
                                value: autoTelegramInterval,
                                onChange: (e) => onAutoTelegramIntervalChange(parseInt(e.target.value)),
                                className: "bg-neutral-800/80 border border-neutral-600 rounded px-1 py-0.5 text-[9px] text-gray-200"
                            },
                                React.createElement('option', { value: 30 }, '30s'),
                                React.createElement('option', { value: 60 }, '1m'),
                                React.createElement('option', { value: 120 }, '2m'),
                                React.createElement('option', { value: 300 }, '5m')
                            ),
                            // Bot√≥n para mostrar/ocultar selector de grupos
                            React.createElement('button', {
                                onClick: () => setShowTelegramGroups(!showTelegramGroups),
                                className: `px-1 py-0.5 rounded text-[8px] font-bold transition-all ${selectedTelegramGroups?.length === 3
                                    ? 'bg-blue-600/40 text-blue-300'
                                    : selectedTelegramGroups?.length > 0
                                        ? 'bg-yellow-600/40 text-yellow-300'
                                        : 'bg-red-600/40 text-red-300'}`,
                                title: `Grupos: ${selectedTelegramGroups?.join(', ') || 'Ninguno'}`
                            }, `${selectedTelegramGroups?.length || 0}/3`),
                            // Manual send button
                            React.createElement('button', {
                                onClick: onTelegramSend,
                                disabled: isSendingTelegram || !selectedTelegramGroups?.length,
                                className: `px-1.5 py-0.5 rounded text-[9px] font-bold transition-all flex items-center gap-0.5 ${isSendingTelegram
                                    ? 'bg-blue-600/50 text-blue-300 cursor-wait'
                                    : !selectedTelegramGroups?.length
                                        ? 'bg-neutral-700/50 text-neutral-500 cursor-not-allowed'
                                        : 'bg-blue-600/40 text-blue-300 hover:bg-blue-500 hover:text-white'}`
                            },
                                isSendingTelegram ? '...' : 'TG',
                                telegramStatus && React.createElement('span', { className: "text-[7px]" }, telegramStatus)
                            ),
                            // Dropdown de grupos
                            showTelegramGroups && React.createElement('div', {
                                className: "absolute top-full right-0 mt-1 bg-neutral-800 border border-neutral-600 rounded-md shadow-lg z-50 p-1.5 min-w-[100px]"
                            },
                                React.createElement('div', { className: "text-[8px] text-neutral-400 mb-1 px-1" }, "Grupos Telegram:"),
                                ['G1', 'G2', 'G3'].map(group =>
                                    React.createElement('button', {
                                        key: group,
                                        onClick: () => onTelegramGroupToggle(group),
                                        className: `w-full px-2 py-1 text-left text-[9px] rounded mb-0.5 transition-all flex items-center gap-1.5 ${selectedTelegramGroups?.includes(group)
                                            ? 'bg-blue-600/50 text-blue-200'
                                            : 'bg-neutral-700/50 text-neutral-400 hover:bg-neutral-600/50'
                                            }`
                                    },
                                        React.createElement('span', {
                                            className: `w-3 h-3 rounded-sm flex items-center justify-center text-[8px] ${selectedTelegramGroups?.includes(group) ? 'bg-blue-500 text-white' : 'bg-neutral-600'
                                                }`
                                        }, selectedTelegramGroups?.includes(group) ? '‚úì' : ''),
                                        `Grupo ${group.slice(1)}`
                                    )
                                )
                            )
                        ),
                        // Templates (ocultos en m√≥vil)
                        React.createElement('div', { className: "hidden sm:flex items-center gap-1" },
                            React.createElement('div', { className: "w-px h-3 bg-neutral-700" }),
                            React.createElement('button', { className: btn, onClick: onSaveTemplate, title: "Save" }, "S"),
                            React.createElement('button', { className: btn, onClick: onLoadTemplate, title: "Load" }, "L"),
                            React.createElement('button', { className: btn, onClick: onExportTemplate, title: "Export" }, "E"),
                            React.createElement('input', { type: "file", ref: templateInputRef, accept: ".json", className: "hidden", onChange: handleTemplateFileChange }),
                            React.createElement('button', { className: btn, onClick: () => templateInputRef.current?.click(), title: "Import" }, "I")
                        ),
                        React.createElement('div', { className: "w-px h-3 bg-neutral-700 hidden sm:block" }),
                        React.createElement('button', { className: `${btn} ${showBacktest ? 'bg-neutral-700' : ''}`, onClick: () => setShowBacktest(!showBacktest) }, "BT")
                    )
                ),
                // Panel expandible: Data Slots
                showSlots && !isCollapsed && React.createElement('div', { className: "px-2 sm:px-3 py-1 bg-neutral-800/30 border-t border-neutral-800 flex items-center gap-2 flex-wrap" },
                    // Botones de acci√≥n r√°pida
                    React.createElement('button', {
                        className: "px-2 py-0.5 text-[9px] font-bold bg-emerald-900/50 border border-emerald-700/50 rounded text-emerald-300 hover:bg-emerald-800/60 transition-all",
                        onClick: onAutoLoadToday,
                        title: "Load today's session files from Dashdata folder"
                    }, "Today"),
                    React.createElement('button', {
                        className: "px-2 py-0.5 text-[9px] font-bold bg-red-900/50 border border-red-700/50 rounded text-red-300 hover:bg-red-800/60 transition-all",
                        onClick: onClearSlots,
                        title: "Clear all slots"
                    }, "Clear"),
                    React.createElement('div', { className: "w-px h-3 bg-neutral-700 mx-1" }),
                    React.createElement('span', { className: "text-[9px] text-neutral-500 font-medium" }, "Main:"),
                    [...Array(2)].map((_, i) => React.createElement(Slot, { key: i + 1, slotId: String(i + 1), fileName: fileNames[String(i + 1)], onFileSelect, onVolumeProfileLoad, compact: true })),
                    React.createElement('span', { className: "text-[9px] text-amber-500 font-medium ml-1" }, "Corr:"),
                    [...Array(4)].map((_, i) => React.createElement(Slot, { key: i + 3, slotId: String(i + 3), fileName: fileNames[String(i + 3)], onFileSelect, onVolumeProfileLoad, compact: true })),
                    // Expirations si hay
                    expirationOptions.size > 0 && React.createElement(React.Fragment, null,
                        React.createElement('div', { className: "w-px h-3 bg-neutral-700 mx-1" }),
                        React.createElement('span', { className: "text-[9px] text-neutral-500" }, "Exp:"),
                        [...Array(2)].map((_, i) => {
                            const slotId = String(i + 1);
                            const options = expirationOptions.get(slotId);
                            const selected = selectedExpirations.get(slotId);
                            if (!options || options.length === 0) return null;
                            return React.createElement('select', { key: slotId, value: selected || 'ALL', onChange: (e) => onExpirationChange(slotId, e.target.value), className: `${select} w-16` },
                                React.createElement('option', { value: 'ALL' }, 'All'),
                                options.map(exp => React.createElement('option', { key: exp, value: exp }, exp))
                            );
                        })
                    )
                ),
                // Panel expandible: Backtest Replay
                showBacktest && !isCollapsed && React.createElement('div', { className: "px-3 py-1.5 bg-neutral-800/30 border-t border-neutral-800 flex items-center gap-2 flex-wrap" },
                    React.createElement('span', { className: "text-[10px] text-neutral-500 font-medium" }, "Replay:"),
                    // Selector de Slot con indicador de Profile
                    React.createElement('div', { className: "flex items-center gap-1" },
                        React.createElement('select', { ref: backtestSlotRef, className: `${select} w-14` },
                            React.createElement('option', { value: "" }, "Slot"),
                            [...Array(2)].map((_, i) => {
                                const sid = String(i + 1);
                                const hasProfile = volumeProfileData && volumeProfileData.has(sid) && volumeProfileData.get(sid)?.size > 0;
                                return React.createElement('option', { key: sid, value: sid }, `S${sid}${hasProfile ? '+' : ''}`);
                            })
                        ),
                        // Indicador de Profile cargado
                        volumeProfileData && volumeProfileData.size > 0 && React.createElement('span', {
                            className: "text-[8px] px-1 py-0.5 rounded bg-purple-900/50 text-purple-300",
                            title: "Volume Profile will sync during replay"
                        }, "VP")
                    ),
                    // Controles de reproducci√≥n
                    React.createElement('button', { className: btn, onClick: () => onBacktestAction('play', { slotId: backtestSlotRef.current?.value, speed: backtestState.speed }), disabled: backtestState.status === 'running', title: "Play" }, "‚ñ∂"),
                    React.createElement('button', { className: btn, onClick: () => onBacktestAction('pause'), disabled: backtestState.status !== 'running', title: "Pause" }, "‚è∏"),
                    React.createElement('button', { className: btn, onClick: () => onBacktestAction('stop'), disabled: backtestState.status === 'stopped', title: "Stop" }, "‚èπ"),
                    React.createElement('button', { className: btn, onClick: () => onBacktestAction('step-prev', { slotId: backtestSlotRef.current?.value }), title: "Step Back" }, "‚óÄ"),
                    React.createElement('button', { className: btn, onClick: () => onBacktestAction('step-next', { slotId: backtestSlotRef.current?.value }), title: "Step Forward" }, "‚ñ∂"),
                    // Velocidad
                    React.createElement('select', { value: backtestState.speed, className: `${select} w-16`, onChange: (e) => onBacktestAction('change-speed', { speed: parseInt(e.target.value, 10) }) },
                        React.createElement('option', { value: "5000" }, "1x"),
                        React.createElement('option', { value: "1000" }, "5x"),
                        React.createElement('option', { value: "500" }, "10x"),
                        React.createElement('option', { value: "100" }, "50x"),
                        React.createElement('option', { value: "10" }, "500x")
                    ),
                    // Estado y timestamp
                    backtestState.status !== 'stopped' && React.createElement('div', { className: "flex items-center gap-2 ml-2" },
                        React.createElement('span', { className: "text-[10px] text-sky-400" }, `${backtestState.currentIndex}/${backtestState.total}`),
                        backtestState.currentTime && React.createElement('span', { className: "text-[9px] text-neutral-400 bg-neutral-900/50 px-1.5 py-0.5 rounded font-mono" }, backtestState.currentTime)
                    )
                )
            );
        };
        // --- END: components/HeaderBar.tsx ---

        // --- START: App.tsx ---
        const App = () => {
            const { useState, useEffect, useCallback, useRef, useMemo } = React;
            const [dataSources, setDataSources] = useState(new Map());
            const [volumeProfileData, setVolumeProfileData] = useState(new Map());
            const [fileNames, setFileNames] = useState({});
            // Charts separados por pesta√±a - cargar desde localStorage
            const [chartConfigsByTab, setChartConfigsByTab] = useState(() => {
                try {
                    const saved = localStorage.getItem('rt_chartConfigsByTab');
                    if (saved) {
                        const parsed = JSON.parse(saved);
                        if (parsed && typeof parsed === 'object') {
                            return {
                                principal: parsed.principal || [],
                                scalping: parsed.scalping || [],
                                custom: parsed.custom || []
                            };
                        }
                    }
                } catch (e) { }
                return { principal: [], scalping: [], custom: [] };
            });

            // Guardar chartConfigsByTab en localStorage
            useEffect(() => {
                try {
                    localStorage.setItem('rt_chartConfigsByTab', JSON.stringify(chartConfigsByTab));
                } catch (e) { }
            }, [chartConfigsByTab]);

            const [isModalOpen, setIsModalOpen] = useState(false);
            const [activeTab, setActiveTab] = useState('principal');
            const [gridLayout, setGridLayout] = useState('2x2'); // '1x1', '2x2', '4x4'
            const [timeFrame, setTimeFrame] = useState('1m');
            const [isHeaderCollapsed, setIsHeaderCollapsed] = useState(false);
            const [backtestState, setBacktestState] = useState({ status: 'stopped', slotId: null, currentIndex: 0, speed: 5000, total: 0, currentTime: '' });
            const fullDataBackup = useRef(new Map());
            const backtestInterval = useRef(null);
            // Refs para autorefresh
            const fileHandlesRef = useRef({});
            const fileLastModifiedTimesRef = useRef({});
            const [dominanceSignals, setDominanceSignals] = useState(new Map());
            const [spikeSignals, setSpikeSignals] = useState(new Map());
            const [evolutionSignals, setEvolutionSignals] = useState(new Map());
            const [keltnerSignals, setKeltnerSignals] = useState(new Map());
            const [expirationOptions, setExpirationOptions] = useState(new Map());
            const [selectedExpirations, setSelectedExpirations] = useState(new Map());
            const [isGlobalConfigOpen, setIsGlobalConfigOpen] = useState(false);
            const [isScannerOpen, setIsScannerOpen] = useState(false);
            const [signalsEnabled, setSignalsEnabled] = useState(false);
            const [currentPreset, setCurrentPreset] = useState('balanced');

            // Obtener chartConfigs de la pesta√±a activa
            const chartConfigs = chartConfigsByTab[activeTab] || [];
            const setChartConfigs = useCallback((updater) => {
                setChartConfigsByTab(prev => ({
                    ...prev,
                    [activeTab]: typeof updater === 'function' ? updater(prev[activeTab] || []) : updater
                }));
            }, [activeTab]);

            // ===== TELEGRAM GLOBAL STATE =====
            const [isSendingTelegram, setIsSendingTelegram] = useState(false);
            const [telegramStatus, setTelegramStatus] = useState(null);
            const [autoTelegramEnabled, setAutoTelegramEnabled] = useState(false);
            const [autoTelegramInterval, setAutoTelegramInterval] = useState(60);
            // Grupos de Telegram seleccionados (por defecto todos activos)
            const [selectedTelegramGroups, setSelectedTelegramGroups] = useState(() => {
                const saved = localStorage.getItem('selectedTelegramGroups');
                return saved ? JSON.parse(saved) : ['G1', 'G2', 'G3'];
            });
            const autoTelegramRef = useRef(null);
            const appContainerRef = useRef(null);
            const globalConfigRef = useRef(null); // Ref para acceder al globalConfig actual

            // Guardar grupos seleccionados en localStorage
            useEffect(() => {
                localStorage.setItem('selectedTelegramGroups', JSON.stringify(selectedTelegramGroups));
            }, [selectedTelegramGroups]);

            // ===== MARKET SENTIMENT GLOBAL STATE =====
            const [globalMarketSentiment, setGlobalMarketSentiment] = useState({
                score: 0,
                label: 'Cargando...',
                color: '#9ca3af',
                lastUpdate: null
            });

            // ===== NASDAQ 100 SENTIMENT GLOBAL STATE =====
            const [globalNasdaq100Sentiment, setGlobalNasdaq100Sentiment] = useState({
                score: 0,
                label: 'Cargando...',
                color: '#9ca3af',
                bullish: 0,
                bearish: 0,
                neutral: 0,
                weightedBullish: 0,
                weightedBearish: 0
            });

            // ===== AI NARRATOR GLOBAL STATE (sincronizado con localStorage) =====
            const [aiNarratorEnabled, setAiNarratorEnabled] = useState(() => {
                const saved = localStorage.getItem('aiNarratorEnabled');
                return saved === null ? true : saved === 'true';
            });
            const [isAiConfigOpen, setIsAiConfigOpen] = useState(false);
            const [aiApiKey, setAiApiKey] = useState(() => localStorage.getItem('groq_api_key') || '');

            // Guardar API Key cuando cambie (usa la misma clave que el resto de la app)
            const handleSaveAiApiKey = useCallback((key) => {
                localStorage.setItem('groq_api_key', key);
                setAiApiKey(key);
                setIsAiConfigOpen(false);
            }, []);

            // Guardar en localStorage cuando cambie
            useEffect(() => {
                try {
                    localStorage.setItem('aiNarratorEnabled', aiNarratorEnabled.toString());
                    // Disparar evento para sincronizar entre pesta√±as (solo si no es la pesta√±a actual)
                    if (typeof window !== 'undefined' && window.dispatchEvent) {
                        window.dispatchEvent(new StorageEvent('storage', {
                            key: 'aiNarratorEnabled',
                            newValue: aiNarratorEnabled.toString()
                        }));
                    }
                } catch (e) {
                    console.error('Error saving AI narrator state:', e);
                }
            }, [aiNarratorEnabled]);

            // Funci√≥n global para enviar captura de pantalla a Telegram
            const handleGlobalTelegramSend = useCallback(async () => {
                if (isSendingTelegram) return;

                // Verificar que hay grupos seleccionados
                if (!selectedTelegramGroups || selectedTelegramGroups.length === 0) {
                    setTelegramStatus('Sin grupos');
                    setTimeout(() => setTelegramStatus(null), 2000);
                    return;
                }

                setIsSendingTelegram(true);
                setTelegramStatus('Capturando...');

                try {
                    await services.telegram.loadHtml2Canvas();

                    // Capturar todo el contenedor de la app
                    const targetElement = document.getElementById('root');
                    const imageBlob = await services.telegram.captureElementAsImage(targetElement);

                    if (!imageBlob) {
                        throw new Error('No se pudo capturar la pantalla');
                    }

                    setTelegramStatus('Enviando...');

                    // Obtener sentimiento de mercado actual
                    const sentiment = globalMarketSentiment || { label: 'Sin datos', score: 0 };
                    const sentimentText = sentiment.label + (sentiment.score !== 0 ? ` (${sentiment.score >= 0 ? '+' : ''}${sentiment.score.toFixed(1)}%)` : '');

                    // Generar caption con info de la plataforma (sin emojis)
                    const now = new Date();
                    const caption = `ReloadingTape Evolution\n` +
                        `----------------------------\n` +
                        `Fecha: ${now.toLocaleDateString('es-ES')} ${now.toLocaleTimeString('es-ES')}\n` +
                        `Mercado: ${sentimentText.toUpperCase()}\n` +
                        `Charts: ${chartConfigs.length} | Slots: ${dataSources.size}\n` +
                        `----------------------------\n` +
                        `Canal: https://t.me/reloadingtape`;

                    // Pasar los grupos seleccionados a la funci√≥n de env√≠o
                    const results = await services.telegram.sendImageToTelegram(imageBlob, caption, selectedTelegramGroups);
                    const successCount = results.filter(r => r.success).length;

                    if (successCount > 0) {
                        setTelegramStatus(`OK ${successCount}/${selectedTelegramGroups.length}`);
                    } else {
                        setTelegramStatus('Error');
                    }

                    setTimeout(() => setTelegramStatus(null), 3000);
                } catch (error) {
                    console.error('Telegram global send error:', error);
                    setTelegramStatus('Error');
                    setTimeout(() => setTelegramStatus(null), 5000);
                } finally {
                    setIsSendingTelegram(false);
                }
            }, [isSendingTelegram, globalMarketSentiment, chartConfigs.length, dataSources.size, selectedTelegramGroups]);

            // Auto-send Telegram effect
            useEffect(() => {
                if (autoTelegramRef.current) {
                    clearInterval(autoTelegramRef.current);
                    autoTelegramRef.current = null;
                }

                if (autoTelegramEnabled && autoTelegramInterval > 0) {
                    autoTelegramRef.current = setInterval(handleGlobalTelegramSend, autoTelegramInterval * 1000);
                }

                return () => {
                    if (autoTelegramRef.current) clearInterval(autoTelegramRef.current);
                };
            }, [autoTelegramEnabled, autoTelegramInterval, handleGlobalTelegramSend]);

            // Estado para configuraci√≥n global - INICIALIZADO DESDE PRESET BALANCED
            const [globalConfig, setGlobalConfig] = useState(() => getConfigFromPreset('balanced'));

            // Mantener ref actualizado para Telegram
            useEffect(() => {
                globalConfigRef.current = globalConfig;
            }, [globalConfig]);

            // Handler para aplicar configuraci√≥n global a todos los gr√°ficos Y al panel de se√±ales
            const handleApplyGlobalConfig = useCallback((config) => {
                console.log('Applying Global Config from Preset:', config.presetKey || 'custom', config);

                // Actualizar preset actual si viene de un preset
                if (config.presetKey && config.presetKey !== 'custom') {
                    setCurrentPreset(config.presetKey);
                }

                // Actualizar el estado global
                setGlobalConfig(config);

                // Actualizar todos los gr√°ficos con TODOS los par√°metros del preset
                setChartConfigs(prev => {
                    console.log('Updating chartConfigs with preset params, count:', prev.length);
                    return prev.map(chart => ({
                        ...chart,
                        parameters: {
                            ...chart.parameters,
                            // Ratios y thresholds
                            bullishThreshold: config.bullishThreshold,
                            bearishThreshold: config.bearishThreshold,
                            dominanceRatio: config.bullishThreshold,
                            towDominanceRatio: config.bullishThreshold,
                            dominanceFilterRatio: config.dominanceFilterRatio || 1.0,
                            // Periodos principales
                            smaPeriod: config.smaPeriod,
                            lookback: config.lookback,
                            rsiLength: config.rsiPeriod || 14,
                            velocityPeriod: config.velocityPeriod || 5,
                            // TOW espec√≠ficos
                            towLookback: config.towLookback || config.lookback,
                            towSignalSmaPeriod: config.towSignalSmaPeriod || 8,
                            towVelocityPeriod: config.velocityPeriod || 5,
                            // Keltner Channel
                            keltnerEmaPeriod: config.keltnerEmaPeriod || 20,
                            keltnerAtrMult: config.keltnerAtrMult || 3.0,
                            keltnerSlopeThreshold: config.keltnerSlopeThreshold || 10000,
                            // Spike thresholds
                            spikeThreshold: config.spikeThreshold || 1.0,
                            intensityThreshold: config.intensityThreshold || 50,
                            // Colores
                            callColor: config.callColor,
                            putColor: config.putColor,
                            smaColor: config.smaColor,
                            // Power Meters
                            powerMeterMode: config.powerMeterMode || 'compact',
                            powerMeterMAWindow: config.powerMeterMAWindow || 300,
                            powerMeterLowThreshold: config.powerMeterLowThreshold || 40,
                            powerMeterMediumThreshold: config.powerMeterMediumThreshold || 70,
                            powerMeterHighThreshold: config.powerMeterHighThreshold || 100,
                            // Forzar detecci√≥n de cambios
                            _updateTimestamp: Date.now()
                        }
                    }));
                });
            }, []);

            const handleDominanceSignalUpdate = useCallback((chartId, signal) => setDominanceSignals(prev => { const newMap = new Map(prev); if (!signal) newMap.delete(chartId); else newMap.set(chartId, signal); return newMap; }), []);
            const handleSpikeSignalUpdate = useCallback((chartId, signal) => setSpikeSignals(prev => { const newMap = new Map(prev); if (!signal || signal === 'FLAT') newMap.delete(chartId); else newMap.set(chartId, signal); return newMap; }), []);
            const handleEvolutionSignalUpdate = useCallback((chartId, signal) => setEvolutionSignals(prev => { const newMap = new Map(prev); if (!signal || signal === 'FLAT') newMap.delete(chartId); else newMap.set(chartId, signal); return newMap; }), []);
            const handleKeltnerSignalUpdate = useCallback((chartId, signal) => setKeltnerSignals(prev => { const newMap = new Map(prev); if (!signal || signal === 'FLAT') newMap.delete(chartId); else newMap.set(chartId, signal); return newMap; }), []);

            const handleExpirationChange = useCallback((slotId, expiration) => {
                setSelectedExpirations(prev => new Map(prev).set(slotId, expiration));

                // Filtrar datos por expiraci√≥n
                const dataSource = dataSources.get(slotId);
                if (dataSource && dataSource.isOptionsFormat && dataSource.rawRows) {
                    const filteredRows = expiration === 'ALL'
                        ? dataSource.rawRows
                        : dataSource.rawRows.filter(r => r.Expiry === expiration);

                    const processedRows = services.signalCalculator.aggregateData(filteredRows, timeFrame);
                    const signalData = services.signalCalculator.calculateAllSignals(processedRows, dataSource.timestampHeader);
                    setDataSources(prev => new Map(prev).set(slotId, { ...dataSource, rows: processedRows, signalData }));
                }
            }, [dataSources, timeFrame]);

            const handleFileSelect = useCallback((text, file, slotId, fileHandle = null) => {
                try {
                    const parseResult = services.csvParser.parseCSV(text);
                    const { headers, rows: rawRows, timestampHeader, priceHeader, isOptionsFormat } = parseResult;

                    // Si es formato de opciones, extraer expiraciones √∫nicas
                    if (isOptionsFormat && rawRows.length > 0) {
                        const expirations = [...new Set(rawRows.map(r => r.Expiry).filter(e => e))].sort();
                        setExpirationOptions(prev => new Map(prev).set(slotId, expirations));
                        // Seleccionar la primera expiraci√≥n por defecto
                        if (expirations.length > 0) {
                            setSelectedExpirations(prev => new Map(prev).set(slotId, expirations[0]));
                        }
                    } else {
                        // Si no es formato de opciones, limpiar expiraciones
                        setExpirationOptions(prev => {
                            const newMap = new Map(prev);
                            newMap.delete(slotId);
                            return newMap;
                        });
                        setSelectedExpirations(prev => {
                            const newMap = new Map(prev);
                            newMap.delete(slotId);
                            return newMap;
                        });
                    }

                    const processedRows = services.signalCalculator.aggregateData(rawRows, timeFrame);
                    const signalData = services.signalCalculator.calculateAllSignals(processedRows, timestampHeader);
                    setDataSources(prev => new Map(prev).set(slotId, { headers, rawRows, rows: processedRows, timestampHeader, priceHeader, signalData, isOptionsFormat, fileName: file.name }));
                    setFileNames(prev => ({ ...prev, [slotId]: file.name }));

                    // Guardar fileHandle para autorefresh
                    if (fileHandle) {
                        fileHandlesRef.current[slotId] = fileHandle;
                        fileLastModifiedTimesRef.current[slotId] = file.lastModified;
                    }
                } catch (error) { alert("Error processing CSV file."); }
            }, [timeFrame]);

            const handleVolumeProfileLoad = useCallback((text, file, slotId) => {
                try {
                    const volumeData = services.csvParser.parseVolumeProfileCSV(text);
                    setVolumeProfileData(prev => new Map(prev).set(slotId, volumeData));
                    alert(`Volume Profile loaded for Slot ${slotId}: ${file.name}`);
                } catch (error) { alert("Error processing Volume Profile CSV file."); }
            }, []);

            // ===== CLEAR ALL SLOTS =====
            const handleClearSlots = useCallback(() => {
                setDataSources(new Map());
                setVolumeProfileData(new Map());
                setFileNames({});
                setExpirationOptions(new Map());
                setSelectedExpirations(new Map());
                fileHandlesRef.current = {};
                fileLastModifiedTimesRef.current = {};
            }, []);

            // ===== AUTO-LOAD TODAY'S SESSION FILES =====
            const handleAutoLoadToday = useCallback(async () => {
                try {
                    // Pedir al usuario que seleccione el directorio de Dashdata
                    const dirHandle = await window.showDirectoryPicker({
                        mode: 'read',
                        startIn: 'documents'
                    });

                    // Buscar la sesi√≥n del d√≠a de hoy
                    const today = new Date();
                    const todaySessionName = `session_${today.getFullYear()}_${String(today.getMonth() + 1).padStart(2, '0')}_${String(today.getDate()).padStart(2, '0')}`;

                    let sessionDir = null;
                    let latestSession = null;

                    // Buscar en el directorio seleccionado
                    for await (const entry of dirHandle.values()) {
                        if (entry.kind === 'directory') {
                            if (entry.name === todaySessionName) {
                                sessionDir = await dirHandle.getDirectoryHandle(entry.name);
                                break;
                            }
                            // Guardar la m√°s reciente como backup
                            if (entry.name.startsWith('session_')) {
                                if (!latestSession || entry.name > latestSession.name) {
                                    latestSession = { name: entry.name, handle: entry };
                                }
                            }
                        }
                    }

                    // Si no hay sesi√≥n de hoy, usar la m√°s reciente
                    if (!sessionDir && latestSession) {
                        sessionDir = await dirHandle.getDirectoryHandle(latestSession.name);
                        console.log(`No today session, using latest: ${latestSession.name}`);
                    }

                    if (!sessionDir) {
                        alert('No session folder found. Make sure you selected the Dashdata directory.');
                        return;
                    }

                    // Buscar la carpeta UnifiedInstrument
                    let unifiedDir = null;
                    try {
                        unifiedDir = await sessionDir.getDirectoryHandle('UnifiedInstrument');
                    } catch (e) {
                        alert('UnifiedInstrument folder not found in session.');
                        return;
                    }

                    // Obtener todos los archivos CSV
                    const csvFiles = [];
                    for await (const entry of unifiedDir.values()) {
                        if (entry.kind === 'file' && entry.name.endsWith('.csv')) {
                            csvFiles.push(entry);
                        }
                    }

                    if (csvFiles.length === 0) {
                        alert('No CSV files found in UnifiedInstrument folder.');
                        return;
                    }

                    // Ordenar por nombre (para tener orden consistente)
                    csvFiles.sort((a, b) => a.name.localeCompare(b.name));

                    // Mapeo de s√≠mbolos a slots
                    const symbolToSlot = {
                        'SPY': '1',
                        'VIX': '2',
                        'QQQ': '3',
                        'SPX': '4',
                        'NDX': '5',
                        'IWM': '6'
                    };

                    // Cargar archivos en los slots correspondientes
                    let loadedCount = 0;
                    for (const fileHandle of csvFiles) {
                        const fileName = fileHandle.name.replace('.csv', '');
                        const symbol = fileName.toUpperCase();
                        const slotId = symbolToSlot[symbol] || null;

                        if (slotId) {
                            try {
                                const file = await fileHandle.getFile();
                                const text = await file.text();
                                handleFileSelect(text, file, slotId, fileHandle);
                                loadedCount++;
                            } catch (err) {
                                console.error(`Error loading ${fileName}:`, err);
                            }
                        }
                    }

                    if (loadedCount > 0) {
                        alert(`Loaded ${loadedCount} files from today's session.`);
                    } else {
                        alert('No matching files found for slots (SPY, VIX, QQQ, SPX, NDX, IWM).');
                    }

                } catch (err) {
                    if (err.name !== 'AbortError') {
                        console.error('Auto-load error:', err);
                        alert('Error loading files. Make sure you grant access to the folder.');
                    }
                }
            }, [handleFileSelect]);

            const handleTimeFrameChange = (newTimeFrame) => {
                setTimeFrame(newTimeFrame);
                const newSources = new Map();
                for (const [slotId, data] of dataSources.entries()) {
                    if (data.rawRows) {
                        const processedRows = services.signalCalculator.aggregateData(data.rawRows, newTimeFrame);
                        const signalData = services.signalCalculator.calculateAllSignals(processedRows, data.timestampHeader);
                        newSources.set(slotId, { ...data, rows: processedRows, signalData });
                    }
                }
                setDataSources(newSources);
            };

            const stopBacktest = useCallback(() => {
                if (backtestInterval.current) clearInterval(backtestInterval.current);
                backtestInterval.current = null;

                // Restaurar TODOS los slots que fueron respaldados
                setDataSources(prev => {
                    const newSources = new Map(prev);
                    fullDataBackup.current.forEach((backup, slotId) => {
                        newSources.set(slotId, backup);
                    });
                    return newSources;
                });

                fullDataBackup.current.clear();
                setBacktestState({ status: 'stopped', slotId: null, currentIndex: 0, speed: 5000, total: 0, currentTime: '' });
            }, []);

            const handleBacktestAction = useCallback((action, payload) => {
                const { slotId, speed } = payload || {};
                if (action === 'stop') { stopBacktest(); return; }
                if (action === 'pause') { if (backtestInterval.current) clearInterval(backtestInterval.current); backtestInterval.current = null; setBacktestState(prev => ({ ...prev, status: 'paused' })); return; }

                // Funci√≥n para sincronizar todos los slots bas√°ndose en un timestamp (solo m√©tricas CSV, NO volume profile)
                const syncAllSlots = (targetTimestamp, primarySlotId) => {
                    // Sincronizar dataSources (CSV de m√©tricas)
                    setDataSources(prev => {
                        const newSources = new Map(prev);

                        // Iterar sobre todos los slots con backup
                        fullDataBackup.current.forEach((backup, sid) => {
                            if (!backup.rawRows || backup.rawRows.length === 0) return;

                            // Encontrar el √≠ndice m√°s cercano al timestamp objetivo
                            let closestIdx = 0;
                            let closestDiff = Infinity;

                            for (let i = 0; i < backup.rawRows.length; i++) {
                                const rowTime = new Date(backup.rawRows[i][backup.timestampHeader]).getTime();
                                const diff = Math.abs(rowTime - targetTimestamp);
                                if (diff < closestDiff) {
                                    closestDiff = diff;
                                    closestIdx = i;
                                }
                                // Si pasamos el timestamp, ya encontramos el m√°s cercano
                                if (rowTime > targetTimestamp) break;
                            }

                            const syncedRows = services.signalCalculator.aggregateData(backup.rawRows.slice(0, closestIdx + 1), timeFrame);
                            newSources.set(sid, { ...backup, rows: syncedRows });
                        });

                        return newSources;
                    });
                    // NOTA: Volume Profile se mantiene completo durante replay para visualizaci√≥n
                };

                if (action === 'change-speed') {
                    const newSpeed = payload.speed;
                    setBacktestState(prev => ({ ...prev, speed: newSpeed }));
                    // Si est√° corriendo, reiniciar el intervalo con la nueva velocidad
                    if (backtestInterval.current && backtestState.status === 'running') {
                        clearInterval(backtestInterval.current);
                        const currentSlotId = backtestState.slotId;
                        const fullData = fullDataBackup.current.get(currentSlotId);
                        if (fullData) {
                            backtestInterval.current = window.setInterval(() => {
                                setBacktestState(prev => {
                                    const newIndex = prev.currentIndex + 1;
                                    if (newIndex >= fullData.rawRows.length) { stopBacktest(); return prev; }
                                    const skipAggregation = newSpeed <= 10;
                                    const shouldUpdateUI = !skipAggregation || (newIndex % 5 === 0) || newIndex >= fullData.rawRows.length - 1;
                                    if (shouldUpdateUI) {
                                        const targetTimestamp = new Date(fullData.rawRows[newIndex][fullData.timestampHeader]).getTime();
                                        syncAllSlots(targetTimestamp, currentSlotId);
                                    }
                                    const currentTime = (fullData.rawRows[newIndex][fullData.timestampHeader]).toLocaleString();
                                    return { ...prev, currentIndex: newIndex, currentTime };
                                });
                            }, newSpeed);
                        }
                    }
                    return;
                }

                const currentSlotId = backtestState.status !== 'stopped' ? backtestState.slotId : slotId;
                if (!currentSlotId || !dataSources.has(currentSlotId)) { alert('Please select a valid slot with data loaded.'); return; }

                // Al iniciar backtest, guardar backup de TODOS los slots cargados PRIMERO
                if (backtestState.status === 'stopped') {
                    dataSources.forEach((data, sid) => {
                        if (!fullDataBackup.current.has(sid) && data.rawRows) {
                            fullDataBackup.current.set(sid, { ...data });
                        }
                    });
                }

                // AHORA obtener fullData del backup (que ya tiene los datos)
                const fullData = fullDataBackup.current.get(currentSlotId) || dataSources.get(currentSlotId);
                if (!fullData || !fullData.rawRows || fullData.rawRows.length === 0) {
                    alert('No hay datos raw disponibles para replay. Verifica que el CSV tenga datos.');
                    return;
                }

                let currentIndex = backtestState.status === 'stopped' || currentSlotId !== backtestState.slotId ? 0 : backtestState.currentIndex;

                const updateData = (newIndex) => {
                    const clampedIndex = Math.max(0, Math.min(fullData.rawRows.length - 1, newIndex));
                    const targetTimestamp = new Date(fullData.rawRows[clampedIndex][fullData.timestampHeader]).getTime();

                    // Sincronizar TODOS los slots al timestamp del slot principal
                    syncAllSlots(targetTimestamp, currentSlotId);

                    const currentTime = (fullData.rawRows[clampedIndex][fullData.timestampHeader]).toLocaleString();
                    setBacktestState(prev => ({ ...prev, currentIndex: clampedIndex, currentTime, slotId: currentSlotId, total: fullData.rawRows.length }));
                };

                if (action === 'step-next') updateData(currentIndex + 1);
                if (action === 'step-prev') updateData(currentIndex - 1);

                if (action === 'play') {
                    if (backtestInterval.current) clearInterval(backtestInterval.current);
                    const playSpeed = speed || backtestState.speed;
                    setBacktestState(prev => ({ ...prev, status: 'running', speed: playSpeed, slotId: currentSlotId, total: fullData.rawRows.length }));

                    backtestInterval.current = window.setInterval(() => {
                        setBacktestState(prev => {
                            const newIndex = prev.currentIndex + 1;
                            if (newIndex >= fullData.rawRows.length) { stopBacktest(); return prev; }

                            const skipAggregation = playSpeed <= 10;
                            const shouldUpdateUI = !skipAggregation || (newIndex % 5 === 0) || newIndex >= fullData.rawRows.length - 1;

                            if (shouldUpdateUI) {
                                const targetTimestamp = new Date(fullData.rawRows[newIndex][fullData.timestampHeader]).getTime();
                                syncAllSlots(targetTimestamp, currentSlotId);
                            }

                            const currentTime = (fullData.rawRows[newIndex][fullData.timestampHeader]).toLocaleString();
                            return { ...prev, currentIndex: newIndex, currentTime };
                        });
                    }, playSpeed);
                }
            }, [backtestState, dataSources, stopBacktest, timeFrame]);

            const handleDeleteChart = (id) => setChartConfigs(prev => prev.filter(c => c.id !== id));
            const handleUpdateChartConfig = (id, newConfig, syncZoomToAll = false) => {
                if (syncZoomToAll && newConfig.zoomState) {
                    // Sincronizar zoomState a TODOS los charts
                    setChartConfigs(prev => prev.map(c => ({ ...c, zoomState: newConfig.zoomState })));
                } else {
                    setChartConfigs(prev => prev.map(c => c.id === id ? { ...c, ...newConfig } : c));
                }
            };
            const handleAddChart = (slotId, category, type, extraParams = {}) => {
                // Default parameters based on chart category
                const defaultParams = category === 'otm-correlation' ? { correlationWindow: 60 } : {};
                // Merge default params with extra params (for Price+Profile+BigTrades)
                const finalParams = { ...defaultParams, ...extraParams };
                setChartConfigs(prev => [...prev, { id: `${type}-${Date.now()}`, slotId, category, type, parameters: finalParams, zoomState: { start: 0, end: 100 } }]);
            };

            // Save Template - Abre di√°logo del sistema para elegir carpeta y nombre
            const handleSaveTemplate = async () => {
                const data = JSON.stringify(chartConfigs, null, 2);
                const blob = new Blob([data], { type: 'application/json' });

                // Usar File System Access API (Chrome/Edge) - Abre di√°logo "Guardar como"
                if (window.showSaveFilePicker) {
                    try {
                        const handle = await window.showSaveFilePicker({
                            suggestedName: 'dashboard-template.json',
                            types: [{
                                description: 'Dashboard Template',
                                accept: { 'application/json': ['.json'] }
                            }]
                        });
                        const writable = await handle.createWritable();
                        await writable.write(blob);
                        await writable.close();
                        alert(`Template saved: ${handle.name}`);
                        return;
                    } catch (err) {
                        if (err.name === 'AbortError') return; // Usuario cancel√≥
                    }
                }

                // Fallback para Firefox/Safari - Pide nombre y descarga
                const templateName = prompt('Enter template name (will save to Downloads):', 'dashboard-template');
                if (!templateName) return;
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${templateName}.json`;
                a.click();
                URL.revokeObjectURL(url);
                alert(`Template downloaded to Downloads folder: ${templateName}.json`);
            };

            // Load Template - Abre di√°logo del sistema para buscar archivo
            const handleLoadTemplate = async () => {
                // Usar File System Access API (Chrome/Edge) - Abre di√°logo "Abrir"
                if (window.showOpenFilePicker) {
                    try {
                        const [handle] = await window.showOpenFilePicker({
                            types: [{
                                description: 'Dashboard Template',
                                accept: { 'application/json': ['.json'] }
                            }],
                            multiple: false
                        });
                        const file = await handle.getFile();
                        const text = await file.text();
                        setChartConfigs(JSON.parse(text));
                        alert(`Template loaded: ${file.name}`);
                        return;
                    } catch (err) {
                        if (err.name === 'AbortError') return; // Usuario cancel√≥
                        if (err instanceof SyntaxError) {
                            alert('Invalid template file.');
                            return;
                        }
                    }
                }

                // Fallback para Firefox/Safari - Input file tradicional
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json,application/json';
                input.onchange = async (e) => {
                    const file = e.target.files?.[0];
                    if (!file) return;
                    try {
                        const text = await file.text();
                        setChartConfigs(JSON.parse(text));
                        alert(`Template loaded: ${file.name}`);
                    } catch (error) {
                        alert('Invalid template file.');
                    }
                };
                input.click();
            };

            const handleExportTemplate = () => { const data = JSON.stringify(chartConfigs, null, 2); const blob = new Blob([data], { type: 'application/json' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = 'chart-template.json'; a.click(); URL.revokeObjectURL(url); };
            const handleImportTemplate = (file) => { const reader = new FileReader(); reader.onload = (e) => { try { setChartConfigs(JSON.parse(e.target?.result)); alert('Template imported!'); } catch (error) { alert('Invalid template file.'); } }; reader.readAsText(file); };
            const consolidatedSignals = useMemo(() => {
                const signals = new Map(); const allDefinitions = [...constants.CHART_DEFINITIONS.main, ...constants.CHART_DEFINITIONS.advanced];
                dominanceSignals.forEach((signal, chartId) => {
                    if (!signal) return; const currentState = typeof signal === 'object' ? signal.state : signal; if (currentState === 'FLAT') return;
                    const config = chartConfigs.find(c => c.id === chartId); const definition = allDefinitions.find(d => d.type === config?.type);
                    if (config && definition) signals.set(chartId, { chartId, chartTitle: `Slot ${config.slotId}: ${definition.name}`, state: currentState, value: typeof signal === 'object' ? signal.value : undefined, type: 'dominance' });
                });
                spikeSignals.forEach((signal, chartId) => {
                    if (signal && signal !== 'FLAT') {
                        const config = chartConfigs.find(c => c.id === chartId); const definition = allDefinitions.find(d => d.type === config?.type);
                        if (config && definition) signals.set(chartId, { chartId, chartTitle: `Slot ${config.slotId}: ${definition.name}`, state: signal, type: 'spike' });
                    }
                });
                return signals;
            }, [dominanceSignals, spikeSignals, chartConfigs]);

            // useEffect para autorefresh cada 5 segundos
            // PAUSAR auto-refresh durante backtest para evitar conflictos
            useEffect(() => {
                // Si el backtest est√° corriendo o pausado, no hacer auto-refresh
                if (backtestState.status === 'running' || backtestState.status === 'paused') {
                    return;
                }

                const interval = setInterval(async () => {
                    for (const slotId of Object.keys(fileHandlesRef.current)) {
                        const fileHandle = fileHandlesRef.current[slotId];
                        const lastModified = fileLastModifiedTimesRef.current[slotId];

                        try {
                            const file = await fileHandle.getFile();
                            if (file.lastModified !== lastModified) {
                                const text = await file.text();
                                handleFileSelect(text, file, slotId, fileHandle);
                            }
                        } catch (err) {
                            console.error(`Error checking file for slot ${slotId}:`, err);
                        }
                    }
                }, 5000);

                return () => clearInterval(interval);
            }, [handleFileSelect, backtestState.status]);

            return React.createElement('div', { className: "bg-neutral-950 text-gray-200 min-h-screen flex flex-col" },
                React.createElement(components.HeaderBar, {
                    onFileSelect: handleFileSelect, onVolumeProfileLoad: handleVolumeProfileLoad, fileNames: fileNames, onAddChart: () => setIsModalOpen(true),
                    onClearSlots: handleClearSlots, onAutoLoadToday: handleAutoLoadToday,
                    gridLayout: gridLayout, onToggleGrid: () => setGridLayout(prev => prev === '1x1' ? '2x2' : prev === '2x2' ? '4x4' : '1x1'), timeFrame: timeFrame, onTimeFrameChange: handleTimeFrameChange,
                    isCollapsed: isHeaderCollapsed, onToggleCollapse: () => setIsHeaderCollapsed(!isHeaderCollapsed), backtestState: backtestState, onBacktestAction: handleBacktestAction,
                    onSaveTemplate: handleSaveTemplate, onLoadTemplate: handleLoadTemplate, onExportTemplate: handleExportTemplate, onImportTemplate: handleImportTemplate,
                    activeTab: activeTab, onTabChange: setActiveTab, expirationOptions: expirationOptions, selectedExpirations: selectedExpirations, onExpirationChange: handleExpirationChange,
                    onOpenGlobalConfig: () => setIsGlobalConfigOpen(true),
                    onOpenScanner: () => setIsScannerOpen(true),
                    signalsEnabled: signalsEnabled,
                    onToggleSignals: () => setSignalsEnabled(prev => !prev),
                    volumeProfileData: volumeProfileData, // Para mostrar indicador en backtest
                    // Telegram global props
                    isSendingTelegram: isSendingTelegram,
                    telegramStatus: telegramStatus,
                    autoTelegramEnabled: autoTelegramEnabled,
                    autoTelegramInterval: autoTelegramInterval,
                    selectedTelegramGroups: selectedTelegramGroups,
                    onTelegramGroupToggle: (group) => {
                        setSelectedTelegramGroups(prev =>
                            prev.includes(group)
                                ? prev.filter(g => g !== group)
                                : [...prev, group]
                        );
                    },
                    onTelegramSend: handleGlobalTelegramSend,
                    onAutoTelegramToggle: () => setAutoTelegramEnabled(!autoTelegramEnabled),
                    onAutoTelegramIntervalChange: setAutoTelegramInterval,
                    // AI Narrator global props
                    aiNarratorEnabled: aiNarratorEnabled,
                    onAiNarratorToggle: () => setAiNarratorEnabled(!aiNarratorEnabled),
                    onOpenAiConfig: () => setIsAiConfigOpen(true)
                }),
                React.createElement(components.GlobalConfigPanel, {
                    isOpen: isGlobalConfigOpen,
                    onClose: () => setIsGlobalConfigOpen(false),
                    onApplyToAll: handleApplyGlobalConfig,
                    currentPreset: currentPreset
                }),
                // Modal de configuraci√≥n AI Narrator
                isAiConfigOpen && React.createElement('div', {
                    className: "fixed inset-0 bg-black/80 flex items-center justify-center z-50",
                    onClick: () => setIsAiConfigOpen(false)
                },
                    React.createElement('div', {
                        className: "bg-neutral-900 border border-neutral-700 rounded-xl p-6 max-w-md w-full mx-4",
                        onClick: (e) => e.stopPropagation()
                    },
                        React.createElement('h2', { className: "text-lg font-bold text-white mb-4" }, 'ü§ñ Configuraci√≥n AI Narrator'),
                        React.createElement('p', { className: "text-sm text-neutral-400 mb-3" },
                            'Configura tu API Key para habilitar el narrador de IA. Soporta:'
                        ),
                        React.createElement('div', { className: "text-xs text-neutral-500 mb-4 space-y-1" },
                            React.createElement('p', null,
                                '‚Ä¢ ',
                                React.createElement('span', { className: "text-orange-400 font-medium" }, 'Groq'),
                                ' (Llama 3.3 70B) - Key: gsk_... ‚Üí ',
                                React.createElement('a', {
                                    href: 'https://console.groq.com/keys',
                                    target: '_blank',
                                    className: "text-sky-400 hover:text-sky-300 underline"
                                }, 'Obtener GRATIS')
                            ),
                            React.createElement('p', null,
                                '‚Ä¢ ',
                                React.createElement('span', { className: "text-blue-400 font-medium" }, 'Google Gemini'),
                                ' (1.5 Flash) - Key: AIza... ‚Üí ',
                                React.createElement('a', {
                                    href: 'https://aistudio.google.com/apikey',
                                    target: '_blank',
                                    className: "text-sky-400 hover:text-sky-300 underline"
                                }, 'Obtener GRATIS')
                            )
                        ),
                        React.createElement('input', {
                            type: 'text',
                            value: aiApiKey,
                            onChange: (e) => setAiApiKey(e.target.value),
                            placeholder: 'gsk_... o AIza...',
                            className: "w-full px-3 py-2 bg-neutral-800 border border-neutral-700 rounded text-white text-sm mb-2"
                        }),
                        React.createElement('p', { className: "text-[10px] text-neutral-600 mb-4" },
                            '‚ö° El sistema detecta autom√°ticamente el proveedor seg√∫n el formato de tu key'
                        ),
                        React.createElement('div', { className: "flex gap-2 justify-end" },
                            React.createElement('button', {
                                onClick: () => setIsAiConfigOpen(false),
                                className: "px-4 py-2 bg-neutral-700 hover:bg-neutral-600 text-white rounded text-sm"
                            }, 'Cancelar'),
                            React.createElement('button', {
                                onClick: () => handleSaveAiApiKey(aiApiKey),
                                className: "px-4 py-2 bg-sky-600 hover:bg-sky-500 text-white rounded text-sm font-medium"
                            }, 'Guardar')
                        )
                    )
                ),
                // Market Scanner Modal (solo si NO est√° en tab sentimiento)
                activeTab !== 'sentimiento' && React.createElement(components.MarketScanner, {
                    isVisible: isScannerOpen,
                    onClose: () => setIsScannerOpen(false)
                }),
                React.createElement('main', { className: "flex-grow p-1 sm:p-2 lg:p-2.5 flex flex-col" },
                    // === PESTA√ëA SENTIMIENTO (siempre montada, oculta con CSS para preservar estado) ===
                    React.createElement('div', {
                        style: { display: activeTab === 'sentimiento' ? 'flex' : 'none', flexDirection: 'column', flex: 1 }
                    },
                        React.createElement(components.SentimentTab, {
                            onSentimentUpdate: setGlobalMarketSentiment,
                            onNasdaq100SentimentUpdate: setGlobalNasdaq100Sentiment,
                            globalAiEnabled: aiNarratorEnabled,
                            onAiEnabledChange: setAiNarratorEnabled
                        })
                    ),

                    // === PESTA√ëA PRINCIPAL ===
                    activeTab === 'principal' && React.createElement(React.Fragment, null,
                        // Panel de Trading Signals - siempre montado para preservar estado
                        dataSources.size > 0 && React.createElement(components.TradingSignalsPanel, {
                            dataSources: dataSources,
                            globalConfig: globalConfig,
                            volumeProfileData: volumeProfileData,
                            isVisible: true,
                            globalMarketSentiment: globalMarketSentiment
                        }),
                        // Charts de la pesta√±a principal
                        chartConfigs.length > 0 && React.createElement(components.ChartGrid, {
                            gridLayout: gridLayout, chartConfigs: chartConfigs, dataSources: dataSources, volumeProfileData: volumeProfileData,
                            onDeleteChart: handleDeleteChart, onUpdateChartConfig: handleUpdateChartConfig,
                            onDominanceSignalUpdate: handleDominanceSignalUpdate, onSpikeSignalUpdate: handleSpikeSignalUpdate, onEvolutionSignalUpdate: handleEvolutionSignalUpdate, onKeltnerSignalUpdate: handleKeltnerSignalUpdate
                        })
                    ),

                    // === PESTA√ëA SCALPING ===
                    activeTab === 'scalping' && React.createElement(React.Fragment, null,
                        // Solo Charts para scalping (sin panel de se√±ales)
                        chartConfigs.length > 0 ? (
                            React.createElement(components.ChartGrid, {
                                gridLayout: gridLayout, chartConfigs: chartConfigs, dataSources: dataSources, volumeProfileData: volumeProfileData,
                                onDeleteChart: handleDeleteChart, onUpdateChartConfig: handleUpdateChartConfig,
                                onDominanceSignalUpdate: handleDominanceSignalUpdate, onSpikeSignalUpdate: handleSpikeSignalUpdate, onEvolutionSignalUpdate: handleEvolutionSignalUpdate, onKeltnerSignalUpdate: handleKeltnerSignalUpdate
                            })
                        ) : (
                            React.createElement('div', { className: "flex-grow flex items-center justify-center" },
                                React.createElement('div', { className: "text-center text-neutral-600" },
                                    React.createElement('h2', { className: "text-xl font-semibold" }, "Scalping"),
                                    React.createElement('p', { className: "mt-2 text-sm" }, "Agrega graficos para analisis rapido")
                                )
                            )
                        )
                    ),

                    // === PESTA√ëA INTEL - MARKET INTELLIGENCE ===
                    activeTab === 'intel' && React.createElement(components.MarketIntelligencePanel, {
                        dataSources: dataSources,
                        globalConfig: globalConfig,
                        aiApiKey: aiApiKey,
                        aiNarratorEnabled: aiNarratorEnabled,
                        volumeProfileData: volumeProfileData,
                        nasdaq100Sentiment: globalNasdaq100Sentiment
                    }),

                    // === PESTA√ëA DVILSH ===
                    activeTab === 'dvilsh' && React.createElement(components.DVILSHPanel, {
                        dataSources: dataSources,
                        globalConfig: globalConfig
                    }),

                    // === PESTA√ëA CUSTOM ‚Üí ANALYSIS CENTER ===
                    activeTab === 'custom' && React.createElement(components.AnalysisCenter, {
                        dataSources: dataSources,
                        chartSlots: window.chartSlots || [],
                        globalAiEnabled: aiNarratorEnabled,
                        onAiEnabledChange: setAiNarratorEnabled
                    })
                ),
                React.createElement(components.AddChartModal, { isOpen: isModalOpen, onClose: () => setIsModalOpen(false), onAddChart: handleAddChart, dataSources: dataSources }),
                backtestState.status !== 'stopped' && React.createElement(components.BacktestIndicator, { state: backtestState })
            );
        };
        // --- END: App.tsx ---

        // --- Root Render ---
        const rootElement = document.getElementById('root');
        if (!rootElement) {
            throw new Error("Could not find root element to mount to");
        }
        const root = ReactDOM.createRoot(rootElement);
        root.render(React.createElement(React.StrictMode, null, React.createElement(App)));

    </script>
    <!-- <script type="module" src="/index.tsx"></script> -->
</body>

</html>